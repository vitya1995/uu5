"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _index = require("../error/index.js");

var _index2 = require("../util/index.js");

var _index3 = require("../logging/index.js");

var _index4 = require("../perflog/index.js");

var logger = _index3.LoggerFactory.get("UuApp.AppClient.Client");

/**
 * Creates an instance of command client which will use specified configuration when invoking commands.
 * Unspecified values are taken from global defaults ({@link UuApp.AppClient.Client.defaults Client.defaults}). Most
 * values can be further overridden when invoking the remote call - see {@link UuApp.AppClient.Client#post Client#post}.
 * 
 * **Interceptors**
 * 
 * It's possible to provide a list of interceptors which pre-/post-process HTTP requests. An interceptor
 * is a JavaScript function {Promise<Response>} interceptorFn({Object} request, {Object} options, {Function} nextInterceptorFn).
 * Request object contains fields uri, method, body and options object contains any remaining options passed down to
 * interceptors, e.g. transformParameters). Example:
 * 
 *     function MyInterceptor(request, options, nextInterceptorFn) {
 *       // pre-process in any way
 *       request.headers["x-extra-header-computed-value"] = Math.random() + "";
 *       console.log("Launching Ajax request. Method:", request.method, "Uri:", request.uri, "Parameters:", request.body, "Other options:", options);
 *       var start = new Date().getTime();
 *       return nextInterceptorFn(request, options).then(function (response) {
 *         // post-process in any way, e.g. add extra field to the response object
 *         response.timeTaken = new Date().getTime() - start;
 *         return response;
 *       }, function error(response) {
 *         // ...
 *         return Promise.reject(response); // keep it rejected (i.e. in error state)
 *       });
 *     }
 *     
 *     // usage of the interceptor
 *     var client = new UuApp.AppClient.Client({
 *       interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *     });
 *     
 * @class UuApp.AppClient.Client
 * @classdesc
 * The Client allows communication with remote uuOS9 endpoints which conform to uuUri format.
 * Besides communication, the client solves also other points of interest, such as authentication or
 * performance logging.
 * 
 * Client uses standardized {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise API}
 * to provide access to the result of the call.
 * 
 *     UuApp.AppClient.Client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function (response) {
 *       console.log(response.data, response.status, response.headers());
 *     }, function (response) { // error
 *       console.log(response.error, response.status, response.headers());
 *     });
 * 
 * When used as above, client uses global defaults (timeout, headers, ...). If the call needs to be parametrized, it can
 * be parametrized directly in {@link UuApp.AppClient.Client#post Client#post} ({@link UuApp.AppClient.Client#get Client#get})
 * call or, alternatively, a client instance can be created with defaults that override the global ones.
 * 
 * For pre-/post-processing of HTTP requests use custom interceptors (see constructor).
 * 
 * **Configuration**
 * 
 * Some options are automatically configured from the environment during
 * {@link UuApp.Util.Config.init Config.init} call. These can be overridden when instantiating
 * the client or in method invocations. Supported environment options:
 * 
 *     {
 *       "gatewayUri": "https://uuappg01.plus4u.net", // default gateway for command calls using uuUri that doesn't contain gateway
 *       "vendor-app-subapp-spp.gatewayUri": "https://elsewhere.plus4u.net"
 *     }
 * 
 * @param {Object} options Default options for this instance of the command client.
 * @param {number} options.requestTimeout The default HTTP timeout for this instance of the command client, in seconds.
 * @param {Object} options.headers The default HTTP headers for command invocations using this instance of the command client.
 * @param {Object[]} options.interceptors List of interceptors to use. Interceptors can arbitrarily pre-/post-process
 *   HTTP requests.
 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
 *   as "gatewayUri" which then take precedence over those from global environment.
 * 
 * @example
 *    var client = new UuApp.AppClient.Client({
 *      requestTimeout: 20,
 *      headers: {
 *        "x-my-extra-header": "abcd"
 *      },
 *      interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *    });
 * 
 *    // ... all calls using "client.get(...)" or "client.post()" will have timeout 20s (unless the timeout
 *    // is overridden in the invoke call directly) and will have an extra HTTP header.
 */
function Client(options) {
  this.options = options || {};
  this.options.headers = keysToLowerCase(this.options.headers);
}

/**
 * Global defaults for command client. 
 * 
 *     {
 *       requestTimeout: 300,   // timeout in seconds
 *       interceptors: [ // default set of interceptors
 *         // ...
 *       ]
 *     }
 * 
 * @name UuApp.AppClient.Client.defaults
 */
Client.defaults = {
  requestTimeout: 300,
  interceptors: [UriHandler, RemoteErrorHandler, UujsonHandler, TransformParametersHandler, PerfLogHandler]
};

function keysToLowerCase(map) {
  if (!map || (typeof map === "undefined" ? "undefined" : _typeof(map)) != "object") return null;
  var result = {};
  for (var k in map) {
    result[k.toLowerCase()] = map[k];
  }return result;
}
Client.prototype.invoke = function (method, uri, parameters, options) {
  // prepare data for interceptors & http client
  var interceptorOpts = Object.assign({}, this.options, options);
  delete interceptorOpts.requestTimeout;
  delete interceptorOpts.headers;
  delete interceptorOpts.interceptors;
  var request = {
    method: (method || "post").toLowerCase(),
    uri: uri,
    body: parameters,
    headers: Object.assign({}, this.options.headers, keysToLowerCase((options || {}).headers))
  };
  var httpClientOpts = {
    requestTimeout: (options || {}).requestTimeout != null ? (options || {}).requestTimeout : this.options.requestTimeout
  };

  // run interceptors (with 1st interceptor being the entry-point of the chain; last interceptor will continue with InvokeXhr method)
  var interceptors = this.options.interceptors || this.constructor.defaults.interceptors || [];
  var lastResponse;
  var chainFn = interceptors.reduceRight(function (chainFn, interceptorFn) {
    return function (req, opts) {
      var result;
      try {
        result = interceptorFn(req, opts, chainFn);
        if (!result || (typeof result === "undefined" ? "undefined" : _typeof(result)) != "object" || typeof result.then != "function") result = Promise.resolve(result);
      } catch (e) {
        result = Promise.reject(e);
      }
      // make sure that interceptor always returns "response" object
      // (even if some unexpected / unhandled error happened)
      return result.then(function (anyValue) {
        var response = anyValue;
        if (!anyValue || !("status" in anyValue)) {
          // it's not a "response" object and it's not rejected (i.e. bugged interceptor) => use it as "data" on last known "response"
          logger.warn("Client interceptor %s resolved the promise into a value that is not a Response object - auto-wrapping.", interceptorFn.name);
          response = lastResponse || interceptorMakeResponse(null, req, opts);
          if (anyValue !== undefined) response.data = anyValue; // don't overwrite data if interceptor just didn't use "return response;"
        }
        lastResponse = response;
        if (lastResponse.error) logger.warn("Client interceptor %s resolved response successfully but kept the error object set - unsetting. Error object:", interceptorFn.name, lastResponse.error);
        lastResponse.error = null;
        return response;
      }, function wrapAsResponse(anyValue) {
        if (!anyValue || !("status" in anyValue)) {
          // it's not a "response" object => take the last known "response" and update its "error" field
          if (!lastResponse) lastResponse = interceptorMakeResponse(null, req, opts);
          lastResponse.error = anyValue instanceof _index.Error ? anyValue : new _index.Error("Client interceptor " + interceptorFn.name + " ended with error.", anyValue);
        } else {
          // it's a "response" object => use it as-is
          lastResponse = anyValue;
        }
        return Promise.reject(lastResponse);
      });
    };
  }, InvokeXhr.bind(null, this, httpClientOpts));
  var resultPromise = chainFn(request, interceptorOpts);

  // add support for aborting on-going requests
  var aborted = false;
  resultPromise.abort = function () {
    aborted = true;
    if (httpClientOpts.xhr) httpClientOpts.xhr.abort(); // Ajax might not have been called yet
  };

  return resultPromise;

  function InvokeXhr(cmdClient, httpClientOpts, finalRequest, finalOpts) {
    if (aborted) return Promise.reject(interceptorMakeResponse(null, finalRequest, { error: new _index.AbortError("The Client call has been aborted.") }));

    var xhr = httpClientOpts.xhr = new XMLHttpRequest();
    return new Promise(function executor(resolve, reject) {
      var canHaveBody = finalRequest.method.match(/^(put|post)$/i);
      var url = finalRequest.uri.toString();
      var body;
      if (!canHaveBody) {
        if (finalRequest.body) url += (url.indexOf("?") == -1 ? "?" : "&") + finalRequest.body;
      } else {
        body = finalRequest.body;
      }
      var headers = finalRequest.headers;
      var timeout = httpClientOpts.requestTimeout = httpClientOpts.requestTimeout != null ? httpClientOpts.requestTimeout : cmdClient.constructor.defaults.requestTimeout;
      if (logger.isDebugLoggable()) logger.debug("Invoking Ajax request.", { method: finalRequest.method, url: url, body: body, requestTimeout: timeout, headers: headers });else if (logger.isInfoLoggable()) logger.info("Invoking Ajax request.", { method: finalRequest.method, url: url });

      xhr.open(finalRequest.method, url, true);
      if (timeout > 0) xhr.timeout = timeout * 1000;
      xhr.withCredentials = true;
      for (var k in headers) {
        var v = headers[k];
        if (k && v != null) {
          // omit "Content-Type" header if it's multipart/form-data, otherwise the browser doesn't update
          // it with proper boundary and server won't be able to parse the body
          if (k === "content-type" && body instanceof FormData && v === "multipart/form-data") continue;
          xhr.setRequestHeader(k.replace(/(^|-)./g, function (m) {
            return m.toUpperCase();
          }), v + "");
        }
      }
      xhr.ontimeout = function (e) {
        // TimeoutError
        logger.info("Request timed out.", { url: url });
        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.TimeoutError("Request timed out - " + url) }));
      };
      xhr.onload = function (e) {
        // status 200 - 5xx
        if (logger.isDebugLoggable()) logger.debug("Received response.", { url: url, status: xhr.status, data: xhr.response });else logger.info("Received response.", { url: url, status: xhr.status });
        resolve(interceptorMakeResponse(xhr, finalRequest, { data: xhr.response }));
      };
      xhr.onabort = function (e) {
        // user / developer abort; AbortError
        logger.info("Request has been aborted.", { url: url });
        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.AbortError("Request has been aborted - " + url) }));
      };
      xhr.onerror = function (e) {
        // network error; NetworkError
        logger.info("Request ended with network error.", { url: url });
        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.NetworkError("Network error - " + url), data: xhr.response }));
      };
      xhr.send(body);
    });
  }
};

/**
 * Invokes remote call using HTTP GET request. See {@link UuApp.AppClient.Client#post Client#post}
 * for detailed options and behaviour.
 * 
 * Keep in mind that the "parameters" parameter is sent via URL parameter(s)
 * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
 * doesn't exceed 2048 bytes.
 * 
 * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
 * @param {*} parameters The parameters to send in the request URL.
 * @param {Object} options Optional options for the remote call.
 * @return Promise resolving to a response object (or rejecting to a response object with error field).
 * @method UuApp.AppClient.Client#get
 * @see {@link UuApp.AppClient.Client#post Client#post}
 * 
 * @example
 *    // simple call
 *    var baseUri = Uri.parse(location.protocol + "//" + location.host + location.pathname).baseUri; // "http://example.com/vendor-app/tid-awid"
 *    Client.get(baseUri.join("+/getAttributes"), { param1: "v1" }).then(function success(response) {
 *      var data = response.data; // contains parsed response entity
 *      console.log(response.status, response.headers(), response.data);
 *    }, function error(response) {
 *      var error = response.error; // contains parsed response error
 *      console.log(response.status, response.headers(), response.error);
 *    });
 *    
 * @example
 *    // parameterizing uuUri and the call
 *    var uri = new UuApp.Uri.UriBuilder("/cds-gb-main/0-0/getAttributes", {
 *      workspace: "15634-34e5684da3435",
 *      useCase: "getConfig",
 *      parameters: { p1: "v1" }
 *    }).toUri();
 *    client.get(uri, null, {
 *      requestTimeout: 5,
 *      headers: {
 *        "x-my-header": "abc"
 *      }
 *    }).then(console.log.bind(console), console.log.bind(console));
 *    
 * @example
 *    // accept any response and don't parse it
 *    var workspace = "...";
 *    var guestbookId = "...";
 *    client.get(`/cds-gb/${workspace}/guestbook/${guestbookId}/downloadData`, null, {
 *      transformResponse: false,
 *      headers: {
 *        "accept": "*\/*"
 *      }
 *    }).then(console.log.bind(console), console.log.bind(console));
 */
Client.prototype.get = function (uri, parameters, options) {
  return this.invoke("get", uri, parameters, options);
};

/**
 * Invokes remote call using HTTP POST request. Default values for settings will
 * be filled in from Client instance configuration and then from global defaults.
 * 
 * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
 * to the specified "content-type" HTTP request/response header.
 * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
 * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or 
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or 
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
 * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
 * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
 * 
 * **Return value**
 * 
 * Return value is a {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
 * resolving / rejecting to a response object which contains following fields:
 * 
 * * {Object} data - response data. Data is parsed with content handler according to "content-type" response header
 *     unless option transformResponse is false (in which case it's left as received from browser).
 * * {Error} error - the error instance (see Error handling below). This field is set if and only if the Promise is rejected. 
 * * {number} status - the HTTP status code.
 * * {function(string)} headers - function which returns value of the specified (case-insenstive) response header.
 *   If called with no arguments, an array with all response headers is returned.
 * * {Object} config - final configuration options that were used for launching AJAX request.
 * 
 * The returned Promise instance additionally contains method {function()} abort for aborting ongoing remote call.
 * 
 * **File upload**
 * 
 * Use "content-type" header with "multipart/form-data" value when uploading binary data (File, Blob). Alternatively, it's
 * possible to use standard {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object - see examples
 * below. Note that when using FormData object, the order of appending the form fields matters - append simple values first
 * and only in the end append file objects. The reason is that in this order, the server might decide not to allow the upload
 * based on the other already-available fields thus allowing to end the connection without full upload of the file(s).
 * _(Client will fix the order of values in FormData object, however not all browsers support this operation.)_
 * 
 * Don't forget to **disable timeout when performing the upload** so that it doesn't get cancelled.  
 * 
 * **Error handling**
 * 
 * If an error happens during the call invocation (determined by HTTP response status code), the resulting Promise is
 * rejected with response object which will contain "error" field set to an instance of one of these error types
 * (when using default interceptors):
 * 
 *   * null - if server sent response with error HTTP status code but it contained no recognizable error data.
 *   * {@link UuApp.Error.RemoteError} - error as sent from remote server. Note that the response can contain
 *     several errors - in such case only first error is extracted into "error" field.
 *   * {@link UuApp.Error.NetworkError} - in case of problems with connecting to remote server.
 *   * {@link UuApp.Error.TimeoutError} - when the request didn't end within specified timeout.
 *   * {@link UuApp.Error.AbortError} - when invocation is aborted by invoking promise.abort() method.
 *   
 * The resulting response object contains also HTTP status code and will contain "data"
 * field set to the response entity (usually containing parsed error list).
 * 
 * **Timeout**
 * 
 * The timeout applies to the remote call duration only. If an interceptor is used which performs lengthy or asynchronous
 * operation prior to executing the remote call, it's not counted towards the timeout.
 * 
 * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
 * @param {(FormData|*)} parameters The DTO to send in the request body.
 * @param {Object} options Optional options for the remote call.
 * @param {number} options.requestTimeout The timeout for the command invocation. Default is 300.
 * @param {Object} options.headers The HTTP headers to send. Header names are case-insensitive, but it's advised
 *   to use lowercased names to prevent duplicities within the map. Headers are merged with default headers from
 *   Client / global configuration. If a header is in defaults and it's required to prevent it from being
 *   sent during this invocation, specify the header and use null as its value. 
 * @param {boolean} options.transformParameters If false, processing of the command parameters (DTO) will be skipped so they'll be
 *   sent exactly as-is (the browser must support sending the value as-is in XmlHttpRequest). Default value is true.
 * @param {boolean} options.transformResponse If false, processing of the response (such as parsing the response as JSON) will be skipped. Default is true.
 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
 *   as "gatewayUri" which then take precedence over those from global environment.
 * @return Promise resolving to a response object (or rejecting to a response object with error field).
 * @method UuApp.AppClient.Client#post
 * 
 * @example
 *    // command call sending data 
 *    var tenant = "UU-BT";
 *    var guestbookId = "123";
 *    client.post(`/cds-gb/${tenant}/guestbook/${guestbookId}/setAttributes`, {
 *      name: "Modified guestbook",
 *      invitesLimit: 10,
 *      public: true
 *    }).then(console.log.bind(console), console.log.bind(console));
 *    
 * @example
 *     // uploading file(s) - variant 1 (explicit Content-Type header)
 *     var file = inputElement.files[0];
 *     var params = {
 *       file: file,
 *       anotherValue: "abc"
 *     }
 *     client.post("/cds-gb/UU-BT/guestbook/123/uploadData", params, {
 *       requestTimeout: 0,
 *       headers: {
 *         "content-type": "multipart/form-data"
 *       }
 *     });
 *     
 *     // uploading file(s) - variant 2 (usage of FormData)
 *     // !!! append files as the last values
 *     var formData = new FormData();
 *     formData.append("anotherValue", "abc");
 *     formData.append("file", file);
 *     var promise = client.post("/cds-gb/UU-BT/guestbook/123/uploadData", formData, {
 *       requestTimeout: 0
 *     });
 *     promise.then(...); // process response / error
 *     
 *     // aborting ongoing call
 *     elementForUploadCancel.onclick = function (e) {
 *       promise.abort(); // promise will be rejected with UuApp.Error.AbortError instance
 *     };
 *     
 * @example
 *    // error distinguishing
 *    client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function success(response) {
 *      console.log(response.status, response.headers(), response.data);
 *    }, function error(response) {
 *      console.log(response.status, response.headers(), response.data);
 *      var error = response.error;
 *      if (error instanceof UuApp.Error.TimeoutError) console.log("Timed out.");
 *      else if (error instanceof UuApp.Error.AbortError) console.log("Aborted.");
 *      else if (error instanceof UuApp.Error.NetworkError) console.log("Communication / network error.");
 *      else if (response.status == 401) console.log("Not authenticated.");
 *      else if (response.status < 500) {
 *        console.log("User or client problem - invalid data / unfulfilled business rules / invalid call / ...", response.data);
 *      } else if (response.status >= 500) console.log("Server-side problem.", response.data);
 *      else console.log("Unrecognized problem.", error);
 *    });
 * 
 * @example
 *    // send data in custom format
 *    client.post("/cds-gb/UU-BT/guestbook/123/setSomething", convertToMySuperFormat(dto), {
 *      transformParameters: false,
 *      headers: {
 *        "content-type": "text/x-my-super-format"
 *      }
 *    }).then(console.log.bind(console), console.log.bind(console));
 */
Client.prototype.post = function (uri, parameters, options) {
  return this.invoke("post", uri, parameters, options);
};
//  Client.prototype.put = function (uri, parameters, options) {
//    return this.invoke("put", uri, parameters, options);
//  };
//  Client.prototype.delete = function (uri, options) {
//    return this.invoke("delete", uri, null, options);
//  };

var defClient;
/**
 * Equivalent to {@link UuApp.AppClient.Client#get} using Client with default
 * configuration, i.e.:
 * 
 *     new UuApp.AppClient.Client().get(uri, options)
 * 
 * @see {@link UuApp.AppClient.Client#get Client#get}
 * @method UuApp.AppClient.Client.get
 */
Client.get = function () /*uri, options*/{
  if (!defClient) defClient = new Client();
  return defClient.get.apply(defClient, arguments);
};

/**
 * Equivalent to {@link UuApp.AppClient.Client#post} using Client with default
 * configuration, i.e.:
 * 
 *     new UuApp.AppClient.Client().post(uri, parameters, options)
 * 
 * @see {@link UuApp.AppClient.Client#post Client#post}
 * @method UuApp.AppClient.Client.post
 */
Client.post = function () /*uri, parameters, options*/{
  if (!defClient) defClient = new Client();
  return defClient.post.apply(defClient, arguments);
};

/**
 * Interceptor for finalizing uuUri URL in case it's incomplete (missing gateway).
 * 
 * @name UuApp.AppClient.Client.UriHandler
 */
Client.UriHandler = UriHandler;
function UriHandler(request, options, nextInterceptorFn) {
  // take gateway from environment only when gateway is missing in URI (and environment was initialized)
  var uri = (request.uri || "").toString();
  request.uri = uri;
  if (uri.match(/^https?:/i)) return nextInterceptorFn(request, options);

  function carryOn(env) {
    if (baseUrl == null) {
      var optName = "gatewayUri";
      baseUrl = env ? env.get(optName) : null;
      if (baseUrl == null) baseUrl = "https://uuappg01.plus4u.net";
    }

    if (baseUrl) request.uri = baseUrl.replace(/\/+$/, "") + "/" + uri.replace(/^\/+/, "");
    return nextInterceptorFn(request, options);
  }
  var baseUrl = options["gatewayUri"];
  if (baseUrl == null) return Promise.resolve(_index2.Config.initPromise).then(carryOn);
  return carryOn();
}

/**
 * Interceptor for extracting error information from response.
 * 
 * @name UuApp.AppClient.Client.RemoteErrorHandler
 */
Client.RemoteErrorHandler = RemoteErrorHandler;
function RemoteErrorHandler(request, options, nextInterceptorFn) {
  // NOTE We assume that the "content-type" transformation has been already performed on response data.
  return nextInterceptorFn(request, options).then(checkError.bind(null, false), checkError.bind(null, true));

  function checkError(isReject, response) {
    if (response.status >= 400) {
      var errorData = response.data;
      // fill first error from response data into "error" field (if any)
      if (errorData && (typeof errorData === "undefined" ? "undefined" : _typeof(errorData)) === "object" && "uuAppErrorMap" in errorData) {
        var errorMap = errorData["uuAppErrorMap"];
        var firstErrorKey = null;
        if (errorMap) for (var k in errorMap) {
          if (errorMap[k] && errorMap[k].type === "error") {
            firstErrorKey = k;
            break;
          }
        }if (firstErrorKey) response.error = new _index.RemoteError(Object.assign({}, errorMap[firstErrorKey], { code: k }));
      }
      return Promise.reject(response);
    }
    return isReject ? Promise.reject(response) : response;
  }
}

/**
 * In case uuJSON format is used, validates input parameters to match uuJSON specification
 * (including validation of declared schema to match invoked command) and ensures uuJSON
 * usage is properly reported to remote server.
 * 
 * Recognized options:
 * 
 * * uujson {boolean} - whether uuJSON format is used. Parameters must contain schema and data.
 *  
 * @name UuApp.AppClient.Client.UujsonHandler
 */
Client.UujsonHandler = UujsonHandler;
function UujsonHandler(request, options, nextInterceptorFn) {
  var uri = request.uri + "";
  var isUujson = options["uujson"] || uri.match(/[?&]_uujson(=|$)/);
  if (isUujson) {
    var usedUri = uri.replace(/[?&]_uujson(?==|$)[^&]*/, "");
    usedUri += (usedUri.indexOf(/\?/) === -1 ? "?" : "&") + "_uujson=";
    request.uri = usedUri;
  }
  return nextInterceptorFn(request, options); // no .then(...) - no response post-processing
}

/**
 * Interceptor for transforming request parameters / response entity according to the Content Type.
 * Recognized options:
 * 
 * - transformParameters {boolean} - whether to transform (serialize by Content-Type) request body
 * - transformResponse {boolean} - whether to transform (deserialize by Content-Type) response body
 * - wrapQuery {boolean} - whether to wrap request body with { dto: ... }
 * 
 * @name UuApp.AppClient.Client.TransformParametersHandler
 */
Client.TransformParametersHandler = TransformParametersHandler;
function TransformParametersHandler(request, options, nextInterceptorFn) {
  function getMimeMainType(mimeType) {
    return (mimeType || "").replace(/[+;].*/, "").trim();
  }

  // add default Content-Type & Accept headers
  var paramsInBody = request.method.match(/^(put|post)$/i);
  var contentTransformers = Client.contentTransformers || {};
  var contentType = request.headers["content-type"];
  if (!("content-type" in request.headers)) {
    if (paramsInBody) {
      var isMultipartPreferred = request.body != null && (request.body instanceof FormData || request.body instanceof Blob || _typeof(request.body) == "object" && Object.keys(request.body).some(function (it) {
        return it instanceof FormData || it instanceof Blob;
      }));
      contentType = isMultipartPreferred ? "multipart/form-data" : "application/json; charset=utf-8";
      request.headers["content-type"] = contentType;
    } else {
      contentType = "application/x-www-form-urlencoded";
    }
  }
  if (!("accept" in request.headers)) request.headers["accept"] = "application/json";

  // wrap request data into "dto" parameter if requested to do so
  if (options.transformParameters !== false && !paramsInBody && request.body != null && options.wrapQuery && contentType == "application/x-www-form-urlencoded") {
    request.body = {
      dto: JSON.stringify(request.body)
    };
  }

  // transform request data
  if (options.transformParameters !== false && request.body != null) {
    var contentHandler = contentTransformers[getMimeMainType(contentType)];
    try {
      if (contentHandler) request.body = contentHandler.serialize(request.body);
    } catch (e) {
      throw new _index.Error("Error while serializing data.", e);
    }
  }

  // continue and transform response data afterwards (regardless of success / failure)
  return nextInterceptorFn(request, options).then(transformResponse.bind(null, false), transformResponse.bind(null, true));

  function transformResponse(isReject, response) {
    if (options.transformResponse !== false) {
      var respContentType = response.headers("content-type");
      var contentHandler = contentTransformers[getMimeMainType(respContentType)];
      try {
        if (contentHandler) response.data = contentHandler.deserialize(response.data);else if (response.status === 204) response.data = null;
      } catch (e) {
        throw new _index.Error("Error while deserializing response data.", e);
      }
    }
    return isReject ? Promise.reject(response) : response;
  }
}

/**
 * Interceptor for performance logging.
 * 
 * @name UuApp.AppClient.Client.PerfLogHandler
 */
function PerfLogHandler(request, options, nextInterceptorFn) {
  var promise;
  _index4.PerfLog.measureSection("commandInvocation", function (section) {
    request.headers["x-request-id"] = section.id;
    promise = nextInterceptorFn(request, options);
    return promise.then(function (response) {
      section.attributes["uri"] = request.uri;
      return response;
    }, function (response) {
      section.attributes["uri"] = request.uri;
      return Promise.reject(response);
    });
  });
  return promise;
}

function interceptorMakeResponse(xhr, request, extraFields) {
  return Object.assign({
    status: xhr ? xhr.status : 0,
    headers: function headers(aHeader) {
      if (!aHeader) return xhr ? xhr.getAllResponseHeaders() : [];
      return xhr ? xhr.getResponseHeader(aHeader) : null;
    }
  }, extraFields);
}

var Json = {
  serialize: function serialize(value) {
    return JSON.stringify(value);
  },
  deserialize: function deserialize(value) {
    return value ? JSON.parse(value) : null;
  }
};
var Form = {
  serialize: function serialize(value) {
    if (value == null) return value;
    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
      logger.warn("Unrecognized value when serializing as application/x-www-form-urlencoded - passing as-is. Value:", { value: value });
      return value;
    }
    var result = [];
    for (var k in value) {
      result.push(encodeURIComponent(k) + "=" + encodeURIComponent(value[k]));
    }return result.join("&");
  },
  deserialize: function deserialize(value) {
    if (value == null) return value;
    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
      logger.warn("Unrecognized value when deserializing as application/x-www-form-urlencoded - passing as-is. Value:", { value: value });
      return value;
    }
    var pairs = value.replace(/\+/g, " ").split("&");
    var result = {};
    for (var i = 0; i < pairs.length; ++i) {
      var pair = pairs[i];
      pair.replace(/^([^=]*)=?(.*)$/, function (m, g1, g2) {
        return result[decodeURIComponent(g1)] = decodeURIComponent(g2);
      });
    }
    return result;
  }
};
var MultiPart = {
  serialize: function serialize(value) {
    if (!value) return value;
    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
      logger.warn("Unrecognized value when serializing as multipart/form-data - passing as-is. Value:", { value: value });
      return value;
    }
    if (value instanceof FormData && typeof value.entries != "function") return value; // FormData without support for iterating over its entries
    if (value instanceof Blob) value = { file: value };

    // make a list and reorder values so that the File instances are at the end of the list
    var data = {};
    if (value instanceof FormData) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = value.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pair = _step.value;
          data[pair[0]] = pair[1];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      data = value;
    }
    var list = [];
    for (var k in data) {
      list.push({ key: k, value: data[k], i: list.length });
    }var max = list.length;
    list.sort(function (a, b) {
      // stable sort
      return (a.value instanceof File ? a.i + max : a.i) - (b.value instanceof File ? b.i + max : b.i);
    });

    // fill values into FormData
    var formData = new FormData();
    list.forEach(function (it) {
      return formData.append(it.key, it.value);
    });
    return formData;
  },
  deserialize: function deserialize(value) {
    throw new _index.Error("Deserializing multipart/form-data is not supported. Value: " + value);
  }
};

/**
 * Transformers which serialize / deserialize content that is sent to / received from
 * server using specific MIME type.
 */
Client.contentTransformers = {
  "application/json": Json,
  // "application/json+extended": Json,
  //"application/x-msgpack": MessagePack,
  //"application/msgpack": MessagePack,
  "application/x-www-form-urlencoded": Form,
  "multipart/form-data": MultiPart
};

module.exports = Client;