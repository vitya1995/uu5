"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _Discovery = require("../discovery/Discovery.js");

var _Discovery2 = _interopRequireDefault(_Discovery);

var _PromiseUtil = require("../util/PromiseUtil.js");

var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

var _PopupComponent = require("../ui/PopupComponent.js");

var _PopupComponent2 = _interopRequireDefault(_PopupComponent);

var _IframeComponent = require("../ui/IframeComponent.js");

var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

var _Jwt = require("../jwt/Jwt.js");

var _Jwt2 = _interopRequireDefault(_Jwt);

var _InvalidTokenError = require("../jwt/InvalidTokenError.js");

var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

var _Jwks = require("../jwks/Jwks.js");

var _Jwks2 = _interopRequireDefault(_Jwks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GRACE_PERIOD = 300;

var ImplicitFlow = {
  /**
   * @param options.serverUri
   * @param options.clientId
   * @param options.redirectUri
   * @param options.loginVisualComponent
   * @param options.loginParams Additional URL parameters to be passed in the HTTP request.
   */
  login: function login(options) {
    var opts = options || {};

    // check that required data is available
    var serverUri = opts.serverUri;
    if (!serverUri) throw new Error("ImplicitFlow.login requires option 'serverUri'.");
    var clientId = opts.clientId;
    if (!clientId) throw new Error("ImplicitFlow.login requires option 'clientId'.");
    var redirectUri = opts.redirectUri;
    if (!redirectUri) throw new Error("ImplicitFlow.login requires option 'redirectUri'.");

    // NOTE Using PromiseUtil.immediateThen which will run our "then" callback immediately if
    // the Discovery.getMetadata is already resolved. The idea is that this login could have
    // been triggered from "click" event and we need to open popup window within this event's
    // lifetime or within single Promise (but not Promise chain because that doesn't work on
    // iPhones).
    return _PromiseUtil2.default.immediateThen(_Discovery2.default.getMetadata(serverUri), function (oidcMetadata) {
      // prepare login URL
      var loginParams = Object.assign({ scope: "openid" }, opts.loginParams, {
        response_type: "id_token token",
        client_id: clientId,
        redirect_uri: redirectUri
      });
      var loginParamsParts = [];
      for (var k in loginParams) {
        var v = loginParams[k];
        if (v == null) continue;
        loginParamsParts.push(encodeURIComponent(k) + "=" + encodeURIComponent(v + ""));
      }
      var loginUrl = oidcMetadata.authorization_endpoint + "?" + loginParamsParts.join("&");

      // display visual component for logging in (popup window)
      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != "none" ? _PopupComponent2.default : _IframeComponent2.default);
      return new Promise(function (resolve, reject) {
        new LoginVisualComponent({
          url: loginUrl,
          onResult: function onResult(aLoginResult) {
            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);
            if (authResponse === false) return reject(new Error("User refused to log in."));
            if (authResponse === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return reject(new Error("Login failed due to popup blocking."));

            // resolve the promise successfully with the token (iff there's no "error" field)
            if (authResponse.error) reject(authResponse);else resolve(authResponse);
          }
        }).render();
      });
    }, function (e) {
      return Promise.reject(e);
    });
  },

  validateAuthResponse: function validateAuthResponse(authResponse, opts) {
    // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation
    // 1. process only recognized fields in response (id_token, expires_in, ...)
    // 2. validate implicit flow callback response ("state")
    // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
    //     ii. validate signature
    //    iii. validate nonce
    // 4. validate access_token

    // 2.i. validate state
    if (opts.loginParams.state && authResponse.state !== opts.loginParams.state) throw new Error("Invalid 'state' in received authorization response. Expected " + opts.loginParams.state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));

    // 2.ii. validate expiration
    if (ImplicitFlow.isAuthResponseExpired(authResponse)) throw new Error("Token expired " + JSON.stringify(authResponse));

    // 3. validate id_token with nonce
    return ImplicitFlow.validateIdToken(authResponse.id_token, opts).then(function (claims) {
      return { authResponse: authResponse, claims: claims };
    });

    // 4. validate access_token
    // NOTE Ignore - we're not using access_token field.
  },
  isAuthResponseExpired: function isAuthResponseExpired(authResponse) {
    var now = new Date().getTime() / 1000;
    var leeway = 60;
    var expired = false;
    if (!authResponse.issued_at) authResponse.issued_at = now;
    if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;
    if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;
    return expired;
  },


  /**
   * @param {*} e The error during authorization.
   * @return Whether the error means that the user is not logged in on the remote server.
   */
  isLoggedOutError: function isLoggedOutError(e) {
    return e && (typeof e === "undefined" ? "undefined" : _typeof(e)) == "object" && typeof e["error_description"] == "string" && e["error_description"].match(/interaction/i) && e["error_description"].match(/required/i);
  },


  /**
   * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.
   */
  validateIdToken: function validateIdToken(token, _ref) {
    var serverUri = _ref.serverUri,
        nonce = _ref.loginParams.nonce;

    // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
    //         1. -Decrypt JWE - not supported.
    //         2. +REQUIRED validate 'iss'
    //         3. +REQUIRED validate 'aud'
    //         4. -SHOULD validate multiple 'aud' vs. 'azp'
    //         5. -SHOULD validate 'azp'
    //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>
    //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration
    //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)
    //         9. +REQUIRED current time < 'exp'
    //        10. +CAN check 'iat'
    //        11. +REQUIRED (for implicit flow) validate nonce
    //        12. -SHOULD check if 'acr' is appropriate
    //        13. -SHOULD check if 'auth_time' was requested.
    //     ii. validate signature
    //    iii. validate nonce
    return _Discovery2.default.getMetadata(serverUri).then(function (metadata) {
      var verifyOptions = {
        // NOTE IE11 doesn't have RS512 (but it has "RS256" and "RS384").
        alg: ["RS256"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)
        iss: [metadata.issuer], // 3.i.2.
        // aud: clientId, // 3.i.3. TODO We don't have the proper value.
        // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') 
        gracePeriod: GRACE_PERIOD
      };
      return _Jwt2.default.decode(token, verifyOptions, function (jwtHeader) {
        // 3.ii.
        if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\d+$/)) throw new Error("Invalid token. Only RSA signature is supported, but token uses algorithm '" + jwtHeader.alg + "'. Token: " + token);
        var keyType = "RSA";

        // check algorithm in token (whether it's really supported by the server)
        var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];
        if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error("Invalid token. Token was signed using algorithm '" + jwtHeader.alg + "' but the OIDC server '" + serverUri + "' supports only " + JSON.stringify(supportedAlgs) + ". Token: " + token);

        // pick the key from JWK Set
        var jwks = new _Jwks2.default({ serverUri: serverUri });
        return jwks.getKey(jwtHeader.kid, keyType).catch(function (e) {
          throw new Error("Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server " + serverUri + ". Token: " + token, e);
        });
      }).then(function (claims) {
        // 3.i.11., 3.iii. validate nonce
        if (nonce && claims.nonce !== nonce) throw new _InvalidTokenError2.default("Invalid nonce in ID token claims. Expected " + nonce + " but got " + claims.nonce);
        return claims;
      });
    });
  },


  /**
   * 
   * @param {*} aLoginCallbackResult 
   * @return One of: 
   * * false - user refused to log in (or popups are blocked)
   * * object with "error" field set - an error
   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
   */
  getAuthResponseFromCallback: function getAuthResponseFromCallback(aLoginCallbackResult) {
    if (aLoginCallbackResult === false || aLoginCallbackResult === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return aLoginCallbackResult;
    if (aLoginCallbackResult instanceof Error) return { error: aLoginCallbackResult };

    // extract login token
    // example of successful aLoginCallbackResult: "...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid" 
    // example of error aLoginCallbackResult:      "...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
    var authResponse = {};
    aLoginCallbackResult.replace(/^[^#]*#?/, "").split(/&/).forEach(function (it) {
      var eqlIdx = it.indexOf("=");
      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
      var value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
      authResponse[key] = value;
    });
    return authResponse;
  }
};

exports.default = ImplicitFlow;