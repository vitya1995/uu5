"use strict";

var _Base64Url = require("../util/Base64Url.js");

var _Base64Url2 = _interopRequireDefault(_Base64Url);

var _InvalidTokenError = require("./InvalidTokenError.js");

var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {
    var webCryptoAlgorithm = {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-" + alg.substr(2) }
    };
    // MS Edge throws error if the key contains field "use" => remove it
    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails
    var usedKey = JSON.parse(JSON.stringify(key));
    delete usedKey.use;

    return crypto.subtle.importKey("jwk", usedKey, webCryptoAlgorithm, false, ["verify"]).then(function (webCryptoKey) {
      // validate signature
      var signatureB64U = tokenParts[2];
      var data = tokenParts[0] + "." + tokenParts[1];
      var signatureBytes = asciiToUint8Array(_Base64Url2.default.decodeToAscii(signatureB64U));
      var dataBytes = asciiToUint8Array(data);
      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);
    }, function (importError) {
      var e = new Error("Unable to verify JSON Web Token - importing key via WebCrypto API failed.\nKey: " + JSON.stringify(usedKey) + "\nToken: " + token + "\nError: " + importError);
      e.cause = importError;
      return Promise.reject(e);
    }).then(function (signatureValid) {
      if (!signatureValid) throw new _InvalidTokenError2.default("Invalid JSON Web Token - signature is not valid. Token: " + token);
      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
      var body = JSON.parse(bodyStr);
      var throwError = function throwError(txt, failedClaim) {
        throw new _InvalidTokenError2.default("Invalid token: " + txt + "\nFailed claim: " + JSON.stringify(failedClaim) + "\nIssued by: " + JSON.stringify(body.iss) + "\nVerification options: " + JSON.stringify(verifyOpts) + "\nToken: " + token);
      };

      // verify claims

      // 'alg' is always checked
      if (!verifyOpts.alg) throw new Error("Unable to verify JWT claim - 'alg' field must be always given for verification.");
      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError("Algorithm " + JSON.stringify(header.alg) + " used by token is not valid - expected one of " + JSON.stringify(verifyOpts.alg) + ".", "alg");

      // 'iss'
      var v;
      v = asArray(verifyOpts.iss);
      if (v && v.indexOf(body.iss) === -1) throwError("Issuer URI " + JSON.stringify(body.iss) + " in token is not valid - expected one of " + JSON.stringify(v) + ". Token was issued by different OpenID Connect server or it was forged.", "iss");

      // 'sub'
      v = asArray(verifyOpts.sub);
      if (v && v.indexOf(body.sub) === -1) throwError("Subject " + JSON.stringify(body.sub) + " in token is not valid - expected one of " + JSON.stringify(v) + ".", "sub");

      // 'aud' - all values from verifyOpts.aud must be present in body.aud 
      v = asArray(verifyOpts.aud);
      var bodyV = asArray(body.aud) || [];
      if (v && bodyV.some(function (bv) {
        return v.indexOf(bv) == -1;
      })) throwError("Audience list " + JSON.stringify(bodyV) + " in token is not valid - some of following values are missing: " + JSON.stringify(v) + ".", "aud");

      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)
      var now = Date.now() / 1000;
      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;
      var gracePeriod = verifyOpts.gracePeriod || 0;

      // 'exp' - expires
      if (typeof body.exp === "number" && body.exp + gracePeriod < now) throwError("Token already expired at " + toTimeString(body.exp) + ", current time is " + toTimeString(now) + ".", "exp");

      // 'nbf' - not before
      if (typeof body.nbf === "number" && now < body.nbf - gracePeriod) throwError("Token is not yet valid - it will become valid at " + toTimeString(body.nbf) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "nbf");

      // 'iat' - issued at time
      if (typeof body.iat === "number" && now < body.iat - gracePeriod) throwError("Token seems to have been issued in the future - " + toTimeString(body.iat) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "iat");

      // 'jti' - JWT id
      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError("Token ID " + JSON.stringify(body.jti) + " not valid - expected " + JSON.stringify(verifyOpts.jti) + ".", "jti");

      return true;
    });
  }
};

function asciiToUint8Array(ascii) {
  return new Uint8Array(ascii.split("").map(function (c) {
    return c.charCodeAt(0);
  }));
}
function asArray(value) {
  if (value == null) return null;
  if (Array.isArray(value)) return value;
  return [value];
}
function toTimeString(seconds) {
  return new Date(seconds * 1000).toISOString().replace(/T/, " ");
}