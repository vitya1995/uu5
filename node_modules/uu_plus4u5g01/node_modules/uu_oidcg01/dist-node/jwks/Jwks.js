"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Discovery = require("../discovery/Discovery.js");

var _Discovery2 = _interopRequireDefault(_Discovery);

var _HttpClient = require("../util/HttpClient.js");

var _HttpClient2 = _interopRequireDefault(_HttpClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var jwkSetCache = {};
var cacheBustCounter = 0;

// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517

var _class = function () {
  function _class(options) {
    _classCallCheck(this, _class);

    if (!options || !options.serverUri) throw new Error("Jwks must be initialized with options containing serverUri.");
    this.options = options;
  }

  _createClass(_class, [{
    key: "getKey",
    value: function getKey(keyId, keyType) {
      return this._getKey(keyId, keyType, false);
    }
  }, {
    key: "_getKey",
    value: function _getKey(keyId, keyType, forceKeySetReload) {
      var _this = this;

      // load set of OIDC server JSON Web Key-s
      return _Discovery2.default.getMetadata(this.options.serverUri).then(function (metadata) {
        // TODO Use also localStorage cache as optimization.
        var jwkSetMeta = jwkSetCache[metadata.jwks_uri];
        if (!jwkSetMeta || forceKeySetReload) {
          var url = metadata.jwks_uri;
          if (forceKeySetReload) url = url.replace(/(\?.*)?$/, function (m) {
            return "?cachebust=" + Date.now().toString(36) + "_" + (cacheBustCounter++).toString(36) + (m ? "&" + m.substr(1) : "");
          });
          jwkSetMeta = jwkSetCache[metadata.jwks_uri] = _HttpClient2.default.get(url).then(function (value) {
            return { jwkSet: value, url: url };
          });
        }
        return jwkSetMeta;
      }).then(function (jwkSetMeta) {
        var jwkSet = jwkSetMeta.jwkSet;
        // choose key by id & type
        var keys = jwkSet.keys;
        if (keyId) keys = keys.filter(function (it) {
          return it.kid === keyId;
        }); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)
        if (keyType) keys = keys.filter(function (it) {
          return it.kty === keyType;
        });
        // keys = keys.filter(it => it.use === "sig" || (it.key_ops||[]).indexOf("verify") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)
        if (keys.length != 1) {
          // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser
          // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)
          if (!forceKeySetReload) return _this._getKey(keyId, keyType, true);
          throw new Error("There's " + keys.length + " JSON Web Key(s) in JWK Set with kid='" + keyId + "' kty='" + keyType + "'. There must be exactly 1. JWK Set has been downloaded from: " + jwkSetMeta.url);
        }
        return keys[0];
      });
    }
  }]);

  return _class;
}();

exports.default = _class;