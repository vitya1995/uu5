'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContentMixin = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _tools = require('./tools.js');

var _tools2 = _interopRequireDefault(_tools);

var _environment = require('../environment/environment.js');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ContentMixin = exports.ContentMixin = {

  //@@viewOn:statics
  statics: {
    "UU5.Common.ContentMixin": {
      requiredMixins: ["UU5.Common.BaseMixin"],
      defaults: {
        standardMode: 'standard',
        outlineMode: 'outline',
        regexpUu5: /^\s*<(uu5json|uu5string|uu5data)\s*\/>/
      },
      errors: {
        unexpectedContentType: 'Type "%s" of content property is unexpected.',
        dynamicOnly: 'Method %s can be used just for dynamic content.',
        insertedchildIdNotExists: 'Child with ID %s does not exist.',
        childIdNotExists: 'Child with ID %s does not exist.',
        indexNotSet: 'In this case index has to be specified.',
        addRenderedChildToIdList_IdDuplicity: 'There is duplicity ID %s in adding rendered child to the list of children by ID.',
        addRenderedChildToNameList_IdDuplicity: 'There is Name duplicity in adding rendered child to the list children by Name.'
      }
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    content: _propTypes2.default.oneOfType([
    // content array:[bodyItem, items, node, number, bool, string]
    _propTypes2.default.array,
    // content bodyItem:{tag:'',props{}}
    _propTypes2.default.shape({
      tag: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
      props: _propTypes2.default.arrayOf(_propTypes2.default.object)
    }),
    // content items:{tag:'',propsArray:[{},{},{},...]}
    _propTypes2.default.shape({
      tag: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
      propsArray: _propTypes2.default.arrayOf(_propTypes2.default.object)
    }),
    // content node
    _propTypes2.default.node,
    // number
    _propTypes2.default.number,
    // bool
    _propTypes2.default.bool]),
    ignoreInnerHTML: _propTypes2.default.bool,
    checkSpaces: _propTypes2.default.bool,
    checkGrammar: _propTypes2.default.bool,
    checkHighlight: _propTypes2.default.bool,
    textCorrector: _propTypes2.default.bool,
    dynamic: _propTypes2.default.bool,
    mode: _propTypes2.default.oneOf(['standard', 'outline'])
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      content: null,
      ignoreInnerHTML: false,
      checkSpaces: false,
      checkGrammar: false,
      checkHighlight: false,
      textCorrector: false,
      dynamic: false,
      mode: 'standard'
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState: function getInitialState() {
    // initialize
    this.registerMixin("UU5.Common.ContentMixin");

    this.renderedChildren = []; // [renderedChild,renderedChild,...]
    this.renderedChildrenIdList = {}; // {id:renderedChild,id:renderedChild,...}
    this.renderedChildrenNameList = {}; // {name:renderedChild,name:renderedChild,...}

    // state
    var state = {
      mode: this.props.mode
    };

    if (this.isDynamic()) {
      state.children = this.buildChildren(this.props);
      state.filter = null;
      state.filteredProps = null;
      state.sorter = null;
      state.sortedIds = null;
    }

    return state;
  },

  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this.isDynamic() && this.setChildren(this.buildChildren(nextProps));
      nextProps.mode !== this.props.mode && this.setState({ mode: nextProps.mode });
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  hasUU5CommonContentMixin: function hasUU5CommonContentMixin() {
    return this.hasMixin("UU5.Common.ContentMixin");
  },

  isDynamic: function isDynamic() {
    return this.props.dynamic;
  },

  getContent: function getContent() {
    return this.props.content;
  },

  getUU5CommonContentMixinProps: function getUU5CommonContentMixinProps() {
    return {
      content: this.getContent(),
      dynamic: this.isDynamic(),
      ignoreInnerHTML: this.props.ignoreInnerHTML,
      checkSpaces: this.props.checkSpaces,
      checkGrammar: this.props.checkGrammar,
      checkHighlight: this.props.checkHighlight,
      mode: this.props.mode
    };
  },

  getUU5CommonContentMixinPropsToPass: function getUU5CommonContentMixinPropsToPass() {
    return this.getUU5CommonContentMixinProps();
  },

  expandChildProps: function expandChildProps(prevChild, childIndex) {
    var newChildProps = prevChild.props;
    newChildProps = _tools2.default.mergeDeep({}, newChildProps);

    // key is id if id is set, or it is childIndex
    // Key can not be generated because of in each render the child has new key and child is unmounted and mounted again
    var key = newChildProps.id || childIndex;

    var isUU5Child = typeof prevChild.type === 'function' && prevChild.type.tagName;

    if (isUU5Child) {
      newChildProps.parent = newChildProps.parent || this;
      //newChildProps.parent = this;

      this.isDynamic() && (newChildProps.id = newChildProps.id || _tools2.default.generateUUID());

      if (typeof this.expandChildProps_ === 'function') {
        var tempChild = _react2.default.cloneElement(prevChild, newChildProps);
        newChildProps = this.expandChildProps_(tempChild, childIndex);
      }
    }

    newChildProps.key = newChildProps.key || key;

    if (isUU5Child) {
      newChildProps.ref = function (renderedChild) {
        renderedChild && this.registerRenderedChild(renderedChild, childIndex);
      }.bind(this);
    }

    return newChildProps;
  },

  buildChild: function buildChild(childTag, childProps, children) {
    if (childProps && childProps.href && childProps.href.match(/^javascript:/i)) {
      childProps = _tools2.default.merge({}, childProps);
      childProps.href = childProps.href.replace(_tools.REGEXP.jsCode, "");
    }
    return _tools2.default.findComponent(childTag, childProps, children);
  },

  cloneChild: function cloneChild(child, props) {
    var clonedChild = void 0;
    if (this.expandChild_) {
      clonedChild = this.expandChild_(_react2.default.cloneElement(child, props), props.key);
    }

    return clonedChild || _react2.default.cloneElement(child, props);
  },

  buildNodeChildren: function buildNodeChildren(children, childPropsExpander) {
    var content = this;
    var newChildren = [];
    _react2.default.Children.forEach(children, function (child, i) {
      if (child !== undefined && child !== null) {
        if (content.shouldChildRender(child)) {
          if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) === 'object') {
            var newChildProps = childPropsExpander(child, i);
            var newChild = content.cloneChild(child, newChildProps);

            // text
          } else {
            // it does not need to cover just spaces by textCorrector
            if (typeof child === 'number' || child.trim() === '' || !_environment2.default.textCorrector && !content.props.textCorrector || !content.props.checkSpaces && !content.props.checkGrammar && !content.props.checkHighlight) {
              newChild = child;
              if (content.expandChild_) {
                newChild = content.expandChild_(newChild, i);
              }
            } else {
              var props = {
                text: child,
                checkSpaces: content.props.textCorrector || content.props.checkSpaces,
                checkGrammar: content.props.textCorrector || content.props.checkGrammar,
                checkHighlight: content.props.textCorrector || content.props.checkHighlight,
                language: content.props.language,
                key: i
              };
              newChild = content.cloneChild(_tools2.default.findComponent('UU5.Common.TextCorrector', props), props);

              if (content.expandChild_) {
                newChild = content.expandChild_(newChild, i);
              }
            }
          }
          newChildren.push(newChild);
        }
      }
    });

    return newChildren;
  },

  shouldChildRender: function shouldChildRender(child) {
    var childTag = _tools2.default.getChildTag(child);
    var result = _environment2.default.nestingLevelStrict ? childTag && !!childTag["UU5.Common.NestingLevelMixin"] : true;

    if (result && typeof this.shouldChildRender_ === 'function') {
      result = this.shouldChildRender_(child);
    }
    return result;
  },

  buildChildren: function buildChildren(contentProps, childPropsExpander, childIndex) {
    var _this = this;

    var children = null;

    if (typeof this.buildChildren_ === 'function') {
      children = this.buildChildren_(contentProps, childPropsExpander);
    } else {
      contentProps = contentProps || this.props;
      childPropsExpander = childPropsExpander || this.expandChildProps;
      childIndex = childIndex || 0;

      var contentValue = contentProps.content;
      var contentType = this._getContentType(contentValue);

      if (contentType === 'uu5json') {
        contentValue = _tools2.default.parseFromUu5JSON(contentValue);
        contentType = this._getContentType(contentValue);
      } else if (contentType === 'uu5data') {
        contentValue = _tools2.default.parseFromUu5Data(contentValue);
        contentType = this._getContentType(contentValue);
      }

      switch (contentType) {
        case 'bodyItem':
          var bodyItemChild = this.buildChild(contentValue.tag, contentValue.props);
          this.shouldChildRender(bodyItemChild) && (children = [this.cloneChild(bodyItemChild, childPropsExpander(bodyItemChild, childIndex))]);
          break;
        case 'array':
          children = contentValue.map(function (bodyItem, i) {
            return _this.buildChildren({ content: bodyItem }, childPropsExpander, i);
          });
          break;
        case 'items':
          var tag = _tools2.default.checkTag(contentValue.tag, true);
          children = [];
          contentValue.propsArray.forEach(function (props, i) {
            var child = tag ? _this.buildChild(tag, props) : _tools2.default.findComponent(contentValue.tag, props);
            child = _this.cloneChild(child, childPropsExpander(child, i));
            _this.shouldChildRender(child) && children.push(child);
          });
          break;
        case 'string':
          if (contentValue.trim() === '' || !_environment2.default.textCorrector && !this.props.textCorrector && !this.props.checkSpaces && !this.props.checkGrammar && !this.props.checkHighlight) {
            children = contentValue;
          } else {
            children = _tools2.default.findComponent('UU5.Common.TextCorrector', {
              parent: this,
              text: contentValue,
              checkSpaces: this.props.textCorrector || this.props.checkSpaces,
              checkGrammar: this.props.textCorrector || this.props.checkGrammar,
              checkHighlight: this.props.textCorrector || this.props.checkHighlight,
              language: this.props.language
            });
          }
          break;
        case 'number':
          children = contentValue;
          break;
        case 'element':
          children = this.cloneChild(contentValue, childPropsExpander(contentValue, childIndex));
          break;
        case 'bool':
          children = contentValue ? 'true' : 'false';
          break;
        case 'uu5string':
          var stringChildren = _tools2.default.getChildrenFromUu5String(contentValue);
          children = this.buildNodeChildren(stringChildren, childPropsExpander);
          break;
        case 'children':
        default:
          if (contentProps.children) {
            children = this.buildNodeChildren(contentProps.children, childPropsExpander);
          }
      }
    }

    return children;
  },

  getStandardChildren: function getStandardChildren() {
    return this.isDynamic() ? this.state.children : this.buildChildren();
  },

  getOutlineChildren: function getOutlineChildren() {
    return _tools2.default.findComponent('UU5.Common.Outline', { element: this, key: 0 });
  },

  getChildren: function getChildren() {
    var children = null;

    switch (this.getMode()) {
      case this.getDefault('standardMode', "UU5.Common.ContentMixin"):
        children = this.getStandardChildren();
        break;
      case this.getDefault('outlineMode', "UU5.Common.ContentMixin"):
        children = this.getOutlineChildren();
        break;
    }

    return children;
  },

  getRenderedChildren: function getRenderedChildren() {
    return this.renderedChildren;
  },

  setRenderedChildren: function setRenderedChildren(childrenIndexList) {
    this.renderedChildren = childrenIndexList;
    return this;
  },

  addRenderedChild: function addRenderedChild(renderedChild, index) {
    if (index === undefined || index === null) {
      this.showError('indexNotSet', null, {
        mixinName: "UU5.Common.ContentMixin",
        context: {
          index: index,
          renderedChild: {
            tagName: renderedChild.getTagName(),
            id: renderedChild.getId(),
            component: renderedChild
          }
        }
      });
    } else {
      this.getRenderedChildren().splice(index, 0, renderedChild);
    }
    return this;
  },

  removeRenderedChild: function removeRenderedChild(renderedChild) {
    this.getRenderedChildren().splice(renderedChild.getIndex(), 1);
    return this;
  },

  getRenderedChildrenIdList: function getRenderedChildrenIdList() {
    return this.renderedChildrenIdList;
  },

  setRenderedChildrenIdList: function setRenderedChildrenIdList(childrenIdList) {
    this.renderedChildrenIdList = childrenIdList;
    return this;
  },

  addRenderedChildToIdList: function addRenderedChildToIdList(renderedChild) {
    var id = renderedChild.getId();
    if (!this.getRenderedChildById(id)) {
      this.getRenderedChildrenIdList()[id] = renderedChild;
    } else if (this.getRenderedChildById(id) !== renderedChild) {
      this.showError('addRenderedChildToIdList_IdDuplicity', id, {
        mixinName: "UU5.Common.ContentMixin",
        context: {
          renderedChildrenIdList: this.getRenderedChildrenIdList(),
          renderedChild: {
            tagName: renderedChild.getTagName(),
            id: renderedChild.getId(),
            component: renderedChild
          }
        }
      });
    }
    return this;
  },

  removeRenderedChildFromIdList: function removeRenderedChildFromIdList(renderedChild) {
    delete this.getRenderedChildrenIdList()[renderedChild.getId()];
    return this;
  },

  getRenderedChildrenNameList: function getRenderedChildrenNameList() {
    return this.renderedChildrenNameList;
  },

  setRenderedChildrenNameList: function setRenderedChildrenNameList(childrenNameList) {
    this.renderedChildrenNameList = childrenNameList;
    return this;
  },

  addRenderedChildToNameList: function addRenderedChildToNameList(renderedChild) {
    var name = renderedChild.getName();
    if (name) {
      var nameList = this.getRenderedChildrenNameList();
      if (!nameList[name] || nameList[name].map(function (rChild) {
        return rChild.getId();
      }).indexOf(renderedChild.getId()) === -1) {

        nameList[name] = nameList[name] || [];
        nameList[name].push(renderedChild);
      }
    }
    return this;
  },

  removeRenderedChildFromNameList: function removeRenderedChildFromNameList(renderedChild) {
    var nameChildren = this.getRenderedChildrenByName(renderedChild.getName());
    if (nameChildren) {
      var childIndex = nameChildren.map(function (rChild) {
        return rChild.getId();
      }).indexOf(renderedChild.getId());

      childIndex > -1 && nameChildren.splice(childIndex, 1);
    }
    return this;
  },

  getChildIndexById: function getChildIndexById(childId) {
    var childIndex;

    if (typeof this.getChildIndexById_ === 'function') {
      childIndex = this.getChildIndexById_(childId);
    } else {
      var children = this.getRenderedChildren();

      var index = childId && children.map(function (child) {
        return child.getId() === childId;
      }).indexOf(true);

      childIndex = index === -1 ? null : index;
    }

    return childIndex;
  },

  getRenderedChildById: function getRenderedChildById(childId) {
    var renderedChild;

    if (typeof this.getRenderedChildById_ === 'function') {
      renderedChild = this.getRenderedChildById_(childId);
    } else {
      renderedChild = this.getRenderedChildrenIdList()[childId] || null;
    }

    return renderedChild;
  },

  getRenderedChildrenByName: function getRenderedChildrenByName(childName) {
    return this.getRenderedChildrenNameList()[childName] || null;
  },

  getRenderedChildByName: function getRenderedChildByName(childName) {
    var renderedChild;

    if (typeof this.getRenderedChildByName_ === 'function') {
      renderedChild = this.getRenderedChildByName_(childName);
    } else {
      var nameChildren = this.getRenderedChildrenByName(childName);
      renderedChild = nameChildren ? nameChildren[0] : null;
    }

    return renderedChild;
  },

  getRenderedChildByIndex: function getRenderedChildByIndex(index) {
    var renderedChild;

    if (typeof this.getRenderedChildByIndex_ === 'function') {
      renderedChild = this.getRenderedChildByIndex_(index);
    } else {
      renderedChild = this.getRenderedChildren()[index] || null;
    }

    return renderedChild;
  },

  getRenderedChildByTagName: function getRenderedChildByTagName(tagName) {
    var foundChild = null;

    if (typeof this.getRenderedChildByTagName_ === 'function') {
      foundChild = this.getRenderedChildByTagName_(tagName);
    } else {
      this.eachRenderedChild(function (renderedChild) {
        var condition = renderedChild.getTagName() === tagName;
        condition && (foundChild = renderedChild);
        return !condition; // false <=> end of cycle
      });
    }

    return foundChild;
  },

  getFirstRenderedChild: function getFirstRenderedChild() {
    var renderedChild = null;

    if (typeof this.getFirstRenderedChild_ === 'function') {
      renderedChild = this.getFirstRenderedChild_();
    } else {
      renderedChild = this.getRenderedChildByIndex(0);
    }

    return renderedChild;
  },

  getLastRenderedChild: function getLastRenderedChild() {
    var renderedChild = null;

    if (typeof this.getLastRenderedChild_ === 'function') {
      renderedChild = this.getLastRenderedChild_();
    } else {
      renderedChild = this.getRenderedChildByIndex(this.getRenderedChildren().length - 1);
    }

    return renderedChild;
  },

  eachRenderedChild: function eachRenderedChild(callback) {
    // function callbackFunction( renderedChild, renderedChildIndex );
    if (typeof this.eachRenderedChild_ === 'function') {
      this.eachRenderedChild_(callback);
    } else {
      var renderedChildren = this.getRenderedChildren();

      // same as: for(var i = 0; i < renderedChildren.length; i++) {
      //          var renderedChild = renderedChildren[i];
      for (var i = 0, renderedChild; renderedChild = renderedChildren[i]; ++i) {
        var result = callback(renderedChild, i);
        if (result === false) {
          break;
        }
      }
    }
    return this;
  },

  registerRenderedChild: function registerRenderedChild(renderedChild, index) {
    if (renderedChild.hasUU5CommonBaseMixin && !this.getRenderedChildById(renderedChild.getId())) {
      this.addRenderedChild(renderedChild, index);
      this.addRenderedChildToIdList(renderedChild);
      this.addRenderedChildToNameList(renderedChild);
    }
    return this;
  },

  unregisterRenderedChild: function unregisterRenderedChild(renderedChild) {
    this.removeRenderedChild(renderedChild);
    this.removeRenderedChildFromIdList(renderedChild);
    this.removeRenderedChildFromNameList(renderedChild);
    return this;
  },

  // dynamic functions

  setChildren: function setChildren(newChildren, setStateCallback) {
    if (this.isDynamic()) {
      if (typeof this.setChildren_ === 'function') {
        this.setChildren_(newChildren, setStateCallback);
      } else {
        this.setState({ children: newChildren }, setStateCallback);
      }
    } else {
      this.showError('dynamicOnly', 'setChildren', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }
    return this;
  },

  /**
   * Inserts child into container. If position is set, child will be added to that position.
   * Only for dynamic container.
   * Can be overridden by insertChild_ function.
   *
   * @param {object|element} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {number} opt.position - Position where the child should be placed to. If not set, child is added
   *                                at the end of children list.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  insertChild: function insertChild(child, opt) {
    var _this2 = this;

    /*
     opt:{
     position: number // Position where the child should be placed to.
     // If not set, child is added at the end of children list.
     shouldUpdate: bool // call setState -> render, default value is true
     callbackFunction: function // function callbackFunction(newRenderedChild)
     }
     */
    if (this.isDynamic()) {
      if (typeof this.insertChild_ === 'function') {
        this.insertChild_(child, opt);
      } else {
        opt = opt || {};

        var children = this.getChildren() || [];
        if (Array.isArray(children)) {
          children = children.slice();
        } else {
          var elem = this.cloneChild(children, this.expandChildProps(children, 0));
          children = [elem];
        }

        var newChild = child.tag ? this.buildChild(child.tag, child.props) : child;

        if (this.shouldChildRender(newChild)) {
          newChild = this.cloneChild(newChild, this.expandChildProps(newChild, typeof opt.position === 'number' ? opt.position : children.length));

          if (typeof opt.position === 'number') {
            children.splice(opt.position, 0, newChild);
          } else {
            children.push(newChild);
          }

          if (opt.shouldUpdate === undefined || opt.shouldUpdate) {
            this.setChildren(children, typeof opt.setStateCallback === 'function' ? function () {
              opt.setStateCallback(_this2.getRenderedChildById(newChild.props.id));
            } : null);
          }
        }
      }
    } else {
      this.showError('dynamicOnly', 'insertChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Inserts child into container at position before another child by ID.
   * Only for dynamic container.
   * Can be overridden by insertChildBefore_ function.
   *
   * @param {object} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {string} opt.childAfterId - ID of the child before which the new child will be placed. If not set, the new
   *                                    child will be placed at the beginning.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  insertChildBefore: function insertChildBefore(child, opt) {
    if (this.isDynamic()) {
      if (typeof this.insertChildBefore_ === 'function') {
        this.insertChildBefore_(child, opt);
      } else {
        opt = opt || {};

        var childIndex;
        if (opt.childAfterId) {
          var renderedChild = this.getRenderedChildById(opt.childAfterId);
          childIndex = renderedChild.getIndex();
        } else {
          childIndex = 0;
        }

        if (childIndex === null) {
          this.showError('insertedchildIdNotExists', opt.childAfterId, {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          this.insertChild(child, _tools2.default.merge({}, opt, { position: childIndex }));
        }
      }
    } else {
      this.showError('dynamicOnly', 'insertChildBefore', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Inserts child into container at position after another child by ID.
   * Only for dynamic container.
   * Can be overridden by insertChildAfter_ function.
   *
   * @param {object} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {string} opt.childBeforeId - ID of child after which the new child will be placed. If not set, the new
   *                                     child will be placed at the end.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  insertChildAfter: function insertChildAfter(child, opt) {
    if (this.isDynamic()) {
      if (typeof this.insertChildAfter_ === 'function') {
        this.insertChildAfter_(child, opt);
      } else {
        // reset position value and copy opt
        opt = _tools2.default.merge({}, opt, { position: undefined }) || {};

        if (opt.childBeforeId) {
          var renderedChild = this.getRenderedChildById(opt.childBeforeId);
          var childIndex = renderedChild.getIndex();
          childIndex !== null && (opt.position = childIndex + 1);
        }

        if (opt.childBeforeId && opt.position === undefined) {
          this.showError('insertedchildIdNotExists', opt.childBeforeId, {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          this.insertChild(child, opt);
        }
      }
    } else {
      this.showError('dynamicOnly', 'insertChildAfter', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Update child props. New props will be merged with old props, so it is possible to change just one property or all
   * of them.
   * Only for dynamic container.
   * Can be overridden by updateChild_ function.
   *
   * TODO: maybe function updateProps() should be in baseMixin (only if parent is dynamic container)
   *
   * @param {string} childId - ID of child, which props are being updated.
   * @param {object} newProps - Props which are being changed. It is not necessary to set all of the props.
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  updateChild: function updateChild(childId, newProps, opt) {
    if (this.isDynamic()) {
      if (typeof this.updateChild_ === 'function') {
        this.updateChild_(childId, newProps, opt);
      } else {
        opt = opt || {};

        var renderedChild = this.getRenderedChildById(childId);

        if (renderedChild === null) {
          this.showError('childIdNotExists', 'updateChild', {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          var childIndex = renderedChild.getIndex();

          var children = this.getChildren();
          // must destroy object reference because of shouldComponentUpdate
          children = children && children.length > 0 ? children.slice() : [];
          var newChild = this.cloneChild(children[childIndex], newProps);
          children[childIndex] = this.cloneChild(children[childIndex], this.expandChildProps(newChild, childIndex));

          (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren(children, opt.setStateCallback);
        }
      }
    } else {
      this.showError('dynamicOnly', 'updateChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Replace child by tag and props on the position.
   * Only for dynamic container.
   * Can be overridden by replaceChild_ function.
   *
   * TODO: maybe function replace() should be in baseMixin (only if parent is dynamic container)
   *
   * @param {string} childId - ID of child, which props are being updated.
   * @param {object} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  replaceChild: function replaceChild(childId, child, opt) {
    if (this.isDynamic()) {
      if (typeof this.replaceChild_ === 'function') {
        this.replaceChild_(childId, child, opt);
      } else {
        opt = opt || {};

        var renderedChild = this.getRenderedChildById(childId);

        if (renderedChild === null) {
          this.showError('childIdNotExists', 'replaceChild', {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          var childIndex = renderedChild.getIndex();

          var children = this.getChildren();
          // must destroy object reference because of shouldComponentUpdate
          children = children && children.length > 0 ? children.slice() : [];
          var newChild = child.tag ? this.buildChild(child.tag, child.props) : child;
          if (this.shouldChildRender(newChild)) {
            children[childIndex] = this.cloneChild(newChild, this.expandChildProps(newChild, childIndex));

            (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren(children, opt.setStateCallback);
          }
        }
      }
    } else {
      this.showError('dynamicOnly', 'replaceChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Deletes child from children list.
   * Only for dynamic container.
   * Can be overridden by deleteChild_ function.
   *
   * TODO: maybe function delete() should be in baseMixin (only if parent is dynamic container)
   *
   * @param {string} childId - ID of child, which props are being deleted.
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  deleteChild: function deleteChild(childId, opt) {
    if (this.isDynamic()) {
      if (typeof this.deleteChild_ === 'function') {
        this.deleteChild_(childId, opt);
      } else {
        opt = opt || {};

        var renderedChild = this.getRenderedChildById(childId);
        if (renderedChild === null) {
          this.showError('childIdNotExists', 'deleteChild', {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          var childIndex = renderedChild.getIndex();

          var children = this.getChildren();
          // must destroy object reference because of shouldComponentUpdate
          children = children && children.length > 0 ? children.slice() : [];
          children.splice(childIndex, 1);

          (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren(children, opt.setStateCallback);
        }
      }
    } else {
      this.showError('dynamicOnly', 'deleteChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Deletes all children.
   * Only for dynamic container.
   * Can be overridden by clearChildren_ function.
   *
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  clearChildren: function clearChildren(opt) {
    if (this.isDynamic()) {
      if (typeof this.clearChildren_ === 'function') {
        this.clearChildren_(opt);
      } else {
        opt = opt || {};
        (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren([], opt.setStateCallback);
      }
    } else {
      this.showError('dynamicOnly', 'clearChildren', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  setFilter: function setFilter(filter, setStateCallback) {
    this.setState({ filter: filter, filteredProps: this._getFilteredChildrenProps(filter) }, setStateCallback);
    return this;
  },

  resetFilter: function resetFilter(setStateCallback) {
    this.setState({ filter: null, filteredProps: null }, setStateCallback);
    return this;
  },

  setSorter: function setSorter(sorter, setStateCallback) {
    this.setState({ sorter: sorter, sortedIds: this._getSortedChildIds(sorter) }, setStateCallback);
    return this;
  },

  resetSorter: function resetSorter(setStateCallback) {
    this.setState({ sorter: null, sortedIds: null }, setStateCallback);
    return this;
  },

  setFilterAndSorter: function setFilterAndSorter(filter, sorter, setStateCallback) {
    this.setState({
      filter: filter, filteredProps: this._getFilteredChildrenProps(filter),
      sorter: sorter, sortedIds: this._getSortedChildIds(sorter)
    }, setStateCallback);

    return this;
  },

  resetFilterAndSorter: function resetFilterAndSorter(setStateCallback) {
    this.setState({
      filter: null, filteredProps: null,
      sorter: null, sortedIds: null
    }, setStateCallback);

    return this;
  },

  getFilteredSorterChildren: function getFilteredSorterChildren(children) {
    var container = this;
    var newChildren = [];

    children = children || this.getChildren();

    if (children) {
      children = Array.isArray(children) ? children : [children];
      children.forEach(function (child) {
        if (child) {
          var childId = child.props && child.props.id;
          var index = container.state.sortedIds && container.state.sortedIds.indexOf(childId);

          if (!container.state.sortedIds || index > -1) {
            var newProps = container.state.filteredProps && container.state.filteredProps[childId];

            if (!container.state.filteredProps || newProps) {
              newProps && Object.keys(newProps).length !== 0 && (child = _react2.default.cloneElement(child, _tools2.default.mergeDeep({}, child.props, newProps)));

              if (typeof index === 'number') {
                newChildren[index] = child;
              } else {
                newChildren.push(child);
              }
            }
          }
        }
      });
    }

    return newChildren;
  },

  // Mode
  setStandardMode: function setStandardMode(setStateCallback) {
    this.setState({ mode: this.getDefault('standardMode', "UU5.Common.ContentMixin") }, setStateCallback);
    return this;
  },

  setOutlineMode: function setOutlineMode(setStateCallback) {
    this.setState({ mode: this.getDefault('outlineMode', "UU5.Common.ContentMixin") }, setStateCallback);
    return this;
  },

  getMode: function getMode() {
    return this.state.mode;
  },

  isStandardMode: function isStandardMode() {
    return this.getMode() === this.getDefault('standardMode', "UU5.Common.ContentMixin");
  },

  isOutlineMode: function isOutlineMode() {
    return this.getMode() === this.getDefault('outlineMode', "UU5.Common.ContentMixin");
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getContentType: function _getContentType(content) {
    var type = null; // one of ['children','uu5json','uu5string','uu5data','string','number','array','items','bodyItem','element','bool']

    if (content === undefined || content === null) {
      // children
      type = 'children';
    } else if (typeof content === 'string') {
      var match = this.getDefault('regexpUu5', "UU5.Common.ContentMixin").exec(content);
      type = match ? match[1] : 'string';
    } else if (typeof content === 'number') {
      type = 'number';
    } else if (typeof content === 'boolean') {
      type = 'bool';
    } else if (Array.isArray(content)) {
      type = 'array';
    } else if (content && (typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object') {
      // bodyItem, items or node
      type = content.tag ? content.propsArray ? 'items' : 'bodyItem' : 'element';
    } else {
      this.showError('unexpectedContentType', typeof content === 'undefined' ? 'undefined' : _typeof(content), {
        mixinName: "UU5.Common.ContentMixin",
        context: {
          content: content
        }
      });
    }

    return type;
  },

  _getFilteredChildrenProps: function _getFilteredChildrenProps(filter) {
    var filteredChildrenProps = {};

    this.eachRenderedChild(function (renderedChild, i) {
      var result = filter(renderedChild, i);
      if (result) {
        result === true && (result = {});
      } else {
        result = { hidden: true };
      }
      filteredChildrenProps[renderedChild.getId()] = result;
    });

    return filteredChildrenProps;
  },

  _getSortedChildIds: function _getSortedChildIds(sorter) {
    var sortedChildren = this.getRenderedChildren().sort(sorter);
    return sortedChildren.map(function (renderedChild) {
      return renderedChild.getId();
    });
  }
  //@@viewOff:componentSpecificHelpers
};

exports.default = ContentMixin;