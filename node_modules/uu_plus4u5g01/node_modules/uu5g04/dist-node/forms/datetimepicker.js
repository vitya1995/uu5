'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Datetimepicker = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _createReactClass = require('create-react-class');

var _createReactClass2 = _interopRequireDefault(_createReactClass);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uu5g = require('uu5g04');

var UU5 = _interopRequireWildcard(_uu5g);

var _formsNs = require('./forms-ns.js');

var _formsNs2 = _interopRequireDefault(_formsNs);

var _inputWrapper = require('./internal/input-wrapper.js');

var _inputWrapper2 = _interopRequireDefault(_inputWrapper);

var _textInput = require('./internal/text-input.js');

var _textInput2 = _interopRequireDefault(_textInput);

var _calendar = require('./calendar.js');

var _calendar2 = _interopRequireDefault(_calendar);

var _time = require('./time.js');

var _time2 = _interopRequireDefault(_time);

var _textInputMixin = require('./mixins/text-input-mixin.js');

var _textInputMixin2 = _interopRequireDefault(_textInputMixin);

require('./datetimepicker.less');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FORMAT_AM = 'AM';
var FORMAT_PM = 'PM';
var FORMAT_12 = '12';
var FORMAT_24 = '24';
var Datetimepicker = exports.Datetimepicker = (0, _createReactClass2.default)({
  displayName: 'Datetimepicker',


  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, _textInputMixin2.default],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: _formsNs2.default.name("Datetimepicker"),
    classNames: {
      main: _formsNs2.default.css("datetimepicker"),
      datepickerOpen: _formsNs2.default.css("datepicker-open"),
      timepickerOpen: _formsNs2.default.css("timepicker-open"),
      menu: _formsNs2.default.css("input-menu")
    },
    defaults: {
      regexpFormat1: /^\d{1,2}:?\d{0,2} ?[PpAa]?\.?[Mm]?\.?$/,
      regexpFormat2: /^\d{1,2}:?\d{0,2}$/,
      regexpTime: /[Pp]\.?([Mm]\.?)?/,
      regexpSpace: / /g
    },
    lsi: function lsi() {
      return UU5.Environment.Lsi.Forms.message;
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(Date), _propTypes2.default.string]),
    dateFrom: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(Date), _propTypes2.default.string]),
    dateTo: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(Date), _propTypes2.default.string]),
    buttonHidden: _propTypes2.default.bool,
    calendarIconOpen: _propTypes2.default.string,
    calendarIconClosed: _propTypes2.default.string,
    timeIconOpen: _propTypes2.default.string,
    timeIconClosed: _propTypes2.default.string,
    format: _propTypes2.default.string,
    timeFormat: _propTypes2.default.string,
    country: _propTypes2.default.string,
    timezone: _propTypes2.default.string,
    nanMessage: _propTypes2.default.any,
    beforeRangeMessage: _propTypes2.default.any,
    afterRangeMessage: _propTypes2.default.any,
    parseDate: _propTypes2.default.func,
    placeholderTime: _propTypes2.default.string,
    dateIcon: _propTypes2.default.string,
    timeIcon: _propTypes2.default.string
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      value: null,
      dateFrom: null,
      dateTo: null,
      isButtonHidden: false,
      calendarIconOpen: 'uu5-calendar',
      calendarIconClosed: 'uu5-calendar',
      timeIconOpen: 'uu5-arrow-up',
      timeIconClosed: 'uu5-arrow-down',
      format: null,
      timeFormat: null,
      country: null,
      nanMessage: 'Please insert a valid date and time.',
      beforeRangeMessage: 'Date and time is out of range.',
      afterRangeMessage: 'Date and time is out of range.',
      parseDate: null,
      placeholderTime: null,
      dateIcon: 'mdi-calendar',
      timeIcon: 'mdi-clock'
    };
  },

  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState: function getInitialState() {
    return {
      calendarOpen: false,
      timeOpen: false,
      format: this.props.format,
      country: this.props.country,
      timezone: this.props.timezone,
      dateString: this._getDateString() || null,
      timeString: this._getTimeString() || null
    };
  },
  componentWillMount: function componentWillMount() {
    if (this.props.onValidate && typeof this.props.onValidate === 'function') {
      var result = this._isValidDateResult({ value: this.state.dateString });
      //let result = this._isValidTimeResult({value: this.state.timeString});
      //TODO: validovat datum i cas
      if (result) {
        if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
          if (result.feedback) {
            this.setFeedback(result.feedback, result.message, result.value);
          } else {
            this._validateOnChange({ value: this.state.value, event: null, component: this });
          }
        }
      }
    } else {
      // this.setInitial(null, this.state.value)
    }
    return this;
  },
  componentDidMount: function componentDidMount() {
    UU5.Environment.EventListener.registerDateTime(this.getId(), this._change);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (this.props.controlled) {
      var date = nextProps.value instanceof Date ? nextProps.value : new Date(nextProps.value);
      var result = this._isValidDateResult({ value: date });
      if (result) {
        if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
          if (result.feedback) {
            this.setFeedback(result.feedback, result.message, result.value);
          } else {
            this.setFeedback(nextProps.feedback, nextProps.message, nextProps.value);
          }
        }
      }
    }
    return this;
  },
  componentWillUnmount: function componentWillUnmount() {
    this._removeEvent();
    UU5.Environment.EventListener.unregisterDateTime(this.getId(), this._change);
  },

  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  openCalendar: function openCalendar(setStateCallback) {
    this._addEvent();
    this.setState({ calendarOpen: true, timeOpen: false }, setStateCallback);
    return this;
  },
  openTime: function openTime(setStateCallback) {
    this._addEvent();
    this.setState({ timeOpen: true, calendarOpen: false }, setStateCallback);
    return this;
  },
  toggleCalendar: function toggleCalendar(setStateCallback) {
    //this.setState((state) => ({calendarOpen: !state.calendarOpen}), setStateCallback);
    this.setState(function (state) {
      state.calendarOpen ? this._removeEvent() : this._addEvent();
      return { calendarOpen: !state.calendarOpen, timeOpen: false };
    }, setStateCallback);
    return this;
  },
  toggleTime: function toggleTime(setStateCallback) {
    //this.setState((state) => ({timeOpen: !state.timeOpen}), setStateCallback);
    this.setState(function (state) {
      state.timeOpen ? this._removeEvent() : this._addEvent();
      return { timeOpen: !state.timeOpen, calendarOpen: false };
    }, setStateCallback);
    return this;
  },
  close: function close(setStateCallback) {
    this._removeEvent();
    if (this._isTimeOpen()) {
      this._onBlurTime(null, { value: this.state.timeString || '', component: this });
    }
    if (this._isCalendarOpen()) {
      this._onBlurCalendar(null, { value: this.state.dateString || '', component: this });
    }

    this.setState({ calendarOpen: false, timeOpen: false }, setStateCallback);
    return this;
  },

  // parseDate (stringDate) {
  //   var config = {
  //     "^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$": '$3-$2-$1',
  //     "^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$": '$3-$1-$2',
  //     "^(\\d{4})-(\\d{1,2})-(\\d{1,2})$": '$1-$2-$3'
  //   };
  //
  //   var date = null;
  //   if (stringDate) {
  //     stringDate = stringDate.replace(/ /g, '');
  //
  //     for (var pattern in config) {
  //       var regExp = new RegExp(pattern);
  //       if (regExp.test(stringDate)) {
  //         var replacedDate = stringDate.replace(regExp, config[pattern]);
  //         var splitter = replacedDate.split('-');
  //         //splitter[1] = UU5.Common.Tools.rjust(splitter[1], 2, '0');
  //         //splitter[2] = UU5.Common.Tools.rjust(splitter[2], 2, '0');
  //         //replacedDate = splitter.join('-');
  //         splitter[0] = Number(splitter[0]);
  //         splitter[1] = Number(splitter[1]) - 1;
  //         splitter[2] = Number(splitter[2]);
  //
  //         date = new Date(splitter[0], splitter[1], splitter[2]);
  //         break;
  //       }
  //     }
  //   }
  //   return date;
  // },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  getValue_: function getValue_() {
    return this._getValue();
  },
  setFeedback_: function setFeedback_(feedback, message, value, setStateCallback) {
    var timeString = this._getTimeString(value);
    var dateString = this._getDateString(value);
    if (this.state.dateString !== dateString || this.state.timeString !== timeString) {
      this.setState({
        dateString: dateString,
        timeString: timeString,
        feedback: feedback,
        message: message
      }, function () {
        return setStateCallback;
      });
    } else {
      this.setState({
        feedback: feedback,
        message: message
      }, function () {
        return setStateCallback;
      });
    }
    return this;
  },
  isOpen_: function isOpen_() {
    return this._isCalendarOpen() || this._isTimeOpen();
  },
  setValue_: function setValue_(value, setStateCallback) {
    // if (value instanceof Date) {
    //   value = this._formatDate(value);
    // }
    if (this._checkRequired({ value: value })) {
      if (typeof this.props.onValidate === 'function') {
        this._validateOnChange({ value: value, event: null, component: this });
      } else {
        this.setInitial(null, value, setStateCallback);
      }
    }

    this.setState({
      value: value,
      dateString: this._getDateString(value),
      timeString: this._getTimeString(value)
    });

    return this;
  },

  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getValue: function _getValue(date, time) {
    var value = void 0;
    date = date instanceof Date ? date : this._parseDate(date ? date : this.state.dateString);
    //time = typeof time === 'object' ? (time.hours + ':' + time.minutes) : this._parseTime(time ? time : this.state.timeString);
    time = (typeof time === 'undefined' ? 'undefined' : _typeof(time)) === 'object' ? time : this._parseTime(time ? time : this.state.timeString);
    date && (value = new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.hours, time.minutes));
    return value;
  },
  _isCalendarOpen: function _isCalendarOpen() {
    return this.state.calendarOpen;
  },
  _isTimeOpen: function _isTimeOpen() {
    return this.state.timeOpen;
  },
  _findTarget: function _findTarget(item) {
    var result = false;
    var id = this.getId();

    if (item.id === id) {
      result = true;
    } else if (item.parentElement) {
      result = this._findTarget(item.parentElement);
    }
    return result;
  },
  _addEvent: function _addEvent() {
    var _this = this;

    UU5.Environment.EventListener.addWindowEvent('click', this.getId(), function (e) {
      var isSelect = _this._findTarget(e.target);

      if (!_this._stopPropagation && !isSelect && _this.isOpen()) {
        _this.close();
      } else {
        _this._stopPropagation = false;
      }
    });
    return this;
  },
  _removeEvent: function _removeEvent() {
    UU5.Environment.EventListener.removeWindowEvent('click', this.getId());
    return this;
  },
  _getDateString: function _getDateString(date) {
    var dateString = void 0;
    date = date || this.props.value;
    if (typeof date === 'string') {
      date = new Date(date);
    }
    if (date) {
      if (date instanceof Date) {
        var newDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        dateString = this._formatDate(newDate);
      }
    }
    return dateString;
  },
  _getTimeString: function _getTimeString(date) {
    var timeString = void 0;
    date = date || this.props.value;
    if (typeof date === 'string') {
      date = new Date(date);
    }
    if (date) {
      if (date instanceof Date) {
        timeString = this._formatTime({ hours: date.getHours(), minutes: date.getMinutes() }, true);
      }
    }
    return timeString;
  },
  _change: function _change(opt) {
    if (typeof this.props.onChange === 'function') {
      this.props.onChange(opt);
    } else {
      this._setOptions(opt);
    }
    return this;
  },
  _setOptions: function _setOptions(opt, setStateCallback) {
    this.setState({
      format: opt.format === undefined ? this.state.format : opt.format,
      country: opt.country === undefined ? this.state.country : opt.country ? opt.country.toLowerCase() : opt.country
    }, setStateCallback);
    return this;
  },
  _onChangeCalendar: function _onChangeCalendar(e) {
    var opt = { value: e.target.value, event: e, component: this };
    var date = this._parseDate(opt.value);
    var formatedDate = date ? this._formatDate(date) : null;
    if (formatedDate) {
      opt.value = formatedDate;
      if (!this.isDisabled() && !this.isReadOnly()) {
        if (typeof this.props.onChange === 'function') {
          this.props.onChange(opt);
        } else {
          if (this.props.validateOnChange) {
            this._validateOnChange(opt);
          } else {
            if (opt.value && this._checkRequired({ value: opt.value })) {
              opt.required = this.props.required;
              var result = this.getChangeFeedback(opt);
              this.setState({
                feedback: result.feedback,
                message: result.message,
                dateString: result.value || ''
              });
            }
          }
        }
      }
    } else {
      this.setState({ dateString: opt.value });
    }
    return this;
  },
  _onChangeTime: function _onChangeTime(e) {
    var opt = { value: e.target.value, event: e, component: this };

    if (opt.value === '' || this._parseTime(opt.value)) {
      if (!this.isDisabled() && !this.isReadOnly()) {
        if (typeof this.props.onChange === 'function') {
          this.props.onChange(opt);
        } else {
          if (this.props.validateOnChange) {
            this._validateOnChange(opt);
          } else {
            if (opt.value === '') {
              this.setState({ timeString: opt.value });
            } else if (this._checkRequired({ value: opt.value })) {
              opt.required = this.props.required;
              var result = this.getChangeFeedback(opt);

              if (!result.value || this.props.timeFormat === FORMAT_12 && result.value.match(this.getDefault().regexpFormat1) || this.props.timeFormat === FORMAT_24 && result.value.match(this.getDefault().regexpFormat2)) {
                this.setState({
                  feedback: result.feedback,
                  message: result.message,
                  timeString: result.value || ''
                });
              } else {
                this.setState({ timeString: result.value });
              }
            }
          }
        }
      }
    }

    return this;
  },
  _onBlurCalendar: function _onBlurCalendar(e, opt) {
    opt = opt && opt.value || !e ? opt : { value: e.target.value, event: e, component: this };

    if (typeof this.props.onBlur === 'function') {
      this.props.onBlur(opt);
    } else {
      if (this._checkRequiredDatetime({ value: opt.value || this.state.dateString }) && !this.props.validateOnChange) {
        opt.required = this.props.required;
        var blurResult = this._getBlurFeedback(opt);
        var result = this._isValidDateResult(blurResult);
        this.setState({
          feedback: result.feedback || 'initial',
          message: result.message,
          dateString: result.value
        });
      }
    }

    return this;
  },
  _onBlurTime: function _onBlurTime(e, opt) {
    opt = opt && opt.value || !e ? opt : { value: e.target.value, event: e, component: this };

    if (typeof this.props.onBlur === 'function') {
      this.props.onBlur(opt);
    } else {
      if (this._checkRequiredDatetime({ value: opt.value || this.state.timeString }) && !this.props.validateOnChange) {
        opt.required = this.props.required;
        var blurResult = this._getBlurFeedback(opt);
        var result = this._isValidTimeResult(blurResult);
        this.setState({
          feedback: result.feedback || 'initial',
          message: result.message,
          timeString: opt.value ? this._formatTime(this._parseTime(blurResult.value), true) : ''
        });
      }
    }

    return this;
  },
  _getBlurFeedback: function _getBlurFeedback(opt) {
    var result = void 0;
    if (typeof this.props.onValidate === 'function') {
      result = this.props.onValidate(opt);
    } else {
      result = {
        feedback: 'initial',
        message: null,
        value: opt.value
      };
    }
    return result;
  },
  _checkRequiredDatetime: function _checkRequiredDatetime(opt) {
    var result = true;
    if (this.props.required && !opt.value) {
      result = false;
      this.setState({
        feedback: 'error',
        message: this.props.requiredMessage || this.getLsiComponent('requiredMessage')
      });
    }

    return result;
  },
  _isValidDateResult: function _isValidDateResult(opt) {
    return this._validateDateRangeResult(this._validateDateResult(opt));
  },
  _validateDateResult: function _validateDateResult(opt) {
    var result = opt;
    var date = opt.value instanceof Date ? opt.value : this._parseDate(opt.value);
    if (!this.state.timeString || !date && opt.value || opt.value === "") {
      result.feedback = 'error';
      result.message = this.props.nanMessage;
    }
    return result;
  },
  _isValidTimeResult: function _isValidTimeResult(opt) {
    var result = opt;
    var time = this._parseTime(opt.value);
    if (!this.state.dateString || !time && opt.value || opt.value === "") {
      result.feedback = 'error';
      result.message = this.props.nanMessage;
    }
    return result;
  },
  _validateDateRangeResult: function _validateDateRangeResult(opt) {
    var result = opt;

    var date = opt.value instanceof Date ? this._getDateString(opt.vale) : this._parseDate(opt.value);
    if (date) {
      var dateFrom = this._getDateFrom();
      var dateTo = this._getDateTo();
      if (dateFrom && date < dateFrom) {
        result.feedback = 'error';
        result.message = this.props.beforeRangeMessage;
      } else if (dateTo && date > dateTo) {
        result.feedback = 'error';
        result.message = this.props.afterRangeMessage;
      }
    }

    return result;
  },
  _validateOnChange: function _validateOnChange(opt) {
    var result = typeof this.props.onValidate === 'function' ? this.props.onValidate(opt) : null;
    if (result) {
      if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
        if (result.feedback) {
          this.setFeedback(result.feedback, result.message, result.value);
        } else {
          this.setState({ value: opt.value });
        }
      } else {
        this.showError('validateError', null, { context: { event: e, func: this.props.onValidate, result: result } });
      }
    }
    return this;
  },
  _getDateIcon: function _getDateIcon() {
    /*let icon = this.props.required ? this.props.successIcon : null;
     switch (this.getFeedback()) {
     case 'success':
     icon = this.props.successIcon;
     break;
     case 'warning':
     icon = this.props.warningIcon;
     break;
     case 'error':
     icon = this.props.errorIcon;
     break;
     }
     return icon;*/
    return this.props.dateIcon;
  },
  _getTimeIcon: function _getTimeIcon() {
    /*let icon = this.props.required ? this.props.successIcon : null;
     switch (this.getFeedback()) {
     case 'success':
     icon = this.props.successIcon;
     break;
     case 'warning':
     icon = this.props.warningIcon;
     break;
     case 'error':
     icon = this.props.errorIcon;
     break;
     }
     return icon;*/
    return this.props.timeIcon;
  },
  _onCalendarChange: function _onCalendarChange(opt) {
    var _this2 = this;

    if (typeof this.props.onChange === 'function') {
      opt.value = this._getValue(opt.value, this.state.timeString);
      opt.component = this;
      this.setState({ calendarOpen: false }, this.props.onChange(opt));
    } else {
      var value = this._formatDate(opt.value);
      this.setState({ calendarOpen: false, dateString: value }, function () {
        return _this2._onBlurCalendar(null, {
          value: value,
          component: _this2
        });
      });
    }
    return this;
  },
  _getCalendarProps: function _getCalendarProps() {
    var date = typeof this.getValue() === 'string' ? this._parseDate(this.getValue()) : this.getValue();

    return {
      className: this.getClassName().menu,
      date: date,
      dateFrom: this.props.dateFrom ? this._getDateFrom() : null,
      dateTo: this.props.dateTo ? this._getDateTo() : null,
      ref_: this._refCalendar,
      hidden: !this._isCalendarOpen(),
      onChange: this._onCalendarChange
    };
  },
  _onTimeChange: function _onTimeChange(opt) {
    var _this3 = this;

    if (typeof this.props.onChange === 'function') {
      opt.component = this;
      opt.value = this._getValue(this.state.dateString, opt.value);
      this.props.onChange(opt);
    } else {
      //TODO: setValue_
      var value = this._formatTime(opt.value, true);
      this.setState({ timeString: value }, function () {
        return _this3._onBlurTime(null, { value: value, component: _this3 });
      });
    }
    return this;
  },
  _getTimeProps: function _getTimeProps(value) {
    if (!this.state.timeString || this.state.timeString.trim() === "") {
      value = null;
    }
    return {
      className: this.getClassName().menu,
      value: value,
      ref_: this._refCalendar,
      hidden: !this._isTimeOpen(),
      onChange: this._onTimeChange,
      format: this.props.timeFormat,
      controlled: true
    };
  },
  _formatTime: function _formatTime(value, fill0) {
    var time = '';
    if (value) {
      if (fill0) {
        time = UU5.Common.Tools.rjust(value.hours, 2, '0') + ':' + UU5.Common.Tools.rjust(value.minutes, 2, '0');
      } else {
        time = value.hours + ':' + value.minutes;
      }
      if (this.props.timeFormat === FORMAT_12) {
        time += ' ' + (value.dayPart || FORMAT_AM);
      }
    }
    return time;
  },
  _parseTime: function _parseTime(stringTime) {
    stringTime = stringTime || '00:00';
    stringTime = stringTime.trim();
    var value = null;

    if (typeof stringTime === 'string' && stringTime !== '') {
      value = {
        hours: 0,
        minutes: 0
      };

      if (stringTime.indexOf(':') !== -1) {
        var dateArray = stringTime.split(':');
        value.hours = parseInt(dateArray[0].trim()) || 0;
        value.minutes = parseInt(dateArray[1].trim()) || 0;
      } else {
        value.hours = parseInt(stringTime) || 0;
      }

      if (value.hours < 0 || value.hours > 23 || value.minutes < 0 || value.minutes > 59) {
        value = null;
      } else if (this.props.timeFormat === FORMAT_12) {
        if (value.hours > 12) {
          value.hours -= 12;
        } else if (value.hours == 0) {
          value.hours = 12;
        }

        if (stringTime.match(this.getDefault().regexpTime)) {
          value.dayPart = FORMAT_PM;
        } else {
          value.dayPart = FORMAT_AM;
        }
      }
    }
    return value;
  },
  _formatDate: function _formatDate(date) {

    var result = null;

    var format = this.state && this.state.format ? this.state.format : this.props.format;
    var country = this.state && this.state.country ? this.state.country : this.props.country;

    if (format) {
      result = UU5.Common.Tools.formatDate(date, format);
    } else if (country) {
      result = this._formatDateByCountry(date, country);
    } else {
      result = UU5.Common.Tools.toLocaleDateString(date, UU5.Common.Tools.getLanguage());
    }
    return result;
  },
  _formatDateByCountry: function _formatDateByCountry(date, country) {
    var result = void 0;
    if (UU5.Environment.dateTimeFormat[country]) {
      result = UU5.Common.Tools.formatDate(date, UU5.Environment.dateTimeFormat[country]);
    } else {
      result = UU5.Common.Tools.toLocaleDateString(date, country);
    }
    return result;
  },
  _getDateFrom: function _getDateFrom() {
    var dateFrom = void 0;
    if (this.props.dateFrom) {
      if (typeof this.props.dateFrom === 'string') {
        dateFrom = this._parseDate(this.props.dateFrom);
      } else if (this.props.dateFrom instanceof Date) {
        dateFrom = this.props.dateFrom;
      }
    }
    return dateFrom;
  },
  _getDateTo: function _getDateTo() {
    var dateTo = void 0;
    if (this.props.dateTo) {
      if (typeof this.props.dateTo === 'string') {
        dateTo = this._parseDate(this.props.dateTo);
      } else if (this.props.dateTo instanceof Date) {
        dateTo = this.props.dateTo;
      }
    }
    return dateTo;
  },
  _isDateReversed: function _isDateReversed() {
    var dateFormat = this.state.country || UU5.Common.Tools.getLanguage();
    return dateFormat.toLowerCase() === 'en' || dateFormat.toLowerCase() === 'en-us';
  },
  _parseDate: function _parseDate(stringDate) {
    var date = null;
    if (this.props.parseDate && typeof this.props.parseDate === 'function') {
      date = this.props.parseDate(stringDate);
    } else {

      var config = {
        "^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$": '$3-$2-$1',
        "^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$": this._isDateReversed() ? '$3-$1-$2' : '$3-$2-$1',
        "^(\\d{4})-(\\d{1,2})-(\\d{1,2})$": '$1-$2-$3'
      };

      stringDate = stringDate && stringDate.replace(this.getDefault().regexpSpace, '');

      for (var pattern in config) {
        var regExp = new RegExp(pattern);
        if (regExp.test(stringDate)) {
          var replacedDate = stringDate.replace(regExp, config[pattern]);

          // because of safari and IE must be date in format YYYY-MM-DD (not YYYY-M-D)
          var parser = replacedDate.split('-');
          replacedDate = [parser[0], UU5.Common.Tools.rjust(parser[1], 2, '0'), UU5.Common.Tools.rjust(parser[2], 2, '0')].join('-');

          date = Date.parse(replacedDate) ? new Date(replacedDate) : null;
          break;
        }
      }
    }
    return date;
  },
  _getCalendarInputAttrs: function _getCalendarInputAttrs() {
    var _this4 = this;

    var props = {};

    if (!this.isReadOnly() && !this.isDisabled()) {
      props.onClick = function () {
        _this4._touchStart === undefined ? _this4.openCalendar() : _this4.toggleCalendar();
      };

      props.onTouchStart = function () {
        _this4._touchStart = new Date();
      };

      props.onTouchEnd = function (e) {
        e.preventDefault();
        if (new Date() - _this4._touchStart < UU5.Environment.holdTimeout) {
          _this4._touchStart = 0;
          e.target.click();
          e.target.focus();
        }
      };
    }
    //props.className += ' ' + ns.css("datepicker");

    return props;
  },
  _getTimeInputAttrs: function _getTimeInputAttrs() {
    var _this5 = this;

    var props = {};

    if (!this.isReadOnly() && !this.isDisabled()) {
      props.onClick = function () {
        _this5._touchStart === undefined ? _this5.openTime() : _this5.toggleTime();
      };

      props.onTouchStart = function () {
        _this5._touchStart = new Date();
      };

      props.onTouchEnd = function (e) {
        e.preventDefault();
        if (new Date() - _this5._touchStart < UU5.Environment.holdTimeout) {
          _this5._touchStart = 0;
          e.target.click();
          e.target.focus();
        }
      };
    }

    return props;
  },
  _getMainAttrs: function _getMainAttrs() {
    var attrs = this._getInputAttrs();
    attrs.id = this.getId();

    if (this.isOpen()) {
      attrs.className += ' ' + this.getClassName().open;
    }

    return attrs;
  },
  _getPlacehoder: function _getPlacehoder() {
    var format = this.state.format || UU5.Environment.dateTimeFormat[this.state.country];
    var placeholder = format;
    if (this.props.placeholder && format) {
      placeholder = this.props.placeholder + ' - ' + format;
    } else if (this.props.placeholder) {
      placeholder = this.props.placeholder;
    }
    return placeholder;
  },


  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render: function render() {
    var _this6 = this;

    var inputId = this.getId() + '-input';

    var date = this.state.dateString;
    var time = this.state.timeString;

    return _react2.default.createElement(
      'div',
      this._getMainAttrs(),
      this.getLabel(inputId),
      this.getInputWrapper([_react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(_textInput2.default, { id: inputId, name: this.props.name || inputId, value: date || '', placeholder: this._getPlacehoder(), type: 'text', onChange: this._onChangeCalendar, onBlur: this._onBlurCalendar, onFocus: this.onFocus, onKeyDown: this.onKeyDown, mainAttrs: this._getCalendarInputAttrs() || this.props.inputAttrs, disabled: this.isDisabled() || this.isLoading(), readonly: this.isReadOnly(), icon: this._getDateIcon(), loading: this.isLoading(), feedback: this.state.feedback, message: this.state.message, iconClickable: false, ref_: function ref_(item) {
            return _this6._textInput = item;
          } }),
        _react2.default.createElement(_calendar2.default, this._getCalendarProps())
      ), _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(_textInput2.default, { id: inputId, name: this.props.name || inputId, value: time || '', placeholder: this.props.placeholderTime, type: 'text', onChange: this._onChangeTime, onBlur: this._onBlurTime, onFocus: this.onFocus, onKeyDown: this.onKeyDown, mainAttrs: this._getTimeInputAttrs() || this.props.inputAttrs, disabled: this.isDisabled() || this.isLoading(), readonly: this.isReadOnly(), icon: this._getTimeIcon(), loading: this.isLoading(), feedback: this.state.feedback, message: this.state.message, iconClickable: false }),
        _react2.default.createElement(_time2.default, this._getTimeProps(this._parseTime(time)))
      )])
    );
  }
  //@@viewOn:render

});

exports.default = Datetimepicker;