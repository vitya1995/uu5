const regexp = {
  url: /^((http[s]?|ftp):\/)?\/?([^:\/\s]+):?(\d+)?([^?#]+)?\??([^#]+)?#?(.*)$/,
  colon: /:$/,
  slash: /^[/]/,
  hash: /^#/
};

export class Url {
  static parse(url) {
    url = url || window.location.href;
    let result = new Url();

    if (typeof url === 'string') {
      let parser;
      try {
        parser = new URL(url);
      } catch (e) {
        // HF for ie, Safari
        let matcher = url.match(regexp.url);

        parser = {
          protocol: matcher[2],
          hostname: matcher[3],
          port: matcher[4],
          pathname: matcher[5],
          search: matcher[6],
          hash: matcher[7]
        };
      }
      parser.protocol && (result.protocol = parser.protocol.replace(regexp.colon, ''));
      parser.hostname && (result.hostName = parser.hostname);
      parser.port && (result.port = parser.port);
      parser.pathname && (result.pathName = parser.pathname.replace(regexp.slash, ''));
      parser.search && (result.parameters = parser.search);
      parser.hash && (result.hash = parser.hash);
    } else if (typeof url === 'object') {
      url.protocol && (result.protocol = url.protocol);
      url.hostName && (result.hostName = url.hostName);
      url.port && (result.port = url.port);
      url.pathName && (result.pathName = url.pathName.replace(regexp.slash, ''));
      url.parameters && (result.parameters = url.parameters);
      url.hash && (result.hash = url.hash);
    }

    return result;
  }

  static encodeValue(value) {
    let result = value + '';

    if (value && (Array.isArray(value) || typeof value === 'object')) {
      result = JSON.stringify(value);
    }

    return encodeURIComponent(result);
  }

  static encodeQuery(params) {
    let query = '?';

    for (let name in params) {
      query += name + '=' + Url.encodeValue(params[name]) + '&';
    }

    return query.substr(0, query.length - 1);
  }

  static decodeValue(value) {
    value = decodeURIComponent(value);
    let result = value;

    if (!isNaN(value)) {
      result = value;
    } else if (value === 'true') {
      result = true;
    } else if (value === 'false') {
      result = false;
    } else {
      let json = Url._checkJson(value);

      if (json) {
        result = json;
      }
    }

    return result;
  }

  static decodeQuery(query) {
    let params = {};

    query.substr(1, query.length - 1).split('&').forEach(value => {
      let valueSplitter = value.split('=');
      params[valueSplitter[0]] = Url.decodeValue(valueSplitter[1]);
    });

    return params;
  }

  static _checkJson(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return false;
    }
  }

  constructor() {
    this.protocol = null;
    this.hostName = null;
    this.port = null;
    this._pathName = null;
    this._parameters = null;
    this._hash = null;
  }

  get pathName() {
    return this._pathName;
  }

  set pathName(pathName) {
    this._pathName = pathName.replace(regexp.slash, '');
    return this;
  }

  get parameters() {
    return this._parameters;
  }

  set parameters(parameters) {
    if (typeof parameters === 'string') {
      this._parameters = Url.decodeQuery(parameters);
    } else {
      this._parameters = parameters || null;
    }
    return this;
  }

  get hash() {
    return this._hash;
  }

  set hash(hash) {
    this._hash = hash.replace(regexp.hash, '');
    return this;
  }

  get host() {
    let host = '';
    this.hostName && (host += this.hostName);
    this.port && (host += ':' + this.port);
    return host;
  }

  get origin() {
    let origin = '';

    this.protocol && (origin += this.protocol + '://');

    let host = this.host;
    host && (origin += host);

    return origin;
  }

  set(params) {
    params.protocol !== undefined && (this.protocol = params.protocol);
    params.hostName !== undefined && (this.hostName = params.hostName);
    params.port !== undefined && (this.port = params.port);
    params.pathName !== undefined && (this.pathName = params.pathName);
    params.parameters !== undefined && (this.parameters = params.parameters);
    params.hash !== undefined && (this.hash = params.hash);
    return this;
  }

  toString() {
    let url = this.origin;
    this.pathName && (url += '/' + this.pathName);
    this.parameters && (url += Url.encodeQuery(this.parameters));
    this.hash && (url += '#' + this.hash);
    return url;
  }
}

export default Url;