import React from 'react';
import createReactClass from 'create-react-class';
import ns from "./common-ns.js";
import PropTypes from 'prop-types';
import Tools from './tools.js';
import Environment from '../environment/environment.js';
import BaseMixin from './base-mixin.js';
import ElementaryMixin from './elementary-mixin.js';
import CcrWriterMixin from './ccr-writer-mixin.js';
import Url from './url.js';
import PureRenderMixin from "./pure-render-mixin";

import './router.less';

export const Router = createReactClass({

  //@@viewOn:mixins
  mixins: [BaseMixin, ElementaryMixin, CcrWriterMixin, PureRenderMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("Router"),
    opt: {
      ccrKey: Environment.CCRKEY_ROUTER
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    basePath: PropTypes.string,
    route: PropTypes.oneOfType([PropTypes.string, // path
    PropTypes.element, PropTypes.shape({
      tag: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
      props: PropTypes.object,
      source: PropTypes.string
    })]),
    notFoundRoute: PropTypes.oneOfType([PropTypes.string, // path
    PropTypes.element, PropTypes.shape({
      tag: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
      props: PropTypes.object
    })]),
    routes: PropTypes.object,
    urlBuilder: PropTypes.func
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      basePath: null,
      route: null,
      notFoundRoute: null,
      routes: null,
      urlBuilder: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    Environment.router = this;
    this._history = [];
    this._routeIndex = null;

    return {
      route: null
    };
  },

  componentWillMount() {
    if (window.location.pathname && this.props.routes && typeof this.props.route === 'string') {
      let path = window.location.pathname;
      let basePath = this._getBasePath(path, this.props);
      basePath && (path = path.replace(basePath, ''));

      let params = null;
      if (window.location.search) {
        params = Tools.decodeQuery(window.location.search);
      }
      this._setRoute(path, params, this.props);
    } else if (!this._shouldImport(this.props.route)) {
      this._setRoute(this.props.route, null, this.props);
    }
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this._setRoute(nextProps.route, null, nextProps);
    }
  },

  componentDidMount() {
    if (this._shouldImport(this.props.route)) {
      this._importRoute(this.props.route);
    }

    window.onpopstate = this._routeByNavigation;
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  // newRoute = {tag: 'Node', props: {}, source: '', notFoundRoute: {} || < />} || <Node {...props} />
  setRoute(newRoute, params, setStateCallback) {
    if (this._shouldImport(newRoute)) {
      this._importRoute(newRoute, params, setStateCallback);
    } else {
      this._setRoute(newRoute, params, null, setStateCallback);
    }
    return this;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getBasePath(path, props) {
    path = path || window.location.pathname;
    return props.basePath === null ? path ? path.replace(/(\/.*?\/.*?)\/.*/, "$1") : '' : props.basePath;
  },

  _shouldImport(route) {
    return route && typeof route === 'object' && route.tag && !Tools.findComponent(route.tag, true);
  },

  _importRoute(route, params, setStateCallback) {
    if (window.System && window.System.import) {
      if (route.source) {
        System.import(route.source).then(exports => {
          let tagArray = route.tag.split('.');
          let calculatedTag = window;
          while (calculatedTag && tagArray.length > 1) {
            let moduleName = tagArray.shift();
            calculatedTag[moduleName] = calculatedTag[moduleName] || {};
            calculatedTag = calculatedTag[moduleName];
          }
          let tagName = tagArray.shift();
          let tagExport = exports[tagName];
          tagExport = tagExport || exports.default;
          calculatedTag[tagName] = tagExport;
          this._setRoute(route, params, null, setStateCallback);
        }, error => {
          Tools.error('Loading package "' + route.source + '" failed with error:', {
            error: error,
            tagName: this.constructor.tagName
          });
        });
      } else {
        Tools.error('Route was not found and has not set any source to import.', {
          route: route,
          tagName: this.constructor.tagName
        });
        this._setRoute(route.notFoundRoute);
      }
    } else {
      Tools.error('System is not defined in window! Cannot import source:', {
        source: route.source,
        tagName: this.constructor.tagName
      });
    }
    return this;
  },

  _setRoute(newRoute, params, props, setStateCallback) {
    props = props || this.props;
    this.setState({ route: this._buildRoute(newRoute, params, null, props) }, setStateCallback);
    return this;
  },

  _getRouteByPath(searchedPath) {
    return this.props.routes[searchedPath] || null;
  },

  _routeByNavigation(event) {
    if (event.state) {
      if (event.state.index < this._routeIndex) {
        // go back
        this._routeIndex = event.state.index;
        // console.log('goBack', this._history[this._routeIndex], event.state, this._routeIndex, this._history);
      } else {
        // go forward
        this._routeIndex = event.state.index;
        // console.log('goForward', this._history[this._routeIndex], event.state, this._routeIndex, this._history);
      }
      let newRoute = this._history[this._routeIndex];
      newRoute && this.setState({ route: newRoute.component ? this._buildComponent(newRoute.component) : this._buildRoute(newRoute.path, newRoute.params, true) });
    }
    // else {
    //   console.log('goInvalid', window.location.pathname, event.state);
    // }
    return this;
  },

  _getUrl(route, params, props) {
    props = props || this.props;
    let url = document.location.origin + (this._getBasePath(null, props) || '') + route;
    params && (url += Tools.encodeQuery(params));
    return url;
  },

  _buildComponent(newRoute, params) {
    let newRouteChild;

    if (newRoute && typeof newRoute === 'object') {
      let newProps = {
        parent: this.getParent()
      };

      params && (newProps.params = params);

      if (newRoute.tag) {
        let tag = Tools.checkTag(newRoute.tag, true);
        let props = Tools.merge({}, newRoute.props, newProps);
        newRouteChild = tag ? React.createElement(tag, props) : Tools.findComponent(newRoute.tag, props);
      } else {
        newRouteChild = React.cloneElement(newRoute, newProps);
      }
    }

    return newRouteChild;
  },

  _buildRoute(route, params, replace, props) {
    let newRouteChild = null;
    props = props || this.props;

    if (route) {
      let newRoute = route;

      if (typeof route === 'string' && this.props.routes) {
        let foundRoute = this._getRouteByPath(route);
        let method = 'replaceState';

        if (foundRoute) {
          if (!foundRoute.noHistory) {
            if (this._routeIndex === null) {
              this._routeIndex = 0;
              this._history.push({ path: route, params: params });
            } else if (!replace) {
              this._routeIndex++;
              this._history.splice(this._routeIndex, this._history.length - 1);
              method = 'pushState';
              this._history.push({ path: route, params: params });
            }
          }

          // console.log(method, route, this._routeIndex, this._history);
          history[method]({ path: route, index: this._routeIndex }, document.title, this._getUrl(route, params, props));

          newRoute = foundRoute.component;
        }
      } else {
        let foundRoute = route;
        let method = 'replaceState';

        params = params || {};
        let path;

        if (params.url && typeof params.url === 'object') {
          let urlBuilder = this.props.urlBuilder || Environment.getUrlBuilder() || Url;
          path = urlBuilder.parse(window.location.href).set(params.url).toString();
        } else {
          path = params.url || window.location.href;
        }

        if (foundRoute) {
          if (!params.noHistory) {
            if (this._routeIndex === null) {
              this._routeIndex = 0;
              this._history.push({ path: path, component: foundRoute });
            } else if (!replace) {
              this._routeIndex++;
              this._history.splice(this._routeIndex, this._history.length - 1);
              method = 'pushState';
              this._history.push({ path: path, component: foundRoute });
            }
          }

          history[method]({ path: path, index: this._routeIndex }, params.title || document.title, path);

          newRoute = foundRoute;
        }
      }

      newRouteChild = this._buildComponent(newRoute, params);
    }

    if (newRouteChild && (!newRouteChild.type || !newRouteChild.type["UU5.Common.VucMixin"] && !newRouteChild.type["UU5.Common.RouteMixin"])) {
      Tools.error('Route component which should be set is not Visual Use Case.', {
        routeParam: route,
        routeChild: newRouteChild,
        tagName: this.constructor.tagName
      });
    }

    return newRouteChild;
  },

  _buildChild() {
    let child;

    if (this.state.route) {
      child = this.state.route;
    } else if (this.props.notFoundRoute) {
      child = this._buildRoute(this.props.notFoundRoute);
    } else {
      child = <div />;
      Tools.error(this.constructor.tagName, 'Router has no content.');
    }

    return child;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return this._buildChild();
  }
  //@@viewOff:render
});

export default Router;