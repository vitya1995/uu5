import React from 'react';
import createReactClass from 'create-react-class';
import ns from "./common-ns.js";
import PropTypes from 'prop-types';
import BaseMixin from './base-mixin';
import ElementaryMixin from './elementary-mixin';
import Tools from './tools';
import Environment from '../environment/environment';
import PureRenderMixin from "./pure-render-mixin";

import './text-corrector.less';

export const TextCorrector = createReactClass({

  //@@viewOn:mixins
  mixins: [BaseMixin, ElementaryMixin, PureRenderMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("TextCorrector"),
    classNames: {
      main: ns.css("text-corrector"),
      error: ns.css("text-corrector-error"),
      highlight: ns.css("text-corrector-highlight")
    },
    defaults: {
      highlightEvent: Tools.events.highlight
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    text: PropTypes.string,
    language: PropTypes.string,
    checkSpaces: PropTypes.bool,
    ignoreGrammar: PropTypes.bool,
    checkHighlight: PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      text: '',
      language: null,
      checkSpaces: false,
      ignoreGrammar: false,
      checkHighlight: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      text: this._correctSpaces(this.props.text)
    };
  },

  componentDidMount() {
    this._switchHighlight(true);
    this._correctText(this.state.text, null, true);
  },

  componentWillReceiveProps(nextProps) {
    this._correctText(nextProps.text);
  },

  componentWillUnmount() {
    this._switchHighlight(false);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _correctSpaces(text) {
    let newText = text;
    if (this.props.checkSpaces) {
      newText = this.replaceByHardSpace(text, this.props.language);
    }
    return newText;
  },

  _isValidWord(word) {
    let result = true;

    let text = /[A-Za-z]+/i.exec(word);
    if (text) {
      result = text[0].toLowerCase() !== 'vidra';
    }

    return result;
  },

  _isHighlightWord(word, searchedText) {
    return word.toLowerCase().indexOf(searchedText) > -1;
  },

  _checkWords(text, searchedTexts) {
    let newTextChildren = [];
    let spaceTmp = [];

    let spaceSplitter = text.split(' ');
    spaceSplitter.forEach(word => {
      if (word.indexOf(Environment.hardSpace.nbSpace) > -1) {
        let nbspSplitter = word.split(Environment.hardSpace.nbSpace);
        let nbspTmp = [];

        nbspSplitter.forEach(word => {
          let newWord = this._checkWord(word, searchedTexts);
          if (typeof newWord === 'string') {
            nbspTmp.push(newWord);
          } else {
            if (nbspTmp.length) {
              spaceTmp.push(nbspTmp.join(Environment.hardSpace.nbSpace));
              nbspTmp = [];
            }

            if (spaceTmp.length) {
              newTextChildren.push((newTextChildren.length ? ' ' : '') + spaceTmp.join(' ') + Environment.hardSpace.nbSpace);
              spaceTmp = [];
            }

            typeof newTextChildren[newTextChildren.length - 1] !== 'string' && newTextChildren.push(Environment.hardSpace.nbSpace);
            newTextChildren.push(newWord);
          }
        });

        if (nbspTmp.length) {
          spaceTmp.push(nbspTmp.join(Environment.hardSpace.nbSpace));
          nbspTmp = [];
        }
      } else {
        let newWord = this._checkWord(word, searchedTexts);

        if (typeof newWord === 'string') {
          spaceTmp.push(newWord);
        } else {
          if (spaceTmp.length) {
            newTextChildren.push((newTextChildren.length ? ' ' : '') + spaceTmp.join(' ') + ' ');
            spaceTmp = [];
          }
          typeof newTextChildren[newTextChildren.length - 1] === 'object' && newTextChildren.push(' ');
          newTextChildren.push(newWord);
        }
      }
    });

    if (spaceTmp.length) {
      newTextChildren.push((newTextChildren.length ? ' ' : '') + spaceTmp.join(' '));
      spaceTmp = [];
    }

    return React.Children.toArray(newTextChildren);
  },

  _checkWord(word, searchedTexts) {
    let result = word;

    if (this.props.checkHighlight && searchedTexts) {
      let searchedText = this._getSearchedText(word, searchedTexts);
      if (searchedText) {
        // full word
        // result = <span className={this.getClassName().highlight}>{word}</span>;

        let startIndex = word.toLowerCase().indexOf(searchedText.toLowerCase());
        let endIndex = startIndex + searchedText.length - 1;
        let searchedPart = word.substr(startIndex, searchedText.length);
        result = [];

        let highlighter = <span className={this.getClassName().highlight}>{searchedPart}</span>;

        if (startIndex > 0) {
          result.push(word.substr(0, endIndex + 1 - searchedPart.length));
        }

        result.push(highlighter);

        if (endIndex < word.length - 1) {
          result.push(word.substr(endIndex + 1, word.length - endIndex - 1));
        }
      }
    }

    if (this.props.checkGrammar && !this._isValidWord(word)) {
      result = <span className={this.getClassName().error}>
          {Array.isArray(result) ? React.Children.toArray(result) : result}
        </span>;
    }

    return result;
  },

  _correctText(text, searchedTexts, isDidMount) {
    let newText = text;
    if (!isDidMount && this.props.checkSpaces) {
      newText = this._correctSpaces(text);
    }

    if (this.props.checkGrammar || this.props.checkHighlight && searchedTexts) {
      newText = this._checkWords(newText || text, searchedTexts);
    }

    if (!isDidMount || text !== newText) {
      this.setState({ text: newText, searchedTexts: searchedTexts });
    }

    return this;
  },

  _switchHighlight(start) {
    if (this.props.checkHighlight) {
      if (start) {
        window.UU5.Environment.EventListener.registerHighlight(this.getId(), this._checkHighlight);
      } else {
        window.UU5.Environment.EventListener.unregisterHighlight(this.getId(), this._checkHighlight);
      }
    }
    return this;
  },

  _getSearchedText(text, searchedTexts) {
    let result = null;
    text = text.toLowerCase();
    for (let i = 0; i < searchedTexts.length; i++) {
      if (text.indexOf(searchedTexts[i].toLowerCase()) > -1) {
        result = searchedTexts[i];
        break;
      }
    }
    return result;
  },

  _checkHighlight(searchedTexts) {
    if (searchedTexts && searchedTexts.length > 0) {
      searchedTexts = Array.isArray(searchedTexts) ? searchedTexts : [searchedTexts];
    } else {
      searchedTexts = null;
    }

    if (!searchedTexts || this.state.searchedTexts || this._getSearchedText(this.props.text, searchedTexts)) {
      this._correctText(this.props.text, searchedTexts);
    }

    return this;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return <span {...this.getMainAttrs()}>
        {this.state.text}
        {this.getDisabledCover()}
      </span>;
  }
  //@@viewOff:render
});

export default TextCorrector;