import React from 'react';
import PropTypes from 'prop-types';
import Tools, { REGEXP } from './tools.js';
import Environment from '../environment/environment.js';

export const ContentMixin = {

  //@@viewOn:statics
  statics: {
    "UU5.Common.ContentMixin": {
      requiredMixins: ["UU5.Common.BaseMixin"],
      defaults: {
        standardMode: 'standard',
        outlineMode: 'outline',
        regexpUu5: /^\s*<(uu5json|uu5string|uu5data)\s*\/>/
      },
      errors: {
        unexpectedContentType: 'Type "%s" of content property is unexpected.',
        dynamicOnly: 'Method %s can be used just for dynamic content.',
        insertedchildIdNotExists: 'Child with ID %s does not exist.',
        childIdNotExists: 'Child with ID %s does not exist.',
        indexNotSet: 'In this case index has to be specified.',
        addRenderedChildToIdList_IdDuplicity: 'There is duplicity ID %s in adding rendered child to the list of children by ID.',
        addRenderedChildToNameList_IdDuplicity: 'There is Name duplicity in adding rendered child to the list children by Name.'
      }
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    content: PropTypes.oneOfType([
    // content array:[bodyItem, items, node, number, bool, string]
    PropTypes.array,
    // content bodyItem:{tag:'',props{}}
    PropTypes.shape({
      tag: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
      props: PropTypes.arrayOf(PropTypes.object)
    }),
    // content items:{tag:'',propsArray:[{},{},{},...]}
    PropTypes.shape({
      tag: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
      propsArray: PropTypes.arrayOf(PropTypes.object)
    }),
    // content node
    PropTypes.node,
    // number
    PropTypes.number,
    // bool
    PropTypes.bool]),
    ignoreInnerHTML: PropTypes.bool,
    checkSpaces: PropTypes.bool,
    checkGrammar: PropTypes.bool,
    checkHighlight: PropTypes.bool,
    textCorrector: PropTypes.bool,
    dynamic: PropTypes.bool,
    mode: PropTypes.oneOf(['standard', 'outline'])
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function () {
    return {
      content: null,
      ignoreInnerHTML: false,
      checkSpaces: false,
      checkGrammar: false,
      checkHighlight: false,
      textCorrector: false,
      dynamic: false,
      mode: 'standard'
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState: function () {
    // initialize
    this.registerMixin("UU5.Common.ContentMixin");

    this.renderedChildren = []; // [renderedChild,renderedChild,...]
    this.renderedChildrenIdList = {}; // {id:renderedChild,id:renderedChild,...}
    this.renderedChildrenNameList = {}; // {name:renderedChild,name:renderedChild,...}

    // state
    var state = {
      mode: this.props.mode
    };

    if (this.isDynamic()) {
      state.children = this.buildChildren(this.props);
      state.filter = null;
      state.filteredProps = null;
      state.sorter = null;
      state.sortedIds = null;
    }

    return state;
  },

  componentWillReceiveProps: function (nextProps) {
    if (nextProps.controlled) {
      this.isDynamic() && this.setChildren(this.buildChildren(nextProps));
      nextProps.mode !== this.props.mode && this.setState({ mode: nextProps.mode });
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  hasUU5CommonContentMixin: function () {
    return this.hasMixin("UU5.Common.ContentMixin");
  },

  isDynamic: function () {
    return this.props.dynamic;
  },

  getContent: function () {
    return this.props.content;
  },

  getUU5CommonContentMixinProps: function () {
    return {
      content: this.getContent(),
      dynamic: this.isDynamic(),
      ignoreInnerHTML: this.props.ignoreInnerHTML,
      checkSpaces: this.props.checkSpaces,
      checkGrammar: this.props.checkGrammar,
      checkHighlight: this.props.checkHighlight,
      mode: this.props.mode
    };
  },

  getUU5CommonContentMixinPropsToPass: function () {
    return this.getUU5CommonContentMixinProps();
  },

  expandChildProps: function (prevChild, childIndex) {
    var newChildProps = prevChild.props;
    newChildProps = Tools.mergeDeep({}, newChildProps);

    // key is id if id is set, or it is childIndex
    // Key can not be generated because of in each render the child has new key and child is unmounted and mounted again
    let key = newChildProps.id || childIndex;

    var isUU5Child = typeof prevChild.type === 'function' && prevChild.type.tagName;

    if (isUU5Child) {
      newChildProps.parent = newChildProps.parent || this;
      //newChildProps.parent = this;

      this.isDynamic() && (newChildProps.id = newChildProps.id || Tools.generateUUID());

      if (typeof this.expandChildProps_ === 'function') {
        var tempChild = React.cloneElement(prevChild, newChildProps);
        newChildProps = this.expandChildProps_(tempChild, childIndex);
      }
    }

    newChildProps.key = newChildProps.key || key;

    if (isUU5Child) {
      newChildProps.ref = function (renderedChild) {
        renderedChild && this.registerRenderedChild(renderedChild, childIndex);
      }.bind(this);
    }

    return newChildProps;
  },

  buildChild: function (childTag, childProps, children) {
    if (childProps && childProps.href && childProps.href.match(/^javascript:/i)) {
      childProps = Tools.merge({}, childProps);
      childProps.href = childProps.href.replace(REGEXP.jsCode, "");
    }
    return Tools.findComponent(childTag, childProps, children);
  },

  cloneChild: function (child, props) {
    let clonedChild;
    if (this.expandChild_) {
      clonedChild = this.expandChild_(React.cloneElement(child, props), props.key);
    }

    return clonedChild || React.cloneElement(child, props);
  },

  buildNodeChildren: function (children, childPropsExpander) {
    var content = this;
    var newChildren = [];
    React.Children.forEach(children, function (child, i) {
      if (child !== undefined && child !== null) {
        if (content.shouldChildRender(child)) {
          if (typeof child === 'object') {
            var newChildProps = childPropsExpander(child, i);
            var newChild = content.cloneChild(child, newChildProps);

            // text
          } else {
            // it does not need to cover just spaces by textCorrector
            if (typeof child === 'number' || child.trim() === '' || !Environment.textCorrector && !content.props.textCorrector || !content.props.checkSpaces && !content.props.checkGrammar && !content.props.checkHighlight) {
              newChild = child;
              if (content.expandChild_) {
                newChild = content.expandChild_(newChild, i);
              }
            } else {
              let props = {
                text: child,
                checkSpaces: content.props.textCorrector || content.props.checkSpaces,
                checkGrammar: content.props.textCorrector || content.props.checkGrammar,
                checkHighlight: content.props.textCorrector || content.props.checkHighlight,
                language: content.props.language,
                key: i
              };
              newChild = content.cloneChild(Tools.findComponent('UU5.Common.TextCorrector', props), props);

              if (content.expandChild_) {
                newChild = content.expandChild_(newChild, i);
              }
            }
          }
          newChildren.push(newChild);
        }
      }
    });

    return newChildren;
  },

  shouldChildRender: function (child) {
    let childTag = Tools.getChildTag(child);
    let result = Environment.nestingLevelStrict ? childTag && !!childTag["UU5.Common.NestingLevelMixin"] : true;

    if (result && typeof this.shouldChildRender_ === 'function') {
      result = this.shouldChildRender_(child);
    }
    return result;
  },

  buildChildren: function (contentProps, childPropsExpander, childIndex) {
    let children = null;

    if (typeof this.buildChildren_ === 'function') {
      children = this.buildChildren_(contentProps, childPropsExpander);
    } else {
      contentProps = contentProps || this.props;
      childPropsExpander = childPropsExpander || this.expandChildProps;
      childIndex = childIndex || 0;

      let contentValue = contentProps.content;
      let contentType = this._getContentType(contentValue);

      if (contentType === 'uu5json') {
        contentValue = Tools.parseFromUu5JSON(contentValue);
        contentType = this._getContentType(contentValue);
      } else if (contentType === 'uu5data') {
        contentValue = Tools.parseFromUu5Data(contentValue);
        contentType = this._getContentType(contentValue);
      }

      switch (contentType) {
        case 'bodyItem':
          let bodyItemChild = this.buildChild(contentValue.tag, contentValue.props);
          this.shouldChildRender(bodyItemChild) && (children = [this.cloneChild(bodyItemChild, childPropsExpander(bodyItemChild, childIndex))]);
          break;
        case 'array':
          children = contentValue.map((bodyItem, i) => {
            return this.buildChildren({ content: bodyItem }, childPropsExpander, i);
          });
          break;
        case 'items':
          let tag = Tools.checkTag(contentValue.tag, true);
          children = [];
          contentValue.propsArray.forEach((props, i) => {
            let child = tag ? this.buildChild(tag, props) : Tools.findComponent(contentValue.tag, props);
            child = this.cloneChild(child, childPropsExpander(child, i));
            this.shouldChildRender(child) && children.push(child);
          });
          break;
        case 'string':
          if (contentValue.trim() === '' || !Environment.textCorrector && !this.props.textCorrector && !this.props.checkSpaces && !this.props.checkGrammar && !this.props.checkHighlight) {
            children = contentValue;
          } else {
            children = Tools.findComponent('UU5.Common.TextCorrector', {
              parent: this,
              text: contentValue,
              checkSpaces: this.props.textCorrector || this.props.checkSpaces,
              checkGrammar: this.props.textCorrector || this.props.checkGrammar,
              checkHighlight: this.props.textCorrector || this.props.checkHighlight,
              language: this.props.language
            });
          }
          break;
        case 'number':
          children = contentValue;
          break;
        case 'element':
          children = this.cloneChild(contentValue, childPropsExpander(contentValue, childIndex));
          break;
        case 'bool':
          children = contentValue ? 'true' : 'false';
          break;
        case 'uu5string':
          let stringChildren = Tools.getChildrenFromUu5String(contentValue);
          children = this.buildNodeChildren(stringChildren, childPropsExpander);
          break;
        case 'children':
        default:
          if (contentProps.children) {
            children = this.buildNodeChildren(contentProps.children, childPropsExpander);
          }
      }
    }

    return children;
  },

  getStandardChildren: function () {
    return this.isDynamic() ? this.state.children : this.buildChildren();
  },

  getOutlineChildren: function () {
    return Tools.findComponent('UU5.Common.Outline', { element: this, key: 0 });
  },

  getChildren: function () {
    var children = null;

    switch (this.getMode()) {
      case this.getDefault('standardMode', "UU5.Common.ContentMixin"):
        children = this.getStandardChildren();
        break;
      case this.getDefault('outlineMode', "UU5.Common.ContentMixin"):
        children = this.getOutlineChildren();
        break;
    }

    return children;
  },

  getRenderedChildren: function () {
    return this.renderedChildren;
  },

  setRenderedChildren: function (childrenIndexList) {
    this.renderedChildren = childrenIndexList;
    return this;
  },

  addRenderedChild: function (renderedChild, index) {
    if (index === undefined || index === null) {
      this.showError('indexNotSet', null, {
        mixinName: "UU5.Common.ContentMixin",
        context: {
          index: index,
          renderedChild: {
            tagName: renderedChild.getTagName(),
            id: renderedChild.getId(),
            component: renderedChild
          }
        }
      });
    } else {
      this.getRenderedChildren().splice(index, 0, renderedChild);
    }
    return this;
  },

  removeRenderedChild: function (renderedChild) {
    this.getRenderedChildren().splice(renderedChild.getIndex(), 1);
    return this;
  },

  getRenderedChildrenIdList: function () {
    return this.renderedChildrenIdList;
  },

  setRenderedChildrenIdList: function (childrenIdList) {
    this.renderedChildrenIdList = childrenIdList;
    return this;
  },

  addRenderedChildToIdList: function (renderedChild) {
    var id = renderedChild.getId();
    if (!this.getRenderedChildById(id)) {
      this.getRenderedChildrenIdList()[id] = renderedChild;
    } else if (this.getRenderedChildById(id) !== renderedChild) {
      this.showError('addRenderedChildToIdList_IdDuplicity', id, {
        mixinName: "UU5.Common.ContentMixin",
        context: {
          renderedChildrenIdList: this.getRenderedChildrenIdList(),
          renderedChild: {
            tagName: renderedChild.getTagName(),
            id: renderedChild.getId(),
            component: renderedChild
          }
        }
      });
    }
    return this;
  },

  removeRenderedChildFromIdList: function (renderedChild) {
    delete this.getRenderedChildrenIdList()[renderedChild.getId()];
    return this;
  },

  getRenderedChildrenNameList: function () {
    return this.renderedChildrenNameList;
  },

  setRenderedChildrenNameList: function (childrenNameList) {
    this.renderedChildrenNameList = childrenNameList;
    return this;
  },

  addRenderedChildToNameList: function (renderedChild) {
    var name = renderedChild.getName();
    if (name) {
      var nameList = this.getRenderedChildrenNameList();
      if (!nameList[name] || nameList[name].map(function (rChild) {
        return rChild.getId();
      }).indexOf(renderedChild.getId()) === -1) {

        nameList[name] = nameList[name] || [];
        nameList[name].push(renderedChild);
      }
    }
    return this;
  },

  removeRenderedChildFromNameList: function (renderedChild) {
    var nameChildren = this.getRenderedChildrenByName(renderedChild.getName());
    if (nameChildren) {
      var childIndex = nameChildren.map(function (rChild) {
        return rChild.getId();
      }).indexOf(renderedChild.getId());

      childIndex > -1 && nameChildren.splice(childIndex, 1);
    }
    return this;
  },

  getChildIndexById: function (childId) {
    var childIndex;

    if (typeof this.getChildIndexById_ === 'function') {
      childIndex = this.getChildIndexById_(childId);
    } else {
      var children = this.getRenderedChildren();

      var index = childId && children.map(function (child) {
        return child.getId() === childId;
      }).indexOf(true);

      childIndex = index === -1 ? null : index;
    }

    return childIndex;
  },

  getRenderedChildById: function (childId) {
    var renderedChild;

    if (typeof this.getRenderedChildById_ === 'function') {
      renderedChild = this.getRenderedChildById_(childId);
    } else {
      renderedChild = this.getRenderedChildrenIdList()[childId] || null;
    }

    return renderedChild;
  },

  getRenderedChildrenByName: function (childName) {
    return this.getRenderedChildrenNameList()[childName] || null;
  },

  getRenderedChildByName: function (childName) {
    var renderedChild;

    if (typeof this.getRenderedChildByName_ === 'function') {
      renderedChild = this.getRenderedChildByName_(childName);
    } else {
      var nameChildren = this.getRenderedChildrenByName(childName);
      renderedChild = nameChildren ? nameChildren[0] : null;
    }

    return renderedChild;
  },

  getRenderedChildByIndex: function (index) {
    var renderedChild;

    if (typeof this.getRenderedChildByIndex_ === 'function') {
      renderedChild = this.getRenderedChildByIndex_(index);
    } else {
      renderedChild = this.getRenderedChildren()[index] || null;
    }

    return renderedChild;
  },

  getRenderedChildByTagName: function (tagName) {
    var foundChild = null;

    if (typeof this.getRenderedChildByTagName_ === 'function') {
      foundChild = this.getRenderedChildByTagName_(tagName);
    } else {
      this.eachRenderedChild(function (renderedChild) {
        var condition = renderedChild.getTagName() === tagName;
        condition && (foundChild = renderedChild);
        return !condition; // false <=> end of cycle
      });
    }

    return foundChild;
  },

  getFirstRenderedChild: function () {
    var renderedChild = null;

    if (typeof this.getFirstRenderedChild_ === 'function') {
      renderedChild = this.getFirstRenderedChild_();
    } else {
      renderedChild = this.getRenderedChildByIndex(0);
    }

    return renderedChild;
  },

  getLastRenderedChild: function () {
    var renderedChild = null;

    if (typeof this.getLastRenderedChild_ === 'function') {
      renderedChild = this.getLastRenderedChild_();
    } else {
      renderedChild = this.getRenderedChildByIndex(this.getRenderedChildren().length - 1);
    }

    return renderedChild;
  },

  eachRenderedChild: function (callback) {
    // function callbackFunction( renderedChild, renderedChildIndex );
    if (typeof this.eachRenderedChild_ === 'function') {
      this.eachRenderedChild_(callback);
    } else {
      var renderedChildren = this.getRenderedChildren();

      // same as: for(var i = 0; i < renderedChildren.length; i++) {
      //          var renderedChild = renderedChildren[i];
      for (var i = 0, renderedChild; renderedChild = renderedChildren[i]; ++i) {
        var result = callback(renderedChild, i);
        if (result === false) {
          break;
        }
      }
    }
    return this;
  },

  registerRenderedChild: function (renderedChild, index) {
    if (renderedChild.hasUU5CommonBaseMixin && !this.getRenderedChildById(renderedChild.getId())) {
      this.addRenderedChild(renderedChild, index);
      this.addRenderedChildToIdList(renderedChild);
      this.addRenderedChildToNameList(renderedChild);
    }
    return this;
  },

  unregisterRenderedChild: function (renderedChild) {
    this.removeRenderedChild(renderedChild);
    this.removeRenderedChildFromIdList(renderedChild);
    this.removeRenderedChildFromNameList(renderedChild);
    return this;
  },

  // dynamic functions

  setChildren: function (newChildren, setStateCallback) {
    if (this.isDynamic()) {
      if (typeof this.setChildren_ === 'function') {
        this.setChildren_(newChildren, setStateCallback);
      } else {
        this.setState({ children: newChildren }, setStateCallback);
      }
    } else {
      this.showError('dynamicOnly', 'setChildren', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }
    return this;
  },

  /**
   * Inserts child into container. If position is set, child will be added to that position.
   * Only for dynamic container.
   * Can be overridden by insertChild_ function.
   *
   * @param {object|element} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {number} opt.position - Position where the child should be placed to. If not set, child is added
   *                                at the end of children list.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  insertChild: function (child, opt) {
    /*
     opt:{
     position: number // Position where the child should be placed to.
     // If not set, child is added at the end of children list.
     shouldUpdate: bool // call setState -> render, default value is true
     callbackFunction: function // function callbackFunction(newRenderedChild)
     }
     */
    if (this.isDynamic()) {
      if (typeof this.insertChild_ === 'function') {
        this.insertChild_(child, opt);
      } else {
        opt = opt || {};

        let children = this.getChildren() || [];
        if (Array.isArray(children)) {
          children = children.slice();
        } else {
          const elem = this.cloneChild(children, this.expandChildProps(children, 0));
          children = [elem];
        }

        let newChild = child.tag ? this.buildChild(child.tag, child.props) : child;

        if (this.shouldChildRender(newChild)) {
          newChild = this.cloneChild(newChild, this.expandChildProps(newChild, typeof opt.position === 'number' ? opt.position : children.length));

          if (typeof opt.position === 'number') {
            children.splice(opt.position, 0, newChild);
          } else {
            children.push(newChild);
          }

          if (opt.shouldUpdate === undefined || opt.shouldUpdate) {
            this.setChildren(children, typeof opt.setStateCallback === 'function' ? () => {
              opt.setStateCallback(this.getRenderedChildById(newChild.props.id));
            } : null);
          }
        }
      }
    } else {
      this.showError('dynamicOnly', 'insertChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Inserts child into container at position before another child by ID.
   * Only for dynamic container.
   * Can be overridden by insertChildBefore_ function.
   *
   * @param {object} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {string} opt.childAfterId - ID of the child before which the new child will be placed. If not set, the new
   *                                    child will be placed at the beginning.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  insertChildBefore: function (child, opt) {
    if (this.isDynamic()) {
      if (typeof this.insertChildBefore_ === 'function') {
        this.insertChildBefore_(child, opt);
      } else {
        opt = opt || {};

        var childIndex;
        if (opt.childAfterId) {
          var renderedChild = this.getRenderedChildById(opt.childAfterId);
          childIndex = renderedChild.getIndex();
        } else {
          childIndex = 0;
        }

        if (childIndex === null) {
          this.showError('insertedchildIdNotExists', opt.childAfterId, {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          this.insertChild(child, Tools.merge({}, opt, { position: childIndex }));
        }
      }
    } else {
      this.showError('dynamicOnly', 'insertChildBefore', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Inserts child into container at position after another child by ID.
   * Only for dynamic container.
   * Can be overridden by insertChildAfter_ function.
   *
   * @param {object} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {string} opt.childBeforeId - ID of child after which the new child will be placed. If not set, the new
   *                                     child will be placed at the end.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  insertChildAfter: function (child, opt) {
    if (this.isDynamic()) {
      if (typeof this.insertChildAfter_ === 'function') {
        this.insertChildAfter_(child, opt);
      } else {
        // reset position value and copy opt
        opt = Tools.merge({}, opt, { position: undefined }) || {};

        if (opt.childBeforeId) {
          var renderedChild = this.getRenderedChildById(opt.childBeforeId);
          var childIndex = renderedChild.getIndex();
          childIndex !== null && (opt.position = childIndex + 1);
        }

        if (opt.childBeforeId && opt.position === undefined) {
          this.showError('insertedchildIdNotExists', opt.childBeforeId, {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          this.insertChild(child, opt);
        }
      }
    } else {
      this.showError('dynamicOnly', 'insertChildAfter', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Update child props. New props will be merged with old props, so it is possible to change just one property or all
   * of them.
   * Only for dynamic container.
   * Can be overridden by updateChild_ function.
   *
   * TODO: maybe function updateProps() should be in baseMixin (only if parent is dynamic container)
   *
   * @param {string} childId - ID of child, which props are being updated.
   * @param {object} newProps - Props which are being changed. It is not necessary to set all of the props.
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  updateChild: function (childId, newProps, opt) {
    if (this.isDynamic()) {
      if (typeof this.updateChild_ === 'function') {
        this.updateChild_(childId, newProps, opt);
      } else {
        opt = opt || {};

        var renderedChild = this.getRenderedChildById(childId);

        if (renderedChild === null) {
          this.showError('childIdNotExists', 'updateChild', {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          var childIndex = renderedChild.getIndex();

          var children = this.getChildren();
          // must destroy object reference because of shouldComponentUpdate
          children = children && children.length > 0 ? children.slice() : [];
          let newChild = this.cloneChild(children[childIndex], newProps);
          children[childIndex] = this.cloneChild(children[childIndex], this.expandChildProps(newChild, childIndex));

          (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren(children, opt.setStateCallback);
        }
      }
    } else {
      this.showError('dynamicOnly', 'updateChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Replace child by tag and props on the position.
   * Only for dynamic container.
   * Can be overridden by replaceChild_ function.
   *
   * TODO: maybe function replace() should be in baseMixin (only if parent is dynamic container)
   *
   * @param {string} childId - ID of child, which props are being updated.
   * @param {object} child - Object with tag of the element and props. E.g. {tag: '...', props: {...}} or Element e.g. < ... />
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  replaceChild: function (childId, child, opt) {
    if (this.isDynamic()) {
      if (typeof this.replaceChild_ === 'function') {
        this.replaceChild_(childId, child, opt);
      } else {
        opt = opt || {};

        var renderedChild = this.getRenderedChildById(childId);

        if (renderedChild === null) {
          this.showError('childIdNotExists', 'replaceChild', {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          var childIndex = renderedChild.getIndex();

          var children = this.getChildren();
          // must destroy object reference because of shouldComponentUpdate
          children = children && children.length > 0 ? children.slice() : [];
          let newChild = child.tag ? this.buildChild(child.tag, child.props) : child;
          if (this.shouldChildRender(newChild)) {
            children[childIndex] = this.cloneChild(newChild, this.expandChildProps(newChild, childIndex));

            (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren(children, opt.setStateCallback);
          }
        }
      }
    } else {
      this.showError('dynamicOnly', 'replaceChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Deletes child from children list.
   * Only for dynamic container.
   * Can be overridden by deleteChild_ function.
   *
   * TODO: maybe function delete() should be in baseMixin (only if parent is dynamic container)
   *
   * @param {string} childId - ID of child, which props are being deleted.
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  deleteChild: function (childId, opt) {
    if (this.isDynamic()) {
      if (typeof this.deleteChild_ === 'function') {
        this.deleteChild_(childId, opt);
      } else {
        opt = opt || {};

        var renderedChild = this.getRenderedChildById(childId);
        if (renderedChild === null) {
          this.showError('childIdNotExists', 'deleteChild', {
            mixinName: "UU5.Common.ContentMixin"
          });
        } else {
          var childIndex = renderedChild.getIndex();

          var children = this.getChildren();
          // must destroy object reference because of shouldComponentUpdate
          children = children && children.length > 0 ? children.slice() : [];
          children.splice(childIndex, 1);

          (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren(children, opt.setStateCallback);
        }
      }
    } else {
      this.showError('dynamicOnly', 'deleteChild', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  /**
   * Deletes all children.
   * Only for dynamic container.
   * Can be overridden by clearChildren_ function.
   *
   * @param {object} opt - Additional parameters.
   * @param {boolean} opt.shouldUpdate - If false, setState is not called.
   * @param {function} opt.setStateCallback - Callback is called after setState.
   * @returns {object} this
   */
  clearChildren: function (opt) {
    if (this.isDynamic()) {
      if (typeof this.clearChildren_ === 'function') {
        this.clearChildren_(opt);
      } else {
        opt = opt || {};
        (opt.shouldUpdate === undefined || opt.shouldUpdate) && this.setChildren([], opt.setStateCallback);
      }
    } else {
      this.showError('dynamicOnly', 'clearChildren', {
        mixinName: "UU5.Common.ContentMixin"
      });
    }

    return this;
  },

  setFilter: function (filter, setStateCallback) {
    this.setState({ filter: filter, filteredProps: this._getFilteredChildrenProps(filter) }, setStateCallback);
    return this;
  },

  resetFilter: function (setStateCallback) {
    this.setState({ filter: null, filteredProps: null }, setStateCallback);
    return this;
  },

  setSorter: function (sorter, setStateCallback) {
    this.setState({ sorter: sorter, sortedIds: this._getSortedChildIds(sorter) }, setStateCallback);
    return this;
  },

  resetSorter: function (setStateCallback) {
    this.setState({ sorter: null, sortedIds: null }, setStateCallback);
    return this;
  },

  setFilterAndSorter: function (filter, sorter, setStateCallback) {
    this.setState({
      filter: filter, filteredProps: this._getFilteredChildrenProps(filter),
      sorter: sorter, sortedIds: this._getSortedChildIds(sorter)
    }, setStateCallback);

    return this;
  },

  resetFilterAndSorter: function (setStateCallback) {
    this.setState({
      filter: null, filteredProps: null,
      sorter: null, sortedIds: null
    }, setStateCallback);

    return this;
  },

  getFilteredSorterChildren: function (children) {
    var container = this;
    var newChildren = [];

    children = children || this.getChildren();

    if (children) {
      children = Array.isArray(children) ? children : [children];
      children.forEach(function (child) {
        if (child) {
          var childId = child.props && child.props.id;
          var index = container.state.sortedIds && container.state.sortedIds.indexOf(childId);

          if (!container.state.sortedIds || index > -1) {
            var newProps = container.state.filteredProps && container.state.filteredProps[childId];

            if (!container.state.filteredProps || newProps) {
              newProps && Object.keys(newProps).length !== 0 && (child = React.cloneElement(child, Tools.mergeDeep({}, child.props, newProps)));

              if (typeof index === 'number') {
                newChildren[index] = child;
              } else {
                newChildren.push(child);
              }
            }
          }
        }
      });
    }

    return newChildren;
  },

  // Mode
  setStandardMode: function (setStateCallback) {
    this.setState({ mode: this.getDefault('standardMode', "UU5.Common.ContentMixin") }, setStateCallback);
    return this;
  },

  setOutlineMode: function (setStateCallback) {
    this.setState({ mode: this.getDefault('outlineMode', "UU5.Common.ContentMixin") }, setStateCallback);
    return this;
  },

  getMode: function () {
    return this.state.mode;
  },

  isStandardMode: function () {
    return this.getMode() === this.getDefault('standardMode', "UU5.Common.ContentMixin");
  },

  isOutlineMode: function () {
    return this.getMode() === this.getDefault('outlineMode', "UU5.Common.ContentMixin");
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getContentType: function (content) {
    let type = null; // one of ['children','uu5json','uu5string','uu5data','string','number','array','items','bodyItem','element','bool']

    if (content === undefined || content === null) {
      // children
      type = 'children';
    } else if (typeof content === 'string') {
      let match = this.getDefault('regexpUu5', "UU5.Common.ContentMixin").exec(content);
      type = match ? match[1] : 'string';
    } else if (typeof content === 'number') {
      type = 'number';
    } else if (typeof content === 'boolean') {
      type = 'bool';
    } else if (Array.isArray(content)) {
      type = 'array';
    } else if (content && typeof content === 'object') {
      // bodyItem, items or node
      type = content.tag ? content.propsArray ? 'items' : 'bodyItem' : 'element';
    } else {
      this.showError('unexpectedContentType', typeof content, {
        mixinName: "UU5.Common.ContentMixin",
        context: {
          content: content
        }
      });
    }

    return type;
  },

  _getFilteredChildrenProps: function (filter) {
    let filteredChildrenProps = {};

    this.eachRenderedChild(function (renderedChild, i) {
      let result = filter(renderedChild, i);
      if (result) {
        result === true && (result = {});
      } else {
        result = { hidden: true };
      }
      filteredChildrenProps[renderedChild.getId()] = result;
    });

    return filteredChildrenProps;
  },

  _getSortedChildIds: function (sorter) {
    let sortedChildren = this.getRenderedChildren().sort(sorter);
    return sortedChildren.map(function (renderedChild) {
      return renderedChild.getId();
    });
  }
  //@@viewOff:componentSpecificHelpers
};

export default ContentMixin;