import React from 'react';
import PropTypes from 'prop-types';
import * as UU5 from 'uu5g04';
import ns from "../forms-ns.js";

import InputMixin from './input-mixin.js';

import Option from './../select-option.js';

export const TextInputMixin = {

  //@@viewOn:mixins
  mixins: [UU5.Common.ColorSchemaMixin, InputMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    "UU5.Forms.TextInputMixin": {
      classNames: {
        main: ns.css("text-input"),
        item: ns.css("auto-complete-item", "group-item")
      }
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    placeholder: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
    required: PropTypes.bool,
    requiredMessage: PropTypes.any,
    focusMessage: PropTypes.any,
    patternMessage: PropTypes.any,
    autocompleteItems: PropTypes.arrayOf(PropTypes.shape({
      value: PropTypes.string,
      params: PropTypes.object,
      content: PropTypes.any
    })),
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    onEnter: PropTypes.func,
    validateOnChange: PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function () {
    return {
      placeholder: null,
      required: false,
      requiredMessage: null,
      focusMessage: null,
      patternMessage: null,
      autocompleteItems: null,
      onFocus: null,
      onBlur: null,
      onEnter: null,
      validateOnChange: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      autocompleteItems: this.props.autocompleteItems,
      foundAutocompleteItems: null,
      selectedIndex: null
    };
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this.setState({ autocompleteItems: nextProps.autocompleteItems });
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  isTextInput() {
    return true;
  },

  getInput() {
    return this._textInput;
  },

  focus() {
    this._textInput && this._textInput.focus();
  },

  isValid: function () {
    var feedback = this.getFeedback();
    var value = this.getValue();
    var result = true;

    if (this.props.required && (value === '' || value === null)) {
      this.setError(this.props.requiredMessage || this.getLsiValue('requiredMessage'));
      result = false;
    } else if (feedback === 'error') {
      result = false;
    } else if (typeof this.isValid_ === 'function') {
      result = this.isValid_();
    }

    if (result && this.props.onValidate) {
      var validation = this.props.onValidate({ value: value, component: this });
      if (validation && typeof validation === 'object') {
        if (validation.feedback === 'error') {
          result = false;
        }
      }
    }

    return result;
  },

  open(setStateCallback) {
    this._stopPropagation = true;
    this._addEvent();
    this.setState({ open: true }, setStateCallback);
    return this;
  },

  isOpen() {
    return typeof this.isOpen_ === "function" ? this.isOpen_() : this.state.open;
  },

  getFocusFeedback() {
    let value;
    if (this.isInitial() && this.props.focusMessage) {
      value = {
        message: this.props.focusMessage,
        value: this.state.value,
        feedback: 'initial'
      };
    }
    return value;
  },

  getBlurFeedback(opt) {
    let result;
    let validateFeedback = this.onValidate(opt);
    if (validateFeedback) {
      result = validateFeedback;
    } else {
      result = {
        feedback: this.state.feedback,
        message: this.state.message,
        value: opt.value
      };
    }
    return result;
  },

  onValidate(opt) {
    let result;
    if (this.props.pattern) {
      let r = new RegExp(this.props.pattern);
      if (!r.test(opt.value)) {
        result = {
          feedback: 'error',
          message: this.props.patternMessage || this.getLsiComponent('patternMessage'),
          value: opt.value
        };
      }
    } else if (typeof this.props.onValidate === 'function') {
      result = this.props.onValidate(opt);
    }

    return result;
  },

  setAutoCompleteItems(items, opt, setStateCallback) {
    opt = opt || {};

    opt.autocompleteItems = items;
    opt.value = opt.value || this.state.value;
    let result = this.getChangeFeedback(opt);

    this.setState({
      autocompleteItems: items,
      feedback: result.feedback,
      message: result.message,
      value: result.value,
      foundAutocompleteItems: result.foundAutocompleteItems,
      selectedIndex: result.selectedIndex
    }, setStateCallback);

    return this;
  },

  onFocus(e) {
    let opt = { value: e.target.value, event: e, component: this };
    if (typeof this.props.onFocus === 'function') {
      this.props.onFocus(opt);
    } else {
      let result = this.getFocusFeedback(opt);
      result && this.setFeedback(result.feedback, result.message, result.value);
    }

    return this;
  },

  onChange(e) {
    let opt = { value: e.target.value, event: e, component: this };

    if (!this.isDisabled() && !this.isReadOnly()) {
      if (typeof this.props.onChange === 'function') {
        this.props.onChange(opt);
      } else if (this.props.validateOnChange) {
        this._validateOnChange(opt);
      } else {
        let result = this.getChangeFeedback(opt);
        this.setState({
          feedback: result.feedback,
          message: result.message,
          value: result.value,
          foundAutocompleteItems: result.foundAutocompleteItems,
          selectedIndex: result.selectedIndex
        });
      }
    }

    return this;
  },

  onBlur(e) {
    let opt = { value: e.target.value, event: e, component: this };

    if (typeof this.props.onBlur === 'function') {
      this.props.onBlur(opt);
    } else {
      if (this._checkRequired({ value: opt.value }) && !this.props.validateOnChange) {
        opt.required = this.props.required;
        let blurResult = this.getBlurFeedback(opt);
        this._setFeedback(blurResult.feedback, blurResult.message, blurResult.value);
      }
    }

    return this;
  },

  onKeyDown(e, param) {
    let opt = { value: e.target.value, event: e, component: this };

    // param is user function passed to inputAttrs.onKeyDown
    if (typeof param === 'function') {
      param(e, opt);
    }

    if (typeof this.props.onEnter === 'function' && (e.keyCode || e.which) === 13 && !e.shiftKey && !e.ctrlKey) {
      this.props.onEnter(opt);
    }

    return this;
  },

  // find: function (foundValue, setStateCallback) {
  //   var values = {first: [], last: []};
  //   this.props.items.forEach(function (item) {
  //     if (foundValue !== '') {
  //       if (new RegExp('^' + foundValue, 'i').exec(item.value)) {
  //         values.first.push(item);
  //       } else if (new RegExp(foundValue, 'gi').exec(item.value)) {
  //         values.last.push(item);
  //       }
  //     }
  //   });
  //   var allValues = values.first.concat(values.last);
  //   this.setState({items: allValues.length ? allValues : null, selectedIndex: null}, setStateCallback);
  //   return this;
  // },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  getChangeFeedback_(opt) {
    let foundedItems = null;
    let selectedIndex = this.state.selectedIndex;

    if (opt.autocompleteItems || this.state.autocompleteItems) {
      foundedItems = this._find(opt.autocompleteItems || this.state.autocompleteItems, opt.value);
      selectedIndex = null;
    }

    return {
      feedback: opt.feedback || InputMixin.INITIAL_FEEDBACK,
      message: opt.message || null,
      value: opt.value === undefined ? this.state.value : opt.value,
      foundAutocompleteItems: foundedItems,
      selectedIndex: selectedIndex
    };
  },

  setChangeFeedback_(opt, setStateCallback) {
    let result = this.getChangeFeedback(opt);

    this.setState({
      feedback: result.feedback,
      message: result.message,
      value: result.value,
      foundAutocompleteItems: result.foundAutocompleteItems,
      selectedIndex: result.selectedIndex
    }, setStateCallback);

    return this;
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _checkRequired(opt) {
    let result = true;
    if (this.props.required && !opt.value) {
      result = false;
      this.setError(this.props.requiredMessage || this.getLsiComponent('requiredMessage'), opt.value);
    }

    return result;
  },

  _find(items, foundValue) {
    let values = { first: [], last: [] };
    let foundValueLower = foundValue.toLowerCase();
    items.forEach(function (item) {
      let itemValueLower = item.value.toLowerCase();
      if (foundValue !== '') {
        if (itemValueLower.substring(0, foundValueLower.length) === foundValueLower) {
          values.first.push(item);
        } else if (itemValueLower.indexOf(foundValueLower) > -1) {
          values.last.push(item);
        }
      }
    });
    let allValues = values.first.concat(values.last);

    return allValues.length ? allValues : null;
  },

  _getBackdropProps() {
    var backdropId = this.getId() + "-backdrop";

    return {
      hidden: !this.state.foundAutocompleteItems,
      id: backdropId,
      onClick: () => this.setState({ foundAutocompleteItems: null, selectedIndex: null })
    };
  },

  _getItemListProps() {
    let props = {
      parent: this
    };

    props.hidden = !this.state.foundAutocompleteItems;
    props.ref = itemList => this._itemList = itemList;
    props.onChange = opt => {
      let value = '';
      if (opt.value !== null) {
        value = this.state.foundAutocompleteItems[opt.value].value;
      }

      // TODO: how to do custom onChange, but items should be hidden because of this path is after choosing some item
      // if (typeof this.props.onChange === 'function') {
      //   opt.component = this;
      //   opt.value = value;
      //   this.setState({ foundAutocompleteItems: null, selectedIndex: null }, () => this.props.onChange(opt));
      // } else {
      this.setState({ value: value, foundAutocompleteItems: null, selectedIndex: null }, () => {
        if (typeof this.props.onBlur === 'function') {
          this.props.onBlur({ value: value, component: this });
        }
      });
      // this.close(() => this.setValue(result));
      // }
    };

    props.value = this.state.value;

    return props;
  },

  _getChildren() {
    return this.state.foundAutocompleteItems && this.state.foundAutocompleteItems.map((item, i) => {
      let className = this.getClassName().item;
      this.state.selectedIndex === i && (className += ' ' + this.getClassName().selected);
      return <Option className={className} key={i} value={item.content || item.value} content={item.content || item.value} mainAttrs={{ id: this.getId() + '-item-' + i }} />;
    });
  }
};

export default TextInputMixin;