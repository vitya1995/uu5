import React from 'react';
import PropTypes from 'prop-types';
import ns from "../forms-ns.js";
import * as UU5 from "uu5g04";

import './input-mixin.less';
import '../col.less';

import Label from './../internal/label.js';
import InputWrapper from './../internal/input-wrapper.js';

const INITIAL_FEEDBACK = 'initial';
const SUCCESS_FEEDBACK = 'success';
const WARNING_FEEDBACK = 'warning';
const ERROR_FEEDBACK = 'error';
const LOADING_FEEDBACK = 'loading';

export const InputMixin = {

  //@@viewOn:mixins
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    "UU5.Forms.InputMixin": {
      classNames: {
        main: ns.css("input"),
        formItem: ns.css("input-form-item"),
        input: ns.css("input-"),
        readOnly: ns.css("input-read-only"),
        hasIcon: ns.css("input-icon")
      },
      defaults: {
        columnRegexp: /^([a-z]+)(?:-)?(\d+)$/
      }
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    label: PropTypes.any,
    message: PropTypes.any,

    feedback: PropTypes.oneOf([INITIAL_FEEDBACK, SUCCESS_FEEDBACK, WARNING_FEEDBACK, ERROR_FEEDBACK, LOADING_FEEDBACK]),

    readOnly: PropTypes.bool,

    size: PropTypes.oneOf(['s', 'm', 'l', 'xl']),

    onChange: PropTypes.func,
    onValidate: PropTypes.func,
    onChangeFeedback: PropTypes.func,

    labelColWidth: PropTypes.oneOfType([PropTypes.shape({
      xs: PropTypes.number,
      s: PropTypes.number,
      m: PropTypes.number,
      l: PropTypes.number,
      xl: PropTypes.number
    }), PropTypes.string]),
    inputColWidth: PropTypes.oneOfType([PropTypes.shape({
      xs: PropTypes.number,
      s: PropTypes.number,
      m: PropTypes.number,
      l: PropTypes.number,
      xl: PropTypes.number
    }), PropTypes.string]),

    inputAttrs: PropTypes.object
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function () {
    return {
      label: null,
      message: null,
      feedback: INITIAL_FEEDBACK,
      readOnly: false,
      size: 'm',
      onChange: null,
      onValidate: null,
      labelColWidth: 'xs12 s5',
      inputColWidth: 'xs12 s7',
      inputAttrs: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState: function () {
    return {
      message: this.props.message,
      feedback: this.props.feedback,
      value: this.props.value,
      readOnly: this.props.readOnly
    };
  },

  componentDidMount: function () {
    var parentForm = this._getForm();
    parentForm && parentForm.registerFormInput(this.getId(), this);
  },

  componentWillReceiveProps: function (nextProps) {
    if (nextProps.id && nextProps.id !== this.props.id) {
      var parentForm = this._getForm();
      if (parentForm) {
        parentForm.unregisterFormInput(this.props.id);
        parentForm.registerFormInput(nextProps.id, this);
      }
    }
    if (nextProps.controlled) {
      //TODO: jine komponenty jak text zkontrolovat willRecievePros (byude se modifikovat jen value), vsude musi byt nextProps.controled
      this.setFeedback(nextProps.feedback, nextProps.message, nextProps.value, () => this.setState({ readOnly: nextProps.readOnly }));
    }
  },

  componentWillUnmount: function () {
    var parentForm = this._getForm();
    parentForm && parentForm.unregisterFormInput(this.getId());
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  isInput() {
    return true;
  },

  getValue() {
    let value;
    if (typeof this.getValue_ === 'function') {
      value = this.getValue_();
    } else {
      value = this.state.value;
    }
    return value;
  },

  setValue(value, setStateCallback) {
    if (typeof this.setValue_ === 'function') {
      this.setValue_(value, setStateCallback);
    } else {
      this.setState({ value: value === undefined ? null : value }, setStateCallback);
    }
    return this;
  },

  getMessage() {
    let message;
    if (typeof this.getMessage_ === 'function') {
      message = this.getMessage_();
    } else {
      message = this.state.message;
    }
    return message;
  },

  setMessage(message, setStateCallback) {
    if (typeof this.setMessage_ === 'function') {
      this.setMessage_(message, setStateCallback);
    } else {
      this.setState({ message: message }, setStateCallback);
    }
    return this;
  },

  getFeedback() {
    let feedback;
    if (typeof this.getFeedback_ === 'function') {
      feedback = this.getFeedback_();
    } else {
      feedback = this.state.feedback;
    }
    return feedback;
  },

  setFeedback(feedback, message, value, setStateCallback) {
    if (typeof this.setFeedback_ === 'function') {
      this.setFeedback_(feedback, message, value, setStateCallback);
    } else {
      this.setState({
        feedback: feedback,
        message: message,
        value: value !== null || value !== undefined ? value : ''
      }, setStateCallback);
    }
    return this;
  },

  setInitial(message, value, setStateCallback) {
    if (typeof this.setInitial_ === 'function') {
      this.setInitial_(message, value, setStateCallback);
    } else {
      this._setFeedback(INITIAL_FEEDBACK, message, value, setStateCallback);
    }
    return this;
  },

  isInitial() {
    return this.getFeedback() === INITIAL_FEEDBACK;
  },

  setLoading(message, value, setStateCallback) {
    if (typeof this.setLoading_ === 'function') {
      this.setLoading_(message, value, setStateCallback);
    } else {
      this._setFeedback(LOADING_FEEDBACK, message, value, setStateCallback);
    }
    return this;
  },

  isLoading() {
    return this.getFeedback() === LOADING_FEEDBACK;
  },

  setSuccess(message, value, setStateCallback) {
    if (typeof this.setSuccess_ === 'function') {
      this.setSuccess_(message, value, setStateCallback);
    } else {
      this._setFeedback(SUCCESS_FEEDBACK, message, value, setStateCallback);
    }
    return this;
  },

  isSuccess() {
    return this.getFeedback() === SUCCESS_FEEDBACK;
  },

  setWarning(message, value, setStateCallback) {
    if (typeof this.setWarning_ === 'function') {
      this.setWarning_(message, value, setStateCallback);
    } else {
      this._setFeedback(WARNING_FEEDBACK, message, value, setStateCallback);
    }
    return this;
  },

  isWarning() {
    return this.getFeedback() === WARNING_FEEDBACK;
  },

  setError(message, value, setStateCallback) {
    if (typeof this.setError_ === 'function') {
      this.setError_(message, value, setStateCallback);
    } else {
      this._setFeedback(ERROR_FEEDBACK, message, value, setStateCallback);
    }
    return this;
  },

  isError() {
    return this.getFeedback() === ERROR_FEEDBACK;
  },

  reset(setStateCallback) {
    if (typeof this.reset_ === 'function') {
      this.reset_(setStateCallback);
    } else {
      this.setState({
        message: this.props.message,
        feedback: this.props.feedback,
        value: this.props.value,
        readOnly: this.props.readOnly
      }, setStateCallback);
    }
    return this;
  },

  //TODO getResetValues

  getChangeFeedback(opt) {
    let result;

    if (typeof this.getChangeFeedback_ === 'function') {
      result = this.getChangeFeedback_(opt);
    } else {
      result = {
        feedback: INITIAL_FEEDBACK,
        message: null,
        value: opt.value
      };
    }

    return result;
  },

  setChangeFeedback(opt, setStateCallback) {
    let result;

    if (typeof this.setChangeFeedback_ === 'function') {
      result = this.setChangeFeedback_(opt, setStateCallback);
    } else {
      result = this.getChangeFeedback(opt);

      this.setState({
        feedback: result.feedback,
        message: result.message,
        value: result.value
      }, setStateCallback);
    }

    return this;
  },

  isReadOnly() {
    return this.state.readOnly;
  },

  setEditableValue(value, setStateCallback) {
    if (typeof this.setEditableValue_ === 'function') {
      this.setEditableValue_(value, setStateCallback);
    } else {
      this.setState({ readOnly: !value }, setStateCallback);
    }
    return this;
  },

  readOnly(setStateCallback) {
    if (typeof this.readOnly_ === 'function') {
      this.readOnly_(setStateCallback);
    } else {
      this.setEditableValue(false, setStateCallback);
    }
    return this;
  },

  editable(setStateCallback) {
    if (typeof this.editable_ === 'function') {
      this.editable_(setStateCallback);
    } else {
      this.setEditableValue(true, setStateCallback);
    }
    return this;
  },

  getLabel(inputId) {
    let result = null;
    if (this.props.label !== null) {
      result = <Label {...this._getLabelProps(inputId)} />;
    }
    return result;
  },

  getInputWrapper(children, buttons) {
    return <InputWrapper {...this._getInputWrapperProps(children, buttons)} />;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getForm: function () {
    var form = null;
    var parent = this.getParent && this.getParent();
    while (parent) {
      if (typeof parent.isInput === 'function' && parent.isInput()) {
        break;
      } else if (typeof parent.isForm === 'function' && parent.isForm()) {
        form = parent;
        break;
      } else {
        parent = parent.getParent && parent.getParent();
      }
    }
    return form;
  },

  _setFeedback: function (feedback, message, value, setStateCallback) {
    if (typeof this.props.onChangeFeedback === 'function') {
      this.props.onChangeFeedback({
        feedback: feedback,
        message: message,
        value: value || '',
        callback: setStateCallback,
        component: this
      });
    } else {
      this.setFeedback(feedback, message, value, setStateCallback);
    }
    return this;
  },

  _getInputAttrs() {
    let mainAttrs = this.getMainAttrs();

    mainAttrs.className += ' ' + this.getClassName('main', "UU5.Forms.InputMixin");
    mainAttrs.className += ' ' + this.getClassName('input', "UU5.Forms.InputMixin") + this.props.size;
    mainAttrs.className += ' ' + this.getClassName('input', "UU5.Forms.InputMixin") + this.state.feedback;
    if (this.isReadOnly()) {
      mainAttrs.className += ' ' + this.getClassName('readOnly', "UU5.Forms.InputMixin");
    }

    if (this.state.feedback != INITIAL_FEEDBACK || this.props.required) {
      mainAttrs.className += ' ' + this.getClassName('hasIcon', "UU5.Forms.InputMixin");
    }

    return mainAttrs;
  },

  _getLabelProps(inputId) {
    let className;
    if (this.props.labelPosition === 'right') {
      className = ns.css("input-label-right");
    }
    return {
      required: this.props.required,
      for: inputId,
      content: this.props.label,
      colWidth: UU5.Common.Tools.buildColWidthClassName(this.props.labelColWidth),
      className: className
    };
  },

  _getInputWrapperProps(children, buttons) {

    let colWidth = UU5.Common.Tools.buildColWidthClassName(this.props.label !== null ? this.props.inputColWidth : 'xs12');
    let feedback = this.getFeedback();
    let message = this.getMessage();
    // if(this.props.labelPosition  && this.props.labelPosition !== 'left') {
    //   colWidth = UU5.Common.Tools.buildColWidthClassName('xs-12');
    //   //feedback = null;
    //   //message = null;
    // }

    return {
      colWidth: colWidth,
      feedback: feedback,
      message: message,
      required: this.props.required,
      buttons: buttons,
      children: children,
      slider: this.getTagName() === 'UU5.Forms.Slider',
      datetimepicker: this.getTagName() === 'UU5.Forms.Datetimepicker'
    };
  }
};

InputMixin.INITIAL_FEEDBACK = INITIAL_FEEDBACK;
InputMixin.SUCCESS_FEEDBACK = SUCCESS_FEEDBACK;
InputMixin.WARNING_FEEDBACK = WARNING_FEEDBACK;
InputMixin.ERROR_FEEDBACK = ERROR_FEEDBACK;
InputMixin.LOADING_FEEDBACK = LOADING_FEEDBACK;

export default InputMixin;