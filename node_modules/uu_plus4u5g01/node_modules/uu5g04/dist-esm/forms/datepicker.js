import React from 'react';
import createReactClass from '../create-react-class.js';
import PropTypes from 'prop-types';
import * as UU5 from "uu5g04";
import ns from "./forms-ns.js";
import TextInput from './internal/text-input.js';
import Calendar from './calendar.js';
import TextInputMixin from './mixins/text-input-mixin.js';

import './datepicker.less';

export const Datepicker = createReactClass({

  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.PureRenderMixin, UU5.Common.ElementaryMixin, TextInputMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("Datepicker"),
    classNames: {
      main: ns.css("datepicker"),
      open: ns.css("datepicker-open"),
      menu: ns.css("input-menu")
    },
    defaults: {
      format: 'dd.mm.Y',
      regexpSpace: / /g
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
    dateFrom: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
    dateTo: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
    buttonHidden: PropTypes.bool,
    iconOpen: PropTypes.string,
    iconClosed: PropTypes.string,
    format: PropTypes.string,
    country: PropTypes.string,
    nanMessage: PropTypes.any,
    beforeRangeMessage: PropTypes.any,
    afterRangeMessage: PropTypes.any,
    parseDate: PropTypes.func,
    disableBackdrop: PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      value: null,
      dateFrom: null,
      dateTo: null,
      buttonHidden: false,
      iconOpen: 'mdi-calendar',
      iconClosed: 'mdi-calendar',
      format: null,
      country: null,
      nanMessage: 'Please insert a valid date.',
      beforeRangeMessage: 'Date is out of range.',
      afterRangeMessage: 'Date is out of range.',
      parseDate: null,
      icon: 'mdi-calendar',
      disableBackdrop: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      open: false,
      format: this.props.format,
      country: this.props.country
    };
  },

  componentWillMount() {
    let value = this._prepareStringDate(this.state.value);

    if (this.props.onValidate && typeof this.props.onValidate === 'function') {
      let result = this._isValidDateResult({ value: value });
      if (result) {
        if (typeof result === 'object') {
          if (result.feedback) {
            this.setFeedback(result.feedback, result.message, result.value);
          } else {
            this._validateOnChange({ value: value, event: null, component: this });
          }
        }
      }
    } else {
      this.setFeedback(this.props.feedback, this.props.message, value);
    }
    return this;
  },

  componentDidMount() {
    UU5.Environment.EventListener.registerDateTime(this.getId(), this._change);
  },

  componentWillReceiveProps(nextProps) {
    if (this.props.controlled) {
      let value = this._prepareStringDate(nextProps.value);
      let result = this._isValidDateResult({ value: value });
      if (result) {
        if (typeof result === 'object') {
          if (result.feedback) {
            this.setFeedback(result.feedback, result.message, result.value);
          } else {
            this.setFeedback(nextProps.feedback, nextProps.message, value);
          }
        }
      }
    }
    return this;
  },

  componentWillUnmount() {
    this._removeEvent();
    UU5.Environment.EventListener.unregisterDateTime(this.getId(), this._change);
  },

  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  close(setStateCallback, e) {
    this._removeEvent();
    let opt = { value: this._formatDate(this.getValue()), event: e, component: this };
    setStateCallback = typeof setStateCallback === 'function' ? setStateCallback : () => this._onBlurCalendar(opt);
    this.setState({ open: false }, setStateCallback);
    return this;
  },

  toggle(setStateCallback, e) {
    let opt = { value: this._formatDate(this.getValue()), event: e, component: this };
    setStateCallback = setStateCallback || this.isOpen() ? () => this._onFocusCalendar(opt) : () => this._onBlurCalendar(opt);
    //this.setState((state) => ({open: !state.open}), setStateCallback);
    this.setState(function (state) {
      state.open ? this._removeEvent() : this._addEvent();
      return { open: !state.open };
    }, setStateCallback);
    return this;
  },

  parseDate(stringDate) {
    var config = {
      "^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$": '$3-$2-$1',
      "^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$": '$3-$1-$2',
      "^(\\d{4})-(\\d{1,2})-(\\d{1,2})$": '$1-$2-$3',
      "^(\\d{1,2})-(\\d{1,2})-(\\d{4})$": '$3-$2-$1'
    };

    var date = null;
    if (stringDate) {
      stringDate = stringDate.replace(this.getDefault().regexpSpace, '');

      for (var pattern in config) {
        var regExp = new RegExp(pattern);
        if (regExp.test(stringDate)) {
          var replacedDate = stringDate.replace(regExp, config[pattern]);
          var splitter = replacedDate.split('-');
          //splitter[1] = UU5.Common.Tools.rjust(splitter[1], 2, '0');
          //splitter[2] = UU5.Common.Tools.rjust(splitter[2], 2, '0');
          //replacedDate = splitter.join('-');
          splitter[0] = Number(splitter[0]);
          splitter[1] = Number(splitter[1]) - 1;
          splitter[2] = Number(splitter[2]);

          date = new Date(splitter[0], splitter[1], splitter[2]);
          break;
        }
      }
    }
    return date;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  // TODO: tohle je ještě otázka - je potřeba nastavit hodnotu z jiné komponenty (musí být validace) a z onChange (neměla by být validace)
  setValue_(value, setStateCallback) {
    value = this._prepareStringDate(value);
    if (this._checkRequired({ value: value })) {
      if (typeof this.props.onValidate === 'function') {
        this._validateOnChange({ value: value, event: null, component: this });
      } else {
        this.setInitial(null, value, setStateCallback);
      }
    }

    return this;
  },

  getValue_() {
    let date;

    if (this.state.value instanceof Date) {
      date = this.state.value;
    } else {
      date = this._parseDate(this.state.value);
    }

    return date;
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _findTarget(item) {
    let result = false;
    let id = this.getId();

    if (item.id === id) {
      result = true;
    } else if (item.parentElement) {
      result = this._findTarget(item.parentElement);
    }
    return result;
  },

  _addEvent() {
    !this.props.disableBackdrop && UU5.Environment.EventListener.addWindowEvent('click', this.getId(), e => {
      let isDatepicker = this._findTarget(e.target);

      if (!this._stopPropagation && !isDatepicker && this.isOpen()) {
        this.close();
      } else {
        this._stopPropagation = false;
      }
    });
    return this;
  },

  _removeEvent() {
    !this.props.disableBackdrop && UU5.Environment.EventListener.removeWindowEvent('click', this.getId());
    return this;
  },

  _change(opt) {
    if (typeof this.props.onChange === 'function') {
      this.props.onChange(opt);
    } else {
      this._setOptions(opt);
    }
    return this;
  },

  _setOptions(opt, setStateCallback) {
    this.setState({
      format: opt.format === undefined ? this.state.format : opt.format,
      country: opt.country === undefined ? this.state.country : opt.country ? opt.country.toLowerCase() : opt.country
    }, setStateCallback);
    return this;
  },

  _onChange(e) {
    let opt = { value: e.target.value, event: e, component: this };
    let date = this._parseDate(opt.value);
    let formatedDate = date ? this._formatDate(date) : null;

    if (!opt.value || formatedDate) {
      opt.value = formatedDate;
      if (!this.isDisabled() && !this.isReadOnly()) {
        if (typeof this.props.onChange === 'function') {
          this.props.onChange(opt);
        } else {
          if (this.props.validateOnChange) {
            this._validateOnChange(opt);
          } else {
            if (opt.value) {
              if (this._checkRequired({ value: opt.value })) {
                opt.required = this.props.required;
                let result = this.getChangeFeedback(opt);
                this.setFeedback(result.feedback, result.message, result.value);
              }
            } else {
              this.setState({ value: opt.value });
            }
          }
        }
      }
    } else {
      this.setState({ value: opt.value });
    }
    return this;
  },

  _onFocus(e) {
    let opt = { value: e.target.value, event: e, component: this };

    this._onFocusCalendar(opt);

    return this;
  },

  _onFocusCalendar(opt) {
    if (typeof this.props.onFocus === 'function') {
      this.props.onFocus(opt);
    } else {
      let result = this.getFocusFeedback(opt);
      result && this.setFeedback(result.feedback, result.message, result.value);
    }

    return this;
  },

  _onBlur(e) {
    let opt = { value: e.target.value, event: e, component: this };
    this._onBlurCalendar(opt);
    return this;
  },

  _onBlurCalendar(opt) {
    if (!this.isOpen()) {
      if (typeof this.props.onBlur === 'function') {
        this.props.onBlur(opt);
      } else {
        if (this._checkRequired({ value: opt.value }) && !this.props.validateOnChange) {
          opt.required = this.props.required;
          let blurResult = this.getBlurFeedback(opt);
          let result = this._isValidDateResult(blurResult);
          this.setFeedback(result.feedback, result.message, result.value);
        }
      }
    }
    return this;
  },

  _isValidDateResult(opt) {
    return this._validateDateRangeResult(this._validateDateResult(opt));
  },

  _validateDateResult(opt) {
    let result = opt;
    let date = this._parseDate(opt.value);
    if (!date && opt.value) {
      result.feedback = 'error';
      result.message = this.props.nanMessage;
    }
    return result;
  },

  _getDate(date) {
    if (typeof date === 'string') {
      date = this._parseDate(date);
    }
    return date;
  },

  _validateDateRangeResult(opt) {
    let result = opt;

    let date = this._parseDate(opt.value);
    if (date) {
      let dateFrom = this._getDateFrom();
      let dateTo = this._getDateTo();
      if (dateFrom && date < dateFrom) {
        result.feedback = 'error';
        result.message = this.props.beforeRangeMessage;
      } else if (dateTo && date > dateTo) {
        result.feedback = 'error';
        result.message = this.props.afterRangeMessage;
      }
    }

    return result;
  },

  _validateOnChange(opt) {
    let result = typeof this.props.onValidate === 'function' ? this.props.onValidate(opt) : null;
    if (result) {
      if (typeof result === 'object') {
        if (result.feedback) {
          this.setFeedback(result.feedback, result.message, result.value);
        } else {
          this.setState({ value: opt.value });
        }
      } else {
        this.showError('validateError', null, { context: { event: e, func: this.props.onValidate, result: result } });
      }
    } else if (this.props.required && this.state.value) {
      this.setSuccess(null, this.state.value);
    }
    return this;
  },

  _getFeedbackIcon() {
    return this.isOpen() ? this.props.iconOpen : this.props.iconClosed;
  },

  _onCalendarChange(opt) {
    let date = this._formatDate(opt.value);
    opt.value = date;
    opt.component = this;
    if (typeof this.props.onChange === 'function') {
      this.setState({ open: false }, this.props.onChange(opt));
    } else {
      this.setValue(date, () => this.close());
    }
    return this;
  },

  _getDateFrom() {
    let dateFrom;
    if (this.props.dateFrom) {
      if (typeof this.props.dateFrom === 'string') {
        dateFrom = this._parseDate(this.props.dateFrom);
      } else if (this.props.dateFrom instanceof Date) {
        dateFrom = this.props.dateFrom;
      }
    }
    return dateFrom;
  },

  _getDateTo() {
    let dateTo;
    if (this.props.dateTo) {
      if (typeof this.props.dateTo === 'string') {
        dateTo = this._parseDate(this.props.dateTo);
      } else if (this.props.dateTo instanceof Date) {
        dateTo = this.props.dateTo;
      }
    }
    return dateTo;
  },

  _getCalendarProps() {
    let date = typeof this.getValue() === 'string' ? this._parseDate(this.getValue()) : this.getValue();

    return {
      className: this.getClassName().menu,
      date: date,
      dateFrom: this._getDateFrom(),
      dateTo: this._getDateTo(),
      ref_: this._refCalendar,
      hidden: !this.isOpen(),
      onChange: this._onCalendarChange
    };
  },

  _prepareStringDate(date) {
    let result = date;
    if (date instanceof Date) {
      result = this._formatDate(date);
    }
    return result;
  },

  _formatDate(date) {
    let result = null;

    if (date) {
      if (this.state.format) {
        result = UU5.Common.Tools.formatDate(date, this.state.format);
      } else if (this.state.country) {
        result = this._formatDateByCountry(date, this.state.country);
      } else {
        result = UU5.Common.Tools.toLocaleDateString(date, UU5.Common.Tools.getLanguage());
      }
    }
    return result;
  },

  _formatDateByCountry(date, country) {
    let result;
    if (UU5.Environment.dateTimeFormat[country]) {
      result = UU5.Common.Tools.formatDate(date, UU5.Environment.dateTimeFormat[country]);
    } else {
      result = UU5.Common.Tools.toLocaleDateString(date, country);
    }
    return result;
  },

  _isDateReversed() {
    const dateFormat = this.state.country || UU5.Common.Tools.getLanguage();
    return dateFormat.toLowerCase() === 'en' || dateFormat.toLowerCase() === 'en-us';
  },

  _parseDate(stringDate) {
    let date = null;
    if (this.props.parseDate && typeof this.props.parseDate === 'function') {
      date = this.props.parseDate(stringDate);
    } else {
      const config = {
        "^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$": '$3-$2-$1',
        "^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$": this._isDateReversed() ? '$3-$1-$2' : '$3-$2-$1',
        "^(\\d{4})-(\\d{1,2})-(\\d{1,2})$": '$1-$2-$3',
        "^(\\d{1,2})-(\\d{1,2})-(\\d{4})$": '$3-$2-$1'
      };

      stringDate = stringDate && stringDate.replace(this.getDefault().regexpSpace, '');

      for (const pattern in config) {
        const regExp = new RegExp(pattern);
        if (regExp.test(stringDate)) {
          let replacedDate = stringDate.replace(regExp, config[pattern]);

          // because of safari and IE must be date in format YYYY-MM-DD (not YYYY-M-D)
          let parser = replacedDate.split('-');
          replacedDate = [parser[0], UU5.Common.Tools.rjust(parser[1], 2, '0'), UU5.Common.Tools.rjust(parser[2], 2, '0')].join('-');

          date = Date.parse(replacedDate) ? new Date(replacedDate) : null;
          date && date.setHours(0, 0, 0, 0);
          break;
        }
      }
    }
    return date;
  },

  _getTextInputAttrs() {
    var props = {};

    if (!this.isReadOnly() && !this.isDisabled()) {
      props.onClick = () => {
        this.open();
      };
    }

    return props;
  },

  _getMainAttrs() {
    let attrs = this._getInputAttrs();
    attrs.id = this.getId();

    if (this.isOpen()) {
      attrs.className += ' ' + this.getClassName().open;
    }

    return attrs;
  },

  _getPlacehoder() {
    let format = this.state.format || UU5.Environment.dateTimeFormat[this.state.country];
    let placeholder = format;
    if (this.props.placeholder && format) {
      placeholder = this.props.placeholder + ' - ' + format;
    } else if (this.props.placeholder) {
      placeholder = this.props.placeholder;
    }
    return placeholder;
  },

  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    let inputId = this.getId() + '-input';
    /*let buttons = !this.isReadOnly() && !this.props.buttonHidden ? [{
        icon: this.isOpen() ? this.props.iconOpen : this.props.iconClosed,
        disabled: this.isDisabled(),
        onClick: this.toggle,
        pressed: this.isOpen(),
        colorSchema: 'default'
      }] : null;*/

    let date = this._parseDate(this.state.value);

    let formatedDate = date ? this._formatDate(date) : this.state.value;
    return <div {...this._getMainAttrs()}>
        {this.getLabel(inputId)}
        {this.getInputWrapper([<TextInput id={inputId} name={this.props.name || inputId} value={formatedDate || ''} placeholder={this._getPlacehoder()} type="text" onChange={this._onChange} onBlur={this._onBlur} onFocus={this._onFocus} onKeyDown={this.onKeyDown} mainAttrs={this._getTextInputAttrs() || this.props.inputAttrs} disabled={this.isDisabled() || this.isLoading()} readonly={this.isReadOnly()} icon={this._getFeedbackIcon()} iconClickable={false} loading={this.isLoading()} ref_={item => this._textInput = item} feedback={this.getFeedback()} />, <Calendar {...this._getCalendarProps()} />])}

      </div>;
  }
  //@@viewOn:render
});

export default Datepicker;