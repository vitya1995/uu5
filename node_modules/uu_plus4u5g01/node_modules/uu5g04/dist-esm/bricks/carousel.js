//@@viewOn:import
import React from "react";
import createReactClass from 'create-react-class';
import PropTypes from "prop-types";
import * as UU5 from "uu5g04";
import ns from "./bricks-ns.js";

import "./carousel.less";
import CarouselItem from './carousel-item.js';
import Icon from './icon.js';
//@@viewOff:import

export const Carousel = createReactClass({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.ContentMixin, UU5.Common.ColorSchemaMixin, UU5.Common.SwipeMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("Carousel"),
    classNames: {
      main: ns.css("carousel"),
      controls: ns.css("carousel-controls"),
      indicators: ns.css("carousel-indicators"),
      active: ns.css("carousel-indicators-active"),
      leftArrow: ns.css("carousel-left"),
      rightArrow: ns.css("carousel-right"),
      lastArrow: ns.css("carousel-last")
    },
    defaults: {
      minAngle: 22.5,
      childTagName: 'UU5.Bricks.Carousel.Item',
      colorSchema: 'default'
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    hideControls: PropTypes.bool,
    hideIndicators: PropTypes.bool,
    activeIndex: PropTypes.number,
    nextIcon: PropTypes.string,
    prevIcon: PropTypes.string,
    displayedItems: PropTypes.number,
    type: PropTypes.oneOf(['circular', 'final', 'rewind']),
    interval: PropTypes.number,
    stepByOne: PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      hideControls: false,
      hideIndicators: false,
      activeIndex: 0,
      nextIcon: 'mdi-chevron-right',
      prevIcon: 'mdi-chevron-left',
      displayedItems: 1,
      type: 'final',
      interval: 5000,
      stepByOne: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      activeIndex: this.props.activeIndex,
      rowHeight: 0,
      renderedChildren: []
    };
  },

  componentWillMount() {
    const children = this.getChildren();
    this.setState({
      children: children,
      tmpChildren: children
    });
  },

  componentDidMount() {
    this._prepareChildren();
    if (this.props.interval > 0) {
      this._autoChange = true;
      this._startAutoSlide();
    }
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.interval > 0 && !this._autoChange) {
      this._autoChange = true;
      this._startAutoSlide();
    }
  },

  componentDidUpdate(prevProps, prevState) {
    if (!this.props.children) return;

    if (this.props !== prevProps) {
      this._resetShifts();
      this._newProps = true;

      if (this.props.controlled) {
        const children = this.getChildren();
        this.setState({
          activeIndex: this.props.activeIndex,
          children: children,
          tmpChildren: children,
          renderedChildren: []
        }, () => this._prepareChildren());
      } else {
        this._prepareChildren();
      }
    } else {
      const indexHasChanged = this.state.activeIndex !== prevState.activeIndex;
      if (this._newProps) {
        this._newProps = false;
      } else if (indexHasChanged) {
        this._swipeRenderedChild();
      } else if (this.state.hadSwiped) {
        this._removeRenderedChild();
      }
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  setActiveIndex(activeIndex, setStateCallback) {
    this._addRenderedChild(activeIndex, setStateCallback);
    return this;
  },

  getActiveIndex() {
    return this.state.activeIndex;
  },

  setNext(setStateCallback) {
    if (this.props.type === 'final' && this.getActiveIndex() >= this._getSlidesLength() - 1) return this;

    let nextIndex = this._getSlidesLength() - 1 < this.getActiveIndex() + 1 ? 0 : this.getActiveIndex() + 1;
    this._addRenderedChild(nextIndex, setStateCallback);

    return this;
  },

  setPrevious(setStateCallback) {
    if (this.props.type === 'final' && this.getActiveIndex() <= 0) return this;

    let previousIndex = this.getActiveIndex() === 0 ? this._getSlidesLength() - 1 : this.getActiveIndex() - 1;
    this._addRenderedChild(previousIndex, setStateCallback);

    return this;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  shouldChildRender_(child) {
    return this.getDefault().childTagName === UU5.Common.Tools.getChildTagName(child);
  },

  expandChildProps_(child) {
    const newChildProps = UU5.Common.Tools.mergeDeep({}, child.props);
    newChildProps.style = newChildProps.style || {};
    newChildProps.style.width = 100 / this.props.displayedItems + '%';
    return newChildProps;
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getMaxHeight() {
    let maxHeight = 0;
    this.eachRenderedChild(child => {
      if (child) {
        let height = UU5.Common.Tools.getOuterHeight(child, true);
        maxHeight = height > maxHeight ? height : maxHeight;
      }
    });
    return maxHeight;
  },

  _prepareChildren() {
    const steps = this.props.stepByOne ? 1 : this.props.displayedItems;
    const properties = {
      index: this.props.activeIndex * steps,
      position: 0,
      height: this._getMaxHeight(),
      noOfElements: this.props.displayedItems
    };

    this.setState({
      activeIndex: this.props.activeIndex,
      tmpChildren: [],
      renderedChildren: this._getContent(properties),
      rowHeight: properties.height
    });
  },

  _pauseAutoSlide() {
    UU5.Environment.TimeManager.clearInterval(this._interval);
  },

  _startAutoSlide() {
    this._interval = UU5.Environment.TimeManager.setInterval(() => this.setNext(), this.props.interval);
  },

  _clickHandler(func) {
    let lastSlide = new Date();
    if (!this.lastSlide || lastSlide - this.lastSlide > 750) {
      func && func();
      this.lastSlide = lastSlide;
    }
    return this;
  },

  _addRenderedChild(nextIndex, setStateCallback) {
    const newRenderedChildren = this.state.renderedChildren.slice();
    const prevIndex = this.state.activeIndex;
    let isDirectionRight = nextIndex - prevIndex >= 0;
    const steps = this.props.stepByOne ? 1 : this.props.displayedItems;
    const no = Math.abs(nextIndex - prevIndex) * steps;

    if (this.props.type === 'circular' && nextIndex === 0 && prevIndex === this._getSlidesLength() - 1) {
      newRenderedChildren.push(...this._getContent({
        index: this.props.stepByOne ? this.props.displayedItems - 1 : 0,
        position: this.props.displayedItems,
        noOfElements: steps,
        newShift: 1
      }));

      isDirectionRight = true;
    } else if (this.props.type === 'circular' && prevIndex === 0 && nextIndex === this._getSlidesLength() - 1) {
      newRenderedChildren.unshift(...this._getContent({
        index: nextIndex * steps,
        position: -1 * steps,
        noOfElements: steps,
        newShift: -1
      }));

      isDirectionRight = false;
    } else {
      if (isDirectionRight) {
        newRenderedChildren.push(...this._getContent({
          index: (prevIndex + 1) * steps + (this.props.displayedItems - steps),
          position: this.props.displayedItems,
          noOfElements: no
        }));
      } else {
        newRenderedChildren.unshift(...this._getContent({
          index: nextIndex * steps,
          position: -1 * no,
          noOfElements: no
        }));
      }
    }

    this.setState({
      activeIndex: nextIndex,
      renderedChildren: newRenderedChildren,
      isDirectionRight: isDirectionRight,
      hadSwiped: false
    }, setStateCallback);
  },

  _swipeRenderedChild() {
    setTimeout(() => {
      let newRenderedChildren = this.state.renderedChildren.slice();
      const size = this.state.renderedChildren.length;

      newRenderedChildren = newRenderedChildren.map((item, i) => {
        const newPosition = this.state.isDirectionRight ? (i - (size - this.props.displayedItems)) * 100 : i * 100;
        const newProps = {
          style: UU5.Common.Tools.mergeDeep({}, item.props.style, this._getChildrenStyle(newPosition)),
          position: newPosition
        };
        return React.cloneElement(item, newProps);
      });

      this.setState({
        renderedChildren: newRenderedChildren,
        hadSwiped: true
      });
    }, 50);
  },

  _removeRenderedChild() {
    setTimeout(() => {
      let newRenderedChildren = this.state.renderedChildren.filter(item => {
        return item.props.position >= 0 && item.props.position < 100 * this.props.displayedItems;
      });
      this.setState({
        renderedChildren: newRenderedChildren,
        hadSwiped: false
      });
    }, 500);
  },

  _getSlidesLength() {
    const children = this.state.children ? this.state.children : this.getChildren();
    const length = children ? children.length : 0;

    return this.props.stepByOne && this.props.displayedItems > 1 ? this.props.type === 'circular' ? length : Math.ceil(length - (this.props.displayedItems - 1)) : Math.ceil(length / this.props.displayedItems);
  },

  _resetShifts() {
    this._shiftCirc = null;
    this._shiftFin = null;
  },

  _getContent(properties) {
    const displayedItems = this.props.displayedItems;
    const children = this.state.children;
    let noOfElements = properties.noOfElements;
    let startPosition = properties.position;
    this._shiftCirc = this._shiftCirc || 0;
    const rest = Math.ceil(children.length / displayedItems) * displayedItems - children.length;

    if (properties.newShift && !this.props.stepByOne) {
      this._shiftCirc += properties.newShift;
    }

    if (this._shiftFin) {
      if (properties.index === 0) {
        noOfElements -= this._shiftFin;
        startPosition += this._shiftFin;
        this._shiftFin = null;
      } else {
        properties.index -= this._shiftFin;
      }
    }

    const childrenToRender = [];
    for (let i = 0; i < noOfElements; ++i) {
      let index = properties.index + i;
      if (this.props.type === 'circular') {
        index += this._shiftCirc * rest;

        if (index >= children.length || index < 0) {
          index = (index + 10000 * children.length) % children.length;
        }
      }

      if (index < children.length) {
        const position = (startPosition + i) * 100;
        const newProps = UU5.Common.Tools.mergeDeep({}, children[index].props);
        newProps.position = position;
        newProps.key = this._getKey(children[index].key);
        newProps.style = UU5.Common.Tools.mergeDeep({}, newProps.style, this._getChildrenStyle(position, displayedItems, properties.height));
        childrenToRender.push(React.cloneElement(children[index], newProps));
      } else {
        if (this.props.type !== 'circular' && !this._shiftFin && !this.props.stepByOne) {
          this._shiftFin = noOfElements - i;
        }
      }
    }

    return childrenToRender;
  },

  _getKey(key) {
    this.state.renderedChildren && this.state.renderedChildren.forEach(item => {
      if (key === item.key) {
        key += '-copy';
      }
    });
    return key;
  },

  _getChildrenStyle(position, displayedItems, height) {
    displayedItems = displayedItems || this.props.displayedItems;
    !height && (height = this.state.rowHeight);

    return {
      width: 100 / displayedItems + '%',
      transform: `translateX(${position}%)`,
      height: height > 0 ? height + 'px' : null
    };
  },

  _customTouchEndHandler() {
    let absAngle = Math.abs(this.getAngle());
    let lastSlide = new Date();

    if (this.isSwipedRight() && absAngle <= this.getDefault().minAngle) {
      if (!this.lastSlide || lastSlide - this.lastSlide > 750) {
        this.setPrevious();
        this.lastSlide = lastSlide;
      }
    } else if (this.isSwipedLeft() && absAngle >= 180 - this.getDefault().minAngle) {
      if (!this.lastSlide || lastSlide - this.lastSlide > 750) {
        this.setNext();
        this.lastSlide = lastSlide;
      }
    }
    return this;
  },

  _buildMainAttrs() {
    let mainAttrs = this.buildMainAttrs();
    mainAttrs.id = this.getId();
    mainAttrs.className = this.getClassName('main');
    mainAttrs.style = mainAttrs.style || {};
    mainAttrs.style.height = this.state.rowHeight + 'px';
    mainAttrs.onTouchStart = this.swipeOnTouchStart;
    mainAttrs.onTouchMove = this.swipeOnTouchMove;
    mainAttrs.onTouchEnd = () => this.swipeOnTouchEnd(this._customTouchEndHandler);
    if (this.props.interval > 0) {
      mainAttrs.onMouseOver = this._pauseAutoSlide;
      mainAttrs.onMouseLeave = this._startAutoSlide;
    }
    return mainAttrs;
  },

  _buildIndicators() {
    let indicators = [];
    for (let i = 0; i < this._getSlidesLength(); i++) {
      let className = i === this.getActiveIndex() ? this.getClassName('active') : '';
      indicators.push(<li key={i} className={className} onClick={() => this._clickHandler(() => this.setActiveIndex(i))} />);
    }
    return indicators;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    const colorSchema = ' color-schema-' + this.getColorSchema();

    let classNameLeft = this.getClassName().leftArrow;
    if (this.props.type === 'final' && this.getActiveIndex() === 0) {
      classNameLeft += ' ' + this.getClassName().lastArrow;
    }

    let classNameRight = this.getClassName().rightArrow;
    if (this.props.type === 'final' && this.getActiveIndex() === this._getSlidesLength() - 1) {
      classNameRight += ' ' + this.getClassName().lastArrow;
    }

    return this.props.children ? <div {...this._buildMainAttrs()}>
          {this.state.renderedChildren}
          {this.state.tmpChildren}

          <div className={this.getClassName().controls + colorSchema}>
            {!this.props.hideControls && <a className={classNameLeft} role="button" onClick={() => this._clickHandler(this.setPrevious)}>
                <Icon icon={this.props.prevIcon} />
              </a>}
            {!this.props.hideIndicators && <ol className={this.getClassName().indicators}>
                {this._buildIndicators()}
              </ol>}
            {!this.props.hideControls && <a className={classNameRight} role="button" onClick={() => this._clickHandler(this.setNext)}>
                <Icon icon={this.props.nextIcon} />
              </a>}
          </div>
        </div> : null;
  }
  //@@viewOff:render
});

Carousel.Item = CarouselItem;
export default Carousel;