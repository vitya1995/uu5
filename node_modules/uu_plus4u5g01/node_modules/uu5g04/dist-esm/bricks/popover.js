import React from 'react';
import createReactClass from 'create-react-class';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import * as UU5 from "uu5g04";
import ns from "./bricks-ns.js";

import { Div } from './factory.js';
import './popover.less';

export const Popover = createReactClass({

  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.PureRenderMixin, UU5.Common.ElementaryMixin, UU5.Common.SectionMixin, UU5.Common.NestingLevelMixin, UU5.Common.CcrWriterMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("ContextMenu"),
    nestingLevelList: UU5.Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: ns.css("popover"),
      open: ns.css("popover-shown"),
      header: ns.css("popover-header"),
      body: ns.css("popover-body"),
      footer: ns.css("popover-footer"),
      top: ns.css("popover-menu-top"),
      bottom: ns.css("popover-menu-bottom"),
      left: ns.css("popover-menu-left"),
      right: ns.css("popover-menu-right")
    },
    defaults: {
      transitionDuration: 100
    },
    opt: {
      nestingLevelRoot: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    shown: PropTypes.bool,
    parentElement: PropTypes.object
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      shown: false,
      parentElement: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      header: null,
      content: null,
      footer: null,
      pageX: null,
      pageY: null,
      position: {
        top: false,
        left: false
      }
    };
  },

  componentWillMount() {
    this.setState({ hidden: !this.props.shown });
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this.setState({ hidden: !nextProps.shown });
    }
  },

  componentWillUnmount: function () {
    UU5.Environment.EventListener.removeWindowEvent('click', this.getId());
  },

  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  open(opt, setStateCallback) {
    this._addEvent();
    this._stopPropagation = true;
    let pageX = opt.pageX || 0;
    let pageY = opt.pageY || 0;
    let position = UU5.Common.Tools.mergeDeep({}, this.state.position);

    if (opt.event) {
      // opt.event.preventDefault();
      // opt.event.stopPropagation();

      pageX = pageX || opt.event.pageX;
      pageY = pageY || opt.event.pageY;
    }

    let parent;
    let parentElement = opt.parentElement === undefined ? this.props.parentElement : opt.parentElement;

    if (parentElement) {
      parent = ReactDOM.findDOMNode(parentElement);
    } else {
      let i = 0;
      do {
        i++;
        parent = UU5.Common.Tools.getElementByComputedStyle(document.getElementById(parent ? parent.id : this.getId()), 'position', ['relative', 'absolute', 'fixed']);
        // TODO not good!!!!
      } while (parent.id && (parent.className.split(" ").indexOf(this.getClassName("main")) > -1 || parent.className.split(" ").indexOf("uu5-bricks-context-menu-item") > -1) && i < 100);
    }
    if (parent) {
      let parentX = UU5.Common.Tools.getOffsetLeft(parent);
      let parentY = UU5.Common.Tools.getOffsetTop(parent);
      pageX = pageX - parentX;
      pageY = pageY - parentY;
    }

    this.setState({
      position: position,
      header: opt.header || this.getHeader(),
      content: opt.content ? this.buildChildren({ content: opt.content }) : this.getChildren(),
      footer: opt.footer || this.getFooter(),
      hidden: true,
      pageX: 0,
      pageY: 0
    }, () => {
      let parentHeight = parent ? UU5.Common.Tools.getInnerHeight(parent) : window.innerHeight;
      let parentWidth = parent ? UU5.Common.Tools.getInnerWidth(parent) : window.innerWidth;
      if (parentHeight < pageY + UU5.Common.Tools.getOuterHeight(this, true) && pageY >= UU5.Common.Tools.getOuterHeight(this, true)) {
        pageY = pageY - UU5.Common.Tools.getOuterHeight(this, true);
        position.top = true;
      } else {
        position.top = false;
      }

      if (parentWidth < pageX + UU5.Common.Tools.getOuterWidth(this, true) && pageX >= UU5.Common.Tools.getOuterWidth(this, true)) {
        pageX = pageX - UU5.Common.Tools.getOuterWidth(this, true);
        position.left = true;
      } else {
        position.left = false;
      }
      this.setState({
        hidden: false,
        pageX: pageX,
        pageY: pageY
      }, () => {
        typeof setStateCallback === 'function' && setStateCallback();
      });
    });
    return this;
  },

  close(setStateCallback) {
    this._removeEvent();

    this.setState({
      // header: null,
      // content: null,
      // footer: null,
      hidden: true
    }, setStateCallback);

    return this;
  },

  isOpen() {
    return !this.state.hidden;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _findTarget(item) {
    let result = false;
    let id = this.getId();

    if (item.id === id) {
      result = true;
    } else if (item.parentElement) {
      result = this._findTarget(item.parentElement);
    }

    return result;
  },

  _addEvent() {
    UU5.Environment.EventListener.addWindowEvent('click', this.getId(), e => {
      let isPopover = this._findTarget(e.target);

      if (!this._stopPropagation && !isPopover && !this.isHidden()) {
        this.close();
      } else {
        this._stopPropagation = false;
      }
    });
    UU5.Environment.EventListener.addWindowEvent('contextmenu', this.getId(), e => {
      let isPopover = this._findTarget(e.target);

      if (!this._stopPropagation && !isPopover && !this.isHidden()) {
        this.close();
      } else {
        this._stopPropagation = false;
      }
    });
    return this;
  },

  _removeEvent() {
    UU5.Environment.EventListener.removeWindowEvent('click', this.getId());
    UU5.Environment.EventListener.removeWindowEvent('contextmenu', this.getId());
    return this;
  },

  _getMainAttrs() {
    let props = this.getMainAttrs();

    props.id = this.getId();

    !this.isHidden() && (props.className += ' ' + this.getClassName().open);
    props.className += this.state.position.top ? ' ' + this.getClassName('top') : ' ' + this.getClassName('bottom');
    props.className += this.state.position.left ? ' ' + this.getClassName('left') : ' ' + this.getClassName('right');

    props.style = {};
    if (this.state.pageX !== null) {
      props.style = {
        left: this.state.pageX,
        top: this.state.pageY
      };
    }

    //opera mini dont know how to use transitions :(
    if (navigator.userAgent.indexOf('Opera Mini') == -1) {
      let time = this.getDefault().transitionDuration / 1000;
      ['WebkitTransitionDuration', 'MozTransitionDuration', 'MsTransitionDuration', 'OTransitionDuration', 'transitionDuration'].forEach(style => {
        // props.style[style] = time + 's';
      });
    }

    return props;
  },

  _getHeader() {
    let header = this.state.header || this.getHeader();
    if (header) {
      header = <div className={this.getClassName().header} key="header">{header}</div>;
    }
    return header;
  },

  _getFooter() {
    let footer = this.state.footer || this.getFooter();
    if (footer) {
      footer = <div className={this.getClassName().footer} key="footer">{footer}</div>;
    }
    return footer;
  },

  _getBody() {
    let children = this.buildChildren({ content: this.state.content, children: this.props.children });
    if (children) {
      children = <div className={this.getClassName().body} key="chidren">{children}</div>;
    }
    return children;
  },

  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return <div {...this._getMainAttrs()}>
        {this._getHeader()}
        {this._getBody()}
        {this._getFooter()}
        {this.getDisabledCover()}
      </div>;
  }
  //@@viewOff:render
});

export default Popover;