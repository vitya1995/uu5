/*! uu_appg01, 3.2.0, 2017-10-11 15:23:00Z */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("UuApp", ["module"], factory);
	else if(typeof exports === 'object')
		exports["UuApp"] = factory(require("module"));
	else
		root["UuApp"] = factory(root["undefined"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*********************************!*\
  !*** ../.tmp/index-withDeps.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var mod=__webpack_require__(/*! module */ 1);
	  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
	  __webpack_require__.p=uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
	  module.exports = __webpack_require__(/*! __project__/index-withDeps.js */ 2);

/***/ },
/* 1 */
/*!*********************************************************************************************!*\
  !*** external {"amd":"module","commonjs":"module","commonjs2":"module","root":"undefined"} ***!
  \*********************************************************************************************/
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/*!***************************!*\
  !*** ./index-withDeps.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _index = __webpack_require__(/*! ./index.js */ 3);

	Object.keys(_index).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _index[key];
	    }
	  });
	});

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var UuApp = _interopRequireWildcard(_uu_appg01_core);

	var _uu_oidcg = __webpack_require__(/*! uu_oidcg01 */ 30);

	var UuOidc = _interopRequireWildcard(_uu_oidcg);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// export dependencies to window explicitly
	var Cmd = window.UuApp = window.UuApp || {};
	for (var k in UuApp) {
	  Cmd[k] = UuApp[k];
	}var Oidc = window.UuOidc = window.UuOidc || {};
	for (var k in UuOidc) {
	  Oidc[k] = UuOidc[k];
	} // export self in a standard way

/***/ },
/* 3 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Client = undefined;

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	Object.keys(_uu_appg01_core).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _uu_appg01_core[key];
	    }
	  });
	});

	var _Client = __webpack_require__(/*! ./Client.js */ 29);

	var _Client2 = _interopRequireDefault(_Client);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Client = _Client2.default;

/***/ },
/* 4 */
/*!**********************************************!*\
  !*** ../~/uu_appg01_core/dist-node/index.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Perflog = exports.Util = exports.Logging = exports.Error = exports.Uri = exports.AppClient = undefined;

	__webpack_require__(/*! ./polyfills.js */ 5);

	var _index = __webpack_require__(/*! ./app-client/index.js */ 10);

	var AppClient = _interopRequireWildcard(_index);

	var _index2 = __webpack_require__(/*! ./uri/index.js */ 25);

	var Uri = _interopRequireWildcard(_index2);

	var _index3 = __webpack_require__(/*! ./error/index.js */ 12);

	var Error = _interopRequireWildcard(_index3);

	var _index4 = __webpack_require__(/*! ./logging/index.js */ 20);

	var Logging = _interopRequireWildcard(_index4);

	var _index5 = __webpack_require__(/*! ./util/index.js */ 18);

	var Util = _interopRequireWildcard(_index5);

	var _index6 = __webpack_require__(/*! ./perflog/index.js */ 23);

	var Perflog = _interopRequireWildcard(_index6);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.AppClient = AppClient;
	exports.Uri = Uri;
	exports.Error = Error;
	exports.Logging = Logging;
	exports.Util = Util;
	exports.Perflog = Perflog;

/***/ },
/* 5 */
/*!**************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/polyfills.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _es6Promise = __webpack_require__(/*! es6-promise */ 6);

	var _es6Promise2 = _interopRequireDefault(_es6Promise);

	var _objectAssign = __webpack_require__(/*! object-assign */ 9);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Promise API (IE)
	_es6Promise2.default.polyfill();

	// Object.assign (IE)
	if (!Object.assign) Object.assign = _objectAssign2.default;

	// document.baseURI (IE)
	if (typeof document !== "undefined" && !document.baseURI) {
	  var baseEl = document.querySelector("base");
	  if (baseEl) document.baseURI = baseEl.href;else document.baseURI = location.href;
	}

/***/ },
/* 6 */
/*!********************************************!*\
  !*** ../~/es6-promise/dist/es6-promise.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */

	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';

	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}

	function isFunction(x) {
	  return typeof x === 'function';
	}

	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}

	var isArray = _isArray;

	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;

	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};

	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}

	function setAsap(asapFn) {
	  asap = asapFn;
	}

	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}

	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }

	  return useSetTimeout();
	}

	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });

	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}

	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}

	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}

	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];

	    callback(arg);

	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }

	  len = 0;
	}

	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(/*! vertx */ 8);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}

	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}

	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;

	  var parent = this;

	  var child = new this.constructor(noop);

	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }

	  var _state = parent._state;

	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }

	  return child;
	}

	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.resolve(1);

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }

	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}

	var PROMISE_ID = Math.random().toString(36).substring(16);

	function noop() {}

	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;

	var GET_THEN_ERROR = new ErrorObject();

	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}

	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}

	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}

	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}

	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;

	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));

	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}

	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}

	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}

	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}

	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }

	  publish(promise);
	}

	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }

	  promise._result = value;
	  promise._state = FULFILLED;

	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}

	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;

	  asap(publishRejection, promise);
	}

	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;

	  parent._onerror = null;

	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;

	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}

	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;

	  if (subscribers.length === 0) {
	    return;
	  }

	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;

	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];

	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }

	  promise._subscribers.length = 0;
	}

	function ErrorObject() {
	  this.error = null;
	}

	var TRY_CATCH_ERROR = new ErrorObject();

	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}

	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;

	  if (hasCallback) {
	    value = tryCatch(callback, detail);

	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }

	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }

	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}

	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}

	var id = 0;
	function nextId() {
	  return id++;
	}

	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}

	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);

	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }

	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;

	    this._result = new Array(this.length);

	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}

	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};

	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;

	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};

	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;

	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);

	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};

	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;

	  if (promise._state === PENDING) {
	    this._remaining--;

	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }

	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};

	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;

	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};

	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```

	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```

	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}

	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.

	  Example:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```

	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```

	  An example real-world use case is implementing timeouts:

	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```

	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}

	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}

	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}

	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}

	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.

	  Terminology
	  -----------

	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.

	  A promise can be in one of three states: pending, fulfilled, or rejected.

	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.

	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.


	  Basic Usage:
	  ------------

	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);

	    // on failure
	    reject(reason);
	  });

	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Advanced Usage:
	  ---------------

	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.

	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();

	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();

	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }

	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Unlike callbacks, promises are great composable primitives.

	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON

	    return values;
	  });
	  ```

	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];

	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}

	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;

	Promise.prototype = {
	  constructor: Promise,

	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,

	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};

	function polyfill() {
	    var local = undefined;

	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }

	    var P = local.Promise;

	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }

	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }

	    local.Promise = Promise;
	}

	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;

	return Promise;

	})));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ../~/process/browser.js */ 7), (function() { return this; }())))

/***/ },
/* 7 */
/*!*******************************!*\
  !*** ../~/process/browser.js ***!
  \*******************************/
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 8 */
/*!***********************!*\
  !*** vertx (ignored) ***!
  \***********************/
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 9 */
/*!***********************************!*\
  !*** ../~/object-assign/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 10 */
/*!*********************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/app-client/index.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Client = undefined;

	var _Client = __webpack_require__(/*! ./Client.js */ 11);

	var _Client2 = _interopRequireDefault(_Client);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Client = _Client2.default;

/***/ },
/* 11 */
/*!**********************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/app-client/Client.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _index = __webpack_require__(/*! ../error/index.js */ 12);

	var _index2 = __webpack_require__(/*! ../util/index.js */ 18);

	var _index3 = __webpack_require__(/*! ../logging/index.js */ 20);

	var _index4 = __webpack_require__(/*! ../perflog/index.js */ 23);

	var logger = _index3.LoggerFactory.get("UuApp.AppClient.Client");

	/**
	 * Creates an instance of command client which will use specified configuration when invoking commands.
	 * Unspecified values are taken from global defaults ({@link UuApp.AppClient.Client.defaults Client.defaults}). Most
	 * values can be further overridden when invoking the remote call - see {@link UuApp.AppClient.Client#post Client#post}.
	 * 
	 * **Interceptors**
	 * 
	 * It's possible to provide a list of interceptors which pre-/post-process HTTP requests. An interceptor
	 * is a JavaScript function {Promise<Response>} interceptorFn({Object} request, {Object} options, {Function} nextInterceptorFn).
	 * Request object contains fields uri, method, body and options object contains any remaining options passed down to
	 * interceptors, e.g. transformParameters). Example:
	 * 
	 *     function MyInterceptor(request, options, nextInterceptorFn) {
	 *       // pre-process in any way
	 *       request.headers["x-extra-header-computed-value"] = Math.random() + "";
	 *       console.log("Launching Ajax request. Method:", request.method, "Uri:", request.uri, "Parameters:", request.body, "Other options:", options);
	 *       var start = new Date().getTime();
	 *       return nextInterceptorFn(request, options).then(function (response) {
	 *         // post-process in any way, e.g. add extra field to the response object
	 *         response.timeTaken = new Date().getTime() - start;
	 *         return response;
	 *       }, function error(response) {
	 *         // ...
	 *         return Promise.reject(response); // keep it rejected (i.e. in error state)
	 *       });
	 *     }
	 *     
	 *     // usage of the interceptor
	 *     var client = new UuApp.AppClient.Client({
	 *       interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
	 *     });
	 *     
	 * @class UuApp.AppClient.Client
	 * @classdesc
	 * The Client allows communication with remote uuOS9 endpoints which conform to uuUri format.
	 * Besides communication, the client solves also other points of interest, such as authentication or
	 * performance logging.
	 * 
	 * Client uses standardized {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise API}
	 * to provide access to the result of the call.
	 * 
	 *     UuApp.AppClient.Client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function (response) {
	 *       console.log(response.data, response.status, response.headers());
	 *     }, function (response) { // error
	 *       console.log(response.error, response.status, response.headers());
	 *     });
	 * 
	 * When used as above, client uses global defaults (timeout, headers, ...). If the call needs to be parametrized, it can
	 * be parametrized directly in {@link UuApp.AppClient.Client#post Client#post} ({@link UuApp.AppClient.Client#get Client#get})
	 * call or, alternatively, a client instance can be created with defaults that override the global ones.
	 * 
	 * For pre-/post-processing of HTTP requests use custom interceptors (see constructor).
	 * 
	 * **Configuration**
	 * 
	 * Some options are automatically configured from the environment during
	 * {@link UuApp.Util.Config.init Config.init} call. These can be overridden when instantiating
	 * the client or in method invocations. Supported environment options:
	 * 
	 *     {
	 *       "gatewayUri": "https://uuappg01.plus4u.net", // default gateway for command calls using uuUri that doesn't contain gateway
	 *       "vendor-app-subapp-spp.gatewayUri": "https://elsewhere.plus4u.net"
	 *     }
	 * 
	 * @param {Object} options Default options for this instance of the command client.
	 * @param {number} options.requestTimeout The default HTTP timeout for this instance of the command client, in seconds.
	 * @param {Object} options.headers The default HTTP headers for command invocations using this instance of the command client.
	 * @param {Object[]} options.interceptors List of interceptors to use. Interceptors can arbitrarily pre-/post-process
	 *   HTTP requests.
	 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
	 *   as "gatewayUri" which then take precedence over those from global environment.
	 * 
	 * @example
	 *    var client = new UuApp.AppClient.Client({
	 *      requestTimeout: 20,
	 *      headers: {
	 *        "x-my-extra-header": "abcd"
	 *      },
	 *      interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
	 *    });
	 * 
	 *    // ... all calls using "client.get(...)" or "client.post()" will have timeout 20s (unless the timeout
	 *    // is overridden in the invoke call directly) and will have an extra HTTP header.
	 */
	function Client(options) {
	  this.options = options || {};
	  this.options.headers = keysToLowerCase(this.options.headers);
	}

	/**
	 * Global defaults for command client. 
	 * 
	 *     {
	 *       requestTimeout: 300,   // timeout in seconds
	 *       interceptors: [ // default set of interceptors
	 *         // ...
	 *       ]
	 *     }
	 * 
	 * @name UuApp.AppClient.Client.defaults
	 */
	Client.defaults = {
	  requestTimeout: 300,
	  interceptors: [UriHandler, RemoteErrorHandler, UujsonHandler, TransformParametersHandler, PerfLogHandler]
	};

	function keysToLowerCase(map) {
	  if (!map || (typeof map === "undefined" ? "undefined" : _typeof(map)) != "object") return null;
	  var result = {};
	  for (var k in map) {
	    result[k.toLowerCase()] = map[k];
	  }return result;
	}
	Client.prototype.invoke = function (method, uri, parameters, options) {
	  // prepare data for interceptors & http client
	  var interceptorOpts = Object.assign({}, this.options, options);
	  delete interceptorOpts.requestTimeout;
	  delete interceptorOpts.headers;
	  delete interceptorOpts.interceptors;
	  var request = {
	    method: (method || "post").toLowerCase(),
	    uri: uri,
	    body: parameters,
	    headers: Object.assign({}, this.options.headers, keysToLowerCase((options || {}).headers))
	  };
	  var httpClientOpts = {
	    requestTimeout: (options || {}).requestTimeout != null ? (options || {}).requestTimeout : this.options.requestTimeout
	  };

	  // run interceptors (with 1st interceptor being the entry-point of the chain; last interceptor will continue with InvokeXhr method)
	  var interceptors = this.options.interceptors || this.constructor.defaults.interceptors || [];
	  var lastResponse;
	  var chainFn = interceptors.reduceRight(function (chainFn, interceptorFn) {
	    return function (req, opts) {
	      var result;
	      try {
	        result = interceptorFn(req, opts, chainFn);
	        if (!result || (typeof result === "undefined" ? "undefined" : _typeof(result)) != "object" || typeof result.then != "function") result = Promise.resolve(result);
	      } catch (e) {
	        result = Promise.reject(e);
	      }
	      // make sure that interceptor always returns "response" object
	      // (even if some unexpected / unhandled error happened)
	      return result.then(function (anyValue) {
	        var response = anyValue;
	        if (!anyValue || !("status" in anyValue)) {
	          // it's not a "response" object and it's not rejected (i.e. bugged interceptor) => use it as "data" on last known "response"
	          logger.warn("Client interceptor %s resolved the promise into a value that is not a Response object - auto-wrapping.", interceptorFn.name);
	          response = lastResponse || interceptorMakeResponse(null, req, opts);
	          if (anyValue !== undefined) response.data = anyValue; // don't overwrite data if interceptor just didn't use "return response;"
	        }
	        lastResponse = response;
	        if (lastResponse.error) logger.warn("Client interceptor %s resolved response successfully but kept the error object set - unsetting. Error object:", interceptorFn.name, lastResponse.error);
	        lastResponse.error = null;
	        return response;
	      }, function wrapAsResponse(anyValue) {
	        if (!anyValue || !("status" in anyValue)) {
	          // it's not a "response" object => take the last known "response" and update its "error" field
	          if (!lastResponse) lastResponse = interceptorMakeResponse(null, req, opts);
	          lastResponse.error = anyValue instanceof _index.Error ? anyValue : new _index.Error("Client interceptor " + interceptorFn.name + " ended with error.", anyValue);
	        } else {
	          // it's a "response" object => use it as-is
	          lastResponse = anyValue;
	        }
	        return Promise.reject(lastResponse);
	      });
	    };
	  }, InvokeXhr.bind(null, this, httpClientOpts));
	  var resultPromise = chainFn(request, interceptorOpts);

	  // add support for aborting on-going requests
	  var aborted = false;
	  resultPromise.abort = function () {
	    aborted = true;
	    if (httpClientOpts.xhr) httpClientOpts.xhr.abort(); // Ajax might not have been called yet
	  };

	  return resultPromise;

	  function InvokeXhr(cmdClient, httpClientOpts, finalRequest, finalOpts) {
	    if (aborted) return Promise.reject(interceptorMakeResponse(null, finalRequest, { error: new _index.AbortError("The Client call has been aborted.") }));

	    var xhr = httpClientOpts.xhr = new XMLHttpRequest();
	    return new Promise(function executor(resolve, reject) {
	      var canHaveBody = finalRequest.method.match(/^(put|post)$/i);
	      var url = finalRequest.uri.toString();
	      var body;
	      if (!canHaveBody) {
	        if (finalRequest.body) url += (url.indexOf("?") == -1 ? "?" : "&") + finalRequest.body;
	      } else {
	        body = finalRequest.body;
	      }
	      var headers = finalRequest.headers;
	      var timeout = httpClientOpts.requestTimeout = httpClientOpts.requestTimeout != null ? httpClientOpts.requestTimeout : cmdClient.constructor.defaults.requestTimeout;
	      if (logger.isDebugLoggable()) logger.debug("Invoking Ajax request.", { method: finalRequest.method, url: url, body: body, requestTimeout: timeout, headers: headers });else if (logger.isInfoLoggable()) logger.info("Invoking Ajax request.", { method: finalRequest.method, url: url });

	      xhr.open(finalRequest.method, url, true);
	      if (timeout > 0) xhr.timeout = timeout * 1000;
	      xhr.withCredentials = true;
	      for (var k in headers) {
	        var v = headers[k];
	        if (k && v != null) {
	          // omit "Content-Type" header if it's multipart/form-data, otherwise the browser doesn't update
	          // it with proper boundary and server won't be able to parse the body
	          if (k === "content-type" && body instanceof FormData && v === "multipart/form-data") continue;
	          xhr.setRequestHeader(k.replace(/(^|-)./g, function (m) {
	            return m.toUpperCase();
	          }), v + "");
	        }
	      }
	      xhr.ontimeout = function (e) {
	        // TimeoutError
	        logger.info("Request timed out.", { url: url });
	        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.TimeoutError("Request timed out - " + url) }));
	      };
	      xhr.onload = function (e) {
	        // status 200 - 5xx
	        if (logger.isDebugLoggable()) logger.debug("Received response.", { url: url, status: xhr.status, data: xhr.response });else logger.info("Received response.", { url: url, status: xhr.status });
	        resolve(interceptorMakeResponse(xhr, finalRequest, { data: xhr.response }));
	      };
	      xhr.onabort = function (e) {
	        // user / developer abort; AbortError
	        logger.info("Request has been aborted.", { url: url });
	        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.AbortError("Request has been aborted - " + url) }));
	      };
	      xhr.onerror = function (e) {
	        // network error; NetworkError
	        logger.info("Request ended with network error.", { url: url });
	        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.NetworkError("Network error - " + url), data: xhr.response }));
	      };
	      xhr.send(body);
	    });
	  }
	};

	/**
	 * Invokes remote call using HTTP GET request. See {@link UuApp.AppClient.Client#post Client#post}
	 * for detailed options and behaviour.
	 * 
	 * Keep in mind that the "parameters" parameter is sent via URL parameter(s)
	 * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
	 * doesn't exceed 2048 bytes.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
	 * @param {*} parameters The parameters to send in the request URL.
	 * @param {Object} options Optional options for the remote call.
	 * @return Promise resolving to a response object (or rejecting to a response object with error field).
	 * @method UuApp.AppClient.Client#get
	 * @see {@link UuApp.AppClient.Client#post Client#post}
	 * 
	 * @example
	 *    // simple call
	 *    var baseUri = Uri.parse(location.protocol + "//" + location.host + location.pathname).baseUri; // "http://example.com/vendor-app/tid-awid"
	 *    Client.get(baseUri.join("+/getAttributes"), { param1: "v1" }).then(function success(response) {
	 *      var data = response.data; // contains parsed response entity
	 *      console.log(response.status, response.headers(), response.data);
	 *    }, function error(response) {
	 *      var error = response.error; // contains parsed response error
	 *      console.log(response.status, response.headers(), response.error);
	 *    });
	 *    
	 * @example
	 *    // parameterizing uuUri and the call
	 *    var uri = new UuApp.Uri.UriBuilder("/cds-gb-main/0-0/getAttributes", {
	 *      workspace: "15634-34e5684da3435",
	 *      useCase: "getConfig",
	 *      parameters: { p1: "v1" }
	 *    }).toUri();
	 *    client.get(uri, null, {
	 *      requestTimeout: 5,
	 *      headers: {
	 *        "x-my-header": "abc"
	 *      }
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 *    
	 * @example
	 *    // accept any response and don't parse it
	 *    var workspace = "...";
	 *    var guestbookId = "...";
	 *    client.get(`/cds-gb/${workspace}/guestbook/${guestbookId}/downloadData`, null, {
	 *      transformResponse: false,
	 *      headers: {
	 *        "accept": "*\/*"
	 *      }
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 */
	Client.prototype.get = function (uri, parameters, options) {
	  return this.invoke("get", uri, parameters, options);
	};

	/**
	 * Invokes remote call using HTTP POST request. Default values for settings will
	 * be filled in from Client instance configuration and then from global defaults.
	 * 
	 * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
	 * to the specified "content-type" HTTP request/response header.
	 * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
	 * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or 
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or 
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
	 * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
	 * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
	 * 
	 * **Return value**
	 * 
	 * Return value is a {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
	 * resolving / rejecting to a response object which contains following fields:
	 * 
	 * * {Object} data - response data. Data is parsed with content handler according to "content-type" response header
	 *     unless option transformResponse is false (in which case it's left as received from browser).
	 * * {Error} error - the error instance (see Error handling below). This field is set if and only if the Promise is rejected. 
	 * * {number} status - the HTTP status code.
	 * * {function(string)} headers - function which returns value of the specified (case-insenstive) response header.
	 *   If called with no arguments, an array with all response headers is returned.
	 * * {Object} config - final configuration options that were used for launching AJAX request.
	 * 
	 * The returned Promise instance additionally contains method {function()} abort for aborting ongoing remote call.
	 * 
	 * **File upload**
	 * 
	 * Use "content-type" header with "multipart/form-data" value when uploading binary data (File, Blob). Alternatively, it's
	 * possible to use standard {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object - see examples
	 * below. Note that when using FormData object, the order of appending the form fields matters - append simple values first
	 * and only in the end append file objects. The reason is that in this order, the server might decide not to allow the upload
	 * based on the other already-available fields thus allowing to end the connection without full upload of the file(s).
	 * _(Client will fix the order of values in FormData object, however not all browsers support this operation.)_
	 * 
	 * Don't forget to **disable timeout when performing the upload** so that it doesn't get cancelled.  
	 * 
	 * **Error handling**
	 * 
	 * If an error happens during the call invocation (determined by HTTP response status code), the resulting Promise is
	 * rejected with response object which will contain "error" field set to an instance of one of these error types
	 * (when using default interceptors):
	 * 
	 *   * null - if server sent response with error HTTP status code but it contained no recognizable error data.
	 *   * {@link UuApp.Error.RemoteError} - error as sent from remote server. Note that the response can contain
	 *     several errors - in such case only first error is extracted into "error" field.
	 *   * {@link UuApp.Error.NetworkError} - in case of problems with connecting to remote server.
	 *   * {@link UuApp.Error.TimeoutError} - when the request didn't end within specified timeout.
	 *   * {@link UuApp.Error.AbortError} - when invocation is aborted by invoking promise.abort() method.
	 *   
	 * The resulting response object contains also HTTP status code and will contain "data"
	 * field set to the response entity (usually containing parsed error list).
	 * 
	 * **Timeout**
	 * 
	 * The timeout applies to the remote call duration only. If an interceptor is used which performs lengthy or asynchronous
	 * operation prior to executing the remote call, it's not counted towards the timeout.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
	 * @param {(FormData|*)} parameters The DTO to send in the request body.
	 * @param {Object} options Optional options for the remote call.
	 * @param {number} options.requestTimeout The timeout for the command invocation. Default is 300.
	 * @param {Object} options.headers The HTTP headers to send. Header names are case-insensitive, but it's advised
	 *   to use lowercased names to prevent duplicities within the map. Headers are merged with default headers from
	 *   Client / global configuration. If a header is in defaults and it's required to prevent it from being
	 *   sent during this invocation, specify the header and use null as its value. 
	 * @param {boolean} options.transformParameters If false, processing of the command parameters (DTO) will be skipped so they'll be
	 *   sent exactly as-is (the browser must support sending the value as-is in XmlHttpRequest). Default value is true.
	 * @param {boolean} options.transformResponse If false, processing of the response (such as parsing the response as JSON) will be skipped. Default is true.
	 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
	 *   as "gatewayUri" which then take precedence over those from global environment.
	 * @return Promise resolving to a response object (or rejecting to a response object with error field).
	 * @method UuApp.AppClient.Client#post
	 * 
	 * @example
	 *    // command call sending data 
	 *    var tenant = "UU-BT";
	 *    var guestbookId = "123";
	 *    client.post(`/cds-gb/${tenant}/guestbook/${guestbookId}/setAttributes`, {
	 *      name: "Modified guestbook",
	 *      invitesLimit: 10,
	 *      public: true
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 *    
	 * @example
	 *     // uploading file(s) - variant 1 (explicit Content-Type header)
	 *     var file = inputElement.files[0];
	 *     var params = {
	 *       file: file,
	 *       anotherValue: "abc"
	 *     }
	 *     client.post("/cds-gb/UU-BT/guestbook/123/uploadData", params, {
	 *       requestTimeout: 0,
	 *       headers: {
	 *         "content-type": "multipart/form-data"
	 *       }
	 *     });
	 *     
	 *     // uploading file(s) - variant 2 (usage of FormData)
	 *     // !!! append files as the last values
	 *     var formData = new FormData();
	 *     formData.append("anotherValue", "abc");
	 *     formData.append("file", file);
	 *     var promise = client.post("/cds-gb/UU-BT/guestbook/123/uploadData", formData, {
	 *       requestTimeout: 0
	 *     });
	 *     promise.then(...); // process response / error
	 *     
	 *     // aborting ongoing call
	 *     elementForUploadCancel.onclick = function (e) {
	 *       promise.abort(); // promise will be rejected with UuApp.Error.AbortError instance
	 *     };
	 *     
	 * @example
	 *    // error distinguishing
	 *    client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function success(response) {
	 *      console.log(response.status, response.headers(), response.data);
	 *    }, function error(response) {
	 *      console.log(response.status, response.headers(), response.data);
	 *      var error = response.error;
	 *      if (error instanceof UuApp.Error.TimeoutError) console.log("Timed out.");
	 *      else if (error instanceof UuApp.Error.AbortError) console.log("Aborted.");
	 *      else if (error instanceof UuApp.Error.NetworkError) console.log("Communication / network error.");
	 *      else if (response.status == 401) console.log("Not authenticated.");
	 *      else if (response.status < 500) {
	 *        console.log("User or client problem - invalid data / unfulfilled business rules / invalid call / ...", response.data);
	 *      } else if (response.status >= 500) console.log("Server-side problem.", response.data);
	 *      else console.log("Unrecognized problem.", error);
	 *    });
	 * 
	 * @example
	 *    // send data in custom format
	 *    client.post("/cds-gb/UU-BT/guestbook/123/setSomething", convertToMySuperFormat(dto), {
	 *      transformParameters: false,
	 *      headers: {
	 *        "content-type": "text/x-my-super-format"
	 *      }
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 */
	Client.prototype.post = function (uri, parameters, options) {
	  return this.invoke("post", uri, parameters, options);
	};
	//  Client.prototype.put = function (uri, parameters, options) {
	//    return this.invoke("put", uri, parameters, options);
	//  };
	//  Client.prototype.delete = function (uri, options) {
	//    return this.invoke("delete", uri, null, options);
	//  };

	var defClient;
	/**
	 * Equivalent to {@link UuApp.AppClient.Client#get} using Client with default
	 * configuration, i.e.:
	 * 
	 *     new UuApp.AppClient.Client().get(uri, options)
	 * 
	 * @see {@link UuApp.AppClient.Client#get Client#get}
	 * @method UuApp.AppClient.Client.get
	 */
	Client.get = function () /*uri, options*/{
	  if (!defClient) defClient = new Client();
	  return defClient.get.apply(defClient, arguments);
	};

	/**
	 * Equivalent to {@link UuApp.AppClient.Client#post} using Client with default
	 * configuration, i.e.:
	 * 
	 *     new UuApp.AppClient.Client().post(uri, parameters, options)
	 * 
	 * @see {@link UuApp.AppClient.Client#post Client#post}
	 * @method UuApp.AppClient.Client.post
	 */
	Client.post = function () /*uri, parameters, options*/{
	  if (!defClient) defClient = new Client();
	  return defClient.post.apply(defClient, arguments);
	};

	/**
	 * Interceptor for finalizing uuUri URL in case it's incomplete (missing gateway).
	 * 
	 * @name UuApp.AppClient.Client.UriHandler
	 */
	Client.UriHandler = UriHandler;
	function UriHandler(request, options, nextInterceptorFn) {
	  // take gateway from environment only when gateway is missing in URI (and environment was initialized)
	  var uri = (request.uri || "").toString();
	  request.uri = uri;
	  if (uri.match(/^https?:/i)) return nextInterceptorFn(request, options);

	  function carryOn(env) {
	    if (baseUrl == null) {
	      var optName = "gatewayUri";
	      baseUrl = env ? env.get(optName) : null;
	      if (baseUrl == null) baseUrl = "https://uuappg01.plus4u.net";
	    }

	    if (baseUrl) request.uri = baseUrl.replace(/\/+$/, "") + "/" + uri.replace(/^\/+/, "");
	    return nextInterceptorFn(request, options);
	  }
	  var baseUrl = options["gatewayUri"];
	  if (baseUrl == null) return Promise.resolve(_index2.Config.initPromise).then(carryOn);
	  return carryOn();
	}

	/**
	 * Interceptor for extracting error information from response.
	 * 
	 * @name UuApp.AppClient.Client.RemoteErrorHandler
	 */
	Client.RemoteErrorHandler = RemoteErrorHandler;
	function RemoteErrorHandler(request, options, nextInterceptorFn) {
	  // NOTE We assume that the "content-type" transformation has been already performed on response data.
	  return nextInterceptorFn(request, options).then(checkError.bind(null, false), checkError.bind(null, true));

	  function checkError(isReject, response) {
	    if (response.status >= 400) {
	      var errorData = response.data;
	      // fill first error from response data into "error" field (if any)
	      if (errorData && (typeof errorData === "undefined" ? "undefined" : _typeof(errorData)) === "object" && "uuAppErrorMap" in errorData) {
	        var errorMap = errorData["uuAppErrorMap"];
	        var firstErrorKey = null;
	        if (errorMap) for (var k in errorMap) {
	          if (errorMap[k] && errorMap[k].type === "error") {
	            firstErrorKey = k;
	            break;
	          }
	        }if (firstErrorKey) response.error = new _index.RemoteError(Object.assign({}, errorMap[firstErrorKey], { code: k }));
	      }
	      return Promise.reject(response);
	    }
	    return isReject ? Promise.reject(response) : response;
	  }
	}

	/**
	 * In case uuJSON format is used, validates input parameters to match uuJSON specification
	 * (including validation of declared schema to match invoked command) and ensures uuJSON
	 * usage is properly reported to remote server.
	 * 
	 * Recognized options:
	 * 
	 * * uujson {boolean} - whether uuJSON format is used. Parameters must contain schema and data.
	 *  
	 * @name UuApp.AppClient.Client.UujsonHandler
	 */
	Client.UujsonHandler = UujsonHandler;
	function UujsonHandler(request, options, nextInterceptorFn) {
	  var uri = request.uri + "";
	  var isUujson = options["uujson"] || uri.match(/[?&]_uujson(=|$)/);
	  if (isUujson) {
	    var usedUri = uri.replace(/[?&]_uujson(?==|$)[^&]*/, "");
	    usedUri += (usedUri.indexOf(/\?/) === -1 ? "?" : "&") + "_uujson=";
	    request.uri = usedUri;
	  }
	  return nextInterceptorFn(request, options); // no .then(...) - no response post-processing
	}

	/**
	 * Interceptor for transforming request parameters / response entity according to the Content Type.
	 * Recognized options:
	 * 
	 * - transformParameters {boolean} - whether to transform (serialize by Content-Type) request body
	 * - transformResponse {boolean} - whether to transform (deserialize by Content-Type) response body
	 * - wrapQuery {boolean} - whether to wrap request body with { dto: ... }
	 * 
	 * @name UuApp.AppClient.Client.TransformParametersHandler
	 */
	Client.TransformParametersHandler = TransformParametersHandler;
	function TransformParametersHandler(request, options, nextInterceptorFn) {
	  function getMimeMainType(mimeType) {
	    return (mimeType || "").replace(/[+;].*/, "").trim();
	  }

	  // add default Content-Type & Accept headers
	  var paramsInBody = request.method.match(/^(put|post)$/i);
	  var contentTransformers = Client.contentTransformers || {};
	  var contentType = request.headers["content-type"];
	  if (!("content-type" in request.headers)) {
	    if (paramsInBody) {
	      var isMultipartPreferred = request.body != null && (request.body instanceof FormData || request.body instanceof Blob || _typeof(request.body) == "object" && Object.keys(request.body).some(function (it) {
	        return it instanceof FormData || it instanceof Blob;
	      }));
	      contentType = isMultipartPreferred ? "multipart/form-data" : "application/json; charset=utf-8";
	      request.headers["content-type"] = contentType;
	    } else {
	      contentType = "application/x-www-form-urlencoded";
	    }
	  }
	  if (!("accept" in request.headers)) request.headers["accept"] = "application/json";

	  // wrap request data into "dto" parameter if requested to do so
	  if (options.transformParameters !== false && !paramsInBody && request.body != null && options.wrapQuery && contentType == "application/x-www-form-urlencoded") {
	    request.body = {
	      dto: JSON.stringify(request.body)
	    };
	  }

	  // transform request data
	  if (options.transformParameters !== false && request.body != null) {
	    var contentHandler = contentTransformers[getMimeMainType(contentType)];
	    try {
	      if (contentHandler) request.body = contentHandler.serialize(request.body);
	    } catch (e) {
	      throw new _index.Error("Error while serializing data.", e);
	    }
	  }

	  // continue and transform response data afterwards (regardless of success / failure)
	  return nextInterceptorFn(request, options).then(transformResponse.bind(null, false), transformResponse.bind(null, true));

	  function transformResponse(isReject, response) {
	    if (options.transformResponse !== false) {
	      var respContentType = response.headers("content-type");
	      var contentHandler = contentTransformers[getMimeMainType(respContentType)];
	      try {
	        if (contentHandler) response.data = contentHandler.deserialize(response.data);else if (response.status === 204) response.data = null;
	      } catch (e) {
	        throw new _index.Error("Error while deserializing response data.", e);
	      }
	    }
	    return isReject ? Promise.reject(response) : response;
	  }
	}

	/**
	 * Interceptor for performance logging.
	 * 
	 * @name UuApp.AppClient.Client.PerfLogHandler
	 */
	function PerfLogHandler(request, options, nextInterceptorFn) {
	  var promise;
	  _index4.PerfLog.measureSection("commandInvocation", function (section) {
	    request.headers["x-request-id"] = section.id;
	    promise = nextInterceptorFn(request, options);
	    return promise.then(function (response) {
	      section.attributes["uri"] = request.uri;
	      return response;
	    }, function (response) {
	      section.attributes["uri"] = request.uri;
	      return Promise.reject(response);
	    });
	  });
	  return promise;
	}

	function interceptorMakeResponse(xhr, request, extraFields) {
	  return Object.assign({
	    status: xhr ? xhr.status : 0,
	    headers: function headers(aHeader) {
	      if (!aHeader) return xhr ? xhr.getAllResponseHeaders() : [];
	      return xhr ? xhr.getResponseHeader(aHeader) : null;
	    }
	  }, extraFields);
	}

	var Json = {
	  serialize: function serialize(value) {
	    return JSON.stringify(value);
	  },
	  deserialize: function deserialize(value) {
	    return value ? JSON.parse(value) : null;
	  }
	};
	var Form = {
	  serialize: function serialize(value) {
	    if (value == null) return value;
	    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
	      logger.warn("Unrecognized value when serializing as application/x-www-form-urlencoded - passing as-is. Value:", { value: value });
	      return value;
	    }
	    var result = [];
	    for (var k in value) {
	      result.push(encodeURIComponent(k) + "=" + encodeURIComponent(value[k]));
	    }return result.join("&");
	  },
	  deserialize: function deserialize(value) {
	    if (value == null) return value;
	    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
	      logger.warn("Unrecognized value when deserializing as application/x-www-form-urlencoded - passing as-is. Value:", { value: value });
	      return value;
	    }
	    var pairs = value.replace(/\+/g, " ").split("&");
	    var result = {};
	    for (var i = 0; i < pairs.length; ++i) {
	      var pair = pairs[i];
	      pair.replace(/^([^=]*)=?(.*)$/, function (m, g1, g2) {
	        return result[decodeURIComponent(g1)] = decodeURIComponent(g2);
	      });
	    }
	    return result;
	  }
	};
	var MultiPart = {
	  serialize: function serialize(value) {
	    if (!value) return value;
	    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
	      logger.warn("Unrecognized value when serializing as multipart/form-data - passing as-is. Value:", { value: value });
	      return value;
	    }
	    if (value instanceof FormData && typeof value.entries != "function") return value; // FormData without support for iterating over its entries
	    if (value instanceof Blob) value = { file: value };

	    // make a list and reorder values so that the File instances are at the end of the list
	    var data = {};
	    if (value instanceof FormData) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = value.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var pair = _step.value;
	          data[pair[0]] = pair[1];
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    } else {
	      data = value;
	    }
	    var list = [];
	    for (var k in data) {
	      list.push({ key: k, value: data[k], i: list.length });
	    }var max = list.length;
	    list.sort(function (a, b) {
	      // stable sort
	      return (a.value instanceof File ? a.i + max : a.i) - (b.value instanceof File ? b.i + max : b.i);
	    });

	    // fill values into FormData
	    var formData = new FormData();
	    list.forEach(function (it) {
	      return formData.append(it.key, it.value);
	    });
	    return formData;
	  },
	  deserialize: function deserialize(value) {
	    throw new _index.Error("Deserializing multipart/form-data is not supported. Value: " + value);
	  }
	};

	/**
	 * Transformers which serialize / deserialize content that is sent to / received from
	 * server using specific MIME type.
	 */
	Client.contentTransformers = {
	  "application/json": Json,
	  // "application/json+extended": Json,
	  //"application/x-msgpack": MessagePack,
	  //"application/msgpack": MessagePack,
	  "application/x-www-form-urlencoded": Form,
	  "multipart/form-data": MultiPart
	};

	module.exports = Client;

/***/ },
/* 12 */
/*!****************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/error/index.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TimeoutError = exports.RemoteError = exports.NetworkError = exports.AbortError = exports.Error = undefined;

	var _Error = __webpack_require__(/*! ./Error.js */ 13);

	var _Error2 = _interopRequireDefault(_Error);

	var _AbortError = __webpack_require__(/*! ./AbortError.js */ 14);

	var _AbortError2 = _interopRequireDefault(_AbortError);

	var _NetworkError = __webpack_require__(/*! ./NetworkError.js */ 15);

	var _NetworkError2 = _interopRequireDefault(_NetworkError);

	var _RemoteError = __webpack_require__(/*! ./RemoteError.js */ 16);

	var _RemoteError2 = _interopRequireDefault(_RemoteError);

	var _TimeoutError = __webpack_require__(/*! ./TimeoutError.js */ 17);

	var _TimeoutError2 = _interopRequireDefault(_TimeoutError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Error = _Error2.default;
	exports.AbortError = _AbortError2.default;
	exports.NetworkError = _NetworkError2.default;
	exports.RemoteError = _RemoteError2.default;
	exports.TimeoutError = _TimeoutError2.default;

/***/ },
/* 13 */
/*!****************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/error/Error.js ***!
  \****************************************************/
/***/ function(module, exports) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	// make native Error-s (TypeError, ...) be converted to JSON "somehow", because right now they always end up as {}
	try {
	  if (JSON.stringify(new Error()) == "{}") {
	    Error.prototype.toJSON = function () {
	      if (Object.hasOwnProperty(this, "toJSON")) return this; // to be on the safe-side
	      // we might be in a sub-classed error (TypeError, even custom Error) so temporarily override
	      // toJSON with as-is serialization and use toString() only if we would get no information otherwise
	      this.toJSON = function () {
	        return this;
	      };
	      var useToString = JSON.stringify(this) == "{}";
	      delete this.toJSON; // deletes override; toJSON on prototype chain (this one or any other) is preserved
	      // use this or toString() for final serialization
	      return useToString ? this.toString() + (this.stack != null ? "\n" + this.stack : "") : this;
	    };
	  }
	} catch (e) {}
	// ignore


	//  /**
	//   * Creates new Error.
	//   * 
	//   * This constructor can be also called with a single object literal containing any fields that
	//   * are to be set to the Error object. 
	//   *
	//   * @param {string} message The message.
	//   * @param {Error} cause (optional) The cause (original error).
	//   * @constructor UuApp.Error.Error
	//   */

	// TODO JSDoc doesn't support describing multiple signatures for the same method :-(.
	//  /**
	//   * Creates new Error.
	//   *
	//   * @param {Object} errorObject Object with any attributes to set to the Error instance.
	//   * @constructor UuApp.Error.Error
	//   */
	function _Error(msgOrObj) {
	  var self = this;
	  if (!(self instanceof _Error)) return new (_Error.bind.apply(_Error, arguments))(); // make an instance even if developer forgot to use "new" keyword
	  var errorObject = msgOrObj;
	  if (!errorObject || (typeof errorObject === "undefined" ? "undefined" : _typeof(errorObject)) != "object") {
	    errorObject = {
	      message: arguments[0],
	      cause: arguments[1]
	    };
	  }
	  Object.assign(this, errorObject);
	  if (!this.id) this.id = generateUuid();
	  if (!this.stack) this.stack = new Error().stack;
	  /**
	   * ID of the error. If not specified, it'll be automatically generated.
	   * @name UuApp.Error.Error#id
	   */
	  /**
	   * The message of the error.
	   * @name UuApp.Error.Error#message
	   */
	  /**
	   * The cause (nested error) of the error.
	   * @name UuApp.Error.Error#cause
	   */
	  /**
	   * Stacktrace of the error. If not specified, it'll be automatically filled via browser.
	   * @name UuApp.Error.Error#stack
	   */
	}
	_Error.prototype = Object.create(Error.prototype);
	_Error.prototype.constructor = _Error;

	function generateUuid() {
	  // generate UUID (RFC4122 version 4 compliant) for the event ID
	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0,
	        v = c == 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	  return uuid;
	}

	module.exports = _Error;

/***/ },
/* 14 */
/*!*********************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/error/AbortError.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 13);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new AbortError.
	 * 
	 * @classdesc
	 * Represents an error when operation was aborted by user.
	 * 
	 * @constructor UuApp.Error.AbortError
	 */
	function AbortError() {
	  _Error2.default.apply(this, arguments);
	}
	AbortError.prototype = Object.create(_Error2.default.prototype);
	AbortError.prototype.constructor = AbortError;

	exports.default = AbortError;

/***/ },
/* 15 */
/*!***********************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/error/NetworkError.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 13);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new NetworkError.
	 * 
	 * @classdesc
	 * Represents an error when operation ended with network failure (host lookup, disconnection, ...).
	 * 
	 * @constructor UuApp.Error.NetworkError
	 */
	function NetworkError() {
	  _Error2.default.apply(this, arguments);
	}
	NetworkError.prototype = Object.create(_Error2.default.prototype);
	NetworkError.prototype.constructor = NetworkError;

	exports.default = NetworkError;

/***/ },
/* 16 */
/*!**********************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/error/RemoteError.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 13);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new RemoteError.
	 * 
	 * @classdesc
	 * Represents an error that happened on a remote server.
	 * 
	 * @param {Object} errorObject Object containing error fields (id, status, code, message, ...).
	 * @constructor UuApp.Error.RemoteError
	 */
	function RemoteError(errorObject) {
	  _Error2.default.apply(this, arguments);
	  delete this.stack; // not interested in client-side stack for remote errors
	}
	RemoteError.prototype = Object.create(_Error2.default.prototype);
	RemoteError.prototype.constructor = RemoteError;
	/**
	 * The unique identifier of this instance of the remote error.
	 * @name UuApp.Error.RemoteError#id
	 */
	/**
	 * The code of the remote error.
	 * @name UuApp.Error.RemoteError#code
	 */
	/**
	 * The message of the remote error.
	 * @name UuApp.Error.RemoteError#message
	 */
	/**
	 * Additional parameters of the remote error.
	 * @name UuApp.Error.RemoteError#paramMap
	 */
	/**
	 * The cause of the remote error.
	 * @name UuApp.Error.RemoteError#cause
	 */

	exports.default = RemoteError;

/***/ },
/* 17 */
/*!***********************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/error/TimeoutError.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 13);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new TimeoutError.
	 * 
	 * @classdesc
	 * Represents an error when operation doesn't finish within required timeout.
	 * 
	 * @constructor UuApp.Error.TimeoutError
	 */
	function TimeoutError() {
	  _Error2.default.apply(this, arguments);
	}
	TimeoutError.prototype = Object.create(_Error2.default.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	exports.default = TimeoutError;

/***/ },
/* 18 */
/*!***************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/util/index.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Config = undefined;

	var _Config = __webpack_require__(/*! ./Config.js */ 19);

	var _Config2 = _interopRequireDefault(_Config);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Config = _Config2.default;

/***/ },
/* 19 */
/*!****************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/util/Config.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Error = __webpack_require__(/*! ../error/Error.js */ 13);

	/**
	 * Initializes new configuration object from provided key-value map, URL or from another Promise resolving
	 * to one of those.
	 * 
	 * @class UuApp.Util.Config
	 * @classdesc
	 * "Global" configuration for components such as Client, Logger, ... The configuration
	 * is a flat map containing data such as addresses to gateways, logging configuration and others and
	 * is typically configured somewhere on server-side. The global configuration is automatically initialized from
	 * global **UU5.Environment** variable, if it exists (otherwise it can be initialized by using
	 * {@link UuApp.Util.Config.init Config.init} method, e.g.:
	 * 
	 *     // initialize configuration from URL
	 *     UuApp.Util.Config.init("/vendor-app/0-0/getClientConfig");
	 * 
	 *     // alternatively, configuration can be initialized directly
	 *     UuApp.Util.Config.init({
	 *       "gatewayUri": "https://uuappg01.plus4u.net",
	 *       "logLevel": "DEBUG"
	 *     });
	 *
	 * Note that the intialization via URL is an asynchronous operation, so components will wait until
	 * it's downloaded.
	 *      
	 * Each component describes its own **supported configuration options** in its class description.
	 * 
	 * @param {(string|Object|Promise)} envOrUrl URL from which to download the key-value map
	 *   (using GET method, expecting application/json data). Alternatively, it can be the key-value
	 *   map directly or a Promise resolving to it. 
	 * @return {Promise} Promise resolved to this instance of Config. Promise is resolved after the key-value map
	 *                   is loaded from given URL, or after given Promise is resolved, or immediately if key-value
	 *                   map was given directly).
	 * @example
	 *     // initialize custom configuration from server
	 *     var myEnv = new UuApp.Util.Config("/vendor-app/0-0/getClientConfig");
	 *     myEnv.initPromise.then(function (env) { // env === myEnv
	 *       console.log("'myEnv' is ready. Values:", env.get());
	 *       var client = new UuApp.AppClient.Client(env.get()); // pass configuration to UuApp.AppClient.Client (gatewayUri, ...)
	 *     });
	 *     
	 *     // initialize custom configuration with directly specified configuration
	 *     var myEnv2 = new UuApp.Util.Config({
	 *       "logLevel": "DEBUG"
	 *     });
	 *     console.log("'myEnv2' is ready. Values:", myEnv2.get());
	 * 
	 *     // use configuration from the result of another promise
	 *     var somePromise = ...; // resolves to key-value map
	 *     var myEnv3 = new UuApp.Util.Config(somePromise);
	 *     myEnv3.then(function (env) { ... }); // env === myEnv3
	 */
	function Config(envOrUrl) {
	  this._env = {};

	  // initialize (but only if not instructed to skip it which is used so that globalConfig can be initialized on-demand)
	  if (envOrUrl !== false) initInstance.apply(this, arguments);
	}

	Config.prototype.initInvoked = false;
	/**
	 * Whether the configuration has finished loading. For configuration that was
	 * initialized by providing key-value map directly, it'll be true from the start.
	 * 
	 * @type {boolean}
	 * @name UuApp.Util.Config#initComplete
	 */
	Config.prototype.initComplete = false;
	/**
	 * Promise resolved when configuration has finished loading.
	 * 
	 * @type {Promise}
	 * @name UuApp.Util.Config#initPromise
	 */
	Config.prototype.initPromise = null;
	/**
	  * URL from which the configuration has been loaded, or null if it wasn't loaded
	  * via URL.
	  * 
	  * @type {string}
	  * @name UuApp.Util.Config#initUrl
	  */
	Config.prototype.initUrl = null;

	/**
	 * Returns value of the specified configuration setting. If no name is given,
	 * map with all settings is returned.
	 * 
	 * @param {string} name The setting whose value to return. If not given,
	 *   map with all settings is returned.
	 * @param {boolean} [recursive=true] Whether to lookup the setting recursively. For example
	 *   retrieving value for name "A.B.C.logLevel" would try "A.B.C.logLevel" first,
	 *   then "A.B.logLevel", then "A.logLevel" and finally "logLevel".
	 * @method UuApp.Util.Config#get
	 */
	Config.prototype.get = function (name, recursive) {
	  if (arguments.length == 0) return this._env;
	  if (recursive === false) return this._env[name];
	  var parts = name.split(/\./);
	  while (parts.length > 1) {
	    var v = this._env[parts.join(".")];
	    if (v != null) return v;
	    parts.splice(parts.length - 2, 1);
	  }
	  return this._env[parts[0]];
	};

	// create default (global) configuration instance but don't initialize it - consumer of the library
	// must do it via Config.init()
	var globalConfig = new Config(false);

	/**
	 * Initializes default (global) configuration from given URL or by given key-value map.
	 * The method accepts the same arguments as the {@link UuApp.Util.Config Config(...)} constructor.
	 * 
	 * Note that components such as UuApp.AppClient.Client will automatically wait until default configuration
	 * is loaded (if .init has been invoked prior to their usage).
	 * 
	 * @return Promise ({@link UuApp.Util.Config#initPromise Config#initPromise) resolved to the loaded key-value map.
	 * @method UuApp.Util.Config.init
	 * @example
	 *     // initialize default (global) configuration from server
	 *     UuApp.Util.Config.init("/vendor-app/0-0/getClientConfig").then(function (env) {
	 *       console.log("Components have been configured using environment", env.get());
	 *     });
	 *     
	 *     // initialize default (global) configuration with directly specified data
	 *     UuApp.Util.Config.init({
	 *       "logLevel": "DEBUG"
	 *     });
	 */
	Config.init = function (envOrUrl) {
	  initInstance.apply(globalConfig, Array.prototype.slice.call(arguments));
	  initInvokedPromiseResolve();
	  globalConfig.initPromise.then(initCompletePromiseResolve, initCompletePromiseReject);
	  return globalConfig.initPromise;
	};

	Object.defineProperties(Config, {
	  /**
	   * Whether the *global* configuration has started loading.
	   * 
	   * @type {boolean}
	   * @name UuApp.Util.Config.initInvoked
	   */
	  initInvoked: { get: function get() {
	      return globalConfig.initInvoked;
	    } },
	  /**
	   * Whether the *global* configuration has finished loading.
	   * 
	   * @type {boolean}
	   * @name UuApp.Util.Config.initComplete
	   */
	  initComplete: { get: function get() {
	      return globalConfig.initComplete;
	    } },
	  /**
	   * Promise resolved when *global* configuration has finished loading. Note that
	   * the field is null prior to Config.init call.
	   * 
	   * @type {Promise}
	   * @name UuApp.Util.Config.initPromise
	   */
	  initPromise: { get: function get() {
	      return globalConfig.initPromise;
	    } },
	  /**
	   * URL from which the configuration has been loaded, or null if it wasn't loaded
	   * via URL.
	   * 
	   * @type {string}
	   * @name UuApp.Util.Config.initUrl
	   */
	  initUrl: { get: function get() {
	      return globalConfig.initUrl;
	    } }
	});

	// promise (always non-null) which resolves after Config.init is completed
	// (if it never gets called, the promise won't get resolved)
	var initCompletePromiseResolve;
	var initCompletePromiseReject;
	Config.initCompletePromise = new Promise(function (rs, rj) {
	  return initCompletePromiseResolve = rs, initCompletePromiseReject = rj;
	});

	// promise (always non-null) which resolves after Config.init is called,
	// even if it wasn't completed yet (if it never gets called, the promise won't get resolved)
	var initInvokedPromiseResolve;
	var initInvokedPromiseReject;
	Config.initInvokedPromise = new Promise(function (rs, rj) {
	  return initInvokedPromiseResolve = rs, initInvokedPromiseReject = rj;
	});

	/**
	 * Returns value of the specified setting from *global* configuration. If no name is given,
	 * map with all settings is returned.
	 * 
	 * @param {string} name The setting whose value to return. If not given,
	 *   map with all settings is returned.
	 * @param {boolean} [recursive=true] Whether to lookup the setting recursively. For example
	 *   retrieving value for name "A.B.C.logLevel" would try "A.B.C.logLevel" first,
	 *   then "A.B.logLevel", then "A.logLevel" and finally "logLevel".
	 * @see UuApp.Util.Config#get
	 * @method UuApp.Util.Config.get
	 */
	Config.get = function () {
	  return globalConfig.get.apply(globalConfig, arguments);
	};

	function initInstance(options) {
	  if (this.initInvoked) throw new Error("UuApp.Util.Config can be initialized only once (#init method). " + "If a private / separate environment is needed, use new UuApp.Util.Config().");
	  this.initInvoked = true;

	  // load environment (sync / async)
	  var loadResult;
	  if (typeof options == "string") {
	    this.initUrl = arguments[0];
	    loadResult = load.apply(this, arguments); // it's a URL
	  } else if (options != null && typeof options.then === "function") loadResult = { promise: Promise.resolve(options) }; // it's a Promise
	  else if (options == null || (typeof options === "undefined" ? "undefined" : _typeof(options)) == "object" || typeof options == "function") loadResult = { immediateResult: options }; // it's a direct value
	    else throw new Error("UuApp.Util.Config can be initialized only with object-like structure, but typeof says '" + (typeof options === "undefined" ? "undefined" : _typeof(options)) + "'. Initialized with: " + JSON.stringify(options));

	  // process load result
	  if (loadResult.immediateResult) {
	    this._env = loadResult.immediateResult;
	    this.initComplete = true;
	    this.initPromise = Promise.resolve(this);
	  } else {
	    this.initPromise = loadResult.promise.then(function (env) {
	      this._env = env;
	      this.initComplete = true;
	      return this;
	    }.bind(this)); // in case of error just propagate it (no error handler here) - we don't want to call services against wrong domains (config contains gateway URIs, ...) 
	  }

	  return this.initPromise;
	}

	function load(url, options) {
	  var result;
	  var p = new Promise(function (resolve, reject) {
	    if (!url) return resolve({});
	    var opts = options || {};

	    var xhr = new XMLHttpRequest();
	    xhr.open("GET", url, opts.sync !== true);
	    xhr.setRequestHeader("Accept", "application/json");
	    xhr.onerror = function (e) {
	      return reject(new Error("Unable to load environment configuration from " + url + " - network error."));
	    };
	    xhr.onload = function (e) {
	      if (xhr.status >= 200 && xhr.status < 300) {
	        try {
	          result = (xhr.responseText ? JSON.parse(xhr.responseText) : null) || {};
	          resolve(result || {});
	          return;
	        } catch (e) {
	          reject(new Error("Unable to load environment configuration from " + url + " - not a JSON. Response:\n" + xhr.responseText));
	        }
	      } else {
	        reject(new Error("Unable to load environment configuration from " + url + " - status " + xhr.status + ". Response:\n" + xhr.responseText));
	      }
	    };
	    xhr.send(null);
	  });
	  return { immediateResult: result, promise: p };
	}

	// if running in browser with SystemJS loader, use UU_ENVIRONMENT module if it's configured
	var inited = false;
	if (typeof window != "undefined") {
	  if (typeof System != "undefined" && window && System && System.has && System.get && System.normalizeSync) {
	    try {
	      // for backward compatibility try initialization via module named "UU_ENVIRONMENT"
	      var normModule = System.normalizeSync("UU_ENVIRONMENT");
	      if (System.has(normModule)) {
	        // the module has been already instantiated
	        var mod = System.get(normModule);
	        Config.init(mod["default"] || mod);
	        if (!normModule.match(/\/UU_ENVIRONMENT$/)) globalConfig.initUrl = normModule;
	        inited = true;
	      } else if (!normModule.match(/\/UU_ENVIRONMENT$/)) {
	        // the module is not ready yet but it is defined (has configured URL to be downloaded from)
	        Config.init(System.import("UU_ENVIRONMENT"));
	        globalConfig.initUrl = normModule;
	        inited = true;
	      }
	    } catch (e) {
	      console.error("Failed to initialize configuration from UU_ENVIRONMENT. Error:", e);
	    }
	  }
	  // initialize configuration from UU5.Environment variable
	  if (!inited && window.UU5 && window.UU5.Environment) {
	    Config.init(window.UU5.Environment);
	    inited = true;
	  }
	}

	module.exports = Config;

/***/ },
/* 20 */
/*!******************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/logging/index.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LoggerFactory = exports.Logger = undefined;

	var _Logger = __webpack_require__(/*! ./Logger.js */ 21);

	var _Logger2 = _interopRequireDefault(_Logger);

	var _LoggerFactory = __webpack_require__(/*! ./LoggerFactory.js */ 22);

	var _LoggerFactory2 = _interopRequireDefault(_LoggerFactory);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Logger = _Logger2.default;
	exports.LoggerFactory = _LoggerFactory2.default;

/***/ },
/* 21 */
/*!*******************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/logging/Logger.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// TODO Change into ES6 imports / exports. Beware that some tests are run via Node environment
	// and it doesn't recognize import / export statements (so tests will stop working). Might get it working
	// by running tests against dist-node/ folder (where the files are downcompiled to ES5).
	var Config = __webpack_require__(/*! ../util/Config.js */ 19);

	/**
	 * @class UuApp.Logging.Logger
	 * @classdesc
	 * Component for logging. Each logged message has a severity level and each logger can be
	 * configured to process only messages with sufficient severity level. Loggers are hierarchical,
	 * i.e. when configuration is processed they inherit severity level from parent modules/packages.
	 * 
	 * Contrary to usual <code>console.log</code>, <code>console.error</code>, ... statements (which
	 * are typically removed from production code), statements using Logger-s are intended to be
	 * preserved in the production environment and turned on/off via {@link UuApp.Util.Config Config}
	 * configuration.
	 * 
	 * **Configuration**
	 * 
	 * Default severity level for loggers is Logger.LEVEL_WARN. Logging is automatically configured from the
	 * global configuration (initialized via {@link UuApp.Util.Config Config.init} call).
	 * Supported environment options:
	 * 
	 *     {
	 *       "logLevel": "ERROR",
	 *       "My.Namespace.logLevel": "WARN"
	 *     }
	 * 
	 * As already said, loggers are hierarchical - with configuration above, logger "My.Namespace.Component"
	 * would have logLevel "WARN" whereas logger "My" would have logLevel "ERROR". Hierarchical logging can
	 * be turned off when initializing a logger - see {@link UuApp.Logging.LoggerFactory.get LoggerFactory.get}.
	 * 
	 * **Typical usage**
	 * 
	 *     // get logger instance and log a message
	 *     var logger = UuApp.Logging.LoggerFactory.get("My.Namespace.Component");
	 *     logger.warn("Universe expansion is accelerating.", {speedBefore: 68, speedAfter: 68.01});
	 *     
	 *     // if logging requires lenghty computation, it can be made conditional so that it
	 *     // doesn't slow down the rest of page if the message wouldn't get logged in the end
	 *     if (logger.isDebugLoggable()) {
	 *       var computedValue = ...; // some lenghty computation
	 *       logger.debug("Value computed to", computedValue);
	 *     }
	 *     
	 */
	function Logger(name) {
	  var _this = this;

	  if (!priv.allowLoggerNew) throw new Error("Use UuApp.Logging.LoggerFactory.get(name) to get an instance of Logger.");
	  this.name = name;

	  // logger can be configured after delay because Util.Config can be loaded asynchronously,
	  // therefore we'll buffer the debug/info/warn/error calls until the configuration is ready
	  var ready = false;
	  this._buffer = [];
	  Object.defineProperty(this, "ready", {
	    get: function get() {
	      return ready && (!Config.initInvoked || Config.initComplete);
	    },
	    set: function set(value) {
	      ready = value;
	      if (ready) flushBuffer.call(_this);
	    }
	  });
	}
	var priv = Logger.priv = {}; // TODO This is not-so-ellegant solution for allowing UriBuilder to call Uri constructor (and forbid it for everyone else).

	/** @name UuApp.Logging.Logger.LEVEL_DEBUG */
	/** @name UuApp.Logging.Logger.LEVEL_INFO */
	/** @name UuApp.Logging.Logger.LEVEL_WARN */
	/** @name UuApp.Logging.Logger.LEVEL_ERROR */
	/** @name UuApp.Logging.Logger.LEVEL_OFF */
	var levels = { DEBUG: 100, INFO: 200, WARN: 300, ERROR: 400, OFF: Math.MAX_VALUE };
	var levelsInverted = Object.keys(levels).reduce(function (r, name) {
	  return r[levels[name]] = name, r;
	}, {}); // { 100: "DEBUG", ...}
	Object.keys(levels).forEach(function (level) {
	  // publish levels as constants
	  Logger["LEVEL_" + level.toUpperCase()] = levels[level];
	});

	/**
	 * Sets severity level of this Logger to given value. Messages with lower (less important)
	 * severity will be ignored when attempted to be logged via this logger. Order of importance:
	 * DEBUG < INFO < WARN < ERROR < OFF.
	 * 
	 * **It's strongly advised not to configure loggers directly using this method** because
	 * if such code gets deployed to production, it'll effectively override settings from
	 * environment and therefore could prevent logging of necessary information.
	 * **Use environment configuration instead - see Configuration chapter in {@link UuApp.Logging.Logger Logger}.
	 * 
	 * @param {(number|string)} level Severity level to set. See Logger.LEVEL_* constants. If null
	 *   is given, default is used (LEVEL_WARN).
	 * @method UuApp.Logging.Logger#setLevel
	 */
	Logger.prototype.setLevel = function (level) {
	  if (level == null) level = Logger.LEVEL_WARN;
	  var num = typeof level == "string" ? levels[level.toUpperCase()] : Number(level);
	  if (typeof num != "number" || isNaN(num)) return; // ignore
	  this.level = num;
	};

	/**
	 * @return {number} Level of this logger.
	 * @method UuApp.Logging.Logger#getLevel
	 */
	Logger.prototype.getLevel = function () {
	  return this.level;
	};

	/**
	 * @return {string} Upper-cased name of the level, such as "ERROR".
	 * @method UuApp.Logging.Logger#getLevelName
	 */
	Logger.prototype.getLevelName = function () {
	  return levelsInverted[this.level];
	};
	Logger.prototype.level = levels.WARN;

	/**
	 * Logs message with severity level "DEBUG".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#debug
	 */
	Logger.prototype.debug = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "debug", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.DEBUG) logToAppenders.call(this, { level: levels.DEBUG, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};

	/**
	 * @return {boolean} Whether this logger logs message with severity level "DEBUG".
	 * @method UuApp.Logging.Logger#isDebugLoggable
	 */
	Logger.prototype.isDebugLoggable = function () {
	  return !this.ready || this.level <= levels.DEBUG;
	};

	/**
	 * Logs message with severity level "INFO".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#info
	 */
	Logger.prototype.info = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "info", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.INFO) logToAppenders.call(this, { level: levels.INFO, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};
	/**
	 * @return {boolean} Whether this logger logs message with severity level "INFO".
	 * @method UuApp.Logging.Logger#isInfoLoggable
	 */
	Logger.prototype.isInfoLoggable = function () {
	  return !this.ready || this.level <= levels.INFO;
	};
	/**
	 * Logs message with severity level "WARN".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#warn
	 */
	Logger.prototype.warn = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "warn", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.WARN) logToAppenders.call(this, { level: levels.WARN, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};
	/**
	 * @return {boolean} Whether this logger logs message with severity level "WARN".
	 * @method UuApp.Logging.Logger#isWarnLoggable
	 */
	Logger.prototype.isWarnLoggable = function () {
	  return !this.ready || this.level <= levels.WARN;
	};
	/**
	 * Logs message with severity level "ERROR".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#error
	 */
	Logger.prototype.error = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "error", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.ERROR) logToAppenders.call(this, { level: levels.ERROR, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};
	/**
	 * @return {boolean} Whether this logger logs message with severity level "ERROR".
	 * @method UuApp.Logging.Logger#isErrorLoggable
	 */
	Logger.prototype.isErrorLoggable = function () {
	  return !this.ready || this.level <= levels.ERROR;
	};

	function logToAppenders(opts) {
	  // TODO Add support for appenders. Currently we'll log only to the console.
	  // TODO Might want to collect additional information (stack frames, ...) - https://github.com/stacktracejs/stacktrace.js
	  // log to console
	  var msg = this.name + ": " + opts.message;
	  Logger.console[levelsInverted[opts.level].toLowerCase()].apply(Logger.console, [msg].concat(opts.args));
	}
	function logToBuffer(method, args) {
	  this._buffer.push({ method: method, args: args });
	}
	function flushBuffer() {
	  var _this2 = this;

	  var v = this._buffer;
	  this._buffer = [];
	  v.forEach(function (it) {
	    return _this2[it.method].apply(_this2, it.args);
	  }); // re-run each method
	}

	// NOTE Logger-s append to Logger.console instead of directly console object
	// so that this can be mocked in tests.
	Logger.console = console;

	// export
	module.exports = Logger;

/***/ },
/* 22 */
/*!**************************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/logging/LoggerFactory.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Logger = __webpack_require__(/*! ./Logger.js */ 21);
	var Config = __webpack_require__(/*! ../util/Config.js */ 19);

	var loggers = {};
	var LoggerFactory = {};
	var loggerPriv = Logger.priv;
	// delete Logger.priv;

	/**
	 * @class UuApp.Logging.LoggerFactory
	 * @classdesc
	 * Factory class for getting access to loggers. See {@link UuApp.Logging.Logger Logger} for more information.
	 */

	/**
	 * Returns an instance of the logger with given name. Settings of the logger are
	 * taken from global configuration (see {@link UuApp.Util.Config.init Config.init}).
	 * Default global logLevel is Logger.{@link UuApp.Logging.Logger.LEVEL_WARN LEVEL_WARN}.
	 * 
	 * Successive calls with the same logger name return the same logger instance.
	 * 
	 * @param {string} name The name of the logger. Typically, it's a fully-qualified name of
	 *   the component that uses the logger, e.g. "My.Namespace.Component".
	 * @param {boolean} hierarchical Whether the logger shall inherit settings from its parent
	 *   package names, e.g. whether logger with name "My.Namespace" should inherit logLevel from "My"
	 *   or from root (hierarchical = true, default) or only settings directly for "My.Namespace" apply
	 *   (hierarchical = false). The parameter is used only during 1st invocation for given logger name,
	 *   in successive calls it's ignored.
	 * @return {UuApp.Logging.Logger} An instance of the logger with given name.
	 * @method UuApp.Logging.LoggerFactory.get
	 */
	LoggerFactory.get = function (name, hierarchical) {
	  if (typeof name != "string") throw new Error("LoggerFactory.get() must be called with a string argument (logger name).");
	  if (loggers[name]) return loggers[name].logger;
	  loggerPriv.allowLoggerNew = true;
	  var logger;
	  try {
	    // create & configure the logger (configure only if configuration is not being loaded at the moment)
	    logger = new Logger(name);
	    if (!Config.initInvoked || Config.initComplete) configure(logger, hierarchical, Config);
	  } finally {
	    loggerPriv.allowLoggerNew = false;
	  }
	  return (loggers[name] = { logger: logger, hierarchical: hierarchical }).logger;
	};

	// configures logger from given environment object
	function configure(logger, hierarchical, env) {
	  // only "logLevel" is currently recognized
	  var logLevel = env.get(logger.name + ".logLevel", hierarchical !== false);
	  logger.setLevel(logLevel);

	  logger.ready = true;
	}

	// create root logger
	Logger.getRootLogger = function () {
	  return rootLogger;
	};
	loggerPriv.allowLoggerNew = true;
	loggers[""] = { logger: new Logger(""), hierarchical: false };
	var rootLogger = loggers[""].logger;
	loggerPriv.allowLoggerNew = false;

	// re-configure existing loggers after global configuration is loaded (if loggers were created sooner than
	// configuration got loaded)
	if (!Config.initComplete) {
	  Config.initInvokedPromise.then(function () {
	    // change loggers to "not-ready" state (they'll buffer logging calls)
	    for (var k in loggers) {
	      loggers[k].logger.ready = false;
	    }
	  });
	  Config.initCompletePromise.then(function (env) {
	    // re-configure loggers and switch to "ready" state
	    for (var k in loggers) {
	      configure(loggers[k].logger, loggers[k].hierarchical, env);
	    }
	  });
	}

	module.exports = LoggerFactory;

/***/ },
/* 23 */
/*!******************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/perflog/index.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PerfLog = undefined;

	var _PerfLog = __webpack_require__(/*! ./PerfLog.js */ 24);

	var _PerfLog2 = _interopRequireDefault(_PerfLog);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.PerfLog = _PerfLog2.default;

/***/ },
/* 24 */
/*!********************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/perflog/PerfLog.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _LoggerFactory = __webpack_require__(/*! ../logging/LoggerFactory.js */ 22);

	var _LoggerFactory2 = _interopRequireDefault(_LoggerFactory);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var perfLog = _LoggerFactory2.default.get("UuApp.Perflog.PerfLog", false);

	var PerfLog = {
	  measureSection: function measureSection(name /*, (optional) attrs, measuredFn*/) {
	    var measuredFn = arguments[arguments.length - 1];
	    var attrs = arguments.length > 2 ? arguments[1] : null;
	    var section = new Section(createSectionId(), name, attrs);
	    var r;
	    try {
	      r = Promise.resolve(measuredFn(section));
	    } catch (e) {
	      r = Promise.reject(e);
	    }
	    function close() {
	      section.close();
	    }
	    return r.then(close, close);
	  }
	};

	var Section = function Section(id, name, attrs) {
	  this.id = id;
	  this.name = name;
	  this.attributes = attrs || {};
	  this.checkpoints = {};
	  this.start = Date.now();
	};
	Section.prototype.setCheckpoint = function (name) {
	  this.checkpoints[name] = Date.now;
	};
	Section.prototype.close = function () {
	  if (this.finish) return;
	  this.finish = Date.now();
	  this.duration = this.finish - this.start;
	  perfLog.info(JSON.stringify(this));
	};

	var rootId;
	function createSectionId() {
	  if (!rootId) rootId = createIdSegment();
	  var childId = createIdSegment();
	  return rootId + "-" + rootId + "-" + childId + "-0000";
	}
	function createIdSegment() {
	  var s = [];
	  for (var i = 0; i < 4; ++i) {
	    s.push((Math.random() * 65536 | 0).toString(16));
	  } // 4 * 4 hexa digits
	  return s.join("");
	}

	exports.default = PerfLog;

/***/ },
/* 25 */
/*!**************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/uri/index.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.UriBuilder = exports.Uri = undefined;

	var _Uri = __webpack_require__(/*! ./Uri.js */ 26);

	var _Uri2 = _interopRequireDefault(_Uri);

	var _UriBuilder = __webpack_require__(/*! ./UriBuilder.js */ 27);

	var _UriBuilder2 = _interopRequireDefault(_UriBuilder);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Uri = _Uri2.default;
	exports.UriBuilder = _UriBuilder2.default;

/***/ },
/* 26 */
/*!************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/uri/Uri.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Err = __webpack_require__(/*! ../error/Error.js */ 13);

	/**
	 * @class UuApp.Uri.Uri
	 * @classdesc
	 * Immutable representation of uuUri. An instance of the Uri can be obtained either by
	 * {@link UuApp.Uri.Uri.parse Uri.parse} or by using {@link UuApp.Uri.UriBuilder UriBuilder} class.
	 * Note that minimal Uri consists of at least "app" and "tid".
	 * 
	 * Examples of usage:
	 * 
	 *     // uri from parsing current location
	 *     var locationUri = Uri.parse(location.protocol + "//" + location.host + location.pathname); // "http://example.com/vendor-app/0-0/some/uc"
	 *     var baseUri = locationUri.baseUri; // "http://example.com/vendor-app/0-0"
	 *     var callUri = baseUri.join("+/getConfig"); // "http://example.com/vendor-app/0-0/getConfig"
	 *    
	 *     // uri from parsing
	 *     var uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app-subapp-spp/tid-awid/useCase?p1=v1");
	 *     console.log(uri.gateway, uri.product, uri.workspace, uri.useCase); 
	 *     var params = uri.parameters; // always returns new copy of parameter map
	 *     for (var k in params) console.log(k, "=", params[k]); // p1 = v1
	 *     
	 *     // uri from UriBuilder
	 *     var uri2 = UuApp.Uri.UriBuilder.parse(uri).setWorkspace("0-0").setUseCase("sys/init").toUri();
	 *     console.log(uri2.toString()); // https://uuos9.plus4u.net/vendor-app-subapp-spp/0-0/sys/init?p1=v1
	 *     
	 *     // uri from parsing (with ECMAScript6 template string, e.g. when using transpilers like Babel)
	 *     // Note that query parameter values shouldn't be injected via template string as they might need
	 *     // to be encoded first.
	 *     var product = "vendor-app";
	 *     var workspace = "tid-awid";
	 *     var uri3 = UuApp.Uri.Uri.parse(`https://uuos9.plus4u.net/${product}/${workspace}`);
	 *    
	 * @see UuApp.Uri.UriBuilder
	 */

	// NOTE Constructor is "private".
	var priv = Uri.priv = {}; // TODO This is not-so-ellegant solution for allowing UriBuilder to call Uri constructor (and forbid it for everyone else).
	var EMPTY = {};
	function Uri(scheme, hostname, port, vendor, app, subApp, spp, tid, awid, useCase, parameters) {
	  var _this = this;

	  if (!priv.allowNew) throw new Err("Use UuApp.Uri.Uri.parse to obtain an instance of uuUri.");

	  useCase = useCase ? useCase.replace(/^\//, "") : useCase; // strip leading slash from useCase
	  if (port && typeof port != "number") port = parseInt(port + "", 10);
	  if ((port == null || port === "") && scheme) port = scheme.match(/^https$/) ? 443 : 80;
	  var gateway = { value: EMPTY, lazyGet: function lazyGet() {
	      return gateway.value !== EMPTY ? gateway.value : gateway.value = _this.Builder.formatGateway(scheme, hostname, port);
	    } };
	  var product = { value: EMPTY, lazyGet: function lazyGet() {
	      return product.value !== EMPTY ? product.value : product.value = _this.Builder.formatProduct(vendor, app, subApp, spp);
	    } };
	  var workspace = { value: EMPTY, lazyGet: function lazyGet() {
	      return workspace.value !== EMPTY ? workspace.value : workspace.value = _this.Builder.formatWorkspace(tid, awid);
	    } };
	  var params = Object.assign({}, parameters); // make a copy to guard against mutation of original "parameters" object
	  var uri = this;

	  // NOTE Attributes are defined as properties so that they throw error when developer
	  // tries tu mutate them (even in non-strict mode).
	  function throwOnSet(attr) {
	    return function () {
	      throw new Err("Cannot set " + attr + " on Uri because instances of Uri are immutable. Use UriBuilder instead.");
	    };
	  }
	  Object.defineProperties(this, {
	    /** @name UuApp.Uri.Uri#scheme */
	    scheme: { get: function get() {
	        return scheme;
	      }, set: throwOnSet("scheme") },

	    /** @name UuApp.Uri.Uri#hostname */
	    hostname: { get: function get() {
	        return hostname;
	      }, set: throwOnSet("hostname") },

	    /** @name UuApp.Uri.Uri#port */
	    port: { get: function get() {
	        return port;
	      }, set: throwOnSet("port") },

	    /**
	     * Formatted string containing scheme, hostname and port. For example for scheme "https",
	     * hostname "example.com" and port "123" it returns "https://example.com:123".
	     * 
	     * @name UuApp.Uri.Uri#gateway
	     */
	    gateway: { get: gateway.lazyGet, set: throwOnSet("gateway") },

	    /** @name UuApp.Uri.Uri#vendor */
	    vendor: { get: function get() {
	        return vendor;
	      }, set: throwOnSet("vendor") },

	    /** @name UuApp.Uri.Uri#app */
	    app: { get: function get() {
	        return app;
	      }, set: throwOnSet("app") },

	    /** @name UuApp.Uri.Uri#subApp */
	    subApp: { get: function get() {
	        return subApp;
	      }, set: throwOnSet("subApp") },

	    /** @name UuApp.Uri.Uri#spp */
	    spp: { get: function get() {
	        return spp;
	      }, set: throwOnSet("spp") },

	    /** @name UuApp.Uri.Uri#product */
	    product: { get: product.lazyGet, set: throwOnSet("product") },

	    /** @name UuApp.Uri.Uri#tid */
	    tid: { get: function get() {
	        return tid;
	      }, set: throwOnSet("tid") },

	    /** @name UuApp.Uri.Uri#awid */
	    awid: { get: function get() {
	        return awid;
	      }, set: throwOnSet("awid") },

	    /** @name UuApp.Uri.Uri#workspace */
	    workspace: { get: workspace.lazyGet, set: throwOnSet("workspace") },

	    /** @name UuApp.Uri.Uri#useCase */
	    useCase: { get: function get() {
	        return useCase;
	      }, set: throwOnSet("useCase") },

	    /**
	     * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
	     * Note that each access returns new copy of the map (to achieve immutability of the Uri class),
	     * therefore usage should look like this:
	     * 
	     *     // OPTIMAL (single read of "parameters" field on uri)
	     *     var params = uri.parameters;
	     *     for (var k in params) console.log(params[k]);
	     *     
	     *     // SUB-OPTIMAL (multiple reads and therefore multiple copying of parameter map)
	     *     // for (var k in uri.parameters) console.log(uri.parameters[k]);
	     * 
	     * @name UuApp.Uri.Uri#parameters
	     */
	    parameters: { get: function get() {
	        return Object.assign({}, params);
	      }, set: throwOnSet("parameters") },

	    /**
	     * URI containing only mandatory routing data (includes only "gateway", "product" and "workspace").
	     * @name UuApp.Uri.Uri#baseUri
	     */
	    baseUri: { get: getBaseUri, set: throwOnSet("baseUri") },
	    /**
	     * Relative URI (without "gateway").
	     * @name UuApp.Uri.Uri#relativeUri
	     */
	    relativeUri: { get: getRelativeUri, set: throwOnSet("relativeUri") }
	  });

	  var baseUri, relativeUri;
	  function getBaseUri() {
	    if (baseUri !== undefined) return baseUri;
	    if (uri.gateway == null || uri.product == null || uri.workspace == null) throw new Err("Insufficient URI - at least one of gateway, product and workspace is not set. Uri: " + uri.toString());
	    baseUri = uri.Builder.parse(uri).set({ useCase: null }).clearParameters().toUri();
	    return baseUri;
	  }
	  function getRelativeUri() {
	    if (relativeUri !== undefined) return relativeUri;
	    relativeUri = uri.Builder.parse(uri).set({ gateway: null }).toUri();
	    return relativeUri;
	  }

	  var str;
	  /**
	   * Converts URI to string.
	   * 
	   * @return URI converted to string.
	   * @method UuApp.Uri.Uri#toString
	   */
	  this.toString = function () {
	    return str !== undefined ? str : str = _this.Builder.format(_this);
	  };

	  //    /**
	  //     * Converts URI to an object literal (a map) containing keys scheme, hostname, ...
	  //     * 
	  //     * @function UuApp.Uri.Uri#toObject
	  //     */
	  //    this.toObject = () => ({
	  //      scheme: scheme, hostname: hostname, port: port, vendor: vendor, app: app, subApp: subApp, spp: spp,
	  //      tid: tid, awid: awid, useCase: useCase, parameters: Object.assign({}, params)
	  //    });

	  // serialize as string when stringifying to JSON
	  this.toJSON = this.toString;

	  // prevent any modification of the Uri object
	  Object.freeze(this);
	}

	/**
	 * Replaces current path with specified absolute path (or adds a relative path to the current path) returning new Uri.
	 * Query parameters are preserved only on last path. Resolving relative path and usage of "./" and "../" works as in standard
	 * URLs (see {@link https://tools.ietf.org/html/rfc2396#appendix-C RFC 2396, examples}).
	 * 
	 * Additionally, it's possible to use "+/" at the beginning of paths - paths starting
	 * with "+/" are joined as if current path (to which new path is being joined) denoted a "folder", i.e. current path
	 * is appended with slash (unless it already ends with slash) and new path is appended afterwards (see examples). 
	 * 
	 * @param {...string} path Absolute or relative paths to replace / add.
	 * @return New Uri whose path is the result of the join.
	 * @method UuApp.Uri.Uri#join
	 * @example
	 *  // replace path with an absolute path (effectively removing also query parameters)
	 *  var uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1?a=b");
	 *  var uri2 = uri.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
	 *  
	 *  // add relative paths
	 *  var uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1");
	 *  var uri2 = uri.join("sys/init?p=v");             // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init?p=v
	 *  var uri3 = uri.join("+/sys/init?p=v");           // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?p=v
	 *  var uri4 = uri.join("+/sys/?a=b", "init?c=d");   // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?c=d
	 */
	Uri.prototype.join = function () /* ... */{
	  if (arguments.length <= 0) return this;
	  var root = this.gateway || "";
	  var path = this.toString().substr(root.length);

	  for (var i = 0; i < arguments.length; ++i) {
	    var pathPart = arguments[i];
	    if (!pathPart) continue;
	    path = path.replace(/[?#].*/, ""); // remove query part because we're going to add / replace path
	    pathPart = pathPart.replace(/((^|\/)\.\.?)$/, "$1/"); // if new path part ends with two dots / one dot, treat it as a "folder", i.e. append "/"
	    if (pathPart.charAt(0) == "/") path = pathPart; // new path part is absolute => replace whole path
	    else if (pathPart.match(/^\+(\/|$)/)) path = path.replace(/\/?$/, "/") + pathPart; // new path part is relative with "+/" => append "/" and then new path
	      else if (path.charAt(path.length - 1) == "/") path += pathPart; // new path part is relative and current path is a "folder" => append new path
	        else path = path.replace(/(^|\/)[^\/]*$/, "$1") + pathPart; // new path part is relative and current path is not a "folder" => replace last segment of current path
	  }

	  // normalize (modify segments to eliminate "../" and "./" from the path)
	  var segments = [];
	  path.split("/").forEach(function (part) {
	    if (part === "..") segments.pop();else if (part !== "." && part !== "+") segments.push(part);
	  });
	  if (segments[0] !== "") segments.unshift(""); // make sure that after "join" operation the path starts with "/"
	  var resultPath = segments.join("/");
	  return Uri.parse(root + resultPath);
	};

	/**
	 * Checks whether the other URI is equal to this one and returns true iff it is.
	 * 
	 * @param {UuApp.Uri.Uri} uri Uri to check equality against.
	 * @return True iff the specified uri is equal to this one.
	 * @method UuApp.Uri.Uri#equals
	 */
	Uri.prototype.equals = function (aUri2) {
	  return this.toString() === (aUri2 || "").toString();
	};

	/**
	 * @param {(string|UuApp.Uri.Uri)} uriStr The string to parse as URI. If an instance of Uri class is given, it's returned as-is.
	 * @return {UuApp.Uri.Uri} Parsed URI.
	 * @method UuApp.Uri.Uri.parse
	 * @example
	 *    var uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app/tid-awid/useCase?p1=v1");
	 *    console.log(uri.gateway, uri.product, uri.workspace, uri.useCase, uri.parameters);
	 */
	Uri.parse = function (uriStr) {
	  if (uriStr instanceof Uri) return uriStr;
	  return Uri.prototype.Builder.parse(uriStr).toUri();
	};

	module.exports = Uri;

/***/ },
/* 27 */
/*!*******************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/uri/UriBuilder.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Err = __webpack_require__(/*! ../error/Error.js */ 13);
	var Uri = __webpack_require__(/*! ./Uri.js */ 26);
	var UriParser = __webpack_require__(/*! ./UriParser.js */ 28);

	/**
	 * Creates an instance of UriBuilder.
	 * 
	 * @class UuApp.Uri.UriBuilder
	 * @classdesc
	 * Class for building uuUri. Typical usage:
	 *     
	 *     // starting from current location
	 *     var uriBuilder = UriBuilder.parse(location.protocol + "//" + location.host + location.pathname);
	 *     var uri1 = uriBuilder.setUseCase("sys/init").setParameters({ p1: "v1" }).toUri();
	 *     console.log(uri1.toString()); // <gateway>/<product>/<workspace>/sys/init?p1=v1
	 *     
	 *     // starting anew, using gateway from main HTML page location
	 *     var gateway = location.origin || (location.protocol + "//" + location.host);
	 *     var uri2 = UriBuilder.set({
	 *       gateway: gateway,
	 *       product: "uu-demoapp-main",
	 *       workspace: "tid123-awid456",
	 *       parameters: { p1: "v1", p2: "v2" }
	 *     }).toUri(); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p1=v1&p2=v2
	 *     
	 *     // parameters example
	 *     var uriBuilder = UriBuilder.parse(uri2);
	 *     var uri3 = uriBuilder.deleteParameter("p1").mergeParameters({ p3: "v3" }).toUri();
	 *     console.log(uri3.toString()); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p2=v2&p3=v3
	 *
	 * @see {@link UuApp.Uri.UriBuilder.parse UriBuilder.parse}
	 * @see {@link UuApp.Uri.UriBuilder.set UriBuilder.set}
	 * @see {@link UuApp.Uri.UriBuilder#toUri UriBuilder#toUri}
	 */

	function UriBuilder() {
	  var _this = this;

	  var self = this;
	  if (!(self instanceof UriBuilder)) return new (UriBuilder.bind.apply(UriBuilder, arguments))(); // make an instance even if developer forgot to use "new" keyword

	  // define properties (setters have validation)
	  var priv = { parameters: {} };
	  /** @name UuApp.Uri.UriBuilder#scheme */
	  /** @name UuApp.Uri.UriBuilder#hostname */
	  /** @name UuApp.Uri.UriBuilder#vendor */
	  /** @name UuApp.Uri.UriBuilder#app */
	  /** @name UuApp.Uri.UriBuilder#subApp */
	  /** @name UuApp.Uri.UriBuilder#spp */
	  /** @name UuApp.Uri.UriBuilder#tid */
	  /** @name UuApp.Uri.UriBuilder#awid */
	  /** @name UuApp.Uri.UriBuilder#useCase */
	  ["scheme", "hostname", "vendor", "app", "subApp", "spp", "tid", "awid", "useCase"].forEach(function (attr) {
	    var validateFn = UriParser["validate" + attr.replace(/^./, function (m) {
	      return m.toUpperCase();
	    })];
	    Object.defineProperty(_this, attr, {
	      get: function get() {
	        return priv[attr];
	      },
	      set: function set(value) {
	        if (value != null) validateFn(value);
	        priv[attr] = value != null ? value : null;
	      }
	    });
	  });
	  Object.defineProperties(this, {
	    /** @name UuApp.Uri.UriBuilder#port */
	    port: {
	      get: function get() {
	        return priv.port != null ? Number(priv.port) : priv.port;
	      }, // convert to number
	      set: function set(value) {
	        if (value != null) UriParser.validatePort(value);
	        priv.port = value != null ? value : null;
	      }
	    },
	    /** @name UuApp.Uri.UriBuilder#gateway */
	    gateway: {
	      get: function get() {
	        return UriBuilder.formatGateway(priv.scheme, priv.hostname, priv.port);
	      },
	      set: function set(value) {
	        var obj = value != null ? UriParser.parseGateway(value) : null;
	        priv.scheme = obj && obj.scheme || null;
	        priv.hostname = obj && obj.hostname || null;
	        priv.port = obj && obj.port != null ? obj.port : null;
	      }
	    },
	    /** @name UuApp.Uri.UriBuilder#product */
	    product: {
	      get: function get() {
	        return UriBuilder.formatProduct(priv.vendor, priv.app, priv.subApp, priv.spp);
	      },
	      set: function set(value) {
	        var obj = value ? UriParser.parseProduct(value) : {};
	        priv.vendor = obj.vendor || null;
	        priv.app = obj.app || null;
	        priv.subApp = obj.subApp || null;
	        priv.spp = obj.spp || null;
	      }
	    },
	    /** @name UuApp.Uri.UriBuilder#workspace */
	    workspace: {
	      get: function get() {
	        return UriBuilder.formatWorkspace(priv.tid, priv.awid);
	      },
	      set: function set(value) {
	        var obj = value ? UriParser.parseWorkspace(value) : {};
	        priv.tid = obj.tid || null;
	        priv.awid = obj.awid || null;
	      }
	    },
	    /**
	     * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
	     * Note that each access returns new copy of the map (to prevent modification of the map without
	     * validating the values / keys).
	     * 
	     *     // BAD (uri.parameters returns copy; modification is not propagated back to UriBuilder)
	     *     uriBuilder.parameters["myParam"] = "value";
	     *     
	     *     // GOOD
	     *     uriBuilder.setParameter("myParam", "value");
	     * 
	     * @name UuApp.Uri.UriBuilder#parameters
	     */
	    parameters: {
	      get: function get() {
	        return Object.assign({}, priv.parameters);
	      },
	      set: function set(value) {
	        priv.parameters = {};
	        if (value) for (var k in value) {
	          this.setParameter(k, value[k]);
	        }
	      }
	    }
	  });

	  /**
	   * Sets query parameter with given name to given value.
	   * 
	   * @param {string} name The parameter name.
	   * @param {string} value The parameter value.
	   * @return This UriBuilder instance for chaining operations.
	   * @method UuApp.Uri.UriBuilder#setParameter
	   */
	  this.setParameter = function (name, value) {
	    UriParser.validateParameterName(name);
	    UriParser.validateParameterValue(value);
	    priv.parameters[name] = value;
	    return this;
	  };

	  /**
	   * Removes query parameter with given name.
	   * 
	   * @param {string} name The parameter name.
	   * @return This UriBuilder instance for chaining operations.
	   * @method UuApp.Uri.UriBuilder#deleteParameter
	   */
	  this.deleteParameter = function (name) {
	    UriParser.validateParameterName(name);
	    delete priv.parameters[name];
	    return this;
	  };

	  /**
	   * Removes all query parameters.
	   * 
	   * @return This UriBuilder instance for chaining operations.
	   * @method UuApp.Uri.UriBuilder#clearParameters
	   */
	  this.clearParameters = function () {
	    priv.parameters = {};
	    return this;
	  };
	}

	/**
	 * Parses URI string (or Uri instance) and resets all fields of this UriBuilder
	 * to parsed values.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri URI to parse.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#parse
	 */
	UriBuilder.prototype.parse = function (uriObj) {
	  var uri = typeof uriObj == "string" ? UriParser.parse(uriObj, UriBuilder).toUri() : uriObj;
	  this.gateway = uri.gateway;
	  this.product = uri.product;
	  this.workspace = uri.workspace;
	  this.useCase = uri.useCase;
	  this.parameters = uri.parameters;
	  return this;
	};

	/**
	 * Equivalent to <code>new UriBuilder().parse(uri)</code>.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri URI to parse.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.parse
	 * @see UuApp.Uri.UriBuilder#parse
	 */
	UriBuilder.parse = function (uri) {
	  return new UriBuilder().parse(uri);
	};

	/**
	 * Sets fields of this UriBuilder to given values.
	 * 
	 * @param {...Object} fieldMap Object(s) containing fields to set to this UriBuilder. If more objects are given,
	 *   fields in latter ones override fields in former ones.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#set
	 * @example
	 *   // replace spp, awid & remove useCase
	 *   var resUri = UriBuilder.parse(someUri).set({
	 *     spp: "async",
	 *     awid: "12345",
	 *     useCase: null
	 *   }).toUri();
	 *   
	 *   // multiple settings
	 *   var defaults = { gateway: "...", product: "uu-demoapp-main", tid: "0", awid: "0" };
	 *   var resUri = UriBuilder.set(defaults, {
	 *     tid: "12f34", // overrides the one from "defaults" variable
	 *     useCase: "getData"
	 *   }).toUri();
	 */
	UriBuilder.prototype.set = function () /* ... */{
	  for (var i = 0; i < arguments.length; ++i) {
	    var hash = arguments[i];
	    if (!hash) continue;
	    if ((typeof hash === "undefined" ? "undefined" : _typeof(hash)) != "object") continue;
	    for (var k in hash) {
	      this[k] = hash[k];
	    }
	  }
	  return this;
	};

	/**
	 * Equivalent to <code>new UriBuilder().set(...)</code>.
	 * 
	 * @param {...Object} fieldMap Object(s) containing fields to set to the UriBuilder. If more objects are given,
	 *   fields in latter ones override fields in former ones.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.set
	 * @see UuApp.Uri.UriBuilder#set
	 */
	UriBuilder.set = function () /* ... */{
	  var builder = new UriBuilder();
	  return builder.set.apply(builder, arguments);
	};

	// add chainable setter functions
	/**
	 * Equivalent to <code>new UriBuilder().setScheme(value)</code>.
	 * 
	 * @param {string} value Scheme to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setScheme
	 * @see UuApp.Uri.UriBuilder#setScheme
	 */
	/**
	 * Chainable setter for scheme.
	 * 
	 * @param {string} value Scheme to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setScheme
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setHostname(value)</code>.
	 * 
	 * @param {string} value Hostname to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setHostname
	 * @see UuApp.Uri.UriBuilder#setHostname
	 */
	/**
	 * Chainable setter for hostname.
	 * 
	 * @param {string} value Hostname to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setHostname
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setPort(value)</code>.
	 * 
	 * @param {(string|number)} value Port to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setPort
	 * @see UuApp.Uri.UriBuilder#setPort
	 */
	/**
	 * Chainable setter for port.
	 * 
	 * @param {string} value Port to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setPort
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setGateway(value)</code>.
	 * 
	 * @param {string} value Gateway to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setGateway
	 * @see UuApp.Uri.UriBuilder#setGateway
	 */
	/**
	 * Chainable setter for gateway.
	 * 
	 * @param {string} value Gateway to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setGateway
	 */

	/**
	 * Equivalent to <code>new UriBuilder().setVendor(value)</code>.
	 * 
	 * @param {string} value Vendor to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setVendor
	 * @see UuApp.Uri.UriBuilder#setVendor
	 */
	/**
	 * Chainable setter for vendor.
	 * 
	 * @param {string} value Vendor to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setVendor
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setApp(value)</code>.
	 * 
	 * @param {string} value Application to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setApp
	 * @see UuApp.Uri.UriBuilder#setApp
	 */
	/**
	 * Chainable setter for application.
	 * 
	 * @param {string} value Application to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setApp
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setSubApp(value)</code>.
	 * 
	 * @param {string} value Sub-application to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setSubApp
	 * @see UuApp.Uri.UriBuilder#setSubApp
	 */
	/**
	 * Chainable setter for sub-application.
	 * 
	 * @param {string} value Sub-application to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setSubApp
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setSpp(value)</code>.
	 * 
	 * @param {string} value SPP to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setSpp
	 * @see UuApp.Uri.UriBuilder#setSpp
	 */
	/**
	 * Chainable setter for SPP.
	 * 
	 * @param {string} value SPP to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setSpp
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setProduct(value)</code>.
	 * 
	 * @param {string} value Product to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setProduct
	 * @see UuApp.Uri.UriBuilder#setProduct
	 */
	/**
	 * Chainable setter for product.
	 * 
	 * @param {string} value Product to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setProduct
	 */

	/**
	 * Equivalent to <code>new UriBuilder().setTid(value)</code>.
	 * 
	 * @param {string} value Tenant ID to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setTid
	 * @see UuApp.Uri.UriBuilder#setTid
	 */
	/**
	 * Chainable setter for tenant ID.
	 * 
	 * @param {string} value Tenant ID to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setTid
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setAwid(value)</code>.
	 * 
	 * @param {string} value Workspace ID to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setAwid
	 * @see UuApp.Uri.UriBuilder#setAwid
	 */
	/**
	 * Chainable setter for workspace ID.
	 * 
	 * @param {string} value Workspace ID to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setAwid
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setWorkspace(value)</code>.
	 * 
	 * @param {string} value Workspace to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setWorkspace
	 * @see UuApp.Uri.UriBuilder#setWorkspace
	 */
	/**
	 * Chainable setter for workspace.
	 * 
	 * @param {string} value Workspace to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setWorkspace
	 */

	/**
	 * Equivalent to <code>new UriBuilder().setUseCase(value)</code>.
	 * 
	 * @param {string} value Use case to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setUseCase
	 * @see UuApp.Uri.UriBuilder#setUseCase
	 */
	/**
	 * Chainable setter for use case.
	 * 
	 * @param {string} value Use case to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setUseCase
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setParameters(value)</code>.
	 * 
	 * @param {string} value Parameters to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setParameters
	 * @see UuApp.Uri.UriBuilder#setParameters
	 */
	/**
	 * Chainable setter for parameters (replaces all parameters).
	 * 
	 * @param {string} value Parameters to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setParameters
	 */
	["scheme", "hostname", "port", "gateway", "vendor", "app", "subApp", "spp", "product", "tid", "awid", "workspace", "useCase", "parameters"].forEach(function (attr) {
	  var setterFnName = "set" + attr.replace(/^./, function (m) {
	    return m.toUpperCase();
	  });
	  UriBuilder.prototype[setterFnName] = function (value) {
	    // "instance" method
	    this[attr] = value;
	    return this;
	  };
	  UriBuilder[setterFnName] = function (value) {
	    // "static" method
	    return new UriBuilder()[setterFnName](value);
	  };
	});
	/**
	 * Equivalent to <code>new UriBuilder().setParameter(name, value)</code>.
	 * 
	 * @param {string} name The parameter name.
	 * @param {string} value The parameter value.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setParameter
	 * @see UuApp.Uri.UriBuilder#setParameter
	 */
	UriBuilder.setParameter = function (name, value) {
	  return new UriBuilder().setParameter(name, value);
	};

	/**
	 * Merges (replaces / adds) provided parameters into the ones already present
	 * in this UriBuilder.
	 * 
	 * @param {Object} map Map with parameters to merge.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#mergeParameters
	 */
	UriBuilder.prototype.mergeParameters = function (value) {
	  if (value) for (var k in value) {
	    this.setParameter(k, value[k]);
	  }return this;
	};

	/**
	 * Replaces current path with specified absolute path (or adds a relative path to the current path) for this UriBuilder.
	 * Works exactly the same way as {@link UuApp.Uri.Uri#join Uri#join} but returns UriBuilder instead of Uri.
	 * 
	 * @param {...string} path Absolute or relative paths to replace / add.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#join
	 * @see UuApp.Uri.Uri#join
	 * @example
	 *  // replace path with an absolute path
	 *  var srcUri = "https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1";
	 *  var uriBuilder = UriBuilder.parse(srcUri);
	 *  uriBuilder.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
	 *  
	 *  // add relative paths
	 *  var uriBuilder = UriBuilder.parse(srcUri);
	 *  uriBuilder.join("./sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init
	 *  var uriBuilder = UriBuilder.parse(srcUri);
	 *  uriBuilder.join("+/sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init
	 */
	UriBuilder.prototype.join = function () /* ... */{
	  var uri = this.toUri();
	  return this.parse(uri.join.apply(uri, arguments));
	};

	var uriPriv = Uri.priv;
	// delete Uri.priv;
	/**
	 * Returns Uri instance from current values of this UriBuilder.
	 * 
	 * @return {UuApp.Uri.Uri} Uri instance from current values of this UriBuilder.
	 * @method UuApp.Uri.UriBuilder#toUri
	 */
	UriBuilder.prototype.toUri = function () {
	  var missing = [];
	  if (this.scheme == null && (this.hostname != null || this.port != null)) missing.push("scheme");
	  if (this.hostname == null && (this.scheme != null || this.port != null)) missing.push("hostname");
	  if (this.vendor == null && (this.subApp != null || this.spp != null)) missing.push("vendor");
	  if (this.app == null) missing.push("app");
	  if (this.subApp == null && this.spp != null) missing.push("subApp");
	  if (this.awid == null) missing.push("awid");
	  if (missing.length) throw new Err("Missing Uri parts: " + missing.join(", ") + ". Values: " + this.toString());

	  uriPriv.allowNew = true;
	  try {
	    return new Uri(this.scheme, this.hostname, this.port, this.vendor, this.app, this.subApp, this.spp, this.tid, this.awid, this.useCase, this.parameters);
	  } finally {
	    uriPriv.allowNew = false;
	  }
	};

	/**
	 * Formats current values of this UriBuilder into a URI-like string.
	 * 
	 * @return {string} Formatted string from current values of this UriBuilder.
	 * @method UuApp.Uri.UriBuilder#toString
	 * @example
	 *   var uriBuilder = UriBuilder.parse("https://uuos9.plus4u.net/vendor-app/tid-awid");
	 *   uriBuilder.toString(); // https://uuos9.plus4u.net/vendor-app/tid-awid
	 */
	UriBuilder.prototype.toString = function () {
	  return UriBuilder.format(this.toUri());
	};

	/**
	 * Formats current values of this UriBuilder into a URI-like string.
	 * 
	 * @return {string} Formatted string from current values of this UriBuilder.
	 * @method UuApp.Uri.UriBuilder#format
	 * @example
	 *   var uriBuilder = UriBuilder.parse("https://uuos9.plus4u.net/vendor-app/tid-awid");
	 *   uriBuilder.format(); // https://uuos9.plus4u.net/vendor-app/tid-awid
	 */
	UriBuilder.prototype.format = function () {
	  return UriBuilder.format(this.toUri());
	};

	UriBuilder.format = function (uri) {
	  return UriParser.format(uri);
	};

	UriBuilder.formatGateway = function (scheme, hostname, port) {
	  return UriParser.formatGateway(scheme, hostname, port);
	};
	UriBuilder.formatProduct = function (vendor, app, subApp, spp) {
	  return UriParser.formatProduct(vendor, app, subApp, spp);
	};
	UriBuilder.formatWorkspace = function (tid, awid) {
	  return UriParser.formatWorkspace(tid, awid);
	};

	Uri.prototype.Builder = UriBuilder;

	module.exports = UriBuilder;

/***/ },
/* 28 */
/*!******************************************************!*\
  !*** ../~/uu_appg01_core/dist-node/uri/UriParser.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Err = __webpack_require__(/*! ../error/Error.js */ 13);

	var ASSET_CLASSIFIER = "static|assets|public";
	var UNRESERVED = "[\\w\\.\\-~]";
	var IDENTIFIER = "[a-zA-Z0-9_]";
	var PATH = "[\\w\\.\\-~\/]";
	var SCHEME = "(" + UNRESERVED + "+)";

	// No reason to match IPv4 (invalid IP address is always
	// matched as generic hostname - we cannot distinguish them)
	// IPV4_PART = "(25[0-5]|2[0-5][0-9]|1[0-9][0-9]|[0-9][0-9]?)"
	// IPV4 = "(#{IPV4_PART}(\\.#{IPV4_PART}){3})"

	// Only rough validation
	// see http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
	var IPV6_PART = "([0-9a-fA-F]{1,4})";
	var IPV6 = "(\\[" + IPV6_PART + "(:(" + IPV6_PART + ")?){1,7}\\])";

	var HOSTNAME = "(" + IPV6 + "|" + UNRESERVED + "+)";
	var PORT = "(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[0-5][0-9]{4}|[1-9][0-9]{0,3})";
	var GATEWAY = "(" + SCHEME + "://" + HOSTNAME + "(:" + PORT + ")?)";
	var VENDOR = "(" + IDENTIFIER + "{1,32})";
	var APP = "(" + IDENTIFIER + "{1,32})";
	var SUB_APP = "(" + IDENTIFIER + "{1,32})";
	var SPP = "(" + IDENTIFIER + "{1,32})";
	var PRODUCT = "(?=[^/]{1,131}(?:/|$))((?:" + VENDOR + "\\-)?" + APP + "(?:\\-" + SUB_APP + "(?:\\-" + SPP + ")?)?)";
	var TID = "(" + IDENTIFIER + "{1,32})";
	var AWID = "(" + IDENTIFIER + "{1,32})";
	var WORKSPACE = "(?=[^/\\?]{1,65}(?:/|\\?|$))((?:" + TID + "\\-)?" + AWID + ")";
	var USE_CASE = "(" + PATH + "*)";
	var PARAMETER_NAME = "(?:" + UNRESERVED + "+)";
	var PARAMETER_VALUE = "(?:[^=&]*)";
	var PARAMETER = "(?:" + PARAMETER_NAME + "(?:=" + PARAMETER_VALUE + ")?)";
	var PARAMETERS = "(" + PARAMETER + "(?:&" + PARAMETER + ")*)";
	var URI_REGEXP = new RegExp("^(?:" + GATEWAY + ")?\\/" + PRODUCT + "\\/" + WORKSPACE + "(?:/" + USE_CASE + ")?(?:\\?" + PARAMETERS + "?)?$");

	// console.log("https://uuos9.plus4u.net:80/vnd-app-subapp-spp/tid-awid/some/long/uc?p1=v1&p2=v2&p3=%25".match(URI_REGEXP));                // non-opaque
	//
	// ["https://uuos9.plus4u.net:80/vnd-app-subapp-spp/tid-awid/some/long/uc?p1=v1&p2=v2&p3=%25", "https://uuos9.plus4u.net:80", "https", "uuos9.plus4u.net", undefined,
	//  undefined, undefined, undefined, undefined, ":80",
	//  "80", "vnd-app-subapp-spp", "vnd", "app", "subapp",
	//  "spp", "tid-awid", "tid", "awid", "/some/long/uc",
	//  "p1=v1&p2=v2&p3=%25", index: 0, input: "https://uuos9.plus4u.net:80/vnd-app-subapp-spp/tid-awid/some/long/uc?p1=v1&p2=v2&p3=%25"]

	var UriParser = {
	  ASSET_CLASSIFIER: ASSET_CLASSIFIER, UNRESERVED: UNRESERVED, IDENTIFIER: IDENTIFIER, SCHEME: SCHEME, IPV6_PART: IPV6_PART, IPV6: IPV6, HOSTNAME: HOSTNAME, PORT: PORT, GATEWAY: GATEWAY, VENDOR: VENDOR, APP: APP, SUB_APP: SUB_APP,
	  SPP: SPP, PRODUCT: PRODUCT, TID: TID, AWID: AWID, WORKSPACE: WORKSPACE, USE_CASE: USE_CASE, PARAMETER_NAME: PARAMETER_NAME, PARAMETER_VALUE: PARAMETER_VALUE, PARAMETER: PARAMETER, PARAMETERS: PARAMETERS, URI_REGEXP: URI_REGEXP,

	  parse: function parse(str, UriBuilder) {
	    if (!UriBuilder) throw new Err("UriBuilder must be provided.");
	    var result = (str || "").match(URI_REGEXP);
	    //      console.log(result);
	    if (!result) throw new Err("Parse error - invalid uri: " + (str || ""));
	    var uriBuilder = new UriBuilder().set({
	      scheme: result[2],
	      hostname: result[3],
	      port: result[10],
	      vendor: result[12],
	      app: result[13],
	      subApp: result[14],
	      spp: result[15],
	      tid: result[17],
	      awid: result[18],
	      useCase: result[19]
	    });
	    var params = result[20];
	    if (params) {
	      params.split("&").forEach(function (pair) {
	        if (!pair) return;
	        var eqlSignIdx = pair.indexOf("=");
	        var k = eqlSignIdx != -1 ? pair.substr(0, eqlSignIdx) : pair;
	        var v = eqlSignIdx != -1 ? pair.substr(eqlSignIdx + 1) : "";
	        uriBuilder.setParameter(k, decodeURIComponent(v)); // key contains only URL-safe characters
	      });
	    }
	    return uriBuilder;
	  },
	  format: function format(uri) {
	    var parts = [];
	    parts.push((uri.gateway || "") + "/" + (uri.product || "") + "/" + (uri.workspace || ""));
	    var uc = uri.useCase;
	    if (uc) {
	      if (uc.charAt(0) != "/") parts.push("/");
	      parts.push(uc);
	    }
	    parts = [parts.join("").replace(/\/+$/, "")]; // remove all trailing slashes
	    var params = uri.parameters;
	    var paramKeys = Object.keys(params);
	    paramKeys.sort();
	    for (var i = 0; i < paramKeys.length; ++i) {
	      var k = paramKeys[i];
	      parts.push(i ? "&" : "?");
	      parts.push(k);
	      var value = params[k];
	      if (value == null || value === "") continue;
	      parts.push("=");
	      parts.push(encodeURIComponent(value));
	    }
	    return parts.join("");
	  },
	  parseGateway: function parseGateway(value) {
	    if (typeof value != "string") throw new InvalidUriPartError("gateway", value, GATEWAY);
	    var result = value.match(new RegExp("^" + GATEWAY + "$"));
	    if (!result) throw new InvalidUriPartError("gateway", value, GATEWAY);
	    //  console.log(result);
	    //      ["http://example.com:123", "http://example.com:123", "http",
	    //       "example.com", undefined, undefined,
	    //       undefined, undefined, undefined,
	    //       ":123", "123"]
	    return { scheme: result[2], hostname: result[3], port: result[10] };
	  },
	  formatGateway: function formatGateway(scheme, hostname, port) {
	    if (!scheme && !hostname && !port) return null;
	    UriParser.validateScheme(scheme);
	    UriParser.validateHostname(hostname);
	    if (port != null) UriParser.validatePort(port);
	    return scheme + "://" + hostname + (port != null ? ":" + port : "");
	  },
	  parseProduct: function parseProduct(value) {
	    if (typeof value != "string") throw new InvalidUriPartError("product", value, PRODUCT);
	    var result = value.match(new RegExp("^" + PRODUCT + "$"));
	    if (!result) throw new InvalidUriPartError("product", value, PRODUCT);
	    return { vendor: result[2], app: result[3], subApp: result[4], spp: result[5] };
	  },
	  formatProduct: function formatProduct(vendor, app, subApp, spp) {
	    if (!vendor && !app && !subApp && !spp) return null;
	    if (vendor) UriParser.validateVendor(vendor);
	    UriParser.validateApp(app);
	    if (subApp) UriParser.validateSubApp(subApp);
	    if (spp) UriParser.validateSpp(spp);

	    var result = [];
	    if (vendor) result.push(vendor + "-");
	    result.push(app);
	    if (subApp) result.push("-" + subApp);
	    if (spp) result.push("-" + spp);
	    return result.join("");
	  },
	  parseWorkspace: function parseWorkspace(value) {
	    if (typeof value != "string") throw new InvalidUriPartError("workspace", value, WORKSPACE);
	    var result = value.match(new RegExp("^" + WORKSPACE + "$"));
	    if (!result) throw new InvalidUriPartError("workspace", value, WORKSPACE);
	    return { tid: result[2], awid: result[3] };
	  },
	  formatWorkspace: function formatWorkspace(tid, awid) {
	    if (!tid && !awid) return null;
	    if (tid) UriParser.validateTid(tid);
	    UriParser.validateAwid(awid);

	    var result = [];
	    if (tid) result.push(tid + "-");
	    result.push(awid);
	    return result.join("");
	  },
	  validateScheme: function validateScheme(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + SCHEME + "$"))) throw new InvalidUriPartError("scheme", value, SCHEME);
	  },
	  validateHostname: function validateHostname(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + HOSTNAME + "$"))) throw new InvalidUriPartError("hostname", value, HOSTNAME);
	  },
	  validatePort: function validatePort(value) {
	    value = typeof value == "number" ? value + "" : value;
	    if (typeof value != "string" || !value.match(new RegExp("^" + PORT + "$"))) throw new InvalidUriPartError("port", value, PORT);
	  },
	  validateGateway: function validateGateway(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + GATEWAY + "$"))) throw new InvalidUriPartError("gateway", value, GATEWAY);
	  },
	  validateVendor: function validateVendor(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + VENDOR + "$"))) throw new InvalidUriPartError("vendor", value, VENDOR);
	  },
	  validateApp: function validateApp(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + APP + "$"))) throw new InvalidUriPartError("app", value, APP);
	  },
	  validateSubApp: function validateSubApp(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + SUB_APP + "$"))) throw new InvalidUriPartError("subApp", value, SUB_APP);
	  },
	  validateSpp: function validateSpp(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + SPP + "$"))) throw new InvalidUriPartError("spp", value, SPP);
	  },
	  validateProduct: function validateProduct(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + PRODUCT + "$"))) throw new InvalidUriPartError("product", value, PRODUCT);
	  },
	  validateTid: function validateTid(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + TID + "$"))) throw new InvalidUriPartError("tid", value, TID);
	  },
	  validateAwid: function validateAwid(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + AWID + "$"))) throw new InvalidUriPartError("awid", value, AWID);
	  },
	  validateWorkspace: function validateWorkspace(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + WORKSPACE + "$"))) throw new InvalidUriPartError("workspace", value, WORKSPACE);
	  },
	  validateUseCase: function validateUseCase(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + USE_CASE + "$"))) throw new InvalidUriPartError("useCase", value, USE_CASE);
	  },
	  validateParameterName: function validateParameterName(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + PARAMETER_NAME + "$"))) throw new InvalidUriPartError("parameterName", value, PARAMETER_NAME);
	  },
	  validateParameterValue: function validateParameterValue(value) {
	    if (value != null && typeof value != "string") throw new InvalidUriPartError("parameterValue", value, String);
	    // for our generic uuUri following check is always true; will skip for optimization
	    //      if (value != null && !encodeURIComponent(value).match(new RegExp("^" + PARAMETER_VALUE + "$"))) throw new InvalidUriPartError("parameterValue", value, PARAMETER_VALUE);
	  }
	};

	function InvalidUriPartError(partName, value, expected) {
	  var message;
	  if (typeof expected != "string") message = "Value \"" + value + "\" of URI part [" + partName + "] must be " + expected + " but is typeof " + (typeof value === "undefined" ? "undefined" : _typeof(value));else message = "Value \"" + value + "\" of URI part [" + partName + "] does not match regular expression /" + expected.replace(/\//g, "\\/") + "/";
	  Err.call(this, message);
	}
	InvalidUriPartError.prototype = Object.create(Err.prototype);
	InvalidUriPartError.prototype.constructor = InvalidUriPartError;

	module.exports = UriParser;

/***/ },
/* 29 */
/*!*******************!*\
  !*** ./Client.js ***!
  \*******************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var UuApp = _interopRequireWildcard(_uu_appg01_core);

	var _uu_oidcg = __webpack_require__(/*! uu_oidcg01 */ 30);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * @class UuApp.Client
	 * @classdesc
	 * The Client allows communication with remote uuOS9 endpoints which conform to uuUri format.
	 * In addition to the basic UuApp.AppClient.Client, this client is preconfigured to use authentication
	 * via uuOS OpenID Connect server.
	 * 
	 * See {@link UuApp.AppClient.Client} for standard usage scenarios and configuration, as well as 
	 * {@link UuOidc.Session} for basic session handling examples.
	 * 
	 * @see UuApp.AppClient.Client
	 * @see UuOidc.Session
	 */
	function Client() /*...*/{
	  UuApp.AppClient.Client.apply(this, arguments);
	  this.defaults = Client.defaults;
	}
	Client.prototype = Object.create(UuApp.AppClient.Client.prototype);
	Client.prototype.constructor = Client;

	// use UuApp default client when invoking get/post
	var defClient;
	/**
	 * @name UuApp.Client.get
	 * @see UuApp.AppClient.Client.get
	 */
	Client.get = function () {
	  if (!defClient) defClient = new Client();
	  return defClient.get.apply(defClient, arguments);
	};
	/**
	 * @name UuApp.Client.post
	 * @see UuApp.AppClient.Client.post
	 */
	Client.post = function (uri, parameters, options) {
	  if (!defClient) defClient = new Client();
	  return defClient.post.apply(defClient, arguments);
	};

	// delegate this Client's defaults to UuApp.AppClient.Client defaults, but override interceptors
	var A = function A() {};
	A.prototype = UuApp.AppClient.Client.defaults;
	Client.defaults = new A();
	var interceptors = [].concat(UuApp.AppClient.Client.defaults.interceptors); // make copy
	interceptors.splice(interceptors.indexOf(UuApp.AppClient.Client.UriHandler) + 1, 0, _uu_oidcg.SessionHandler); // add after UriHandler
	/**
	 * @name UuApp.Client.defaults
	 * @see UuApp.AppClient.Client.defaults
	 */
	Client.defaults.interceptors = interceptors;

	// export
	exports.default = Client;

/***/ },
/* 30 */
/*!******************************************!*\
  !*** ../~/uu_oidcg01/dist-node/index.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SessionHandler = exports.Session = undefined;

	var _Session = __webpack_require__(/*! ./Session.js */ 31);

	var _Session2 = _interopRequireDefault(_Session);

	var _SessionHandler = __webpack_require__(/*! ./SessionHandler.js */ 52);

	var _SessionHandler2 = _interopRequireDefault(_SessionHandler);

	__webpack_require__(/*! ./bootstrap-session.js */ 53);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// make UuOidc always present in global variable so that there're no issues
	// with detecting it (even during load via SystemJS)
	if (typeof window !== "undefined") window.UuOidc = { Session: _Session2.default, SessionHandler: _SessionHandler2.default };

	exports.Session = _Session2.default;
	exports.SessionHandler = _SessionHandler2.default;

/***/ },
/* 31 */
/*!********************************************!*\
  !*** ../~/uu_oidcg01/dist-node/Session.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var _Defaults = __webpack_require__(/*! ./Defaults.js */ 32);

	var _Defaults2 = _interopRequireDefault(_Defaults);

	var _ImplicitFlow = __webpack_require__(/*! ./flow/ImplicitFlow.js */ 33);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	var _SessionContext = __webpack_require__(/*! ./SessionContext.js */ 46);

	var _SessionContext2 = _interopRequireDefault(_SessionContext);

	var _Uuid = __webpack_require__(/*! ./util/Uuid.js */ 47);

	var _Uuid2 = _interopRequireDefault(_Uuid);

	var _Os8Auth = __webpack_require__(/*! ./uuos8/Os8Auth.js */ 48);

	var _Os8Auth2 = _interopRequireDefault(_Os8Auth);

	var _PromiseUtil = __webpack_require__(/*! ./util/PromiseUtil.js */ 36);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	var _StringUtil = __webpack_require__(/*! ./util/StringUtil.js */ 49);

	var _StringUtil2 = _interopRequireDefault(_StringUtil);

	var _IframeComponent = __webpack_require__(/*! ./ui/IframeComponent.js */ 39);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	var _SessionStateChangeNotifier = __webpack_require__(/*! ./SessionStateChangeNotifier.js */ 50);

	var _SessionStateChangeNotifier2 = _interopRequireDefault(_SessionStateChangeNotifier);

	var _Discovery = __webpack_require__(/*! ./discovery/Discovery.js */ 34);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var UuAppError = _uu_appg01_core.Error.Error;
	var logger = _uu_appg01_core.Logging.LoggerFactory.get("UuOidc.Session");

	var Session = function () {

	  /**
	   * Creates new Session with specified options.
	   * 
	   * @class UuOidc.Session
	   * @classdesc
	   * 
	   * Session handling via OpenID Connect server.
	   * 
	   * **Configuration**
	   * 
	   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback
	   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be
	   * configured as described below - configuration parameter "uuoidc.redirectUri".
	   * 
	   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:
	   * 
	   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
	   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for
	   *   accessing most of user data.
	   * * **uuoidc.redirectUri** - redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
	   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
	   *   to document.baseURI (current URL). Default is "callbacks/oidc-callback.html".
	   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is "https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be".
	   * * **uuoidc.sessionExpiringNotificationTime** - a "sessionExpiring" notification event is triggered these many seconds prior to the session expiration.
	   *   Default is 5 minutes. Using 0 disables the notification.
	   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
	   *   Default is 5. Using 0 disables the checking.
	   * 
	   * **Supported events**
	   * 
	   * It's possible to handle session state changes and other notifications by registering a listener function to any of these events
	   * (see also {@link UuOidc.Session#addListener}):
	   * 
	   * * **identityChange** - triggerred whenever an identity changes (user logs in / out / changes its authorization status). Event's
	   * "data" field contains the new identity (see {@link UuOidc.Session#getIdentity}).
	   * * **sessionExpiring** - triggerred some time before the global session against OpenID Connect server expires. The application
	   * can show a warning at this moment and suggest to the user to re-login themselves. Re-login can be initiated by
	   * {@link UuOidc.Session#login Session#login}({ prompt: "login" }) which forces a popup window to be shown.
	   * The event's "data" field contains an object with following fields:
	   *     * expiresAt - time in milliseconds when the expiration of the global session will occur.
	   * * **sessionExtended** - trigerred after the global session against OpenID Connect server has been extended. The application should
	   * remove the warning about necessity of user re-login if it's showing one (i.e. if there happenned a sessionExpiring event, the user
	   * re-logged in, possibly in different browser tab, then the application should no longer display any warning about sessionExpiring).
	   * The event's "data" field contains an object with following fields:
	   *     * expiresAt - time in milliseconds when the expiration of the global session will occur
	   * 
	   * @param options {Object|UuApp.Util.Config} Options.
	   * @param options.serverUri OpenID Connect server to perform login / logout against.
	   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
	   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
	   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
	   *   to document.baseURI (current URL).
	   * @param options.sessionExpiringNotificationTime A "sessionExpiring" notification event is triggered these many seconds prior to the session expiration.
	   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
	   */
	  function Session(options) {
	    var _this = this;

	    _classCallCheck(this, Session);

	    if (!options) throw new UuAppError("Session must be initialized with proper options or UuApp.Util.Config.");
	    this._optionsMergedPromise = _PromiseUtil2.default.wrapForImmediateThen(Promise.resolve(options && typeof options.get == "function" ? options.initPromise : options).then(function (env) {
	      Object.keys(_Defaults2.default).forEach(function (k) {
	        var v = void 0;
	        if (env && typeof env.get == "function") v = env.get("uuoidc." + k, false);else if (env) v = env[k];
	        if (v == null) v = _Defaults2.default[k];
	        _this[k === "redirectUri" ? "implicitFlowRedirectUri" : k] = v;
	      });
	      if (!_this.clientId) _this.clientId = "uu-oidc:unregistered-client:" + (0, _Uuid2.default)();
	      // if redirect URI is relative then absolutize it (relative to current document.baseURI)
	      if (!_this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) {
	        // no protocol present
	        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\/).*/, "$1");
	        if (_this.implicitFlowRedirectUri.charAt(0) != "/") _this.implicitFlowRedirectUri = toFullUrl(baseUrl + _this.implicitFlowRedirectUri);else _this.implicitFlowRedirectUri = toFullUrl(_this.implicitFlowRedirectUri);
	      }
	      // sanitize times & interval settings
	      if (typeof _this.sessionExpiringNotificationTime !== "number" || _this.sessionExpiringNotificationTime < 0) _this.sessionExpiringNotificationTime = _Defaults2.default.sessionExpiringNotificationTime;
	      if (typeof _this.sessionCheckInterval !== "number" || _this.sessionCheckInterval < 0) _this.sessionCheckInterval = _Defaults2.default.sessionCheckInterval;
	      if (_this.sessionCheckInterval > 0 && _this.sessionCheckInterval < 2) _this.sessionCheckInterval = 2; // minimal interval is 2, but allow "0" for disabling the check
	      if (typeof _this.tokenRefreshLeeway !== "number" || _this.tokenRefreshLeeway < 0) _this.tokenRefreshLeeway = _Defaults2.default.tokenRefreshLeeway;
	      if (typeof _this.tokenRefreshFailureRetryInterval !== "number" || _this.tokenRefreshFailureRetryInterval < 0) _this.tokenRefreshFailureRetryInterval = _Defaults2.default.tokenRefreshFailureRetryInterval;
	      if (_this.tokenRefreshFailureRetryInterval > 0) _this.tokenRefreshFailureRetryInterval = Math.max(5, _this.tokenRefreshFailureRetryInterval);

	      // add session state checking which, in case that we were logged in and a logout
	      // against OIDC is detected (e.g. in another browser tab), will log us out
	      if (_this.sessionCheckInterval) {
	        _this._sessionChecker = new _SessionStateChangeNotifier2.default(_this);
	        _this._sessionChecker.onStateChange(function () {
	          logger.debug("Session state change detected.");
	          if (!_this.isAuthenticated()) return; // don't check new state if we're currently logged out (don't auto-login)

	          // check login state against OpenID server (basically renew the token,
	          // possibly logging out if the current user on OpenID server differs from ours)
	          _this._silentTokenRefresh(true);
	        });
	      }
	    }));
	    this._loginInProgress = 0;
	    this._silentTokenRefreshInProgress = 0;
	    this.nonce = Math.random().toString(32).substr(2);

	    var listeners = {};
	    /**
	     * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:
	     * 
	     * * **type** The type of the event, e.g. "identityChange".
	     * * **data** The data passed to the event.
	     * 
	     * See {@link UuOidc.Session Session} for the list of supported events.
	     * 
	     * @param {string} eventName The event to register listener for.
	     * @param {function(Event)} listener The function to be called whenever the event is trigerred.
	     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeListener}).
	     * @see UuOidc.Session#removeListener
	     * @method UuOidc.Session#addListener
	     */
	    this.addListener = function (eventName, listener) {
	      var list = listeners[eventName];
	      if (!list) list = listeners[eventName] = [];
	      list.push(listener);
	      return _this.removeListener.bind(_this, eventName, listener);
	    };
	    /**
	     * Removes listener for specified event.
	     * 
	     * @param {string} eventName The event to remove listener for.
	     * @param {function(Event)} listener The listener (function) to unregister.
	     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
	     * @see UuOidc.Session#addListener
	     * @method UuOidc.Session#removeListener
	     */
	    this.removeListener = function (eventName, listener) {
	      var list = listeners[eventName];
	      if (!list) return false;
	      var idx = list.indexOf(listener);
	      if (idx != -1) list.splice(idx, 1);
	      return idx != -1;
	    };

	    this._runListeners = function (eventName, data) {
	      logger.debug("Launching event \"" + eventName + ".\"");
	      var list = listeners[eventName];
	      if (list) {
	        var e = {
	          type: eventName,
	          data: data
	        };
	        list.forEach(function (it) {
	          return it.call(_this, e);
	        });
	      }
	      // run also deprecated identityChangeListener-s (they don't get "event" object but directly the data)
	      // if this is "identityChange" event
	      // TODO 3.0 Remove.
	      if (eventName === "identityChange" && listeners["__identityChange"]) listeners["__identityChange"].forEach(function (it) {
	        return it.call(_this, data);
	      });
	    };

	    /**
	     * @return {boolean} True iff the user is authenticated (logged in).
	     * @method UuOidc.Session#isAuthenticated
	     */
	    this.isAuthenticated = function () {
	      return !!_this._loginCtx;
	    };

	    /**
	     * Adds listener for changes of user identity (logins / logouts).
	     * 
	     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.
	     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).
	     * @see UuOidc.Session#addListener
	     * @see UuOidc.Session#getIdentity
	     * @method UuOidc.Session#addIdentityChangeListener
	     * @deprecated Use Session#addListener("identityChange", listener) instead. Note that the listener accepts Event object.
	     */
	    this.addIdentityChangeListener = this.addListener.bind(this, "__identityChange");

	    /**
	     * Removes listener for changes of user identity (logins / logouts).
	     * 
	     * @param {Function(Object)} listener The listener to remove.
	     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
	     * @see UuOidc.Session#removeListener
	     * @method UuOidc.Session#removeIdentityChangeListener
	     * @deprecated Use Session#removeListener("identityChange", listener) instead.
	     */
	    this.removeIdentityChangeListener = this.removeListener.bind(this, "__identityChange");

	    // add session_expires_at field
	    // NOTE This is required for "auto-logout", "session expiring" and "session extended" functionality.
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run
	    // And that they are run pretty much immediately (so that authResponse.session_expires_in
	    // is relative to the moment when we received the response).
	    this.addListener("identityChange", function (e) {
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      if (!authResponse || !authResponse.session_expires_in) return;
	      if (authResponse.session_expires_at) return;
	      authResponse.session_expires_at = Math.floor(Date.now() / 1000) + Number(authResponse.session_expires_in);
	    });

	    // auto-logout when server-side session reaches its expiration time (or when token
	    // reaches its expiration time in case that server-side session info is not available)
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run
	    // (so that info from new token gets checked again).
	    this.addListener("identityChange", function (e) {
	      if (_this._autoLogoutTimeout) {
	        clearTimeout(_this._autoLogoutTimeout);
	        delete _this._autoLogoutTimeout;
	      }
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      if (!authResponse) return;

	      // plan local logout
	      var expiresAt = authResponse.session_expires_at || (_this.getClaims() || {})["exp"];
	      if (!expiresAt) return;
	      var now = new Date().getTime();
	      var delay = Math.max(0, expiresAt * 1000 - now);
	      logger.debug("Planning local auto-logout at " + toTimeString(new Date(now + delay)) + ".");
	      _this._autoLogoutTimeout = setTimeout(function () {
	        delete _this._autoLogoutTimeout;
	        _this._localLogout();
	      }, delay);
	    });

	    // support for token auto-refresh when its nearing expiration
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run
	    // (so that token refreshing gets re-planned / cleaned).
	    this.addListener("identityChange", function (e) {
	      if (!_this.tokenRefreshEnabled) return;

	      if (_this._sessionRefreshTimeout) {
	        clearTimeout(_this._sessionRefreshTimeout);
	        delete _this._sessionRefreshTimeout;
	      }
	      var claims = _this.getClaims();
	      var expiresAt = (claims || {})["exp"];
	      if (!expiresAt) return; // not logged in (or there's something with the claims but that shouldn't happen)

	      // plan token refresh
	      var now = new Date().getTime();
	      var delay = Math.max(0, expiresAt * 1000 - now - _this.tokenRefreshLeeway * 1000);
	      logger.debug("Planning token auto-refresh at " + toTimeString(new Date(now + delay)) + ".");
	      _this._sessionRefreshTimeout = setTimeout(function () {
	        delete _this._sessionRefreshTimeout;
	        _this._silentTokenRefresh();
	      }, delay);
	    });

	    // support for "session extended" notification
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run.
	    this.addListener("identityChange", function (e) {
	      var LEEWAY_MILLIS = 10 * 1000; // use leeway because server sends "session_expires_in" which is relative so if network becomes slower, we might then compute the "...expires_at" value as if it was greater than before
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      var wasExtended = _this._activeSessionExpiresAtMillis && authResponse && authResponse.session_expires_at * 1000 > _this._activeSessionExpiresAtMillis + LEEWAY_MILLIS;
	      _this._activeSessionExpiresAtMillis = authResponse ? authResponse.session_expires_at * 1000 : null;
	      if (wasExtended) {
	        _this._sessionExpiringBlocked = false;
	        var expiresAt = _this._activeSessionExpiresAtMillis;
	        setTimeout(function () {
	          // we're currently processing "identityChange" listeners so let them finish and run "sessionExtended" afterwards
	          _this._runListeners("sessionExtended", { expiresAt: expiresAt });
	        }, 0);
	      }
	    });

	    // support for "session expiring" notification
	    // NOTE Must be after "session extended" functionality (so that unblocking done there
	    // gets performed sooner than the code below).
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run.
	    var prevIdentity = undefined;
	    this.addListener("identityChange", function (e) {
	      if (_this.sessionExpiringNotificationTime <= 0) return; // disabled

	      if (_this._sessionExpiringTimeout) {
	        clearTimeout(_this._sessionExpiringTimeout);
	        delete _this._sessionExpiringTimeout;
	      }
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      var newIdentity = (_this.getClaims() || {})["sub"];
	      if (newIdentity != prevIdentity) _this._sessionExpiringBlocked = false;
	      prevIdentity = newIdentity;

	      if (!authResponse) return; // not logged in
	      if (!authResponse.session_expires_at) return; // "session expiring" notification not supported on server
	      if (_this._sessionExpiringBlocked) return; // don't trigger "session expiring" multiple times for the same session

	      var expiresAt = authResponse.session_expires_at * 1000;
	      var now = Date.now();
	      var delay = Math.max(0, expiresAt - now - _this.sessionExpiringNotificationTime * 1000);
	      logger.debug("Planning sessionExpiring notification at " + toTimeString(new Date(now + delay)) + ".");
	      _this._sessionExpiringTimeout = setTimeout(function () {
	        delete _this._sessionExpiringTimeout;
	        _this._sessionExpiringBlocked = true;
	        _this._runListeners("sessionExpiring", { expiresAt: expiresAt });
	      }, delay);
	    });
	  }

	  /**
	   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:
	   * 
	   * * id
	   * * name
	   * * uuIdentity
	   * * email
	   * * levelOfAssurance
	   * * loginLevelOfAssurance
	   * 
	   * @return {Object} Identity of currently logged in user or null if not logged in.
	   * @method UuOidc.Session#getIdentity
	   */


	  _createClass(Session, [{
	    key: "getIdentity",
	    value: function getIdentity() {
	      return this._loginCtx ? this._loginCtx.getIdentity() : null;
	    }

	    /**
	     * Returns all claims present in the token (or null if not logged in).
	     * 
	     * @method UuOidc.Session#getClaims
	     */

	  }, {
	    key: "getClaims",
	    value: function getClaims() {
	      return this._loginCtx ? this._loginCtx.getClaims() : null;
	    }

	    /**
	     * Login against OpenID Connect server. If no or empty options are used, user will be required to
	     * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in
	     * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can
	     * be forced by using option "prompt" set to "login".
	     * 
	     * @param options {Object} Options.
	     * @param options.prompt {string} (optional) One of "" (default), "none" (check login state without user interaction), "login" (re-request authentication).
	     * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).
	     * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.
	     * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it
	     *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:
	     * 
	     * * "urn:ietf:params:oauth:token-type:jwt-uuos8" - indicates that the token being passed to the login was originally issued by uuOS8
	     * 
	     * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained
	     *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:
	     * 
	     *   * false - user refused to log in
	     *   * Error - any other error such as network problems, ...
	     * 
	     * @method UuOidc.Session#login
	     */

	  }, {
	    key: "login",
	    value: function login(options) {
	      // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).

	      // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)
	      var opts;
	      if (options) opts = Object.keys(options).reduce(function (r, k) {
	        return r[_StringUtil2.default.toSnakeCase(k)] = options[k], r;
	      }, {});

	      return this._login(opts);
	    }

	    // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.

	  }, {
	    key: "_login",
	    value: function _login(options, canUpdateSessionWithLoginResultFn) {
	      var _this2 = this;

	      var opts = Object.assign({}, options);

	      // there's a special case in which we support providing uuOS8 token
	      var os8Token;
	      if (opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
	        os8Token = opts.access_token;
	        delete opts.access_token;
	        delete opts.token_type_hint;
	      }

	      // use accessToken directly if it's provided
	      var accessToken = opts.access_token;
	      delete opts.access_token;

	      var doLogin = function doLogin() {
	        ++_this2._loginInProgress;

	        // if calling Session.login() with no parameters, log in as non-anonymous user
	        if (Object.keys(opts).length == 0) opts["acr_values"] = 1;

	        // if we have user then login only if options indicate that we have to
	        if (!accessToken && _this2._loginCtx) {
	          var useCurrent = true;
	          if (opts["prompt"] || opts["max_age"] || opts["access_token"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.

	          // check required login level of assurance
	          var acr_values = (opts["acr_values"] != null ? opts["acr_values"] + "" : "").split(/\s+/);
	          var identity = _this2.getIdentity();
	          if (acr_values.every(function (v) {
	            return Number(v) > identity.loginLevelOfAssurance;
	          })) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login

	          // check current token expiration
	          if (_ImplicitFlow2.default.isAuthResponseExpired(_this2._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login

	          // use current token if everything seems fine
	          if (useCurrent) {
	            --_this2._loginInProgress;
	            return Promise.resolve(_this2);
	          }
	        }

	        // login using implicit flow
	        var authResponse = accessToken ? { id_token: accessToken } : null;
	        var nonce = accessToken || os8Token || "nonce" in opts ? opts["nonce"] : _this2.nonce;
	        opts.nonce = nonce;
	        delete opts.state; // we'll generate our own, if needed

	        // NOTE Clicking a button, which launches this login method, can result in
	        // at most 1 Promise resolution. If 2 or more Promises are chained, mobile
	        // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise
	        // is wrapped via PromiseUtil which then allows us here to call our "then" function immediately
	        // if the this._optionsMergedPromise has already been resolved.
	        // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)
	        // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is
	        // not trivial.
	        var authResponsePromise = Promise.resolve(authResponse || _PromiseUtil2.default.immediateThen(_this2._optionsMergedPromise, function () {
	          // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll
	          // do this by exchanging tokens via non-standard endpoint for uuOS8
	          if (os8Token) {
	            var os8Auth = new _Os8Auth2.default({
	              serverUri: _this2.serverUri,
	              clientId: _this2.clientId,
	              redirectUri: _this2.implicitFlowRedirectUri
	            });
	            return os8Auth.grantExchangeToken({
	              subject_token: os8Token
	            });
	          }

	          // authenticate using implicit flow
	          opts.state = Math.random().toString(32).substr(2);
	          return _ImplicitFlow2.default.login({
	            serverUri: _this2.serverUri,
	            clientId: _this2.clientId,
	            redirectUri: _this2.implicitFlowRedirectUri,
	            loginParams: opts
	          });
	        }, function (e) {
	          return Promise.reject(e);
	        }));
	        return authResponsePromise.then(function (authResponse) {
	          // validate response
	          return _this2._optionsMergedPromise.then(function () {
	            return _ImplicitFlow2.default.validateAuthResponse(authResponse, {
	              serverUri: _this2.serverUri,
	              clientId: _this2.clientId,
	              loginParams: opts
	            });
	          });
	        }).then(function (_ref) {
	          var authResponse = _ref.authResponse,
	              claims = _ref.claims;

	          // login successful => update the session
	          if (!canUpdateSessionWithLoginResultFn || canUpdateSessionWithLoginResultFn({ authResponse: authResponse, claims: claims }) !== false) {
	            _this2._loginCtx = new _SessionContext2.default(opts, authResponse, claims);
	            _this2._runListeners("identityChange", _this2.getIdentity());
	          }
	          return _this2;
	        }).then(function (r) {
	          --_this2._loginInProgress;
	          return r;
	        }, function (e) {
	          --_this2._loginInProgress;
	          return Promise.reject(e);
	        });
	      };

	      // wait for session restoring in case that this instance of the session is the "main" session
	      return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? _PromiseUtil2.default.immediateThen(Session.initPromise, doLogin) : doLogin();
	    }

	    /**
	     * Tries to re-authenticate the user silently:
	     * - if we are locally logged out => do nothing
	     * - if a user is logged in (on remote) and it's the same user as ours => use the new token
	     * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout
	     * - if a user is not logged in (on remote) => perform local logout
	     */

	  }, {
	    key: "_silentTokenRefresh",
	    value: function _silentTokenRefresh(aSkipIfPlanned) {
	      var _this3 = this;

	      if (aSkipIfPlanned && (this._silentTokenRefreshTimeout || this._silentTokenRefreshInProgress > 0)) return;

	      if (this._silentTokenRefreshTimeout) {
	        clearTimeout(this._silentTokenRefreshTimeout);
	        delete this._silentTokenRefreshTimeout;
	      }
	      var invocationCount = 0;
	      var doSilentRenew = function doSilentRenew() {
	        if (!_this3.isAuthenticated()) return;

	        logger.debug("Silent token refresh - starting.");
	        ++_this3._silentTokenRefreshInProgress;
	        ++invocationCount;
	        return _this3._login({
	          acr_values: "1",
	          prompt: "none"
	        }, function (_ref2) {
	          var claims = _ref2.claims;

	          --_this3._silentTokenRefreshInProgress;
	          if (!_this3.isAuthenticated()) {
	            // no-op (we're logged out and don't want to silently auto-login)
	            logger.debug("Silent token refresh - ending with no-op (local session is already logged out).");
	            return false; // don't use the new authResponse
	          }
	          // if the user is different than the current one then perform logout
	          if (claims.sub !== _this3.getClaims().sub) {
	            logger.debug("Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).");
	            _this3._localLogout();
	            return false; // don't use the new authResponse
	          }
	          logger.debug("Silent token refresh - ending with token renewed.");
	          return true; // use the new authResponse
	        }).catch(function (e) {
	          var err = e && e.error ? e.error : e; // e could be AuthenticationResponse, Error or anything else
	          if (_ImplicitFlow2.default.isLoggedOutError(e)) {
	            logger.debug("Silent token refresh - ending with local logout (user is not logged in on remote).");
	            _this3._localLogout();
	            return;
	          }
	          if (!_this3._silentTokenRefreshTimeout && _this3.tokenRefreshFailureRetryInterval) {
	            logger.debug("Silent token refresh - will retry in " + _this3.tokenRefreshFailureRetryInterval + "s (operation ended with unexpected error).", { error: err });
	            _this3._silentTokenRefreshTimeout = setTimeout(function () {
	              delete _this3._silentTokenRefreshTimeout;
	              doSilentRenew();
	            }, _this3.tokenRefreshFailureRetryInterval * 1000);
	          } else {
	            if (_this3._silentTokenRefreshTimeout) logger.debug("Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).", { error: err });else logger.debug("Silent token refresh - ending with no-op (operation ended with unexpected error).", { error: err });
	          }
	          if (invocationCount === 1) console.warn("Token refresh failed with error:", err);else if (invocationCount === 2) console.warn("Suppressing further notifications of token refresh problem to prevent log cluttering (until success or logout).");
	        });
	      };

	      doSilentRenew();
	    }
	  }, {
	    key: "_localLogout",
	    value: function _localLogout() {
	      logger.debug("Performing local-logout.");
	      if (!this._loginCtx) return;
	      delete this._loginCtx;
	      this._runListeners("identityChange", this.getIdentity());
	    }

	    /**
	     * Log out the user.
	     * 
	     * @return Promise resolved after the user gets logged out (or immediately, if the user is not logged in).
	     * @method UuOidc.Session#logout
	     */

	  }, {
	    key: "logout",
	    value: function logout() {
	      var _this4 = this;

	      if (!this._loginCtx) return Promise.resolve();

	      // logout global session using end_session_endpoint (in an iframe)
	      return this._optionsMergedPromise.then(function () {
	        return _Discovery2.default.getMetadata(_this4.serverUri).then(function (metadata) {
	          return new Promise(function (resolve, reject) {
	            if (!_this4._loginCtx) return resolve();
	            var logoutCallbackUri = _this4.implicitFlowRedirectUri;
	            var logoutUrl = metadata.end_session_endpoint + "?post_logout_redirect_uri=" + encodeURIComponent(logoutCallbackUri) + "&id_token_hint=" + encodeURIComponent(_this4._loginCtx.authResponse.id_token);
	            new _IframeComponent2.default({
	              url: logoutUrl,
	              onResult: function onResult(result) {
	                if (result instanceof Error) {
	                  result.message = "Logout failed." + (result.message ? " " + result.message : "");
	                  reject(result);
	                } else {
	                  _this4._localLogout();
	                  resolve();
	                }
	              }
	            }).render();
	          });
	        });
	      });
	    }

	    /**
	     * Returns token and its type for calling commands. Returned object contains following fields:
	     * 
	     * * tokenType - the type of the token, such as "Bearer",
	     * * token - the token itself.
	     * 
	     * If the user is not logged in, null is returned.
	     * 
	     * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.
	     * @return Object containing token and its type, or null if user is not logged in.
	     * @method UuOidc.Session#getCallToken
	     */

	  }, {
	    key: "getCallToken",
	    value: function getCallToken(callUri) {
	      var authResponse = (this._loginCtx || {}).authResponse;
	      if (!authResponse) return null;
	      var result = {
	        tokenType: authResponse.token_type || null,
	        token: authResponse.id_token || null
	      };
	      return result;
	    }
	  }]);

	  return Session;
	}();

	exports.default = Session;


	function toFullUrl(path) {
	  var a = document.createElement("a");
	  a.href = path;
	  return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
	}

	function toTimeString(date) {
	  return (
	    // date.getFullYear() + "-" + ("0" + (date.getMonth() + 1)).substr(-2) + "-" + ("0" + date.getDate()).substr(-2) + " " +
	    ("0" + date.getHours()).substr(-2) + ":" + ("0" + date.getMinutes()).substr(-2) + ":" + ("0" + date.getSeconds()).substr(-2)
	  );
	}

	/**
	 * Current session.
	 * 
	 * @name UuOidc.Session.currentSession
	 * @type UuOidc.Session
	 */
	var currentSession;
	var allowAutoInitSession = true;
	Object.defineProperty(Session, "currentSession", {
	  get: function get() {
	    if (allowAutoInitSession && !currentSession) {
	      currentSession = new Session(_uu_appg01_core.Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).
	      currentSession.initComplete = false;
	      currentSession.initPromise = Session.initPromise;
	    }
	    return currentSession;
	  },
	  set: function set(value) {
	    allowAutoInitSession = false;
	    currentSession = value;
	  }
	});

	var finalizeInit;
	/**
	 * Promise resolved after session initialization (restoring state) finishes.
	 * 
	 * @type {Promise<UuOidc.Session>}
	 * @name UuOidc.Session.initPromise 
	 */
	/**
	 * Promise resolved after session initialization (restoring state) finishes.
	 * Note that this field is available only on a session instance that is
	 * created automatically during page load.
	 * 
	 * @type {Promise<UuOidc.Session>}
	 * @name UuOidc.Session#initPromise 
	 */
	Session.initPromise = _PromiseUtil2.default.wrapForImmediateThen(new Promise(function (resolve, reject) {
	  finalizeInit = function finalizeInit(isOk, result) {
	    Session.initComplete = true;
	    Session.currentSession.initComplete = true;
	    if (!isOk) console.log("Session initialization failed:", result);
	    resolve(Session.currentSession); // always resolve as success even if checking session state failed
	    return Session.initPromise;
	  };
	}));
	Session.initPromise._finalizeInit = finalizeInit;

	/**
	 * Whether the session initialization performed during page load has already completed.
	 * 
	 * @type {boolean}
	 * @name UuOidc.Session.initComplete
	 */
	/**
	 * Whether the session initialization performed during page load has already completed.
	 * Note that this field is available only on a session instance that is
	 * created automatically during page load.
	 * 
	 * @type {boolean}
	 * @name UuOidc.Session#initComplete
	 */
	Session.initComplete = false;

/***/ },
/* 32 */
/*!*********************************************!*\
  !*** ../~/uu_oidcg01/dist-node/Defaults.js ***!
  \*********************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// NOTE If changed, update also JSDoc in Session.js.
	exports.default = {
	  serverUri: "https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be",
	  clientId: null,
	  redirectUri: "callbacks/oidc-callback.html",
	  sessionCheckInterval: 5, // seconds between postMessage queries posted to check_session_iframe
	  sessionExpiringNotificationTime: 5 * 60, // seconds; event "sessionExpiring" will be launched these seconds prior to real expiration
	  tokenRefreshEnabled: true,
	  tokenRefreshLeeway: 5 * 60, // seconds prior to token expiration, at which to attempt refreshing of the token
	  tokenRefreshFailureRetryInterval: 30 // when refreshing token fails (e.g. due to network problem) wait these seconds and then try again
	};

/***/ },
/* 33 */
/*!******************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/flow/ImplicitFlow.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _Discovery = __webpack_require__(/*! ../discovery/Discovery.js */ 34);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _PromiseUtil = __webpack_require__(/*! ../util/PromiseUtil.js */ 36);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	var _PopupComponent = __webpack_require__(/*! ../ui/PopupComponent.js */ 37);

	var _PopupComponent2 = _interopRequireDefault(_PopupComponent);

	var _IframeComponent = __webpack_require__(/*! ../ui/IframeComponent.js */ 39);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	var _Jwt = __webpack_require__(/*! ../jwt/Jwt.js */ 40);

	var _Jwt2 = _interopRequireDefault(_Jwt);

	var _InvalidTokenError = __webpack_require__(/*! ../jwt/InvalidTokenError.js */ 42);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	var _Jwks = __webpack_require__(/*! ../jwks/Jwks.js */ 45);

	var _Jwks2 = _interopRequireDefault(_Jwks);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var GRACE_PERIOD = 300;

	var ImplicitFlow = {
	  /**
	   * @param options.serverUri
	   * @param options.clientId
	   * @param options.redirectUri
	   * @param options.loginVisualComponent
	   * @param options.loginParams Additional URL parameters to be passed in the HTTP request.
	   */
	  login: function login(options) {
	    var opts = options || {};

	    // check that required data is available
	    var serverUri = opts.serverUri;
	    if (!serverUri) throw new Error("ImplicitFlow.login requires option 'serverUri'.");
	    var clientId = opts.clientId;
	    if (!clientId) throw new Error("ImplicitFlow.login requires option 'clientId'.");
	    var redirectUri = opts.redirectUri;
	    if (!redirectUri) throw new Error("ImplicitFlow.login requires option 'redirectUri'.");

	    // NOTE Using PromiseUtil.immediateThen which will run our "then" callback immediately if
	    // the Discovery.getMetadata is already resolved. The idea is that this login could have
	    // been triggered from "click" event and we need to open popup window within this event's
	    // lifetime or within single Promise (but not Promise chain because that doesn't work on
	    // iPhones).
	    return _PromiseUtil2.default.immediateThen(_Discovery2.default.getMetadata(serverUri), function (oidcMetadata) {
	      // prepare login URL
	      var loginParams = Object.assign({ scope: "openid" }, opts.loginParams, {
	        response_type: "id_token token",
	        client_id: clientId,
	        redirect_uri: redirectUri
	      });
	      var loginParamsParts = [];
	      for (var k in loginParams) {
	        var v = loginParams[k];
	        if (v == null) continue;
	        loginParamsParts.push(encodeURIComponent(k) + "=" + encodeURIComponent(v + ""));
	      }
	      var loginUrl = oidcMetadata.authorization_endpoint + "?" + loginParamsParts.join("&");

	      // display visual component for logging in (popup window)
	      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != "none" ? _PopupComponent2.default : _IframeComponent2.default);
	      return new Promise(function (resolve, reject) {
	        new LoginVisualComponent({
	          url: loginUrl,
	          onResult: function onResult(aLoginResult) {
	            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);
	            if (authResponse === false) return reject(new Error("User refused to log in."));
	            if (authResponse === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return reject(new Error("Login failed due to popup blocking."));

	            // resolve the promise successfully with the token (iff there's no "error" field)
	            if (authResponse.error) reject(authResponse);else resolve(authResponse);
	          }
	        }).render();
	      });
	    }, function (e) {
	      return Promise.reject(e);
	    });
	  },

	  validateAuthResponse: function validateAuthResponse(authResponse, opts) {
	    // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation
	    // 1. process only recognized fields in response (id_token, expires_in, ...)
	    // 2. validate implicit flow callback response ("state")
	    // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
	    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
	    //     ii. validate signature
	    //    iii. validate nonce
	    // 4. validate access_token

	    // 2.i. validate state
	    if (opts.loginParams.state && authResponse.state !== opts.loginParams.state) throw new Error("Invalid 'state' in received authorization response. Expected " + opts.loginParams.state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));

	    // 2.ii. validate expiration
	    if (ImplicitFlow.isAuthResponseExpired(authResponse)) throw new Error("Token expired " + JSON.stringify(authResponse));

	    // 3. validate id_token with nonce
	    return ImplicitFlow.validateIdToken(authResponse.id_token, opts).then(function (claims) {
	      return { authResponse: authResponse, claims: claims };
	    });

	    // 4. validate access_token
	    // NOTE Ignore - we're not using access_token field.
	  },
	  isAuthResponseExpired: function isAuthResponseExpired(authResponse) {
	    var now = new Date().getTime() / 1000;
	    var leeway = 60;
	    var expired = false;
	    if (!authResponse.issued_at) authResponse.issued_at = now;
	    if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;
	    if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;
	    return expired;
	  },


	  /**
	   * @param {*} e The error during authorization.
	   * @return Whether the error means that the user is not logged in on the remote server.
	   */
	  isLoggedOutError: function isLoggedOutError(e) {
	    return e && (typeof e === "undefined" ? "undefined" : _typeof(e)) == "object" && typeof e["error_description"] == "string" && e["error_description"].match(/interaction/i) && e["error_description"].match(/required/i);
	  },


	  /**
	   * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.
	   */
	  validateIdToken: function validateIdToken(token, _ref) {
	    var serverUri = _ref.serverUri,
	        nonce = _ref.loginParams.nonce;

	    // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
	    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
	    //         1. -Decrypt JWE - not supported.
	    //         2. +REQUIRED validate 'iss'
	    //         3. +REQUIRED validate 'aud'
	    //         4. -SHOULD validate multiple 'aud' vs. 'azp'
	    //         5. -SHOULD validate 'azp'
	    //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>
	    //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration
	    //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)
	    //         9. +REQUIRED current time < 'exp'
	    //        10. +CAN check 'iat'
	    //        11. +REQUIRED (for implicit flow) validate nonce
	    //        12. -SHOULD check if 'acr' is appropriate
	    //        13. -SHOULD check if 'auth_time' was requested.
	    //     ii. validate signature
	    //    iii. validate nonce
	    return _Discovery2.default.getMetadata(serverUri).then(function (metadata) {
	      var verifyOptions = {
	        // NOTE IE11 doesn't have RS512 (but it has "RS256" and "RS384").
	        alg: ["RS256"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)
	        iss: [metadata.issuer], // 3.i.2.
	        // aud: clientId, // 3.i.3. TODO We don't have the proper value.
	        // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') 
	        gracePeriod: GRACE_PERIOD
	      };
	      return _Jwt2.default.decode(token, verifyOptions, function (jwtHeader) {
	        // 3.ii.
	        if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\d+$/)) throw new Error("Invalid token. Only RSA signature is supported, but token uses algorithm '" + jwtHeader.alg + "'. Token: " + token);
	        var keyType = "RSA";

	        // check algorithm in token (whether it's really supported by the server)
	        var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];
	        if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error("Invalid token. Token was signed using algorithm '" + jwtHeader.alg + "' but the OIDC server '" + serverUri + "' supports only " + JSON.stringify(supportedAlgs) + ". Token: " + token);

	        // pick the key from JWK Set
	        var jwks = new _Jwks2.default({ serverUri: serverUri });
	        return jwks.getKey(jwtHeader.kid, keyType).catch(function (e) {
	          throw new Error("Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server " + serverUri + ". Token: " + token, e);
	        });
	      }).then(function (claims) {
	        // 3.i.11., 3.iii. validate nonce
	        if (nonce && claims.nonce !== nonce) throw new _InvalidTokenError2.default("Invalid nonce in ID token claims. Expected " + nonce + " but got " + claims.nonce);
	        return claims;
	      });
	    });
	  },


	  /**
	   * 
	   * @param {*} aLoginCallbackResult 
	   * @return One of: 
	   * * false - user refused to log in (or popups are blocked)
	   * * object with "error" field set - an error
	   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
	   */
	  getAuthResponseFromCallback: function getAuthResponseFromCallback(aLoginCallbackResult) {
	    if (aLoginCallbackResult === false || aLoginCallbackResult === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return aLoginCallbackResult;
	    if (aLoginCallbackResult instanceof Error) return { error: aLoginCallbackResult };

	    // extract login token
	    // example of successful aLoginCallbackResult: "...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid" 
	    // example of error aLoginCallbackResult:      "...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
	    var authResponse = {};
	    aLoginCallbackResult.replace(/^[^#]*#?/, "").split(/&/).forEach(function (it) {
	      var eqlIdx = it.indexOf("=");
	      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
	      var value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
	      authResponse[key] = value;
	    });
	    return authResponse;
	  }
	};

	exports.default = ImplicitFlow;

/***/ },
/* 34 */
/*!********************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/discovery/Discovery.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _HttpClient = __webpack_require__(/*! ../util/HttpClient.js */ 35);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	var _PromiseUtil = __webpack_require__(/*! ../util/PromiseUtil.js */ 36);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var oidcMetadataCache = {}; // stores Promises

	var Discovery = {
	  /**
	   * @return Promise resolving to OIDC discovery metadata for given issuerUri.
	   */
	  getMetadata: function getMetadata(aIssuerUri) {
	    var issuerUri = aIssuerUri.replace(/\/+$/, ""); // strip trailing slash(es) (this also normalizes it as a key to cache)
	    var metadata = oidcMetadataCache[issuerUri];
	    if (metadata) return metadata;
	    var discoveryEndpoint = Discovery.getMetadataUri(issuerUri);
	    return oidcMetadataCache[issuerUri] = _PromiseUtil2.default.wrapForImmediateThen(_HttpClient2.default.get(discoveryEndpoint).catch(function (e) {
	      delete oidcMetadataCache[issuerUri]; // don't cache errors so that e.g. clicking a button 2nd time (after network is up again) has chance to work
	      throw e;
	    }));
	  },
	  getMetadataUri: function getMetadataUri(aIssuerUri) {
	    var issuerUri = aIssuerUri.replace(/\/+$/, ""); // strip trailing slash(es) (this also normalizes it as a key to cache)
	    return issuerUri + "/.well-known/openid-configuration";
	  }
	};

	exports.default = Discovery;

/***/ },
/* 35 */
/*!****************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/util/HttpClient.js ***!
  \****************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// helper for invoking Ajax requests and returning Promise
	function xhrJson(method, url, body, extraSettingFn) {
	  return new Promise(function (resolve, reject) {
	    var xhr = new XMLHttpRequest();
	    xhr.open(method, url, true);
	    xhr.withCredentials = true;
	    xhr.setRequestHeader("Accept", "application/json");
	    xhr.onreadystatechange = function (e) {
	      if (xhr.readyState == 4) {
	        if (xhr.status >= 200 && xhr.status < 300) {
	          try {
	            var json = JSON.parse(xhr.responseText);
	            resolve(json);
	          } catch (err) {
	            reject(err);
	          }
	        } else {
	          reject(new Error("Server responded with status " + xhr.status)); // TODO Better error.
	        }
	      }
	    };
	    xhr.withCredentials = true;
	    if (extraSettingFn) extraSettingFn(xhr);
	    xhr.send(body);
	  });
	}

	exports.default = {
	  get: function get() {
	    return xhrJson.bind(this, "GET").apply(this, Array.prototype.slice.call(arguments));
	  },
	  post: function post() {
	    return xhrJson.bind(this, "POST").apply(this, Array.prototype.slice.call(arguments));
	  }
	};

/***/ },
/* 36 */
/*!*****************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/util/PromiseUtil.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  /**
	   * Wraps Promise so that it can then be used in immediateThen function.
	   */
	  wrapForImmediateThen: function wrapForImmediateThen(promise) {
	    promise.then(function (v) {
	      return promise._immediateValue = v;
	    }, function (e) {
	      return promise._immediateError = e;
	    });
	    return promise;
	  },

	  /**
	   * If promise has already been resolved, thenFn is called immediately (or catchFn in
	   * case that the promise has been rejected). Otherwise thenFn and catchFn callbacks
	   * are simply registered via promise.then(thenFn, catchFn).
	   * 
	   * Note that this works only on promises that were wrapped via #wrapForImmediateThen
	   * function.
	   * 
	   * @return Return value of thenFn/catchFn (if invoked immediately) or promise.then(thenFn, catchFn).
	   */
	  immediateThen: function immediateThen(promise, thenFn, catchFn) {
	    if ("_immediateValue" in promise) return typeof thenFn == "function" ? thenFn(promise._immediateValue) : promise._immediateValue;
	    if ("_immediateError" in promise) {
	      if (typeof catchFn == "function") return catchFn(promise._immediateError);
	      throw promise._immediateError;
	    }
	    return promise.then(thenFn, catchFn);
	  }
	};

/***/ },
/* 37 */
/*!******************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/ui/PopupComponent.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CallbackHandler = __webpack_require__(/*! ./CallbackHandler.js */ 38);

	var _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Default visual component for presenting login/logout prompt to the user. It displays the
	 * URL in a popup window and waits until the user logs in / closes the window. After that
	 * initAttrs.onResult(authResultUrl) is called as callback.
	 * 
	 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
	 * @param initAttrs.onResult The callback to call after login finishes. If the login finished
	 *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.
	 *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which
	 *   contains the authentication response in fragment). 
	 */
	var PopupComponent = function PopupComponent(initAttrs) {
	  var attrs = Object.assign({}, initAttrs);
	  var state = {
	    loginWindow: null,
	    closeCheckInterval: null
	  };

	  // add self to the list of opened loginWindows
	  _CallbackHandler2.default.registerForCallback(this, state);

	  this.finalize = function (result) {
	    // cleanup & do the callback
	    this.finalize = function () {};
	    this.destroy();
	    if (attrs.onResult) attrs.onResult(result);
	  }.bind(this);

	  var closeCheck = function () {
	    if (!state.loginWindow || !state.loginWindow.closed) return;
	    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value "false"
	  }.bind(this);

	  this.render = function () {
	    var _this = this;

	    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)
	    if (!state.loginWindow) {
	      var rect = { width: 599, height: 600 };
	      rect.left = (screen.availWidth - rect.width) / 2 + screen.availLeft;
	      rect.top = (screen.availHeight - rect.height) / 2 + screen.availTop;
	      state.loginWindow = window.open(attrs.url, "_blank", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=" + rect.width + ",height=" + rect.height + ",top=" + rect.top + ",left=" + rect.left);
	      if (!state.loginWindow) {
	        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in
	        Promise.resolve().then(function () {
	          return _this.finalize(PopupComponent.ERROR_POPUP_BLOCKED);
	        }); // finalize in async way
	      } else {
	        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);
	      }
	    }
	  };

	  this.destroy = function () {
	    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();
	    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);
	    this.destroy = function () {};
	    _CallbackHandler2.default.unregisterForCallback(this);
	  };
	};

	PopupComponent.ERROR_POPUP_BLOCKED = "POPUP_BLOCKED";

	exports.default = PopupComponent;

/***/ },
/* 38 */
/*!*******************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/ui/CallbackHandler.js ***!
  \*******************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// login callback handling
	var VC_CALLBACK_FN_NAME = "uuOidcCallbackFn"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.

	// make sure that callback works correctly even if multiple invocations using visual component below were
	// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup
	// and are now displayed both)
	if (typeof window != "undefined" && !window[VC_CALLBACK_FN_NAME]) {
	  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow) {
	    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
	    // received callback from a popup => find out which component is using the source window and notify it
	    for (var i = 0; i < loginWindows.length; ++i) {
	      var p = loginWindows[i];
	      if (p.state.loginWindow == aSourceWindow) {
	        p.component.finalize(aLoginResult);
	        return;
	      }
	    }
	    console.warn("Received unexpected callback from window", aSourceWindow, "Passed result was:", aLoginResult, "Ignoring the callback.");
	  };
	  window[VC_CALLBACK_FN_NAME].loginWindows = [];
	}

	exports.default = {
	  registerForCallback: function registerForCallback(component, state) {
	    window[VC_CALLBACK_FN_NAME].loginWindows.push({ component: component, state: state });
	  },
	  unregisterForCallback: function unregisterForCallback(component) {
	    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
	    for (var i = 0; i < loginWindows.length; ++i) {
	      // remove self from opened loginWindows
	      if (loginWindows[i].component === component) {
	        loginWindows.splice(i, 1);
	        break;
	      }
	    }
	  }
	};

/***/ },
/* 39 */
/*!*******************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/ui/IframeComponent.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CallbackHandler = __webpack_require__(/*! ./CallbackHandler.js */ 38);

	var _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt="none" cases.
	 * After login/logout initAttrs.onResult(authResultUrl) is called as callback. In case of an error, an error instance
	 * is passed to the callback.
	 * 
	 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
	 * @param initAttrs.onResult The callback to call after login/logout finishes.
	 * @param initAttrs.timeout Seconds to wait after which consider the attempt unsuccessful, resulting in UuApp.Error.TimeoutError result.
	 */
	var IframeComponent = function IframeComponent(initAttrs) {
	  var attrs = Object.assign({}, initAttrs);
	  var state = {
	    iframe: null
	  };
	  Object.defineProperty(state, "loginWindow", {
	    get: function get() {
	      try {
	        // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)
	        return state.iframe != null ? state.iframe.contentWindow : null;
	      } catch (e) {
	        // ignore
	      }
	      return null;
	    }
	  });

	  // add self to the list of openend loginWindows
	  _CallbackHandler2.default.registerForCallback(this, state);

	  // finalization callback (for this component instance) called after login from redirect_uri page
	  this.finalize = function (aLoginResult) {
	    // cleanup & do the callback
	    this.finalize = function () {};
	    this.destroy();
	    if (attrs.onResult) attrs.onResult(aLoginResult);
	  }.bind(this);

	  this.render = function () {
	    var _this = this;

	    if (!state.iframe) {
	      state.iframe = document.createElement("iframe");
	      state.iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
	      state.iframe.src = attrs.url;
	      state.iframe.onload = function () {
	        return _this.finalize(new Error("OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running." + " Alternatively, an error might have happened on OIDC server while processing URL " + attrs.url + " or the application sent wrong redirect_uri."));
	      }; // proper callback page will perform callback prior to onload event
	      state.iframe.onerror = function () {
	        return _this.finalize(new Error("OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running." + " Alternatively, an error might have happened on OIDC server while processing URL " + attrs.url + " or the application sent wrong redirect_uri."));
	      };
	      document.body.appendChild(state.iframe);
	      if (attrs.timeout) this._timeout = setTimeout(function () {
	        _this.finalize(new _uu_appg01_core.Error.TimeoutError("OIDC iframe didn't receive callback within " + attrs.timeout + "s."));
	      }, attrs.timeout * 1000);
	    }
	  };

	  this.destroy = function () {
	    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);
	    this.destroy = function () {};
	    if (this._timeout) clearTimeout(this._timeout);
	    _CallbackHandler2.default.unregisterForCallback(this);
	  };
	};

	exports.default = IframeComponent;

/***/ },
/* 40 */
/*!********************************************!*\
  !*** ../~/uu_oidcg01/dist-node/jwt/Jwt.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Base64Url = __webpack_require__(/*! ../util/Base64Url.js */ 41);

	var _Base64Url2 = _interopRequireDefault(_Base64Url);

	var _InvalidTokenError = __webpack_require__(/*! ./InvalidTokenError.js */ 42);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	var _JwtVerifierWebCrypto = __webpack_require__(/*! ./JwtVerifierWebCrypto.js */ 43);

	var _JwtVerifierWebCrypto2 = _interopRequireDefault(_JwtVerifierWebCrypto);

	var _JwtVerifierJsrsasign = __webpack_require__(/*! ./JwtVerifierJsrsasign.js */ 44);

	var _JwtVerifierJsrsasign2 = _interopRequireDefault(_JwtVerifierJsrsasign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519
	//     - JSON (containing claims) encoded in a JWS / JWE structure
	// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515
	// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516

	// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net
	// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,
	// but not on production; it's ~90kB of minified code).
	var hasWebCrypto = typeof crypto != "undefined" && crypto.subtle && crypto.subtle.importKey;
	var useWebCrypto = hasWebCrypto && (typeof location == "undefined" || location.protocol == "https:");
	var verifier = useWebCrypto ? _JwtVerifierWebCrypto2.default : _JwtVerifierJsrsasign2.default;

	var DEFAULT_ALG = "RS256";
	exports.default = {
	  /**
	   * 
	   */
	  decode: function decode(token, verifyOpts, getKeyFn) {
	    var tokenParts;
	    var header;
	    return Promise.resolve().then(function () {
	      if (typeof token != "string") throw new Error("Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).");
	      tokenParts = token.split(".");
	      if (tokenParts.length != 3) throw new Error("Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: " + token);

	      // parse header
	      var headerB64U = tokenParts[0];
	      var headerStr = _Base64Url2.default.decode(headerB64U);
	      header = JSON.parse(headerStr);
	      if (header.typ != "JWT") throw new Error("Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: " + token);

	      // get key
	      return getKeyFn(header);
	    }).then(function (key) {
	      // NOTE Check the whole importKey call if adding support for other key types.
	      if (!key || key.kty != "RSA") throw new Error("Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: " + JSON.stringify(key));
	      // always verify algorithm against the one is JOSE header
	      var alg = key.alg || DEFAULT_ALG;
	      if (alg !== header.alg) throw new _InvalidTokenError2.default("Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '" + header.alg + "', verification key uses '" + key.alg + "' (with default of '" + DEFAULT_ALG + "'). Token: " + token + " Key: " + JSON.stringify(key));

	      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);
	    }).then(function (valid) {
	      if (!valid) throw new _InvalidTokenError2.default("Invalid JSON Web Token: " + token);
	      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
	      var body = JSON.parse(bodyStr);
	      return body;
	    });
	  }
	};

/***/ },
/* 41 */
/*!***************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/util/Base64Url.js ***!
  \***************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Base64Url = {
	  /**
	   * @param txtAscii Ascii string to encode (each character is in range 0-255).
	   * @return {string} Provided string encoded to Base64Url encoding.
	   */
	  encodeAscii: function encodeAscii(txtAscii) {
	    if (!txtAscii) return txtAscii;
	    return btoa(txtAscii).replace(/\+/g, "-").replace(/\//g, "_");
	  },
	  /**
	   * @param txtUtf8 UTF-8 string to encode.
	   * @return {string} Provided string encoded to Base64Url encoding.
	   */
	  encode: function encode(txtUtf8) {
	    if (!txtUtf8) return txtUtf8;
	    return Base64Url.encodeAscii(unescape(encodeURIComponent(txtUtf8)));
	  },
	  /**
	   * @return {string} Base64Url decoded to an Ascii string (each character is in range 0-255).
	   */
	  decodeToAscii: function decodeToAscii(base64Url) {
	    if (!base64Url) return null;
	    var base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
	    return atob(base64);
	  },
	  /**
	   * @return {string} Base64Url decoded to a UTF-8 string.
	   */
	  decode: function decode(base64Url) {
	    var ascii = Base64Url.decodeToAscii(base64Url);
	    return ascii != null ? decodeURIComponent(escape(ascii)) : null;
	  }
	};
	exports.default = Base64Url;

/***/ },
/* 42 */
/*!**********************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/jwt/InvalidTokenError.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var InvalidTokenError = function (_Errors$Error) {
	  _inherits(InvalidTokenError, _Errors$Error);

	  function InvalidTokenError() {
	    _classCallCheck(this, InvalidTokenError);

	    return _possibleConstructorReturn(this, (InvalidTokenError.__proto__ || Object.getPrototypeOf(InvalidTokenError)).apply(this, arguments));
	  }

	  return InvalidTokenError;
	}(_uu_appg01_core.Error.Error);

	exports.default = InvalidTokenError;

/***/ },
/* 43 */
/*!*************************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/jwt/JwtVerifierWebCrypto.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Base64Url = __webpack_require__(/*! ../util/Base64Url.js */ 41);

	var _Base64Url2 = _interopRequireDefault(_Base64Url);

	var _InvalidTokenError = __webpack_require__(/*! ./InvalidTokenError.js */ 42);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports = {
	  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {
	    var webCryptoAlgorithm = {
	      name: "RSASSA-PKCS1-v1_5",
	      hash: { name: "SHA-" + alg.substr(2) }
	    };
	    // MS Edge throws error if the key contains field "use" => remove it
	    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails
	    var usedKey = JSON.parse(JSON.stringify(key));
	    delete usedKey.use;

	    return crypto.subtle.importKey("jwk", usedKey, webCryptoAlgorithm, false, ["verify"]).then(function (webCryptoKey) {
	      // validate signature
	      var signatureB64U = tokenParts[2];
	      var data = tokenParts[0] + "." + tokenParts[1];
	      var signatureBytes = asciiToUint8Array(_Base64Url2.default.decodeToAscii(signatureB64U));
	      var dataBytes = asciiToUint8Array(data);
	      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);
	    }, function (importError) {
	      var e = new Error("Unable to verify JSON Web Token - importing key via WebCrypto API failed.\nKey: " + JSON.stringify(usedKey) + "\nToken: " + token + "\nError: " + importError);
	      e.cause = importError;
	      return Promise.reject(e);
	    }).then(function (signatureValid) {
	      if (!signatureValid) throw new _InvalidTokenError2.default("Invalid JSON Web Token - signature is not valid. Token: " + token);
	      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
	      var body = JSON.parse(bodyStr);
	      var throwError = function throwError(txt, failedClaim) {
	        throw new _InvalidTokenError2.default("Invalid token: " + txt + "\nFailed claim: " + JSON.stringify(failedClaim) + "\nIssued by: " + JSON.stringify(body.iss) + "\nVerification options: " + JSON.stringify(verifyOpts) + "\nToken: " + token);
	      };

	      // verify claims

	      // 'alg' is always checked
	      if (!verifyOpts.alg) throw new Error("Unable to verify JWT claim - 'alg' field must be always given for verification.");
	      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError("Algorithm " + JSON.stringify(header.alg) + " used by token is not valid - expected one of " + JSON.stringify(verifyOpts.alg) + ".", "alg");

	      // 'iss'
	      var v;
	      v = asArray(verifyOpts.iss);
	      if (v && v.indexOf(body.iss) === -1) throwError("Issuer URI " + JSON.stringify(body.iss) + " in token is not valid - expected one of " + JSON.stringify(v) + ". Token was issued by different OpenID Connect server or it was forged.", "iss");

	      // 'sub'
	      v = asArray(verifyOpts.sub);
	      if (v && v.indexOf(body.sub) === -1) throwError("Subject " + JSON.stringify(body.sub) + " in token is not valid - expected one of " + JSON.stringify(v) + ".", "sub");

	      // 'aud' - all values from verifyOpts.aud must be present in body.aud 
	      v = asArray(verifyOpts.aud);
	      var bodyV = asArray(body.aud) || [];
	      if (v && bodyV.some(function (bv) {
	        return v.indexOf(bv) == -1;
	      })) throwError("Audience list " + JSON.stringify(bodyV) + " in token is not valid - some of following values are missing: " + JSON.stringify(v) + ".", "aud");

	      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)
	      var now = Date.now() / 1000;
	      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;
	      var gracePeriod = verifyOpts.gracePeriod || 0;

	      // 'exp' - expires
	      if (typeof body.exp === "number" && body.exp + gracePeriod < now) throwError("Token already expired at " + toTimeString(body.exp) + ", current time is " + toTimeString(now) + ".", "exp");

	      // 'nbf' - not before
	      if (typeof body.nbf === "number" && now < body.nbf - gracePeriod) throwError("Token is not yet valid - it will become valid at " + toTimeString(body.nbf) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "nbf");

	      // 'iat' - issued at time
	      if (typeof body.iat === "number" && now < body.iat - gracePeriod) throwError("Token seems to have been issued in the future - " + toTimeString(body.iat) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "iat");

	      // 'jti' - JWT id
	      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError("Token ID " + JSON.stringify(body.jti) + " not valid - expected " + JSON.stringify(verifyOpts.jti) + ".", "jti");

	      return true;
	    });
	  }
	};

	function asciiToUint8Array(ascii) {
	  return new Uint8Array(ascii.split("").map(function (c) {
	    return c.charCodeAt(0);
	  }));
	}
	function asArray(value) {
	  if (value == null) return null;
	  if (Array.isArray(value)) return value;
	  return [value];
	}
	function toTimeString(seconds) {
	  return new Date(seconds * 1000).toISOString().replace(/T/, " ");
	}

/***/ },
/* 44 */
/*!*************************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/jwt/JwtVerifierJsrsasign.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _module = __webpack_require__(/*! module */ 1);

	var _module2 = _interopRequireDefault(_module);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var scriptUri = ((_module2.default ? _module2.default.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
	var jsrsasign = undefined;
	var Verifier = {
	  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {
	    var _this = this;

	    return Promise.resolve().then(function () {
	      // load jsrsasign library on 1st verification
	      if (jsrsasign === undefined) {
	        var continueFn = Verifier.verify.bind(_this, key, alg, verifyOpts, header, tokenParts, token);
	        var isMin = scriptUri.indexOf(".min.") != -1;
	        var baseUrl = scriptUri.replace(/^(.*\/).*/, "$1");
	        var url = baseUrl + "jsrsasign" + (isMin ? ".min" : "") + ".js";
	        var loadPromise;
	        if (typeof System != "undefined") loadPromise = System.import(url);else loadPromise = new Promise(function (resolve, reject) {
	          var script = document.createElement("script");
	          script.onload = function () {
	            resolve(window["Jsrsasign"]);
	          };
	          script.onerror = function (e) {
	            reject(e);
	          };
	          script.src = url;
	          document.head.appendChild(script);
	        });
	        return loadPromise.then(function (obj) {
	          jsrsasign = obj || null;
	          return continueFn();
	        }, function (e) {
	          // NOTE Don't set jsrsasign to null (if network was down, next attempt of the user might work)
	          console.error(e);
	          return continueFn();
	        });
	      }
	      if (!jsrsasign) throw new Error("Unable to verify token because jsrsasign library failed to load.");

	      // var exampleKey = {"kty":"RSA","e":"AQAB","n":"yXxJt2xevNsgGGGFfX5e22Jvy0_Eopgkumz7mJ7ScWlPfsMsAi8BZsF7nbDjA3T3v2vy2_-DaLDg-z-BjRwQIPL1LRzQGeDDSVmPcZtbexqkpjouxZ6-abpefSAFX5cA8NJ5h4JknFJWAsxxKEw4Ogy6XFd_BEaDmyXlLcV65Bs","alg":"RS256","kid":"rJZx5vzX1FOt_Nt8sB8jUA","use":"sig"};
	      // var pem = KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(exampleKey));
	      //   =>
	      // -----BEGIN PUBLIC KEY-----
	      // MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJfEm3bF682yAYYYV9fl7bYm/L
	      // T8SimCS6bPuYntJxaU9+wywCLwFmwXudsOMDdPe/a/Lb/4NosOD7P4GNHBAg8vUt
	      // HNAZ4MNJWY9xm1t7GqSmOi7Fnr5pul59IAVflwDw0nmHgmScUlYCzHEoTDg6DLpc
	      // V38ERoObJeUtxXrkGwIDAQAB
	      // -----END PUBLIC KEY-----

	      // do the verification
	      var keyInst = jsrsasign.KEYUTIL.getKey(key);
	      var result = jsrsasign.jws.JWS.verifyJWT(token, keyInst, verifyOpts); // see lib/jsrsasign-.../jws-3.3.js
	      return result || Promise.reject(new Error("Token is not valid. Token: " + token));
	    });
	  }
	};

	module.exports = Verifier;

/***/ },
/* 45 */
/*!**********************************************!*\
  !*** ../~/uu_oidcg01/dist-node/jwks/Jwks.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Discovery = __webpack_require__(/*! ../discovery/Discovery.js */ 34);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _HttpClient = __webpack_require__(/*! ../util/HttpClient.js */ 35);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var jwkSetCache = {};
	var cacheBustCounter = 0;

	// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517

	var _class = function () {
	  function _class(options) {
	    _classCallCheck(this, _class);

	    if (!options || !options.serverUri) throw new Error("Jwks must be initialized with options containing serverUri.");
	    this.options = options;
	  }

	  _createClass(_class, [{
	    key: "getKey",
	    value: function getKey(keyId, keyType) {
	      return this._getKey(keyId, keyType, false);
	    }
	  }, {
	    key: "_getKey",
	    value: function _getKey(keyId, keyType, forceKeySetReload) {
	      var _this = this;

	      // load set of OIDC server JSON Web Key-s
	      return _Discovery2.default.getMetadata(this.options.serverUri).then(function (metadata) {
	        // TODO Use also localStorage cache as optimization.
	        var jwkSetMeta = jwkSetCache[metadata.jwks_uri];
	        if (!jwkSetMeta || forceKeySetReload) {
	          var url = metadata.jwks_uri;
	          if (forceKeySetReload) url = url.replace(/(\?.*)?$/, function (m) {
	            return "?cachebust=" + Date.now().toString(36) + "_" + (cacheBustCounter++).toString(36) + (m ? "&" + m.substr(1) : "");
	          });
	          jwkSetMeta = jwkSetCache[metadata.jwks_uri] = _HttpClient2.default.get(url).then(function (value) {
	            return { jwkSet: value, url: url };
	          });
	        }
	        return jwkSetMeta;
	      }).then(function (jwkSetMeta) {
	        var jwkSet = jwkSetMeta.jwkSet;
	        // choose key by id & type
	        var keys = jwkSet.keys;
	        if (keyId) keys = keys.filter(function (it) {
	          return it.kid === keyId;
	        }); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)
	        if (keyType) keys = keys.filter(function (it) {
	          return it.kty === keyType;
	        });
	        // keys = keys.filter(it => it.use === "sig" || (it.key_ops||[]).indexOf("verify") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)
	        if (keys.length != 1) {
	          // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser
	          // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)
	          if (!forceKeySetReload) return _this._getKey(keyId, keyType, true);
	          throw new Error("There's " + keys.length + " JSON Web Key(s) in JWK Set with kid='" + keyId + "' kty='" + keyType + "'. There must be exactly 1. JWK Set has been downloaded from: " + jwkSetMeta.url);
	        }
	        return keys[0];
	      });
	    }
	  }]);

	  return _class;
	}();

	exports.default = _class;

/***/ },
/* 46 */
/*!***************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/SessionContext.js ***!
  \***************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SessionContext = function SessionContext(loginOptions, authResponse, claims) {
	  _classCallCheck(this, SessionContext);

	  this.loginOptions = loginOptions;
	  this.authResponse = authResponse;
	  this.claims = claims;

	  this.getClaims = function () {
	    return claims;
	  };

	  var identity;
	  this.getIdentity = function () {
	    if (identity) return identity;
	    return identity = {
	      id: claims["sub"],
	      name: claims["name"],
	      email: claims["email"],
	      uuIdentity: claims["uu_identity"],
	      levelOfAssurance: Number(claims["loa"]),
	      loginLevelOfAssurance: Number(claims["acr"])
	    };
	  };
	};

	exports.default = SessionContext;

/***/ },
/* 47 */
/*!**********************************************!*\
  !*** ../~/uu_oidcg01/dist-node/util/Uuid.js ***!
  \**********************************************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = generateUuid;
	function generateUuid() {
	  // generate UUID (RFC4122 version 4 compliant) for the event ID
	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0,
	        v = c == 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	  return uuid;
	}

/***/ },
/* 48 */
/*!**************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/uuos8/Os8Auth.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _IframeComponent = __webpack_require__(/*! ../ui/IframeComponent.js */ 39);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	var _ImplicitFlow = __webpack_require__(/*! ../flow/ImplicitFlow.js */ 33);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Os8Auth = function () {

	  /**
	   * @param options.serverUri
	   * @param options.clientId
	   * @param options.redirectUri
	   */
	  function Os8Auth(options) {
	    _classCallCheck(this, Os8Auth);

	    if (!options || !options.serverUri || !options.clientId || !options.redirectUri) throw new Error("Os8Auth must be initialized with options containing serverUri, clientId and redirectUri.");
	    this.options = options;
	  }

	  /**
	   * @param parameters
	   * @param parameters.subject_token
	   */


	  _createClass(Os8Auth, [{
	    key: "grantExchangeToken",
	    value: function grantExchangeToken(parameters) {
	      var params = parameters || {};
	      if (!params.subject_token) throw new Error("Os8Auth.grantExchangeToken must be called with parameter subject_token.");
	      var urlParams = Object.assign({}, params, {
	        response_type: "id_token token",
	        client_id: this.options.clientId,
	        redirect_uri: this.options.redirectUri
	      });
	      var urlParamsParts = Object.keys(urlParams).filter(function (k) {
	        return urlParams[k] != null;
	      }).map(function (k) {
	        return encodeURIComponent(k) + "=" + encodeURIComponent(urlParams[k] + "");
	      });
	      var url = this.options.serverUri.replace(/\/*$/, "/") + "exchangeOs8Token" + "?" + urlParamsParts.join("&");

	      return new Promise(function (resolve, reject) {
	        new _IframeComponent2.default({
	          url: url,
	          onResult: function onResult(aLoginResult) {
	            var authResponse = _ImplicitFlow2.default.getAuthResponseFromCallback(aLoginResult);
	            if (!authResponse || authResponse.error) reject(authResponse);else resolve(authResponse);
	          }
	        }).render();
	      });
	    }
	  }]);

	  return Os8Auth;
	}();

	exports.default = Os8Auth;

/***/ },
/* 49 */
/*!****************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/util/StringUtil.js ***!
  \****************************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  toSnakeCase: function toSnakeCase(aText) {
	    return (aText || "").replace(/[A-Z]/g, function (m) {
	      return "_" + m.toLowerCase();
	    });
	  }
	};

/***/ },
/* 50 */
/*!***************************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/SessionStateChangeNotifier.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Dom = __webpack_require__(/*! ./util/Dom.js */ 51);

	var _Dom2 = _interopRequireDefault(_Dom);

	var _Discovery = __webpack_require__(/*! ./discovery/Discovery.js */ 34);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var logger = _uu_appg01_core.Logging.LoggerFactory.get("UuOidc.SessionStateChangeNotifier");

	var SessionStateChangeNotifier = function () {
	  function SessionStateChangeNotifier(session) {
	    _classCallCheck(this, SessionStateChangeNotifier);

	    this.session = session;
	    this._listeners = [];

	    this._checkState = this._checkState.bind(this);
	    this._onMessage = this._onMessage.bind(this);
	    this._init();
	  }

	  _createClass(SessionStateChangeNotifier, [{
	    key: "onStateChange",
	    value: function onStateChange(listenerFn) {
	      var _this = this;

	      this._listeners.push(listenerFn);
	      return function () {
	        // return function for unregistering
	        var idx = _this._listeners.indexOf(listenerFn);
	        if (idx != -1) _this._listeners.splice(idx, 1);
	        return idx != -1;
	      };
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      if (this._destroyed) return;
	      this._destroyed = true;
	      if (this._stateCheckInterval) clearInterval(this._stateCheckInterval);
	      delete this._stateCheckInterval;
	      window.removeEventListener("message", this._onMessage);
	      this._listeners = [];
	    }
	  }, {
	    key: "_init",
	    value: function _init() {
	      var _this2 = this;

	      // add iframe with check_session_iframe URL
	      _Dom2.default.domReady.then(function () {
	        if (_this2._destroyed) return;
	        return _Discovery2.default.getMetadata(_this2.session.serverUri).then(function (metadata) {
	          var iframeUrl = metadata.check_session_iframe;
	          if (!iframeUrl) {
	            console.error("The OpenID Connect server", _this2.session.serverUri, "doesn't support check_session_iframe (see", _Discovery2.default.getMetadataUri(_this2.session.serverUri), ").");
	            return;
	          }
	          logger.debug("Creating iframe with check_session_iframe endpoint URL - " + iframeUrl);
	          _this2._iframeTrustedOrigin = getOrigin(iframeUrl);
	          var iframe = _this2._iframe = document.createElement("iframe");
	          iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
	          iframe.tabIndex = "-1";
	          iframe.onload = function () {
	            return _this2._stateCheckAllowed = true;
	          };
	          iframe.src = iframeUrl;
	          document.body.appendChild(iframe);

	          // add message handler for processing messages from the iframe
	          window.addEventListener("message", _this2._onMessage);

	          // start checking
	          _this2._stateCheckInterval = setInterval(_this2._checkState, _this2.session.sessionCheckInterval * 1000);
	        });
	      });
	    }
	  }, {
	    key: "_onMessage",
	    value: function _onMessage(e) {
	      logger.debug("Received message from " + e.origin + ": " + e.data);
	      if (!this._iframe || e.source !== this._iframe.contentWindow || e.origin !== this._iframeTrustedOrigin) return;
	      if (e.data === "changed") {
	        logger.info("Received session state change notification from OIDC iframe (message: '" + e.data + "').");
	        this._listeners.forEach(function (fn) {
	          return fn();
	        });
	      }
	    }
	  }, {
	    key: "_checkState",
	    value: function _checkState() {
	      if (!this._stateCheckAllowed || !this._iframe) return;
	      var authResponse = (this.session._loginCtx || {}).authResponse;
	      if (!authResponse) return; // we have no session state (and we don't really need to get info that the user became logged in due to login in different tab)
	      if (!authResponse.session_state) return; // unknown session state (e.g. current token was provided directly, instead of via login in browser tab)

	      var query = this.session.clientId + " " + authResponse.session_state;
	      logger.debug("Querying session state change from OIDC iframe. Query: " + query);
	      this._iframe.contentWindow.postMessage(query, this._iframeTrustedOrigin);
	    }
	  }]);

	  return SessionStateChangeNotifier;
	}();

	exports.default = SessionStateChangeNotifier;


	function getOrigin(absUrl) {
	  return (absUrl || "").match(/^(https?:\/\/[^\/]+).*$/)[1] || null;
	}

/***/ },
/* 51 */
/*!*********************************************!*\
  !*** ../~/uu_oidcg01/dist-node/util/Dom.js ***!
  \*********************************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
	var domReadyPromise = isBrowser ? document.readyState === "interactive" || document.readyState === "complete" ? Promise.resolve() : new Promise(function (resolve) {
	  document.addEventListener("DOMContentLoaded", resolve, false);
	}) : Promise.resolve();

	exports.default = {
	  domReady: domReadyPromise
	};

/***/ },
/* 52 */
/*!***************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/SessionHandler.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = SessionHandler;

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var UuApp = _interopRequireWildcard(_uu_appg01_core);

	var _Session = __webpack_require__(/*! ./Session.js */ 31);

	var _Session2 = _interopRequireDefault(_Session);

	var _StringUtil = __webpack_require__(/*! ./util/StringUtil.js */ 49);

	var _StringUtil2 = _interopRequireDefault(_StringUtil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.

	/**
	 * @class UuOidc.SessionHandler
	 * @classdesc
	 * Interceptor for Client which authenticates command calls by using user from
	 * current / specified session. Additionally, if server responds with authentication challenge
	 * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor
	 * performs session login and calls the command again.
	 * 
	 * Interceptor is skipped if there's request header "authorization" set for the command call, even
	 * if the header value is null.
	 * 
	 * **Configuration**
	 * 
	 * Interceptor recognizes following options for command call:
	 * 
	 * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.
	 * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.
	 * 
	 * **Error handling**
	 * 
	 * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):
	 * 
	 * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.
	 */
	function SessionHandler(request, options, nextInterceptorFn) {
	  var hasCustomAuthn = "authorization" in request.headers;
	  if (hasCustomAuthn) return nextInterceptorFn(request, options);

	  var session = options.session || _Session2.default.currentSession;
	  var loginParams = options["uuoidc.loginParameters"];
	  if (loginParams) loginParams = Object.keys(loginParams).reduce(function (r, k) {
	    return r[_StringUtil2.default.toSnakeCase(k)] = loginParams[k], r;
	  }, {});
	  var count = 0;

	  function runWith(extraLoginParams) {
	    if (++count > 5) throw new UuApp.Error.AbortError("Command invocation stopped because user was not able to fulfill login requirements for the command within " + count + " attempts.");

	    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)
	    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);
	    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams) : Promise.resolve(session)).catch(function (e) {
	      // if user login failed then abort or throw
	      if (e === false) throw new UuApp.Error.AbortError("Command invocation stopped because user refused to log in.");
	      throw new UuApp.Error.Error("Command invocation stopped because of a login error.", e);
	    }).then(function (session) {
	      var isAuthenticated = session.isAuthenticated();
	      if (isAuthenticated) {
	        return Promise.resolve(session.getCallToken()).then(function (callToken) {
	          return { isAuthenticated: isAuthenticated, callToken: callToken };
	        });
	      }
	      return { isAuthenticated: isAuthenticated, callToken: null };
	    }).then(function (data) {
	      var isAuthenticated = data.isAuthenticated;
	      var callToken = data.callToken;
	      var authToken = callToken ? callToken.token : null;
	      if (authToken) request.headers["authorization"] = [callToken.tokenType || "Bearer", authToken].join(" ");
	      return nextInterceptorFn(request, options).catch(function (response) {
	        // check for special response values in WWW-Authenticate response header which indicates
	        // that we shall run login procedure with additional parameters and then try again the same command
	        try {
	          // NOTE Using try-catch in case that target server is cross-domain and CORS doesn't allow
	          // access to response headers.
	          var wwwAuthenticate = response.headers("www-authenticate");
	        } catch (e) {
	          console.error(e);
	        }
	        if (wwwAuthenticate) {
	          var valueMap = {};
	          wwwAuthenticate.replace(/^\S+\s+/, "").split(/,/).map(function (it) {
	            return it.trim();
	          }).forEach(function (it) {
	            // remove "Bearer "
	            var idx = it.indexOf("=");
	            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));
	            var value = decodeUriWithPlus(idx == -1 ? "" : it.substr(idx + 1));
	            valueMap[key] = decodeUriWithPlus(value);
	          });

	          var relevantValues = Object.keys(valueMap).filter(function (key) {
	            return key.match(/^(max_age|acr_values|prompt|scope)$/);
	          }).reduce(function (r, k) {
	            return r[k] = valueMap[k], r;
	          }, {});
	          // if there's any of relevant keys in the WWW-Authenticate response header then
	          // re-run the whole OIDC Handler with those values sent to login
	          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);

	          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also
	          if (!isAuthenticated) return runWith({ acr_values: "1" }); // require non-anonymous
	        }
	        return Promise.reject(response);
	      });
	    });
	  }
	  return runWith(null);
	}

	function decodeUriWithPlus(txt) {
	  return decodeURIComponent(txt.replace(/\+/g, " "));
	}

/***/ },
/* 53 */
/*!******************************************************!*\
  !*** ../~/uu_oidcg01/dist-node/bootstrap-session.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Session = __webpack_require__(/*! ./Session.js */ 31);

	var _Session2 = _interopRequireDefault(_Session);

	var _Dom = __webpack_require__(/*! ./util/Dom.js */ 51);

	var _Dom2 = _interopRequireDefault(_Dom);

	var _ImplicitFlow = __webpack_require__(/*! ./flow/ImplicitFlow.js */ 33);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function tryAutoLogin() {
	  if (_Session2.default.currentSession.isAuthenticated() || _Session2.default.currentSession._loginInProgress > 0) return;

	  // if there's access_token parameter in current URL, consider it as the id_token of the user
	  var id_token;
	  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {
	    id_token = decodeURIComponent(g.replace(/\+/g, " "));
	  });
	  if (id_token) {
	    return _Session2.default.currentSession._login({
	      access_token: id_token,
	      nonce: null
	    });
	  }

	  // try to login with no user interaction
	  return _Session2.default.currentSession._login({
	    prompt: "none", // no user interaction
	    acr_values: "1" // non-anonymous user
	  }).catch(function (e) {
	    if (_ImplicitFlow2.default.isLoggedOutError(e)) return; // everything is fine, we just aren't logged in
	    throw e; // some other error happenned
	  });
	}

	// try to login without prompting user (only for browser environment)
	var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
	if (isBrowser) {
	  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works
	  _Dom2.default.domReady.then(function () {
	    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter
	  }).then(_Session2.default.initPromise._finalizeInit.bind(null, true), _Session2.default.initPromise._finalizeInit.bind(null, false));
	} else {
	  _Session2.default.initPromise._finalizeInit(true);
	}

/***/ }
/******/ ])
});
;