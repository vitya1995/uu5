/*! uu_appg01_core, 3.2.0, 2017-10-11 15:23:33Z */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("UuApp", ["module"], factory);
	else if(typeof exports === 'object')
		exports["UuApp"] = factory(require("module"));
	else
		root["UuApp"] = factory(root["undefined"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!************************!*\
  !*** ../.tmp/index.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var mod=__webpack_require__(/*! module */ 1);
	  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
	  __webpack_require__.p=uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
	  module.exports = __webpack_require__(/*! __project__/index.js */ 2);

/***/ },
/* 1 */
/*!*********************************************************************************************!*\
  !*** external {"amd":"module","commonjs":"module","commonjs2":"module","root":"undefined"} ***!
  \*********************************************************************************************/
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Perflog = exports.Util = exports.Logging = exports.Error = exports.Uri = exports.AppClient = undefined;

	__webpack_require__(/*! ./polyfills.js */ 3);

	var _index = __webpack_require__(/*! ./app-client/index.js */ 8);

	var AppClient = _interopRequireWildcard(_index);

	var _index2 = __webpack_require__(/*! ./uri/index.js */ 23);

	var Uri = _interopRequireWildcard(_index2);

	var _index3 = __webpack_require__(/*! ./error/index.js */ 10);

	var Error = _interopRequireWildcard(_index3);

	var _index4 = __webpack_require__(/*! ./logging/index.js */ 18);

	var Logging = _interopRequireWildcard(_index4);

	var _index5 = __webpack_require__(/*! ./util/index.js */ 16);

	var Util = _interopRequireWildcard(_index5);

	var _index6 = __webpack_require__(/*! ./perflog/index.js */ 21);

	var Perflog = _interopRequireWildcard(_index6);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.AppClient = AppClient;
	exports.Uri = Uri;
	exports.Error = Error;
	exports.Logging = Logging;
	exports.Util = Util;
	exports.Perflog = Perflog;

/***/ },
/* 3 */
/*!**********************!*\
  !*** ./polyfills.js ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _es6Promise = __webpack_require__(/*! es6-promise */ 4);

	var _es6Promise2 = _interopRequireDefault(_es6Promise);

	var _objectAssign = __webpack_require__(/*! object-assign */ 7);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Promise API (IE)
	_es6Promise2.default.polyfill();

	// Object.assign (IE)
	if (!Object.assign) Object.assign = _objectAssign2.default;

	// document.baseURI (IE)
	if (typeof document !== "undefined" && !document.baseURI) {
	  var baseEl = document.querySelector("base");
	  if (baseEl) document.baseURI = baseEl.href;else document.baseURI = location.href;
	}

/***/ },
/* 4 */
/*!********************************************!*\
  !*** ../~/es6-promise/dist/es6-promise.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */

	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';

	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}

	function isFunction(x) {
	  return typeof x === 'function';
	}

	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}

	var isArray = _isArray;

	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;

	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};

	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}

	function setAsap(asapFn) {
	  asap = asapFn;
	}

	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}

	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }

	  return useSetTimeout();
	}

	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });

	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}

	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}

	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}

	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];

	    callback(arg);

	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }

	  len = 0;
	}

	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(/*! vertx */ 6);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}

	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}

	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;

	  var parent = this;

	  var child = new this.constructor(noop);

	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }

	  var _state = parent._state;

	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }

	  return child;
	}

	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.resolve(1);

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }

	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}

	var PROMISE_ID = Math.random().toString(36).substring(16);

	function noop() {}

	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;

	var GET_THEN_ERROR = new ErrorObject();

	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}

	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}

	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}

	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}

	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;

	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));

	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}

	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}

	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}

	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}

	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }

	  publish(promise);
	}

	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }

	  promise._result = value;
	  promise._state = FULFILLED;

	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}

	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;

	  asap(publishRejection, promise);
	}

	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;

	  parent._onerror = null;

	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;

	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}

	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;

	  if (subscribers.length === 0) {
	    return;
	  }

	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;

	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];

	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }

	  promise._subscribers.length = 0;
	}

	function ErrorObject() {
	  this.error = null;
	}

	var TRY_CATCH_ERROR = new ErrorObject();

	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}

	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;

	  if (hasCallback) {
	    value = tryCatch(callback, detail);

	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }

	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }

	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}

	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}

	var id = 0;
	function nextId() {
	  return id++;
	}

	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}

	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);

	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }

	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;

	    this._result = new Array(this.length);

	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}

	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};

	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;

	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};

	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;

	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);

	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};

	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;

	  if (promise._state === PENDING) {
	    this._remaining--;

	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }

	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};

	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;

	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};

	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```

	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```

	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}

	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.

	  Example:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```

	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```

	  An example real-world use case is implementing timeouts:

	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```

	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}

	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}

	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}

	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}

	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.

	  Terminology
	  -----------

	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.

	  A promise can be in one of three states: pending, fulfilled, or rejected.

	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.

	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.


	  Basic Usage:
	  ------------

	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);

	    // on failure
	    reject(reason);
	  });

	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Advanced Usage:
	  ---------------

	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.

	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();

	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();

	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }

	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Unlike callbacks, promises are great composable primitives.

	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON

	    return values;
	  });
	  ```

	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];

	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}

	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;

	Promise.prototype = {
	  constructor: Promise,

	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,

	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};

	function polyfill() {
	    var local = undefined;

	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }

	    var P = local.Promise;

	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }

	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }

	    local.Promise = Promise;
	}

	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;

	return Promise;

	})));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ../~/process/browser.js */ 5), (function() { return this; }())))

/***/ },
/* 5 */
/*!*******************************!*\
  !*** ../~/process/browser.js ***!
  \*******************************/
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 6 */
/*!***********************!*\
  !*** vertx (ignored) ***!
  \***********************/
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 7 */
/*!***********************************!*\
  !*** ../~/object-assign/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 8 */
/*!*****************************!*\
  !*** ./app-client/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Client = undefined;

	var _Client = __webpack_require__(/*! ./Client.js */ 9);

	var _Client2 = _interopRequireDefault(_Client);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Client = _Client2.default;

/***/ },
/* 9 */
/*!******************************!*\
  !*** ./app-client/Client.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _index = __webpack_require__(/*! ../error/index.js */ 10);

	var _index2 = __webpack_require__(/*! ../util/index.js */ 16);

	var _index3 = __webpack_require__(/*! ../logging/index.js */ 18);

	var _index4 = __webpack_require__(/*! ../perflog/index.js */ 21);

	var logger = _index3.LoggerFactory.get("UuApp.AppClient.Client");

	/**
	 * Creates an instance of command client which will use specified configuration when invoking commands.
	 * Unspecified values are taken from global defaults ({@link UuApp.AppClient.Client.defaults Client.defaults}). Most
	 * values can be further overridden when invoking the remote call - see {@link UuApp.AppClient.Client#post Client#post}.
	 * 
	 * **Interceptors**
	 * 
	 * It's possible to provide a list of interceptors which pre-/post-process HTTP requests. An interceptor
	 * is a JavaScript function {Promise<Response>} interceptorFn({Object} request, {Object} options, {Function} nextInterceptorFn).
	 * Request object contains fields uri, method, body and options object contains any remaining options passed down to
	 * interceptors, e.g. transformParameters). Example:
	 * 
	 *     function MyInterceptor(request, options, nextInterceptorFn) {
	 *       // pre-process in any way
	 *       request.headers["x-extra-header-computed-value"] = Math.random() + "";
	 *       console.log("Launching Ajax request. Method:", request.method, "Uri:", request.uri, "Parameters:", request.body, "Other options:", options);
	 *       var start = new Date().getTime();
	 *       return nextInterceptorFn(request, options).then(function (response) {
	 *         // post-process in any way, e.g. add extra field to the response object
	 *         response.timeTaken = new Date().getTime() - start;
	 *         return response;
	 *       }, function error(response) {
	 *         // ...
	 *         return Promise.reject(response); // keep it rejected (i.e. in error state)
	 *       });
	 *     }
	 *     
	 *     // usage of the interceptor
	 *     var client = new UuApp.AppClient.Client({
	 *       interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
	 *     });
	 *     
	 * @class UuApp.AppClient.Client
	 * @classdesc
	 * The Client allows communication with remote uuOS9 endpoints which conform to uuUri format.
	 * Besides communication, the client solves also other points of interest, such as authentication or
	 * performance logging.
	 * 
	 * Client uses standardized {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise API}
	 * to provide access to the result of the call.
	 * 
	 *     UuApp.AppClient.Client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function (response) {
	 *       console.log(response.data, response.status, response.headers());
	 *     }, function (response) { // error
	 *       console.log(response.error, response.status, response.headers());
	 *     });
	 * 
	 * When used as above, client uses global defaults (timeout, headers, ...). If the call needs to be parametrized, it can
	 * be parametrized directly in {@link UuApp.AppClient.Client#post Client#post} ({@link UuApp.AppClient.Client#get Client#get})
	 * call or, alternatively, a client instance can be created with defaults that override the global ones.
	 * 
	 * For pre-/post-processing of HTTP requests use custom interceptors (see constructor).
	 * 
	 * **Configuration**
	 * 
	 * Some options are automatically configured from the environment during
	 * {@link UuApp.Util.Config.init Config.init} call. These can be overridden when instantiating
	 * the client or in method invocations. Supported environment options:
	 * 
	 *     {
	 *       "gatewayUri": "https://uuappg01.plus4u.net", // default gateway for command calls using uuUri that doesn't contain gateway
	 *       "vendor-app-subapp-spp.gatewayUri": "https://elsewhere.plus4u.net"
	 *     }
	 * 
	 * @param {Object} options Default options for this instance of the command client.
	 * @param {number} options.requestTimeout The default HTTP timeout for this instance of the command client, in seconds.
	 * @param {Object} options.headers The default HTTP headers for command invocations using this instance of the command client.
	 * @param {Object[]} options.interceptors List of interceptors to use. Interceptors can arbitrarily pre-/post-process
	 *   HTTP requests.
	 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
	 *   as "gatewayUri" which then take precedence over those from global environment.
	 * 
	 * @example
	 *    var client = new UuApp.AppClient.Client({
	 *      requestTimeout: 20,
	 *      headers: {
	 *        "x-my-extra-header": "abcd"
	 *      },
	 *      interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
	 *    });
	 * 
	 *    // ... all calls using "client.get(...)" or "client.post()" will have timeout 20s (unless the timeout
	 *    // is overridden in the invoke call directly) and will have an extra HTTP header.
	 */
	function Client(options) {
	  this.options = options || {};
	  this.options.headers = keysToLowerCase(this.options.headers);
	}

	/**
	 * Global defaults for command client. 
	 * 
	 *     {
	 *       requestTimeout: 300,   // timeout in seconds
	 *       interceptors: [ // default set of interceptors
	 *         // ...
	 *       ]
	 *     }
	 * 
	 * @name UuApp.AppClient.Client.defaults
	 */
	Client.defaults = {
	  requestTimeout: 300,
	  interceptors: [UriHandler, RemoteErrorHandler, UujsonHandler, TransformParametersHandler, PerfLogHandler]
	};

	function keysToLowerCase(map) {
	  if (!map || (typeof map === "undefined" ? "undefined" : _typeof(map)) != "object") return null;
	  var result = {};
	  for (var k in map) {
	    result[k.toLowerCase()] = map[k];
	  }return result;
	}
	Client.prototype.invoke = function (method, uri, parameters, options) {
	  // prepare data for interceptors & http client
	  var interceptorOpts = Object.assign({}, this.options, options);
	  delete interceptorOpts.requestTimeout;
	  delete interceptorOpts.headers;
	  delete interceptorOpts.interceptors;
	  var request = {
	    method: (method || "post").toLowerCase(),
	    uri: uri,
	    body: parameters,
	    headers: Object.assign({}, this.options.headers, keysToLowerCase((options || {}).headers))
	  };
	  var httpClientOpts = {
	    requestTimeout: (options || {}).requestTimeout != null ? (options || {}).requestTimeout : this.options.requestTimeout
	  };

	  // run interceptors (with 1st interceptor being the entry-point of the chain; last interceptor will continue with InvokeXhr method)
	  var interceptors = this.options.interceptors || this.constructor.defaults.interceptors || [];
	  var lastResponse;
	  var chainFn = interceptors.reduceRight(function (chainFn, interceptorFn) {
	    return function (req, opts) {
	      var result;
	      try {
	        result = interceptorFn(req, opts, chainFn);
	        if (!result || (typeof result === "undefined" ? "undefined" : _typeof(result)) != "object" || typeof result.then != "function") result = Promise.resolve(result);
	      } catch (e) {
	        result = Promise.reject(e);
	      }
	      // make sure that interceptor always returns "response" object
	      // (even if some unexpected / unhandled error happened)
	      return result.then(function (anyValue) {
	        var response = anyValue;
	        if (!anyValue || !("status" in anyValue)) {
	          // it's not a "response" object and it's not rejected (i.e. bugged interceptor) => use it as "data" on last known "response"
	          logger.warn("Client interceptor %s resolved the promise into a value that is not a Response object - auto-wrapping.", interceptorFn.name);
	          response = lastResponse || interceptorMakeResponse(null, req, opts);
	          if (anyValue !== undefined) response.data = anyValue; // don't overwrite data if interceptor just didn't use "return response;"
	        }
	        lastResponse = response;
	        if (lastResponse.error) logger.warn("Client interceptor %s resolved response successfully but kept the error object set - unsetting. Error object:", interceptorFn.name, lastResponse.error);
	        lastResponse.error = null;
	        return response;
	      }, function wrapAsResponse(anyValue) {
	        if (!anyValue || !("status" in anyValue)) {
	          // it's not a "response" object => take the last known "response" and update its "error" field
	          if (!lastResponse) lastResponse = interceptorMakeResponse(null, req, opts);
	          lastResponse.error = anyValue instanceof _index.Error ? anyValue : new _index.Error("Client interceptor " + interceptorFn.name + " ended with error.", anyValue);
	        } else {
	          // it's a "response" object => use it as-is
	          lastResponse = anyValue;
	        }
	        return Promise.reject(lastResponse);
	      });
	    };
	  }, InvokeXhr.bind(null, this, httpClientOpts));
	  var resultPromise = chainFn(request, interceptorOpts);

	  // add support for aborting on-going requests
	  var aborted = false;
	  resultPromise.abort = function () {
	    aborted = true;
	    if (httpClientOpts.xhr) httpClientOpts.xhr.abort(); // Ajax might not have been called yet
	  };

	  return resultPromise;

	  function InvokeXhr(cmdClient, httpClientOpts, finalRequest, finalOpts) {
	    if (aborted) return Promise.reject(interceptorMakeResponse(null, finalRequest, { error: new _index.AbortError("The Client call has been aborted.") }));

	    var xhr = httpClientOpts.xhr = new XMLHttpRequest();
	    return new Promise(function executor(resolve, reject) {
	      var canHaveBody = finalRequest.method.match(/^(put|post)$/i);
	      var url = finalRequest.uri.toString();
	      var body;
	      if (!canHaveBody) {
	        if (finalRequest.body) url += (url.indexOf("?") == -1 ? "?" : "&") + finalRequest.body;
	      } else {
	        body = finalRequest.body;
	      }
	      var headers = finalRequest.headers;
	      var timeout = httpClientOpts.requestTimeout = httpClientOpts.requestTimeout != null ? httpClientOpts.requestTimeout : cmdClient.constructor.defaults.requestTimeout;
	      if (logger.isDebugLoggable()) logger.debug("Invoking Ajax request.", { method: finalRequest.method, url: url, body: body, requestTimeout: timeout, headers: headers });else if (logger.isInfoLoggable()) logger.info("Invoking Ajax request.", { method: finalRequest.method, url: url });

	      xhr.open(finalRequest.method, url, true);
	      if (timeout > 0) xhr.timeout = timeout * 1000;
	      xhr.withCredentials = true;
	      for (var k in headers) {
	        var v = headers[k];
	        if (k && v != null) {
	          // omit "Content-Type" header if it's multipart/form-data, otherwise the browser doesn't update
	          // it with proper boundary and server won't be able to parse the body
	          if (k === "content-type" && body instanceof FormData && v === "multipart/form-data") continue;
	          xhr.setRequestHeader(k.replace(/(^|-)./g, function (m) {
	            return m.toUpperCase();
	          }), v + "");
	        }
	      }
	      xhr.ontimeout = function (e) {
	        // TimeoutError
	        logger.info("Request timed out.", { url: url });
	        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.TimeoutError("Request timed out - " + url) }));
	      };
	      xhr.onload = function (e) {
	        // status 200 - 5xx
	        if (logger.isDebugLoggable()) logger.debug("Received response.", { url: url, status: xhr.status, data: xhr.response });else logger.info("Received response.", { url: url, status: xhr.status });
	        resolve(interceptorMakeResponse(xhr, finalRequest, { data: xhr.response }));
	      };
	      xhr.onabort = function (e) {
	        // user / developer abort; AbortError
	        logger.info("Request has been aborted.", { url: url });
	        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.AbortError("Request has been aborted - " + url) }));
	      };
	      xhr.onerror = function (e) {
	        // network error; NetworkError
	        logger.info("Request ended with network error.", { url: url });
	        reject(interceptorMakeResponse(xhr, finalRequest, { error: new _index.NetworkError("Network error - " + url), data: xhr.response }));
	      };
	      xhr.send(body);
	    });
	  }
	};

	/**
	 * Invokes remote call using HTTP GET request. See {@link UuApp.AppClient.Client#post Client#post}
	 * for detailed options and behaviour.
	 * 
	 * Keep in mind that the "parameters" parameter is sent via URL parameter(s)
	 * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
	 * doesn't exceed 2048 bytes.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
	 * @param {*} parameters The parameters to send in the request URL.
	 * @param {Object} options Optional options for the remote call.
	 * @return Promise resolving to a response object (or rejecting to a response object with error field).
	 * @method UuApp.AppClient.Client#get
	 * @see {@link UuApp.AppClient.Client#post Client#post}
	 * 
	 * @example
	 *    // simple call
	 *    var baseUri = Uri.parse(location.protocol + "//" + location.host + location.pathname).baseUri; // "http://example.com/vendor-app/tid-awid"
	 *    Client.get(baseUri.join("+/getAttributes"), { param1: "v1" }).then(function success(response) {
	 *      var data = response.data; // contains parsed response entity
	 *      console.log(response.status, response.headers(), response.data);
	 *    }, function error(response) {
	 *      var error = response.error; // contains parsed response error
	 *      console.log(response.status, response.headers(), response.error);
	 *    });
	 *    
	 * @example
	 *    // parameterizing uuUri and the call
	 *    var uri = new UuApp.Uri.UriBuilder("/cds-gb-main/0-0/getAttributes", {
	 *      workspace: "15634-34e5684da3435",
	 *      useCase: "getConfig",
	 *      parameters: { p1: "v1" }
	 *    }).toUri();
	 *    client.get(uri, null, {
	 *      requestTimeout: 5,
	 *      headers: {
	 *        "x-my-header": "abc"
	 *      }
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 *    
	 * @example
	 *    // accept any response and don't parse it
	 *    var workspace = "...";
	 *    var guestbookId = "...";
	 *    client.get(`/cds-gb/${workspace}/guestbook/${guestbookId}/downloadData`, null, {
	 *      transformResponse: false,
	 *      headers: {
	 *        "accept": "*\/*"
	 *      }
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 */
	Client.prototype.get = function (uri, parameters, options) {
	  return this.invoke("get", uri, parameters, options);
	};

	/**
	 * Invokes remote call using HTTP POST request. Default values for settings will
	 * be filled in from Client instance configuration and then from global defaults.
	 * 
	 * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
	 * to the specified "content-type" HTTP request/response header.
	 * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
	 * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or 
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or 
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
	 * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
	 * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
	 * 
	 * **Return value**
	 * 
	 * Return value is a {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
	 * resolving / rejecting to a response object which contains following fields:
	 * 
	 * * {Object} data - response data. Data is parsed with content handler according to "content-type" response header
	 *     unless option transformResponse is false (in which case it's left as received from browser).
	 * * {Error} error - the error instance (see Error handling below). This field is set if and only if the Promise is rejected. 
	 * * {number} status - the HTTP status code.
	 * * {function(string)} headers - function which returns value of the specified (case-insenstive) response header.
	 *   If called with no arguments, an array with all response headers is returned.
	 * * {Object} config - final configuration options that were used for launching AJAX request.
	 * 
	 * The returned Promise instance additionally contains method {function()} abort for aborting ongoing remote call.
	 * 
	 * **File upload**
	 * 
	 * Use "content-type" header with "multipart/form-data" value when uploading binary data (File, Blob). Alternatively, it's
	 * possible to use standard {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object - see examples
	 * below. Note that when using FormData object, the order of appending the form fields matters - append simple values first
	 * and only in the end append file objects. The reason is that in this order, the server might decide not to allow the upload
	 * based on the other already-available fields thus allowing to end the connection without full upload of the file(s).
	 * _(Client will fix the order of values in FormData object, however not all browsers support this operation.)_
	 * 
	 * Don't forget to **disable timeout when performing the upload** so that it doesn't get cancelled.  
	 * 
	 * **Error handling**
	 * 
	 * If an error happens during the call invocation (determined by HTTP response status code), the resulting Promise is
	 * rejected with response object which will contain "error" field set to an instance of one of these error types
	 * (when using default interceptors):
	 * 
	 *   * null - if server sent response with error HTTP status code but it contained no recognizable error data.
	 *   * {@link UuApp.Error.RemoteError} - error as sent from remote server. Note that the response can contain
	 *     several errors - in such case only first error is extracted into "error" field.
	 *   * {@link UuApp.Error.NetworkError} - in case of problems with connecting to remote server.
	 *   * {@link UuApp.Error.TimeoutError} - when the request didn't end within specified timeout.
	 *   * {@link UuApp.Error.AbortError} - when invocation is aborted by invoking promise.abort() method.
	 *   
	 * The resulting response object contains also HTTP status code and will contain "data"
	 * field set to the response entity (usually containing parsed error list).
	 * 
	 * **Timeout**
	 * 
	 * The timeout applies to the remote call duration only. If an interceptor is used which performs lengthy or asynchronous
	 * operation prior to executing the remote call, it's not counted towards the timeout.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
	 * @param {(FormData|*)} parameters The DTO to send in the request body.
	 * @param {Object} options Optional options for the remote call.
	 * @param {number} options.requestTimeout The timeout for the command invocation. Default is 300.
	 * @param {Object} options.headers The HTTP headers to send. Header names are case-insensitive, but it's advised
	 *   to use lowercased names to prevent duplicities within the map. Headers are merged with default headers from
	 *   Client / global configuration. If a header is in defaults and it's required to prevent it from being
	 *   sent during this invocation, specify the header and use null as its value. 
	 * @param {boolean} options.transformParameters If false, processing of the command parameters (DTO) will be skipped so they'll be
	 *   sent exactly as-is (the browser must support sending the value as-is in XmlHttpRequest). Default value is true.
	 * @param {boolean} options.transformResponse If false, processing of the response (such as parsing the response as JSON) will be skipped. Default is true.
	 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
	 *   as "gatewayUri" which then take precedence over those from global environment.
	 * @return Promise resolving to a response object (or rejecting to a response object with error field).
	 * @method UuApp.AppClient.Client#post
	 * 
	 * @example
	 *    // command call sending data 
	 *    var tenant = "UU-BT";
	 *    var guestbookId = "123";
	 *    client.post(`/cds-gb/${tenant}/guestbook/${guestbookId}/setAttributes`, {
	 *      name: "Modified guestbook",
	 *      invitesLimit: 10,
	 *      public: true
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 *    
	 * @example
	 *     // uploading file(s) - variant 1 (explicit Content-Type header)
	 *     var file = inputElement.files[0];
	 *     var params = {
	 *       file: file,
	 *       anotherValue: "abc"
	 *     }
	 *     client.post("/cds-gb/UU-BT/guestbook/123/uploadData", params, {
	 *       requestTimeout: 0,
	 *       headers: {
	 *         "content-type": "multipart/form-data"
	 *       }
	 *     });
	 *     
	 *     // uploading file(s) - variant 2 (usage of FormData)
	 *     // !!! append files as the last values
	 *     var formData = new FormData();
	 *     formData.append("anotherValue", "abc");
	 *     formData.append("file", file);
	 *     var promise = client.post("/cds-gb/UU-BT/guestbook/123/uploadData", formData, {
	 *       requestTimeout: 0
	 *     });
	 *     promise.then(...); // process response / error
	 *     
	 *     // aborting ongoing call
	 *     elementForUploadCancel.onclick = function (e) {
	 *       promise.abort(); // promise will be rejected with UuApp.Error.AbortError instance
	 *     };
	 *     
	 * @example
	 *    // error distinguishing
	 *    client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function success(response) {
	 *      console.log(response.status, response.headers(), response.data);
	 *    }, function error(response) {
	 *      console.log(response.status, response.headers(), response.data);
	 *      var error = response.error;
	 *      if (error instanceof UuApp.Error.TimeoutError) console.log("Timed out.");
	 *      else if (error instanceof UuApp.Error.AbortError) console.log("Aborted.");
	 *      else if (error instanceof UuApp.Error.NetworkError) console.log("Communication / network error.");
	 *      else if (response.status == 401) console.log("Not authenticated.");
	 *      else if (response.status < 500) {
	 *        console.log("User or client problem - invalid data / unfulfilled business rules / invalid call / ...", response.data);
	 *      } else if (response.status >= 500) console.log("Server-side problem.", response.data);
	 *      else console.log("Unrecognized problem.", error);
	 *    });
	 * 
	 * @example
	 *    // send data in custom format
	 *    client.post("/cds-gb/UU-BT/guestbook/123/setSomething", convertToMySuperFormat(dto), {
	 *      transformParameters: false,
	 *      headers: {
	 *        "content-type": "text/x-my-super-format"
	 *      }
	 *    }).then(console.log.bind(console), console.log.bind(console));
	 */
	Client.prototype.post = function (uri, parameters, options) {
	  return this.invoke("post", uri, parameters, options);
	};
	//  Client.prototype.put = function (uri, parameters, options) {
	//    return this.invoke("put", uri, parameters, options);
	//  };
	//  Client.prototype.delete = function (uri, options) {
	//    return this.invoke("delete", uri, null, options);
	//  };

	var defClient;
	/**
	 * Equivalent to {@link UuApp.AppClient.Client#get} using Client with default
	 * configuration, i.e.:
	 * 
	 *     new UuApp.AppClient.Client().get(uri, options)
	 * 
	 * @see {@link UuApp.AppClient.Client#get Client#get}
	 * @method UuApp.AppClient.Client.get
	 */
	Client.get = function () /*uri, options*/{
	  if (!defClient) defClient = new Client();
	  return defClient.get.apply(defClient, arguments);
	};

	/**
	 * Equivalent to {@link UuApp.AppClient.Client#post} using Client with default
	 * configuration, i.e.:
	 * 
	 *     new UuApp.AppClient.Client().post(uri, parameters, options)
	 * 
	 * @see {@link UuApp.AppClient.Client#post Client#post}
	 * @method UuApp.AppClient.Client.post
	 */
	Client.post = function () /*uri, parameters, options*/{
	  if (!defClient) defClient = new Client();
	  return defClient.post.apply(defClient, arguments);
	};

	/**
	 * Interceptor for finalizing uuUri URL in case it's incomplete (missing gateway).
	 * 
	 * @name UuApp.AppClient.Client.UriHandler
	 */
	Client.UriHandler = UriHandler;
	function UriHandler(request, options, nextInterceptorFn) {
	  // take gateway from environment only when gateway is missing in URI (and environment was initialized)
	  var uri = (request.uri || "").toString();
	  request.uri = uri;
	  if (uri.match(/^https?:/i)) return nextInterceptorFn(request, options);

	  function carryOn(env) {
	    if (baseUrl == null) {
	      var optName = "gatewayUri";
	      baseUrl = env ? env.get(optName) : null;
	      if (baseUrl == null) baseUrl = "https://uuappg01.plus4u.net";
	    }

	    if (baseUrl) request.uri = baseUrl.replace(/\/+$/, "") + "/" + uri.replace(/^\/+/, "");
	    return nextInterceptorFn(request, options);
	  }
	  var baseUrl = options["gatewayUri"];
	  if (baseUrl == null) return Promise.resolve(_index2.Config.initPromise).then(carryOn);
	  return carryOn();
	}

	/**
	 * Interceptor for extracting error information from response.
	 * 
	 * @name UuApp.AppClient.Client.RemoteErrorHandler
	 */
	Client.RemoteErrorHandler = RemoteErrorHandler;
	function RemoteErrorHandler(request, options, nextInterceptorFn) {
	  // NOTE We assume that the "content-type" transformation has been already performed on response data.
	  return nextInterceptorFn(request, options).then(checkError.bind(null, false), checkError.bind(null, true));

	  function checkError(isReject, response) {
	    if (response.status >= 400) {
	      var errorData = response.data;
	      // fill first error from response data into "error" field (if any)
	      if (errorData && (typeof errorData === "undefined" ? "undefined" : _typeof(errorData)) === "object" && "uuAppErrorMap" in errorData) {
	        var errorMap = errorData["uuAppErrorMap"];
	        var firstErrorKey = null;
	        if (errorMap) for (var k in errorMap) {
	          if (errorMap[k] && errorMap[k].type === "error") {
	            firstErrorKey = k;
	            break;
	          }
	        }if (firstErrorKey) response.error = new _index.RemoteError(Object.assign({}, errorMap[firstErrorKey], { code: k }));
	      }
	      return Promise.reject(response);
	    }
	    return isReject ? Promise.reject(response) : response;
	  }
	}

	/**
	 * In case uuJSON format is used, validates input parameters to match uuJSON specification
	 * (including validation of declared schema to match invoked command) and ensures uuJSON
	 * usage is properly reported to remote server.
	 * 
	 * Recognized options:
	 * 
	 * * uujson {boolean} - whether uuJSON format is used. Parameters must contain schema and data.
	 *  
	 * @name UuApp.AppClient.Client.UujsonHandler
	 */
	Client.UujsonHandler = UujsonHandler;
	function UujsonHandler(request, options, nextInterceptorFn) {
	  var uri = request.uri + "";
	  var isUujson = options["uujson"] || uri.match(/[?&]_uujson(=|$)/);
	  if (isUujson) {
	    var usedUri = uri.replace(/[?&]_uujson(?==|$)[^&]*/, "");
	    usedUri += (usedUri.indexOf(/\?/) === -1 ? "?" : "&") + "_uujson=";
	    request.uri = usedUri;
	  }
	  return nextInterceptorFn(request, options); // no .then(...) - no response post-processing
	}

	/**
	 * Interceptor for transforming request parameters / response entity according to the Content Type.
	 * Recognized options:
	 * 
	 * - transformParameters {boolean} - whether to transform (serialize by Content-Type) request body
	 * - transformResponse {boolean} - whether to transform (deserialize by Content-Type) response body
	 * - wrapQuery {boolean} - whether to wrap request body with { dto: ... }
	 * 
	 * @name UuApp.AppClient.Client.TransformParametersHandler
	 */
	Client.TransformParametersHandler = TransformParametersHandler;
	function TransformParametersHandler(request, options, nextInterceptorFn) {
	  function getMimeMainType(mimeType) {
	    return (mimeType || "").replace(/[+;].*/, "").trim();
	  }

	  // add default Content-Type & Accept headers
	  var paramsInBody = request.method.match(/^(put|post)$/i);
	  var contentTransformers = Client.contentTransformers || {};
	  var contentType = request.headers["content-type"];
	  if (!("content-type" in request.headers)) {
	    if (paramsInBody) {
	      var isMultipartPreferred = request.body != null && (request.body instanceof FormData || request.body instanceof Blob || _typeof(request.body) == "object" && Object.keys(request.body).some(function (it) {
	        return it instanceof FormData || it instanceof Blob;
	      }));
	      contentType = isMultipartPreferred ? "multipart/form-data" : "application/json; charset=utf-8";
	      request.headers["content-type"] = contentType;
	    } else {
	      contentType = "application/x-www-form-urlencoded";
	    }
	  }
	  if (!("accept" in request.headers)) request.headers["accept"] = "application/json";

	  // wrap request data into "dto" parameter if requested to do so
	  if (options.transformParameters !== false && !paramsInBody && request.body != null && options.wrapQuery && contentType == "application/x-www-form-urlencoded") {
	    request.body = {
	      dto: JSON.stringify(request.body)
	    };
	  }

	  // transform request data
	  if (options.transformParameters !== false && request.body != null) {
	    var contentHandler = contentTransformers[getMimeMainType(contentType)];
	    try {
	      if (contentHandler) request.body = contentHandler.serialize(request.body);
	    } catch (e) {
	      throw new _index.Error("Error while serializing data.", e);
	    }
	  }

	  // continue and transform response data afterwards (regardless of success / failure)
	  return nextInterceptorFn(request, options).then(transformResponse.bind(null, false), transformResponse.bind(null, true));

	  function transformResponse(isReject, response) {
	    if (options.transformResponse !== false) {
	      var respContentType = response.headers("content-type");
	      var contentHandler = contentTransformers[getMimeMainType(respContentType)];
	      try {
	        if (contentHandler) response.data = contentHandler.deserialize(response.data);else if (response.status === 204) response.data = null;
	      } catch (e) {
	        throw new _index.Error("Error while deserializing response data.", e);
	      }
	    }
	    return isReject ? Promise.reject(response) : response;
	  }
	}

	/**
	 * Interceptor for performance logging.
	 * 
	 * @name UuApp.AppClient.Client.PerfLogHandler
	 */
	function PerfLogHandler(request, options, nextInterceptorFn) {
	  var promise;
	  _index4.PerfLog.measureSection("commandInvocation", function (section) {
	    request.headers["x-request-id"] = section.id;
	    promise = nextInterceptorFn(request, options);
	    return promise.then(function (response) {
	      section.attributes["uri"] = request.uri;
	      return response;
	    }, function (response) {
	      section.attributes["uri"] = request.uri;
	      return Promise.reject(response);
	    });
	  });
	  return promise;
	}

	function interceptorMakeResponse(xhr, request, extraFields) {
	  return Object.assign({
	    status: xhr ? xhr.status : 0,
	    headers: function headers(aHeader) {
	      if (!aHeader) return xhr ? xhr.getAllResponseHeaders() : [];
	      return xhr ? xhr.getResponseHeader(aHeader) : null;
	    }
	  }, extraFields);
	}

	var Json = {
	  serialize: function serialize(value) {
	    return JSON.stringify(value);
	  },
	  deserialize: function deserialize(value) {
	    return value ? JSON.parse(value) : null;
	  }
	};
	var Form = {
	  serialize: function serialize(value) {
	    if (value == null) return value;
	    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
	      logger.warn("Unrecognized value when serializing as application/x-www-form-urlencoded - passing as-is. Value:", { value: value });
	      return value;
	    }
	    var result = [];
	    for (var k in value) {
	      result.push(encodeURIComponent(k) + "=" + encodeURIComponent(value[k]));
	    }return result.join("&");
	  },
	  deserialize: function deserialize(value) {
	    if (value == null) return value;
	    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
	      logger.warn("Unrecognized value when deserializing as application/x-www-form-urlencoded - passing as-is. Value:", { value: value });
	      return value;
	    }
	    var pairs = value.replace(/\+/g, " ").split("&");
	    var result = {};
	    for (var i = 0; i < pairs.length; ++i) {
	      var pair = pairs[i];
	      pair.replace(/^([^=]*)=?(.*)$/, function (m, g1, g2) {
	        return result[decodeURIComponent(g1)] = decodeURIComponent(g2);
	      });
	    }
	    return result;
	  }
	};
	var MultiPart = {
	  serialize: function serialize(value) {
	    if (!value) return value;
	    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) != "object") {
	      logger.warn("Unrecognized value when serializing as multipart/form-data - passing as-is. Value:", { value: value });
	      return value;
	    }
	    if (value instanceof FormData && typeof value.entries != "function") return value; // FormData without support for iterating over its entries
	    if (value instanceof Blob) value = { file: value };

	    // make a list and reorder values so that the File instances are at the end of the list
	    var data = {};
	    if (value instanceof FormData) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = value.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var pair = _step.value;
	          data[pair[0]] = pair[1];
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    } else {
	      data = value;
	    }
	    var list = [];
	    for (var k in data) {
	      list.push({ key: k, value: data[k], i: list.length });
	    }var max = list.length;
	    list.sort(function (a, b) {
	      // stable sort
	      return (a.value instanceof File ? a.i + max : a.i) - (b.value instanceof File ? b.i + max : b.i);
	    });

	    // fill values into FormData
	    var formData = new FormData();
	    list.forEach(function (it) {
	      return formData.append(it.key, it.value);
	    });
	    return formData;
	  },
	  deserialize: function deserialize(value) {
	    throw new _index.Error("Deserializing multipart/form-data is not supported. Value: " + value);
	  }
	};

	/**
	 * Transformers which serialize / deserialize content that is sent to / received from
	 * server using specific MIME type.
	 */
	Client.contentTransformers = {
	  "application/json": Json,
	  // "application/json+extended": Json,
	  //"application/x-msgpack": MessagePack,
	  //"application/msgpack": MessagePack,
	  "application/x-www-form-urlencoded": Form,
	  "multipart/form-data": MultiPart
	};

	module.exports = Client;

/***/ },
/* 10 */
/*!************************!*\
  !*** ./error/index.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TimeoutError = exports.RemoteError = exports.NetworkError = exports.AbortError = exports.Error = undefined;

	var _Error = __webpack_require__(/*! ./Error.js */ 11);

	var _Error2 = _interopRequireDefault(_Error);

	var _AbortError = __webpack_require__(/*! ./AbortError.js */ 12);

	var _AbortError2 = _interopRequireDefault(_AbortError);

	var _NetworkError = __webpack_require__(/*! ./NetworkError.js */ 13);

	var _NetworkError2 = _interopRequireDefault(_NetworkError);

	var _RemoteError = __webpack_require__(/*! ./RemoteError.js */ 14);

	var _RemoteError2 = _interopRequireDefault(_RemoteError);

	var _TimeoutError = __webpack_require__(/*! ./TimeoutError.js */ 15);

	var _TimeoutError2 = _interopRequireDefault(_TimeoutError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Error = _Error2.default;
	exports.AbortError = _AbortError2.default;
	exports.NetworkError = _NetworkError2.default;
	exports.RemoteError = _RemoteError2.default;
	exports.TimeoutError = _TimeoutError2.default;

/***/ },
/* 11 */
/*!************************!*\
  !*** ./error/Error.js ***!
  \************************/
/***/ function(module, exports) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	// make native Error-s (TypeError, ...) be converted to JSON "somehow", because right now they always end up as {}
	try {
	  if (JSON.stringify(new Error()) == "{}") {
	    Error.prototype.toJSON = function () {
	      if (Object.hasOwnProperty(this, "toJSON")) return this; // to be on the safe-side
	      // we might be in a sub-classed error (TypeError, even custom Error) so temporarily override
	      // toJSON with as-is serialization and use toString() only if we would get no information otherwise
	      this.toJSON = function () {
	        return this;
	      };
	      var useToString = JSON.stringify(this) == "{}";
	      delete this.toJSON; // deletes override; toJSON on prototype chain (this one or any other) is preserved
	      // use this or toString() for final serialization
	      return useToString ? this.toString() + (this.stack != null ? "\n" + this.stack : "") : this;
	    };
	  }
	} catch (e) {}
	// ignore


	//  /**
	//   * Creates new Error.
	//   * 
	//   * This constructor can be also called with a single object literal containing any fields that
	//   * are to be set to the Error object. 
	//   *
	//   * @param {string} message The message.
	//   * @param {Error} cause (optional) The cause (original error).
	//   * @constructor UuApp.Error.Error
	//   */

	// TODO JSDoc doesn't support describing multiple signatures for the same method :-(.
	//  /**
	//   * Creates new Error.
	//   *
	//   * @param {Object} errorObject Object with any attributes to set to the Error instance.
	//   * @constructor UuApp.Error.Error
	//   */
	function _Error(msgOrObj) {
	  var self = this;
	  if (!(self instanceof _Error)) return new (_Error.bind.apply(_Error, arguments))(); // make an instance even if developer forgot to use "new" keyword
	  var errorObject = msgOrObj;
	  if (!errorObject || (typeof errorObject === "undefined" ? "undefined" : _typeof(errorObject)) != "object") {
	    errorObject = {
	      message: arguments[0],
	      cause: arguments[1]
	    };
	  }
	  Object.assign(this, errorObject);
	  if (!this.id) this.id = generateUuid();
	  if (!this.stack) this.stack = new Error().stack;
	  /**
	   * ID of the error. If not specified, it'll be automatically generated.
	   * @name UuApp.Error.Error#id
	   */
	  /**
	   * The message of the error.
	   * @name UuApp.Error.Error#message
	   */
	  /**
	   * The cause (nested error) of the error.
	   * @name UuApp.Error.Error#cause
	   */
	  /**
	   * Stacktrace of the error. If not specified, it'll be automatically filled via browser.
	   * @name UuApp.Error.Error#stack
	   */
	}
	_Error.prototype = Object.create(Error.prototype);
	_Error.prototype.constructor = _Error;

	function generateUuid() {
	  // generate UUID (RFC4122 version 4 compliant) for the event ID
	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0,
	        v = c == 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	  return uuid;
	}

	module.exports = _Error;

/***/ },
/* 12 */
/*!*****************************!*\
  !*** ./error/AbortError.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 11);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new AbortError.
	 * 
	 * @classdesc
	 * Represents an error when operation was aborted by user.
	 * 
	 * @constructor UuApp.Error.AbortError
	 */
	function AbortError() {
	  _Error2.default.apply(this, arguments);
	}
	AbortError.prototype = Object.create(_Error2.default.prototype);
	AbortError.prototype.constructor = AbortError;

	exports.default = AbortError;

/***/ },
/* 13 */
/*!*******************************!*\
  !*** ./error/NetworkError.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 11);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new NetworkError.
	 * 
	 * @classdesc
	 * Represents an error when operation ended with network failure (host lookup, disconnection, ...).
	 * 
	 * @constructor UuApp.Error.NetworkError
	 */
	function NetworkError() {
	  _Error2.default.apply(this, arguments);
	}
	NetworkError.prototype = Object.create(_Error2.default.prototype);
	NetworkError.prototype.constructor = NetworkError;

	exports.default = NetworkError;

/***/ },
/* 14 */
/*!******************************!*\
  !*** ./error/RemoteError.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 11);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new RemoteError.
	 * 
	 * @classdesc
	 * Represents an error that happened on a remote server.
	 * 
	 * @param {Object} errorObject Object containing error fields (id, status, code, message, ...).
	 * @constructor UuApp.Error.RemoteError
	 */
	function RemoteError(errorObject) {
	  _Error2.default.apply(this, arguments);
	  delete this.stack; // not interested in client-side stack for remote errors
	}
	RemoteError.prototype = Object.create(_Error2.default.prototype);
	RemoteError.prototype.constructor = RemoteError;
	/**
	 * The unique identifier of this instance of the remote error.
	 * @name UuApp.Error.RemoteError#id
	 */
	/**
	 * The code of the remote error.
	 * @name UuApp.Error.RemoteError#code
	 */
	/**
	 * The message of the remote error.
	 * @name UuApp.Error.RemoteError#message
	 */
	/**
	 * Additional parameters of the remote error.
	 * @name UuApp.Error.RemoteError#paramMap
	 */
	/**
	 * The cause of the remote error.
	 * @name UuApp.Error.RemoteError#cause
	 */

	exports.default = RemoteError;

/***/ },
/* 15 */
/*!*******************************!*\
  !*** ./error/TimeoutError.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Error = __webpack_require__(/*! ./Error.js */ 11);

	var _Error2 = _interopRequireDefault(_Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates new TimeoutError.
	 * 
	 * @classdesc
	 * Represents an error when operation doesn't finish within required timeout.
	 * 
	 * @constructor UuApp.Error.TimeoutError
	 */
	function TimeoutError() {
	  _Error2.default.apply(this, arguments);
	}
	TimeoutError.prototype = Object.create(_Error2.default.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	exports.default = TimeoutError;

/***/ },
/* 16 */
/*!***********************!*\
  !*** ./util/index.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Config = undefined;

	var _Config = __webpack_require__(/*! ./Config.js */ 17);

	var _Config2 = _interopRequireDefault(_Config);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Config = _Config2.default;

/***/ },
/* 17 */
/*!************************!*\
  !*** ./util/Config.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Error = __webpack_require__(/*! ../error/Error.js */ 11);

	/**
	 * Initializes new configuration object from provided key-value map, URL or from another Promise resolving
	 * to one of those.
	 * 
	 * @class UuApp.Util.Config
	 * @classdesc
	 * "Global" configuration for components such as Client, Logger, ... The configuration
	 * is a flat map containing data such as addresses to gateways, logging configuration and others and
	 * is typically configured somewhere on server-side. The global configuration is automatically initialized from
	 * global **UU5.Environment** variable, if it exists (otherwise it can be initialized by using
	 * {@link UuApp.Util.Config.init Config.init} method, e.g.:
	 * 
	 *     // initialize configuration from URL
	 *     UuApp.Util.Config.init("/vendor-app/0-0/getClientConfig");
	 * 
	 *     // alternatively, configuration can be initialized directly
	 *     UuApp.Util.Config.init({
	 *       "gatewayUri": "https://uuappg01.plus4u.net",
	 *       "logLevel": "DEBUG"
	 *     });
	 *
	 * Note that the intialization via URL is an asynchronous operation, so components will wait until
	 * it's downloaded.
	 *      
	 * Each component describes its own **supported configuration options** in its class description.
	 * 
	 * @param {(string|Object|Promise)} envOrUrl URL from which to download the key-value map
	 *   (using GET method, expecting application/json data). Alternatively, it can be the key-value
	 *   map directly or a Promise resolving to it. 
	 * @return {Promise} Promise resolved to this instance of Config. Promise is resolved after the key-value map
	 *                   is loaded from given URL, or after given Promise is resolved, or immediately if key-value
	 *                   map was given directly).
	 * @example
	 *     // initialize custom configuration from server
	 *     var myEnv = new UuApp.Util.Config("/vendor-app/0-0/getClientConfig");
	 *     myEnv.initPromise.then(function (env) { // env === myEnv
	 *       console.log("'myEnv' is ready. Values:", env.get());
	 *       var client = new UuApp.AppClient.Client(env.get()); // pass configuration to UuApp.AppClient.Client (gatewayUri, ...)
	 *     });
	 *     
	 *     // initialize custom configuration with directly specified configuration
	 *     var myEnv2 = new UuApp.Util.Config({
	 *       "logLevel": "DEBUG"
	 *     });
	 *     console.log("'myEnv2' is ready. Values:", myEnv2.get());
	 * 
	 *     // use configuration from the result of another promise
	 *     var somePromise = ...; // resolves to key-value map
	 *     var myEnv3 = new UuApp.Util.Config(somePromise);
	 *     myEnv3.then(function (env) { ... }); // env === myEnv3
	 */
	function Config(envOrUrl) {
	  this._env = {};

	  // initialize (but only if not instructed to skip it which is used so that globalConfig can be initialized on-demand)
	  if (envOrUrl !== false) initInstance.apply(this, arguments);
	}

	Config.prototype.initInvoked = false;
	/**
	 * Whether the configuration has finished loading. For configuration that was
	 * initialized by providing key-value map directly, it'll be true from the start.
	 * 
	 * @type {boolean}
	 * @name UuApp.Util.Config#initComplete
	 */
	Config.prototype.initComplete = false;
	/**
	 * Promise resolved when configuration has finished loading.
	 * 
	 * @type {Promise}
	 * @name UuApp.Util.Config#initPromise
	 */
	Config.prototype.initPromise = null;
	/**
	  * URL from which the configuration has been loaded, or null if it wasn't loaded
	  * via URL.
	  * 
	  * @type {string}
	  * @name UuApp.Util.Config#initUrl
	  */
	Config.prototype.initUrl = null;

	/**
	 * Returns value of the specified configuration setting. If no name is given,
	 * map with all settings is returned.
	 * 
	 * @param {string} name The setting whose value to return. If not given,
	 *   map with all settings is returned.
	 * @param {boolean} [recursive=true] Whether to lookup the setting recursively. For example
	 *   retrieving value for name "A.B.C.logLevel" would try "A.B.C.logLevel" first,
	 *   then "A.B.logLevel", then "A.logLevel" and finally "logLevel".
	 * @method UuApp.Util.Config#get
	 */
	Config.prototype.get = function (name, recursive) {
	  if (arguments.length == 0) return this._env;
	  if (recursive === false) return this._env[name];
	  var parts = name.split(/\./);
	  while (parts.length > 1) {
	    var v = this._env[parts.join(".")];
	    if (v != null) return v;
	    parts.splice(parts.length - 2, 1);
	  }
	  return this._env[parts[0]];
	};

	// create default (global) configuration instance but don't initialize it - consumer of the library
	// must do it via Config.init()
	var globalConfig = new Config(false);

	/**
	 * Initializes default (global) configuration from given URL or by given key-value map.
	 * The method accepts the same arguments as the {@link UuApp.Util.Config Config(...)} constructor.
	 * 
	 * Note that components such as UuApp.AppClient.Client will automatically wait until default configuration
	 * is loaded (if .init has been invoked prior to their usage).
	 * 
	 * @return Promise ({@link UuApp.Util.Config#initPromise Config#initPromise) resolved to the loaded key-value map.
	 * @method UuApp.Util.Config.init
	 * @example
	 *     // initialize default (global) configuration from server
	 *     UuApp.Util.Config.init("/vendor-app/0-0/getClientConfig").then(function (env) {
	 *       console.log("Components have been configured using environment", env.get());
	 *     });
	 *     
	 *     // initialize default (global) configuration with directly specified data
	 *     UuApp.Util.Config.init({
	 *       "logLevel": "DEBUG"
	 *     });
	 */
	Config.init = function (envOrUrl) {
	  initInstance.apply(globalConfig, Array.prototype.slice.call(arguments));
	  initInvokedPromiseResolve();
	  globalConfig.initPromise.then(initCompletePromiseResolve, initCompletePromiseReject);
	  return globalConfig.initPromise;
	};

	Object.defineProperties(Config, {
	  /**
	   * Whether the *global* configuration has started loading.
	   * 
	   * @type {boolean}
	   * @name UuApp.Util.Config.initInvoked
	   */
	  initInvoked: { get: function get() {
	      return globalConfig.initInvoked;
	    } },
	  /**
	   * Whether the *global* configuration has finished loading.
	   * 
	   * @type {boolean}
	   * @name UuApp.Util.Config.initComplete
	   */
	  initComplete: { get: function get() {
	      return globalConfig.initComplete;
	    } },
	  /**
	   * Promise resolved when *global* configuration has finished loading. Note that
	   * the field is null prior to Config.init call.
	   * 
	   * @type {Promise}
	   * @name UuApp.Util.Config.initPromise
	   */
	  initPromise: { get: function get() {
	      return globalConfig.initPromise;
	    } },
	  /**
	   * URL from which the configuration has been loaded, or null if it wasn't loaded
	   * via URL.
	   * 
	   * @type {string}
	   * @name UuApp.Util.Config.initUrl
	   */
	  initUrl: { get: function get() {
	      return globalConfig.initUrl;
	    } }
	});

	// promise (always non-null) which resolves after Config.init is completed
	// (if it never gets called, the promise won't get resolved)
	var initCompletePromiseResolve;
	var initCompletePromiseReject;
	Config.initCompletePromise = new Promise(function (rs, rj) {
	  return initCompletePromiseResolve = rs, initCompletePromiseReject = rj;
	});

	// promise (always non-null) which resolves after Config.init is called,
	// even if it wasn't completed yet (if it never gets called, the promise won't get resolved)
	var initInvokedPromiseResolve;
	var initInvokedPromiseReject;
	Config.initInvokedPromise = new Promise(function (rs, rj) {
	  return initInvokedPromiseResolve = rs, initInvokedPromiseReject = rj;
	});

	/**
	 * Returns value of the specified setting from *global* configuration. If no name is given,
	 * map with all settings is returned.
	 * 
	 * @param {string} name The setting whose value to return. If not given,
	 *   map with all settings is returned.
	 * @param {boolean} [recursive=true] Whether to lookup the setting recursively. For example
	 *   retrieving value for name "A.B.C.logLevel" would try "A.B.C.logLevel" first,
	 *   then "A.B.logLevel", then "A.logLevel" and finally "logLevel".
	 * @see UuApp.Util.Config#get
	 * @method UuApp.Util.Config.get
	 */
	Config.get = function () {
	  return globalConfig.get.apply(globalConfig, arguments);
	};

	function initInstance(options) {
	  if (this.initInvoked) throw new Error("UuApp.Util.Config can be initialized only once (#init method). " + "If a private / separate environment is needed, use new UuApp.Util.Config().");
	  this.initInvoked = true;

	  // load environment (sync / async)
	  var loadResult;
	  if (typeof options == "string") {
	    this.initUrl = arguments[0];
	    loadResult = load.apply(this, arguments); // it's a URL
	  } else if (options != null && typeof options.then === "function") loadResult = { promise: Promise.resolve(options) }; // it's a Promise
	  else if (options == null || (typeof options === "undefined" ? "undefined" : _typeof(options)) == "object" || typeof options == "function") loadResult = { immediateResult: options }; // it's a direct value
	    else throw new Error("UuApp.Util.Config can be initialized only with object-like structure, but typeof says '" + (typeof options === "undefined" ? "undefined" : _typeof(options)) + "'. Initialized with: " + JSON.stringify(options));

	  // process load result
	  if (loadResult.immediateResult) {
	    this._env = loadResult.immediateResult;
	    this.initComplete = true;
	    this.initPromise = Promise.resolve(this);
	  } else {
	    this.initPromise = loadResult.promise.then(function (env) {
	      this._env = env;
	      this.initComplete = true;
	      return this;
	    }.bind(this)); // in case of error just propagate it (no error handler here) - we don't want to call services against wrong domains (config contains gateway URIs, ...) 
	  }

	  return this.initPromise;
	}

	function load(url, options) {
	  var result;
	  var p = new Promise(function (resolve, reject) {
	    if (!url) return resolve({});
	    var opts = options || {};

	    var xhr = new XMLHttpRequest();
	    xhr.open("GET", url, opts.sync !== true);
	    xhr.setRequestHeader("Accept", "application/json");
	    xhr.onerror = function (e) {
	      return reject(new Error("Unable to load environment configuration from " + url + " - network error."));
	    };
	    xhr.onload = function (e) {
	      if (xhr.status >= 200 && xhr.status < 300) {
	        try {
	          result = (xhr.responseText ? JSON.parse(xhr.responseText) : null) || {};
	          resolve(result || {});
	          return;
	        } catch (e) {
	          reject(new Error("Unable to load environment configuration from " + url + " - not a JSON. Response:\n" + xhr.responseText));
	        }
	      } else {
	        reject(new Error("Unable to load environment configuration from " + url + " - status " + xhr.status + ". Response:\n" + xhr.responseText));
	      }
	    };
	    xhr.send(null);
	  });
	  return { immediateResult: result, promise: p };
	}

	// if running in browser with SystemJS loader, use UU_ENVIRONMENT module if it's configured
	var inited = false;
	if (typeof window != "undefined") {
	  if (typeof System != "undefined" && window && System && System.has && System.get && System.normalizeSync) {
	    try {
	      // for backward compatibility try initialization via module named "UU_ENVIRONMENT"
	      var normModule = System.normalizeSync("UU_ENVIRONMENT");
	      if (System.has(normModule)) {
	        // the module has been already instantiated
	        var mod = System.get(normModule);
	        Config.init(mod["default"] || mod);
	        if (!normModule.match(/\/UU_ENVIRONMENT$/)) globalConfig.initUrl = normModule;
	        inited = true;
	      } else if (!normModule.match(/\/UU_ENVIRONMENT$/)) {
	        // the module is not ready yet but it is defined (has configured URL to be downloaded from)
	        Config.init(System.import("UU_ENVIRONMENT"));
	        globalConfig.initUrl = normModule;
	        inited = true;
	      }
	    } catch (e) {
	      console.error("Failed to initialize configuration from UU_ENVIRONMENT. Error:", e);
	    }
	  }
	  // initialize configuration from UU5.Environment variable
	  if (!inited && window.UU5 && window.UU5.Environment) {
	    Config.init(window.UU5.Environment);
	    inited = true;
	  }
	}

	module.exports = Config;

/***/ },
/* 18 */
/*!**************************!*\
  !*** ./logging/index.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LoggerFactory = exports.Logger = undefined;

	var _Logger = __webpack_require__(/*! ./Logger.js */ 19);

	var _Logger2 = _interopRequireDefault(_Logger);

	var _LoggerFactory = __webpack_require__(/*! ./LoggerFactory.js */ 20);

	var _LoggerFactory2 = _interopRequireDefault(_LoggerFactory);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Logger = _Logger2.default;
	exports.LoggerFactory = _LoggerFactory2.default;

/***/ },
/* 19 */
/*!***************************!*\
  !*** ./logging/Logger.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// TODO Change into ES6 imports / exports. Beware that some tests are run via Node environment
	// and it doesn't recognize import / export statements (so tests will stop working). Might get it working
	// by running tests against dist-node/ folder (where the files are downcompiled to ES5).
	var Config = __webpack_require__(/*! ../util/Config.js */ 17);

	/**
	 * @class UuApp.Logging.Logger
	 * @classdesc
	 * Component for logging. Each logged message has a severity level and each logger can be
	 * configured to process only messages with sufficient severity level. Loggers are hierarchical,
	 * i.e. when configuration is processed they inherit severity level from parent modules/packages.
	 * 
	 * Contrary to usual <code>console.log</code>, <code>console.error</code>, ... statements (which
	 * are typically removed from production code), statements using Logger-s are intended to be
	 * preserved in the production environment and turned on/off via {@link UuApp.Util.Config Config}
	 * configuration.
	 * 
	 * **Configuration**
	 * 
	 * Default severity level for loggers is Logger.LEVEL_WARN. Logging is automatically configured from the
	 * global configuration (initialized via {@link UuApp.Util.Config Config.init} call).
	 * Supported environment options:
	 * 
	 *     {
	 *       "logLevel": "ERROR",
	 *       "My.Namespace.logLevel": "WARN"
	 *     }
	 * 
	 * As already said, loggers are hierarchical - with configuration above, logger "My.Namespace.Component"
	 * would have logLevel "WARN" whereas logger "My" would have logLevel "ERROR". Hierarchical logging can
	 * be turned off when initializing a logger - see {@link UuApp.Logging.LoggerFactory.get LoggerFactory.get}.
	 * 
	 * **Typical usage**
	 * 
	 *     // get logger instance and log a message
	 *     var logger = UuApp.Logging.LoggerFactory.get("My.Namespace.Component");
	 *     logger.warn("Universe expansion is accelerating.", {speedBefore: 68, speedAfter: 68.01});
	 *     
	 *     // if logging requires lenghty computation, it can be made conditional so that it
	 *     // doesn't slow down the rest of page if the message wouldn't get logged in the end
	 *     if (logger.isDebugLoggable()) {
	 *       var computedValue = ...; // some lenghty computation
	 *       logger.debug("Value computed to", computedValue);
	 *     }
	 *     
	 */
	function Logger(name) {
	  var _this = this;

	  if (!priv.allowLoggerNew) throw new Error("Use UuApp.Logging.LoggerFactory.get(name) to get an instance of Logger.");
	  this.name = name;

	  // logger can be configured after delay because Util.Config can be loaded asynchronously,
	  // therefore we'll buffer the debug/info/warn/error calls until the configuration is ready
	  var ready = false;
	  this._buffer = [];
	  Object.defineProperty(this, "ready", {
	    get: function get() {
	      return ready && (!Config.initInvoked || Config.initComplete);
	    },
	    set: function set(value) {
	      ready = value;
	      if (ready) flushBuffer.call(_this);
	    }
	  });
	}
	var priv = Logger.priv = {}; // TODO This is not-so-ellegant solution for allowing UriBuilder to call Uri constructor (and forbid it for everyone else).

	/** @name UuApp.Logging.Logger.LEVEL_DEBUG */
	/** @name UuApp.Logging.Logger.LEVEL_INFO */
	/** @name UuApp.Logging.Logger.LEVEL_WARN */
	/** @name UuApp.Logging.Logger.LEVEL_ERROR */
	/** @name UuApp.Logging.Logger.LEVEL_OFF */
	var levels = { DEBUG: 100, INFO: 200, WARN: 300, ERROR: 400, OFF: Math.MAX_VALUE };
	var levelsInverted = Object.keys(levels).reduce(function (r, name) {
	  return r[levels[name]] = name, r;
	}, {}); // { 100: "DEBUG", ...}
	Object.keys(levels).forEach(function (level) {
	  // publish levels as constants
	  Logger["LEVEL_" + level.toUpperCase()] = levels[level];
	});

	/**
	 * Sets severity level of this Logger to given value. Messages with lower (less important)
	 * severity will be ignored when attempted to be logged via this logger. Order of importance:
	 * DEBUG < INFO < WARN < ERROR < OFF.
	 * 
	 * **It's strongly advised not to configure loggers directly using this method** because
	 * if such code gets deployed to production, it'll effectively override settings from
	 * environment and therefore could prevent logging of necessary information.
	 * **Use environment configuration instead - see Configuration chapter in {@link UuApp.Logging.Logger Logger}.
	 * 
	 * @param {(number|string)} level Severity level to set. See Logger.LEVEL_* constants. If null
	 *   is given, default is used (LEVEL_WARN).
	 * @method UuApp.Logging.Logger#setLevel
	 */
	Logger.prototype.setLevel = function (level) {
	  if (level == null) level = Logger.LEVEL_WARN;
	  var num = typeof level == "string" ? levels[level.toUpperCase()] : Number(level);
	  if (typeof num != "number" || isNaN(num)) return; // ignore
	  this.level = num;
	};

	/**
	 * @return {number} Level of this logger.
	 * @method UuApp.Logging.Logger#getLevel
	 */
	Logger.prototype.getLevel = function () {
	  return this.level;
	};

	/**
	 * @return {string} Upper-cased name of the level, such as "ERROR".
	 * @method UuApp.Logging.Logger#getLevelName
	 */
	Logger.prototype.getLevelName = function () {
	  return levelsInverted[this.level];
	};
	Logger.prototype.level = levels.WARN;

	/**
	 * Logs message with severity level "DEBUG".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#debug
	 */
	Logger.prototype.debug = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "debug", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.DEBUG) logToAppenders.call(this, { level: levels.DEBUG, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};

	/**
	 * @return {boolean} Whether this logger logs message with severity level "DEBUG".
	 * @method UuApp.Logging.Logger#isDebugLoggable
	 */
	Logger.prototype.isDebugLoggable = function () {
	  return !this.ready || this.level <= levels.DEBUG;
	};

	/**
	 * Logs message with severity level "INFO".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#info
	 */
	Logger.prototype.info = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "info", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.INFO) logToAppenders.call(this, { level: levels.INFO, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};
	/**
	 * @return {boolean} Whether this logger logs message with severity level "INFO".
	 * @method UuApp.Logging.Logger#isInfoLoggable
	 */
	Logger.prototype.isInfoLoggable = function () {
	  return !this.ready || this.level <= levels.INFO;
	};
	/**
	 * Logs message with severity level "WARN".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#warn
	 */
	Logger.prototype.warn = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "warn", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.WARN) logToAppenders.call(this, { level: levels.WARN, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};
	/**
	 * @return {boolean} Whether this logger logs message with severity level "WARN".
	 * @method UuApp.Logging.Logger#isWarnLoggable
	 */
	Logger.prototype.isWarnLoggable = function () {
	  return !this.ready || this.level <= levels.WARN;
	};
	/**
	 * Logs message with severity level "ERROR".
	 * 
	 * @param {string} message The message to log.
	 * @param {...Object} any Additional values to log with the message.
	 * @method UuApp.Logging.Logger#error
	 */
	Logger.prototype.error = function () /* ... */{
	  if (!this.ready) return logToBuffer.call(this, "error", Array.prototype.slice.call(arguments));
	  if (this.level <= levels.ERROR) logToAppenders.call(this, { level: levels.ERROR, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
	};
	/**
	 * @return {boolean} Whether this logger logs message with severity level "ERROR".
	 * @method UuApp.Logging.Logger#isErrorLoggable
	 */
	Logger.prototype.isErrorLoggable = function () {
	  return !this.ready || this.level <= levels.ERROR;
	};

	function logToAppenders(opts) {
	  // TODO Add support for appenders. Currently we'll log only to the console.
	  // TODO Might want to collect additional information (stack frames, ...) - https://github.com/stacktracejs/stacktrace.js
	  // log to console
	  var msg = this.name + ": " + opts.message;
	  Logger.console[levelsInverted[opts.level].toLowerCase()].apply(Logger.console, [msg].concat(opts.args));
	}
	function logToBuffer(method, args) {
	  this._buffer.push({ method: method, args: args });
	}
	function flushBuffer() {
	  var _this2 = this;

	  var v = this._buffer;
	  this._buffer = [];
	  v.forEach(function (it) {
	    return _this2[it.method].apply(_this2, it.args);
	  }); // re-run each method
	}

	// NOTE Logger-s append to Logger.console instead of directly console object
	// so that this can be mocked in tests.
	Logger.console = console;

	// export
	module.exports = Logger;

/***/ },
/* 20 */
/*!**********************************!*\
  !*** ./logging/LoggerFactory.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Logger = __webpack_require__(/*! ./Logger.js */ 19);
	var Config = __webpack_require__(/*! ../util/Config.js */ 17);

	var loggers = {};
	var LoggerFactory = {};
	var loggerPriv = Logger.priv;
	// delete Logger.priv;

	/**
	 * @class UuApp.Logging.LoggerFactory
	 * @classdesc
	 * Factory class for getting access to loggers. See {@link UuApp.Logging.Logger Logger} for more information.
	 */

	/**
	 * Returns an instance of the logger with given name. Settings of the logger are
	 * taken from global configuration (see {@link UuApp.Util.Config.init Config.init}).
	 * Default global logLevel is Logger.{@link UuApp.Logging.Logger.LEVEL_WARN LEVEL_WARN}.
	 * 
	 * Successive calls with the same logger name return the same logger instance.
	 * 
	 * @param {string} name The name of the logger. Typically, it's a fully-qualified name of
	 *   the component that uses the logger, e.g. "My.Namespace.Component".
	 * @param {boolean} hierarchical Whether the logger shall inherit settings from its parent
	 *   package names, e.g. whether logger with name "My.Namespace" should inherit logLevel from "My"
	 *   or from root (hierarchical = true, default) or only settings directly for "My.Namespace" apply
	 *   (hierarchical = false). The parameter is used only during 1st invocation for given logger name,
	 *   in successive calls it's ignored.
	 * @return {UuApp.Logging.Logger} An instance of the logger with given name.
	 * @method UuApp.Logging.LoggerFactory.get
	 */
	LoggerFactory.get = function (name, hierarchical) {
	  if (typeof name != "string") throw new Error("LoggerFactory.get() must be called with a string argument (logger name).");
	  if (loggers[name]) return loggers[name].logger;
	  loggerPriv.allowLoggerNew = true;
	  var logger;
	  try {
	    // create & configure the logger (configure only if configuration is not being loaded at the moment)
	    logger = new Logger(name);
	    if (!Config.initInvoked || Config.initComplete) configure(logger, hierarchical, Config);
	  } finally {
	    loggerPriv.allowLoggerNew = false;
	  }
	  return (loggers[name] = { logger: logger, hierarchical: hierarchical }).logger;
	};

	// configures logger from given environment object
	function configure(logger, hierarchical, env) {
	  // only "logLevel" is currently recognized
	  var logLevel = env.get(logger.name + ".logLevel", hierarchical !== false);
	  logger.setLevel(logLevel);

	  logger.ready = true;
	}

	// create root logger
	Logger.getRootLogger = function () {
	  return rootLogger;
	};
	loggerPriv.allowLoggerNew = true;
	loggers[""] = { logger: new Logger(""), hierarchical: false };
	var rootLogger = loggers[""].logger;
	loggerPriv.allowLoggerNew = false;

	// re-configure existing loggers after global configuration is loaded (if loggers were created sooner than
	// configuration got loaded)
	if (!Config.initComplete) {
	  Config.initInvokedPromise.then(function () {
	    // change loggers to "not-ready" state (they'll buffer logging calls)
	    for (var k in loggers) {
	      loggers[k].logger.ready = false;
	    }
	  });
	  Config.initCompletePromise.then(function (env) {
	    // re-configure loggers and switch to "ready" state
	    for (var k in loggers) {
	      configure(loggers[k].logger, loggers[k].hierarchical, env);
	    }
	  });
	}

	module.exports = LoggerFactory;

/***/ },
/* 21 */
/*!**************************!*\
  !*** ./perflog/index.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PerfLog = undefined;

	var _PerfLog = __webpack_require__(/*! ./PerfLog.js */ 22);

	var _PerfLog2 = _interopRequireDefault(_PerfLog);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.PerfLog = _PerfLog2.default;

/***/ },
/* 22 */
/*!****************************!*\
  !*** ./perflog/PerfLog.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _LoggerFactory = __webpack_require__(/*! ../logging/LoggerFactory.js */ 20);

	var _LoggerFactory2 = _interopRequireDefault(_LoggerFactory);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var perfLog = _LoggerFactory2.default.get("UuApp.Perflog.PerfLog", false);

	var PerfLog = {
	  measureSection: function measureSection(name /*, (optional) attrs, measuredFn*/) {
	    var measuredFn = arguments[arguments.length - 1];
	    var attrs = arguments.length > 2 ? arguments[1] : null;
	    var section = new Section(createSectionId(), name, attrs);
	    var r;
	    try {
	      r = Promise.resolve(measuredFn(section));
	    } catch (e) {
	      r = Promise.reject(e);
	    }
	    function close() {
	      section.close();
	    }
	    return r.then(close, close);
	  }
	};

	var Section = function Section(id, name, attrs) {
	  this.id = id;
	  this.name = name;
	  this.attributes = attrs || {};
	  this.checkpoints = {};
	  this.start = Date.now();
	};
	Section.prototype.setCheckpoint = function (name) {
	  this.checkpoints[name] = Date.now;
	};
	Section.prototype.close = function () {
	  if (this.finish) return;
	  this.finish = Date.now();
	  this.duration = this.finish - this.start;
	  perfLog.info(JSON.stringify(this));
	};

	var rootId;
	function createSectionId() {
	  if (!rootId) rootId = createIdSegment();
	  var childId = createIdSegment();
	  return rootId + "-" + rootId + "-" + childId + "-0000";
	}
	function createIdSegment() {
	  var s = [];
	  for (var i = 0; i < 4; ++i) {
	    s.push((Math.random() * 65536 | 0).toString(16));
	  } // 4 * 4 hexa digits
	  return s.join("");
	}

	exports.default = PerfLog;

/***/ },
/* 23 */
/*!**********************!*\
  !*** ./uri/index.js ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.UriBuilder = exports.Uri = undefined;

	var _Uri = __webpack_require__(/*! ./Uri.js */ 24);

	var _Uri2 = _interopRequireDefault(_Uri);

	var _UriBuilder = __webpack_require__(/*! ./UriBuilder.js */ 25);

	var _UriBuilder2 = _interopRequireDefault(_UriBuilder);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Uri = _Uri2.default;
	exports.UriBuilder = _UriBuilder2.default;

/***/ },
/* 24 */
/*!********************!*\
  !*** ./uri/Uri.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Err = __webpack_require__(/*! ../error/Error.js */ 11);

	/**
	 * @class UuApp.Uri.Uri
	 * @classdesc
	 * Immutable representation of uuUri. An instance of the Uri can be obtained either by
	 * {@link UuApp.Uri.Uri.parse Uri.parse} or by using {@link UuApp.Uri.UriBuilder UriBuilder} class.
	 * Note that minimal Uri consists of at least "app" and "tid".
	 * 
	 * Examples of usage:
	 * 
	 *     // uri from parsing current location
	 *     var locationUri = Uri.parse(location.protocol + "//" + location.host + location.pathname); // "http://example.com/vendor-app/0-0/some/uc"
	 *     var baseUri = locationUri.baseUri; // "http://example.com/vendor-app/0-0"
	 *     var callUri = baseUri.join("+/getConfig"); // "http://example.com/vendor-app/0-0/getConfig"
	 *    
	 *     // uri from parsing
	 *     var uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app-subapp-spp/tid-awid/useCase?p1=v1");
	 *     console.log(uri.gateway, uri.product, uri.workspace, uri.useCase); 
	 *     var params = uri.parameters; // always returns new copy of parameter map
	 *     for (var k in params) console.log(k, "=", params[k]); // p1 = v1
	 *     
	 *     // uri from UriBuilder
	 *     var uri2 = UuApp.Uri.UriBuilder.parse(uri).setWorkspace("0-0").setUseCase("sys/init").toUri();
	 *     console.log(uri2.toString()); // https://uuos9.plus4u.net/vendor-app-subapp-spp/0-0/sys/init?p1=v1
	 *     
	 *     // uri from parsing (with ECMAScript6 template string, e.g. when using transpilers like Babel)
	 *     // Note that query parameter values shouldn't be injected via template string as they might need
	 *     // to be encoded first.
	 *     var product = "vendor-app";
	 *     var workspace = "tid-awid";
	 *     var uri3 = UuApp.Uri.Uri.parse(`https://uuos9.plus4u.net/${product}/${workspace}`);
	 *    
	 * @see UuApp.Uri.UriBuilder
	 */

	// NOTE Constructor is "private".
	var priv = Uri.priv = {}; // TODO This is not-so-ellegant solution for allowing UriBuilder to call Uri constructor (and forbid it for everyone else).
	var EMPTY = {};
	function Uri(scheme, hostname, port, vendor, app, subApp, spp, tid, awid, useCase, parameters) {
	  var _this = this;

	  if (!priv.allowNew) throw new Err("Use UuApp.Uri.Uri.parse to obtain an instance of uuUri.");

	  useCase = useCase ? useCase.replace(/^\//, "") : useCase; // strip leading slash from useCase
	  if (port && typeof port != "number") port = parseInt(port + "", 10);
	  if ((port == null || port === "") && scheme) port = scheme.match(/^https$/) ? 443 : 80;
	  var gateway = { value: EMPTY, lazyGet: function lazyGet() {
	      return gateway.value !== EMPTY ? gateway.value : gateway.value = _this.Builder.formatGateway(scheme, hostname, port);
	    } };
	  var product = { value: EMPTY, lazyGet: function lazyGet() {
	      return product.value !== EMPTY ? product.value : product.value = _this.Builder.formatProduct(vendor, app, subApp, spp);
	    } };
	  var workspace = { value: EMPTY, lazyGet: function lazyGet() {
	      return workspace.value !== EMPTY ? workspace.value : workspace.value = _this.Builder.formatWorkspace(tid, awid);
	    } };
	  var params = Object.assign({}, parameters); // make a copy to guard against mutation of original "parameters" object
	  var uri = this;

	  // NOTE Attributes are defined as properties so that they throw error when developer
	  // tries tu mutate them (even in non-strict mode).
	  function throwOnSet(attr) {
	    return function () {
	      throw new Err("Cannot set " + attr + " on Uri because instances of Uri are immutable. Use UriBuilder instead.");
	    };
	  }
	  Object.defineProperties(this, {
	    /** @name UuApp.Uri.Uri#scheme */
	    scheme: { get: function get() {
	        return scheme;
	      }, set: throwOnSet("scheme") },

	    /** @name UuApp.Uri.Uri#hostname */
	    hostname: { get: function get() {
	        return hostname;
	      }, set: throwOnSet("hostname") },

	    /** @name UuApp.Uri.Uri#port */
	    port: { get: function get() {
	        return port;
	      }, set: throwOnSet("port") },

	    /**
	     * Formatted string containing scheme, hostname and port. For example for scheme "https",
	     * hostname "example.com" and port "123" it returns "https://example.com:123".
	     * 
	     * @name UuApp.Uri.Uri#gateway
	     */
	    gateway: { get: gateway.lazyGet, set: throwOnSet("gateway") },

	    /** @name UuApp.Uri.Uri#vendor */
	    vendor: { get: function get() {
	        return vendor;
	      }, set: throwOnSet("vendor") },

	    /** @name UuApp.Uri.Uri#app */
	    app: { get: function get() {
	        return app;
	      }, set: throwOnSet("app") },

	    /** @name UuApp.Uri.Uri#subApp */
	    subApp: { get: function get() {
	        return subApp;
	      }, set: throwOnSet("subApp") },

	    /** @name UuApp.Uri.Uri#spp */
	    spp: { get: function get() {
	        return spp;
	      }, set: throwOnSet("spp") },

	    /** @name UuApp.Uri.Uri#product */
	    product: { get: product.lazyGet, set: throwOnSet("product") },

	    /** @name UuApp.Uri.Uri#tid */
	    tid: { get: function get() {
	        return tid;
	      }, set: throwOnSet("tid") },

	    /** @name UuApp.Uri.Uri#awid */
	    awid: { get: function get() {
	        return awid;
	      }, set: throwOnSet("awid") },

	    /** @name UuApp.Uri.Uri#workspace */
	    workspace: { get: workspace.lazyGet, set: throwOnSet("workspace") },

	    /** @name UuApp.Uri.Uri#useCase */
	    useCase: { get: function get() {
	        return useCase;
	      }, set: throwOnSet("useCase") },

	    /**
	     * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
	     * Note that each access returns new copy of the map (to achieve immutability of the Uri class),
	     * therefore usage should look like this:
	     * 
	     *     // OPTIMAL (single read of "parameters" field on uri)
	     *     var params = uri.parameters;
	     *     for (var k in params) console.log(params[k]);
	     *     
	     *     // SUB-OPTIMAL (multiple reads and therefore multiple copying of parameter map)
	     *     // for (var k in uri.parameters) console.log(uri.parameters[k]);
	     * 
	     * @name UuApp.Uri.Uri#parameters
	     */
	    parameters: { get: function get() {
	        return Object.assign({}, params);
	      }, set: throwOnSet("parameters") },

	    /**
	     * URI containing only mandatory routing data (includes only "gateway", "product" and "workspace").
	     * @name UuApp.Uri.Uri#baseUri
	     */
	    baseUri: { get: getBaseUri, set: throwOnSet("baseUri") },
	    /**
	     * Relative URI (without "gateway").
	     * @name UuApp.Uri.Uri#relativeUri
	     */
	    relativeUri: { get: getRelativeUri, set: throwOnSet("relativeUri") }
	  });

	  var baseUri, relativeUri;
	  function getBaseUri() {
	    if (baseUri !== undefined) return baseUri;
	    if (uri.gateway == null || uri.product == null || uri.workspace == null) throw new Err("Insufficient URI - at least one of gateway, product and workspace is not set. Uri: " + uri.toString());
	    baseUri = uri.Builder.parse(uri).set({ useCase: null }).clearParameters().toUri();
	    return baseUri;
	  }
	  function getRelativeUri() {
	    if (relativeUri !== undefined) return relativeUri;
	    relativeUri = uri.Builder.parse(uri).set({ gateway: null }).toUri();
	    return relativeUri;
	  }

	  var str;
	  /**
	   * Converts URI to string.
	   * 
	   * @return URI converted to string.
	   * @method UuApp.Uri.Uri#toString
	   */
	  this.toString = function () {
	    return str !== undefined ? str : str = _this.Builder.format(_this);
	  };

	  //    /**
	  //     * Converts URI to an object literal (a map) containing keys scheme, hostname, ...
	  //     * 
	  //     * @function UuApp.Uri.Uri#toObject
	  //     */
	  //    this.toObject = () => ({
	  //      scheme: scheme, hostname: hostname, port: port, vendor: vendor, app: app, subApp: subApp, spp: spp,
	  //      tid: tid, awid: awid, useCase: useCase, parameters: Object.assign({}, params)
	  //    });

	  // serialize as string when stringifying to JSON
	  this.toJSON = this.toString;

	  // prevent any modification of the Uri object
	  Object.freeze(this);
	}

	/**
	 * Replaces current path with specified absolute path (or adds a relative path to the current path) returning new Uri.
	 * Query parameters are preserved only on last path. Resolving relative path and usage of "./" and "../" works as in standard
	 * URLs (see {@link https://tools.ietf.org/html/rfc2396#appendix-C RFC 2396, examples}).
	 * 
	 * Additionally, it's possible to use "+/" at the beginning of paths - paths starting
	 * with "+/" are joined as if current path (to which new path is being joined) denoted a "folder", i.e. current path
	 * is appended with slash (unless it already ends with slash) and new path is appended afterwards (see examples). 
	 * 
	 * @param {...string} path Absolute or relative paths to replace / add.
	 * @return New Uri whose path is the result of the join.
	 * @method UuApp.Uri.Uri#join
	 * @example
	 *  // replace path with an absolute path (effectively removing also query parameters)
	 *  var uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1?a=b");
	 *  var uri2 = uri.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
	 *  
	 *  // add relative paths
	 *  var uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1");
	 *  var uri2 = uri.join("sys/init?p=v");             // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init?p=v
	 *  var uri3 = uri.join("+/sys/init?p=v");           // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?p=v
	 *  var uri4 = uri.join("+/sys/?a=b", "init?c=d");   // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?c=d
	 */
	Uri.prototype.join = function () /* ... */{
	  if (arguments.length <= 0) return this;
	  var root = this.gateway || "";
	  var path = this.toString().substr(root.length);

	  for (var i = 0; i < arguments.length; ++i) {
	    var pathPart = arguments[i];
	    if (!pathPart) continue;
	    path = path.replace(/[?#].*/, ""); // remove query part because we're going to add / replace path
	    pathPart = pathPart.replace(/((^|\/)\.\.?)$/, "$1/"); // if new path part ends with two dots / one dot, treat it as a "folder", i.e. append "/"
	    if (pathPart.charAt(0) == "/") path = pathPart; // new path part is absolute => replace whole path
	    else if (pathPart.match(/^\+(\/|$)/)) path = path.replace(/\/?$/, "/") + pathPart; // new path part is relative with "+/" => append "/" and then new path
	      else if (path.charAt(path.length - 1) == "/") path += pathPart; // new path part is relative and current path is a "folder" => append new path
	        else path = path.replace(/(^|\/)[^\/]*$/, "$1") + pathPart; // new path part is relative and current path is not a "folder" => replace last segment of current path
	  }

	  // normalize (modify segments to eliminate "../" and "./" from the path)
	  var segments = [];
	  path.split("/").forEach(function (part) {
	    if (part === "..") segments.pop();else if (part !== "." && part !== "+") segments.push(part);
	  });
	  if (segments[0] !== "") segments.unshift(""); // make sure that after "join" operation the path starts with "/"
	  var resultPath = segments.join("/");
	  return Uri.parse(root + resultPath);
	};

	/**
	 * Checks whether the other URI is equal to this one and returns true iff it is.
	 * 
	 * @param {UuApp.Uri.Uri} uri Uri to check equality against.
	 * @return True iff the specified uri is equal to this one.
	 * @method UuApp.Uri.Uri#equals
	 */
	Uri.prototype.equals = function (aUri2) {
	  return this.toString() === (aUri2 || "").toString();
	};

	/**
	 * @param {(string|UuApp.Uri.Uri)} uriStr The string to parse as URI. If an instance of Uri class is given, it's returned as-is.
	 * @return {UuApp.Uri.Uri} Parsed URI.
	 * @method UuApp.Uri.Uri.parse
	 * @example
	 *    var uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app/tid-awid/useCase?p1=v1");
	 *    console.log(uri.gateway, uri.product, uri.workspace, uri.useCase, uri.parameters);
	 */
	Uri.parse = function (uriStr) {
	  if (uriStr instanceof Uri) return uriStr;
	  return Uri.prototype.Builder.parse(uriStr).toUri();
	};

	module.exports = Uri;

/***/ },
/* 25 */
/*!***************************!*\
  !*** ./uri/UriBuilder.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Err = __webpack_require__(/*! ../error/Error.js */ 11);
	var Uri = __webpack_require__(/*! ./Uri.js */ 24);
	var UriParser = __webpack_require__(/*! ./UriParser.js */ 26);

	/**
	 * Creates an instance of UriBuilder.
	 * 
	 * @class UuApp.Uri.UriBuilder
	 * @classdesc
	 * Class for building uuUri. Typical usage:
	 *     
	 *     // starting from current location
	 *     var uriBuilder = UriBuilder.parse(location.protocol + "//" + location.host + location.pathname);
	 *     var uri1 = uriBuilder.setUseCase("sys/init").setParameters({ p1: "v1" }).toUri();
	 *     console.log(uri1.toString()); // <gateway>/<product>/<workspace>/sys/init?p1=v1
	 *     
	 *     // starting anew, using gateway from main HTML page location
	 *     var gateway = location.origin || (location.protocol + "//" + location.host);
	 *     var uri2 = UriBuilder.set({
	 *       gateway: gateway,
	 *       product: "uu-demoapp-main",
	 *       workspace: "tid123-awid456",
	 *       parameters: { p1: "v1", p2: "v2" }
	 *     }).toUri(); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p1=v1&p2=v2
	 *     
	 *     // parameters example
	 *     var uriBuilder = UriBuilder.parse(uri2);
	 *     var uri3 = uriBuilder.deleteParameter("p1").mergeParameters({ p3: "v3" }).toUri();
	 *     console.log(uri3.toString()); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p2=v2&p3=v3
	 *
	 * @see {@link UuApp.Uri.UriBuilder.parse UriBuilder.parse}
	 * @see {@link UuApp.Uri.UriBuilder.set UriBuilder.set}
	 * @see {@link UuApp.Uri.UriBuilder#toUri UriBuilder#toUri}
	 */

	function UriBuilder() {
	  var _this = this;

	  var self = this;
	  if (!(self instanceof UriBuilder)) return new (UriBuilder.bind.apply(UriBuilder, arguments))(); // make an instance even if developer forgot to use "new" keyword

	  // define properties (setters have validation)
	  var priv = { parameters: {} };
	  /** @name UuApp.Uri.UriBuilder#scheme */
	  /** @name UuApp.Uri.UriBuilder#hostname */
	  /** @name UuApp.Uri.UriBuilder#vendor */
	  /** @name UuApp.Uri.UriBuilder#app */
	  /** @name UuApp.Uri.UriBuilder#subApp */
	  /** @name UuApp.Uri.UriBuilder#spp */
	  /** @name UuApp.Uri.UriBuilder#tid */
	  /** @name UuApp.Uri.UriBuilder#awid */
	  /** @name UuApp.Uri.UriBuilder#useCase */
	  ["scheme", "hostname", "vendor", "app", "subApp", "spp", "tid", "awid", "useCase"].forEach(function (attr) {
	    var validateFn = UriParser["validate" + attr.replace(/^./, function (m) {
	      return m.toUpperCase();
	    })];
	    Object.defineProperty(_this, attr, {
	      get: function get() {
	        return priv[attr];
	      },
	      set: function set(value) {
	        if (value != null) validateFn(value);
	        priv[attr] = value != null ? value : null;
	      }
	    });
	  });
	  Object.defineProperties(this, {
	    /** @name UuApp.Uri.UriBuilder#port */
	    port: {
	      get: function get() {
	        return priv.port != null ? Number(priv.port) : priv.port;
	      }, // convert to number
	      set: function set(value) {
	        if (value != null) UriParser.validatePort(value);
	        priv.port = value != null ? value : null;
	      }
	    },
	    /** @name UuApp.Uri.UriBuilder#gateway */
	    gateway: {
	      get: function get() {
	        return UriBuilder.formatGateway(priv.scheme, priv.hostname, priv.port);
	      },
	      set: function set(value) {
	        var obj = value != null ? UriParser.parseGateway(value) : null;
	        priv.scheme = obj && obj.scheme || null;
	        priv.hostname = obj && obj.hostname || null;
	        priv.port = obj && obj.port != null ? obj.port : null;
	      }
	    },
	    /** @name UuApp.Uri.UriBuilder#product */
	    product: {
	      get: function get() {
	        return UriBuilder.formatProduct(priv.vendor, priv.app, priv.subApp, priv.spp);
	      },
	      set: function set(value) {
	        var obj = value ? UriParser.parseProduct(value) : {};
	        priv.vendor = obj.vendor || null;
	        priv.app = obj.app || null;
	        priv.subApp = obj.subApp || null;
	        priv.spp = obj.spp || null;
	      }
	    },
	    /** @name UuApp.Uri.UriBuilder#workspace */
	    workspace: {
	      get: function get() {
	        return UriBuilder.formatWorkspace(priv.tid, priv.awid);
	      },
	      set: function set(value) {
	        var obj = value ? UriParser.parseWorkspace(value) : {};
	        priv.tid = obj.tid || null;
	        priv.awid = obj.awid || null;
	      }
	    },
	    /**
	     * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
	     * Note that each access returns new copy of the map (to prevent modification of the map without
	     * validating the values / keys).
	     * 
	     *     // BAD (uri.parameters returns copy; modification is not propagated back to UriBuilder)
	     *     uriBuilder.parameters["myParam"] = "value";
	     *     
	     *     // GOOD
	     *     uriBuilder.setParameter("myParam", "value");
	     * 
	     * @name UuApp.Uri.UriBuilder#parameters
	     */
	    parameters: {
	      get: function get() {
	        return Object.assign({}, priv.parameters);
	      },
	      set: function set(value) {
	        priv.parameters = {};
	        if (value) for (var k in value) {
	          this.setParameter(k, value[k]);
	        }
	      }
	    }
	  });

	  /**
	   * Sets query parameter with given name to given value.
	   * 
	   * @param {string} name The parameter name.
	   * @param {string} value The parameter value.
	   * @return This UriBuilder instance for chaining operations.
	   * @method UuApp.Uri.UriBuilder#setParameter
	   */
	  this.setParameter = function (name, value) {
	    UriParser.validateParameterName(name);
	    UriParser.validateParameterValue(value);
	    priv.parameters[name] = value;
	    return this;
	  };

	  /**
	   * Removes query parameter with given name.
	   * 
	   * @param {string} name The parameter name.
	   * @return This UriBuilder instance for chaining operations.
	   * @method UuApp.Uri.UriBuilder#deleteParameter
	   */
	  this.deleteParameter = function (name) {
	    UriParser.validateParameterName(name);
	    delete priv.parameters[name];
	    return this;
	  };

	  /**
	   * Removes all query parameters.
	   * 
	   * @return This UriBuilder instance for chaining operations.
	   * @method UuApp.Uri.UriBuilder#clearParameters
	   */
	  this.clearParameters = function () {
	    priv.parameters = {};
	    return this;
	  };
	}

	/**
	 * Parses URI string (or Uri instance) and resets all fields of this UriBuilder
	 * to parsed values.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri URI to parse.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#parse
	 */
	UriBuilder.prototype.parse = function (uriObj) {
	  var uri = typeof uriObj == "string" ? UriParser.parse(uriObj, UriBuilder).toUri() : uriObj;
	  this.gateway = uri.gateway;
	  this.product = uri.product;
	  this.workspace = uri.workspace;
	  this.useCase = uri.useCase;
	  this.parameters = uri.parameters;
	  return this;
	};

	/**
	 * Equivalent to <code>new UriBuilder().parse(uri)</code>.
	 * 
	 * @param {(string|UuApp.Uri.Uri)} uri URI to parse.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.parse
	 * @see UuApp.Uri.UriBuilder#parse
	 */
	UriBuilder.parse = function (uri) {
	  return new UriBuilder().parse(uri);
	};

	/**
	 * Sets fields of this UriBuilder to given values.
	 * 
	 * @param {...Object} fieldMap Object(s) containing fields to set to this UriBuilder. If more objects are given,
	 *   fields in latter ones override fields in former ones.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#set
	 * @example
	 *   // replace spp, awid & remove useCase
	 *   var resUri = UriBuilder.parse(someUri).set({
	 *     spp: "async",
	 *     awid: "12345",
	 *     useCase: null
	 *   }).toUri();
	 *   
	 *   // multiple settings
	 *   var defaults = { gateway: "...", product: "uu-demoapp-main", tid: "0", awid: "0" };
	 *   var resUri = UriBuilder.set(defaults, {
	 *     tid: "12f34", // overrides the one from "defaults" variable
	 *     useCase: "getData"
	 *   }).toUri();
	 */
	UriBuilder.prototype.set = function () /* ... */{
	  for (var i = 0; i < arguments.length; ++i) {
	    var hash = arguments[i];
	    if (!hash) continue;
	    if ((typeof hash === "undefined" ? "undefined" : _typeof(hash)) != "object") continue;
	    for (var k in hash) {
	      this[k] = hash[k];
	    }
	  }
	  return this;
	};

	/**
	 * Equivalent to <code>new UriBuilder().set(...)</code>.
	 * 
	 * @param {...Object} fieldMap Object(s) containing fields to set to the UriBuilder. If more objects are given,
	 *   fields in latter ones override fields in former ones.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.set
	 * @see UuApp.Uri.UriBuilder#set
	 */
	UriBuilder.set = function () /* ... */{
	  var builder = new UriBuilder();
	  return builder.set.apply(builder, arguments);
	};

	// add chainable setter functions
	/**
	 * Equivalent to <code>new UriBuilder().setScheme(value)</code>.
	 * 
	 * @param {string} value Scheme to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setScheme
	 * @see UuApp.Uri.UriBuilder#setScheme
	 */
	/**
	 * Chainable setter for scheme.
	 * 
	 * @param {string} value Scheme to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setScheme
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setHostname(value)</code>.
	 * 
	 * @param {string} value Hostname to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setHostname
	 * @see UuApp.Uri.UriBuilder#setHostname
	 */
	/**
	 * Chainable setter for hostname.
	 * 
	 * @param {string} value Hostname to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setHostname
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setPort(value)</code>.
	 * 
	 * @param {(string|number)} value Port to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setPort
	 * @see UuApp.Uri.UriBuilder#setPort
	 */
	/**
	 * Chainable setter for port.
	 * 
	 * @param {string} value Port to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setPort
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setGateway(value)</code>.
	 * 
	 * @param {string} value Gateway to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setGateway
	 * @see UuApp.Uri.UriBuilder#setGateway
	 */
	/**
	 * Chainable setter for gateway.
	 * 
	 * @param {string} value Gateway to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setGateway
	 */

	/**
	 * Equivalent to <code>new UriBuilder().setVendor(value)</code>.
	 * 
	 * @param {string} value Vendor to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setVendor
	 * @see UuApp.Uri.UriBuilder#setVendor
	 */
	/**
	 * Chainable setter for vendor.
	 * 
	 * @param {string} value Vendor to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setVendor
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setApp(value)</code>.
	 * 
	 * @param {string} value Application to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setApp
	 * @see UuApp.Uri.UriBuilder#setApp
	 */
	/**
	 * Chainable setter for application.
	 * 
	 * @param {string} value Application to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setApp
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setSubApp(value)</code>.
	 * 
	 * @param {string} value Sub-application to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setSubApp
	 * @see UuApp.Uri.UriBuilder#setSubApp
	 */
	/**
	 * Chainable setter for sub-application.
	 * 
	 * @param {string} value Sub-application to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setSubApp
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setSpp(value)</code>.
	 * 
	 * @param {string} value SPP to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setSpp
	 * @see UuApp.Uri.UriBuilder#setSpp
	 */
	/**
	 * Chainable setter for SPP.
	 * 
	 * @param {string} value SPP to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setSpp
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setProduct(value)</code>.
	 * 
	 * @param {string} value Product to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setProduct
	 * @see UuApp.Uri.UriBuilder#setProduct
	 */
	/**
	 * Chainable setter for product.
	 * 
	 * @param {string} value Product to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setProduct
	 */

	/**
	 * Equivalent to <code>new UriBuilder().setTid(value)</code>.
	 * 
	 * @param {string} value Tenant ID to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setTid
	 * @see UuApp.Uri.UriBuilder#setTid
	 */
	/**
	 * Chainable setter for tenant ID.
	 * 
	 * @param {string} value Tenant ID to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setTid
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setAwid(value)</code>.
	 * 
	 * @param {string} value Workspace ID to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setAwid
	 * @see UuApp.Uri.UriBuilder#setAwid
	 */
	/**
	 * Chainable setter for workspace ID.
	 * 
	 * @param {string} value Workspace ID to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setAwid
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setWorkspace(value)</code>.
	 * 
	 * @param {string} value Workspace to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setWorkspace
	 * @see UuApp.Uri.UriBuilder#setWorkspace
	 */
	/**
	 * Chainable setter for workspace.
	 * 
	 * @param {string} value Workspace to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setWorkspace
	 */

	/**
	 * Equivalent to <code>new UriBuilder().setUseCase(value)</code>.
	 * 
	 * @param {string} value Use case to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setUseCase
	 * @see UuApp.Uri.UriBuilder#setUseCase
	 */
	/**
	 * Chainable setter for use case.
	 * 
	 * @param {string} value Use case to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setUseCase
	 */
	/**
	 * Equivalent to <code>new UriBuilder().setParameters(value)</code>.
	 * 
	 * @param {string} value Parameters to set.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setParameters
	 * @see UuApp.Uri.UriBuilder#setParameters
	 */
	/**
	 * Chainable setter for parameters (replaces all parameters).
	 * 
	 * @param {string} value Parameters to set.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#setParameters
	 */
	["scheme", "hostname", "port", "gateway", "vendor", "app", "subApp", "spp", "product", "tid", "awid", "workspace", "useCase", "parameters"].forEach(function (attr) {
	  var setterFnName = "set" + attr.replace(/^./, function (m) {
	    return m.toUpperCase();
	  });
	  UriBuilder.prototype[setterFnName] = function (value) {
	    // "instance" method
	    this[attr] = value;
	    return this;
	  };
	  UriBuilder[setterFnName] = function (value) {
	    // "static" method
	    return new UriBuilder()[setterFnName](value);
	  };
	});
	/**
	 * Equivalent to <code>new UriBuilder().setParameter(name, value)</code>.
	 * 
	 * @param {string} name The parameter name.
	 * @param {string} value The parameter value.
	 * @return New UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder.setParameter
	 * @see UuApp.Uri.UriBuilder#setParameter
	 */
	UriBuilder.setParameter = function (name, value) {
	  return new UriBuilder().setParameter(name, value);
	};

	/**
	 * Merges (replaces / adds) provided parameters into the ones already present
	 * in this UriBuilder.
	 * 
	 * @param {Object} map Map with parameters to merge.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#mergeParameters
	 */
	UriBuilder.prototype.mergeParameters = function (value) {
	  if (value) for (var k in value) {
	    this.setParameter(k, value[k]);
	  }return this;
	};

	/**
	 * Replaces current path with specified absolute path (or adds a relative path to the current path) for this UriBuilder.
	 * Works exactly the same way as {@link UuApp.Uri.Uri#join Uri#join} but returns UriBuilder instead of Uri.
	 * 
	 * @param {...string} path Absolute or relative paths to replace / add.
	 * @return This UriBuilder instance.
	 * @method UuApp.Uri.UriBuilder#join
	 * @see UuApp.Uri.Uri#join
	 * @example
	 *  // replace path with an absolute path
	 *  var srcUri = "https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1";
	 *  var uriBuilder = UriBuilder.parse(srcUri);
	 *  uriBuilder.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
	 *  
	 *  // add relative paths
	 *  var uriBuilder = UriBuilder.parse(srcUri);
	 *  uriBuilder.join("./sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init
	 *  var uriBuilder = UriBuilder.parse(srcUri);
	 *  uriBuilder.join("+/sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init
	 */
	UriBuilder.prototype.join = function () /* ... */{
	  var uri = this.toUri();
	  return this.parse(uri.join.apply(uri, arguments));
	};

	var uriPriv = Uri.priv;
	// delete Uri.priv;
	/**
	 * Returns Uri instance from current values of this UriBuilder.
	 * 
	 * @return {UuApp.Uri.Uri} Uri instance from current values of this UriBuilder.
	 * @method UuApp.Uri.UriBuilder#toUri
	 */
	UriBuilder.prototype.toUri = function () {
	  var missing = [];
	  if (this.scheme == null && (this.hostname != null || this.port != null)) missing.push("scheme");
	  if (this.hostname == null && (this.scheme != null || this.port != null)) missing.push("hostname");
	  if (this.vendor == null && (this.subApp != null || this.spp != null)) missing.push("vendor");
	  if (this.app == null) missing.push("app");
	  if (this.subApp == null && this.spp != null) missing.push("subApp");
	  if (this.awid == null) missing.push("awid");
	  if (missing.length) throw new Err("Missing Uri parts: " + missing.join(", ") + ". Values: " + this.toString());

	  uriPriv.allowNew = true;
	  try {
	    return new Uri(this.scheme, this.hostname, this.port, this.vendor, this.app, this.subApp, this.spp, this.tid, this.awid, this.useCase, this.parameters);
	  } finally {
	    uriPriv.allowNew = false;
	  }
	};

	/**
	 * Formats current values of this UriBuilder into a URI-like string.
	 * 
	 * @return {string} Formatted string from current values of this UriBuilder.
	 * @method UuApp.Uri.UriBuilder#toString
	 * @example
	 *   var uriBuilder = UriBuilder.parse("https://uuos9.plus4u.net/vendor-app/tid-awid");
	 *   uriBuilder.toString(); // https://uuos9.plus4u.net/vendor-app/tid-awid
	 */
	UriBuilder.prototype.toString = function () {
	  return UriBuilder.format(this.toUri());
	};

	/**
	 * Formats current values of this UriBuilder into a URI-like string.
	 * 
	 * @return {string} Formatted string from current values of this UriBuilder.
	 * @method UuApp.Uri.UriBuilder#format
	 * @example
	 *   var uriBuilder = UriBuilder.parse("https://uuos9.plus4u.net/vendor-app/tid-awid");
	 *   uriBuilder.format(); // https://uuos9.plus4u.net/vendor-app/tid-awid
	 */
	UriBuilder.prototype.format = function () {
	  return UriBuilder.format(this.toUri());
	};

	UriBuilder.format = function (uri) {
	  return UriParser.format(uri);
	};

	UriBuilder.formatGateway = function (scheme, hostname, port) {
	  return UriParser.formatGateway(scheme, hostname, port);
	};
	UriBuilder.formatProduct = function (vendor, app, subApp, spp) {
	  return UriParser.formatProduct(vendor, app, subApp, spp);
	};
	UriBuilder.formatWorkspace = function (tid, awid) {
	  return UriParser.formatWorkspace(tid, awid);
	};

	Uri.prototype.Builder = UriBuilder;

	module.exports = UriBuilder;

/***/ },
/* 26 */
/*!**************************!*\
  !*** ./uri/UriParser.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Err = __webpack_require__(/*! ../error/Error.js */ 11);

	var ASSET_CLASSIFIER = "static|assets|public";
	var UNRESERVED = "[\\w\\.\\-~]";
	var IDENTIFIER = "[a-zA-Z0-9_]";
	var PATH = "[\\w\\.\\-~\/]";
	var SCHEME = "(" + UNRESERVED + "+)";

	// No reason to match IPv4 (invalid IP address is always
	// matched as generic hostname - we cannot distinguish them)
	// IPV4_PART = "(25[0-5]|2[0-5][0-9]|1[0-9][0-9]|[0-9][0-9]?)"
	// IPV4 = "(#{IPV4_PART}(\\.#{IPV4_PART}){3})"

	// Only rough validation
	// see http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
	var IPV6_PART = "([0-9a-fA-F]{1,4})";
	var IPV6 = "(\\[" + IPV6_PART + "(:(" + IPV6_PART + ")?){1,7}\\])";

	var HOSTNAME = "(" + IPV6 + "|" + UNRESERVED + "+)";
	var PORT = "(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[0-5][0-9]{4}|[1-9][0-9]{0,3})";
	var GATEWAY = "(" + SCHEME + "://" + HOSTNAME + "(:" + PORT + ")?)";
	var VENDOR = "(" + IDENTIFIER + "{1,32})";
	var APP = "(" + IDENTIFIER + "{1,32})";
	var SUB_APP = "(" + IDENTIFIER + "{1,32})";
	var SPP = "(" + IDENTIFIER + "{1,32})";
	var PRODUCT = "(?=[^/]{1,131}(?:/|$))((?:" + VENDOR + "\\-)?" + APP + "(?:\\-" + SUB_APP + "(?:\\-" + SPP + ")?)?)";
	var TID = "(" + IDENTIFIER + "{1,32})";
	var AWID = "(" + IDENTIFIER + "{1,32})";
	var WORKSPACE = "(?=[^/\\?]{1,65}(?:/|\\?|$))((?:" + TID + "\\-)?" + AWID + ")";
	var USE_CASE = "(" + PATH + "*)";
	var PARAMETER_NAME = "(?:" + UNRESERVED + "+)";
	var PARAMETER_VALUE = "(?:[^=&]*)";
	var PARAMETER = "(?:" + PARAMETER_NAME + "(?:=" + PARAMETER_VALUE + ")?)";
	var PARAMETERS = "(" + PARAMETER + "(?:&" + PARAMETER + ")*)";
	var URI_REGEXP = new RegExp("^(?:" + GATEWAY + ")?\\/" + PRODUCT + "\\/" + WORKSPACE + "(?:/" + USE_CASE + ")?(?:\\?" + PARAMETERS + "?)?$");

	// console.log("https://uuos9.plus4u.net:80/vnd-app-subapp-spp/tid-awid/some/long/uc?p1=v1&p2=v2&p3=%25".match(URI_REGEXP));                // non-opaque
	//
	// ["https://uuos9.plus4u.net:80/vnd-app-subapp-spp/tid-awid/some/long/uc?p1=v1&p2=v2&p3=%25", "https://uuos9.plus4u.net:80", "https", "uuos9.plus4u.net", undefined,
	//  undefined, undefined, undefined, undefined, ":80",
	//  "80", "vnd-app-subapp-spp", "vnd", "app", "subapp",
	//  "spp", "tid-awid", "tid", "awid", "/some/long/uc",
	//  "p1=v1&p2=v2&p3=%25", index: 0, input: "https://uuos9.plus4u.net:80/vnd-app-subapp-spp/tid-awid/some/long/uc?p1=v1&p2=v2&p3=%25"]

	var UriParser = {
	  ASSET_CLASSIFIER: ASSET_CLASSIFIER, UNRESERVED: UNRESERVED, IDENTIFIER: IDENTIFIER, SCHEME: SCHEME, IPV6_PART: IPV6_PART, IPV6: IPV6, HOSTNAME: HOSTNAME, PORT: PORT, GATEWAY: GATEWAY, VENDOR: VENDOR, APP: APP, SUB_APP: SUB_APP,
	  SPP: SPP, PRODUCT: PRODUCT, TID: TID, AWID: AWID, WORKSPACE: WORKSPACE, USE_CASE: USE_CASE, PARAMETER_NAME: PARAMETER_NAME, PARAMETER_VALUE: PARAMETER_VALUE, PARAMETER: PARAMETER, PARAMETERS: PARAMETERS, URI_REGEXP: URI_REGEXP,

	  parse: function parse(str, UriBuilder) {
	    if (!UriBuilder) throw new Err("UriBuilder must be provided.");
	    var result = (str || "").match(URI_REGEXP);
	    //      console.log(result);
	    if (!result) throw new Err("Parse error - invalid uri: " + (str || ""));
	    var uriBuilder = new UriBuilder().set({
	      scheme: result[2],
	      hostname: result[3],
	      port: result[10],
	      vendor: result[12],
	      app: result[13],
	      subApp: result[14],
	      spp: result[15],
	      tid: result[17],
	      awid: result[18],
	      useCase: result[19]
	    });
	    var params = result[20];
	    if (params) {
	      params.split("&").forEach(function (pair) {
	        if (!pair) return;
	        var eqlSignIdx = pair.indexOf("=");
	        var k = eqlSignIdx != -1 ? pair.substr(0, eqlSignIdx) : pair;
	        var v = eqlSignIdx != -1 ? pair.substr(eqlSignIdx + 1) : "";
	        uriBuilder.setParameter(k, decodeURIComponent(v)); // key contains only URL-safe characters
	      });
	    }
	    return uriBuilder;
	  },
	  format: function format(uri) {
	    var parts = [];
	    parts.push((uri.gateway || "") + "/" + (uri.product || "") + "/" + (uri.workspace || ""));
	    var uc = uri.useCase;
	    if (uc) {
	      if (uc.charAt(0) != "/") parts.push("/");
	      parts.push(uc);
	    }
	    parts = [parts.join("").replace(/\/+$/, "")]; // remove all trailing slashes
	    var params = uri.parameters;
	    var paramKeys = Object.keys(params);
	    paramKeys.sort();
	    for (var i = 0; i < paramKeys.length; ++i) {
	      var k = paramKeys[i];
	      parts.push(i ? "&" : "?");
	      parts.push(k);
	      var value = params[k];
	      if (value == null || value === "") continue;
	      parts.push("=");
	      parts.push(encodeURIComponent(value));
	    }
	    return parts.join("");
	  },
	  parseGateway: function parseGateway(value) {
	    if (typeof value != "string") throw new InvalidUriPartError("gateway", value, GATEWAY);
	    var result = value.match(new RegExp("^" + GATEWAY + "$"));
	    if (!result) throw new InvalidUriPartError("gateway", value, GATEWAY);
	    //  console.log(result);
	    //      ["http://example.com:123", "http://example.com:123", "http",
	    //       "example.com", undefined, undefined,
	    //       undefined, undefined, undefined,
	    //       ":123", "123"]
	    return { scheme: result[2], hostname: result[3], port: result[10] };
	  },
	  formatGateway: function formatGateway(scheme, hostname, port) {
	    if (!scheme && !hostname && !port) return null;
	    UriParser.validateScheme(scheme);
	    UriParser.validateHostname(hostname);
	    if (port != null) UriParser.validatePort(port);
	    return scheme + "://" + hostname + (port != null ? ":" + port : "");
	  },
	  parseProduct: function parseProduct(value) {
	    if (typeof value != "string") throw new InvalidUriPartError("product", value, PRODUCT);
	    var result = value.match(new RegExp("^" + PRODUCT + "$"));
	    if (!result) throw new InvalidUriPartError("product", value, PRODUCT);
	    return { vendor: result[2], app: result[3], subApp: result[4], spp: result[5] };
	  },
	  formatProduct: function formatProduct(vendor, app, subApp, spp) {
	    if (!vendor && !app && !subApp && !spp) return null;
	    if (vendor) UriParser.validateVendor(vendor);
	    UriParser.validateApp(app);
	    if (subApp) UriParser.validateSubApp(subApp);
	    if (spp) UriParser.validateSpp(spp);

	    var result = [];
	    if (vendor) result.push(vendor + "-");
	    result.push(app);
	    if (subApp) result.push("-" + subApp);
	    if (spp) result.push("-" + spp);
	    return result.join("");
	  },
	  parseWorkspace: function parseWorkspace(value) {
	    if (typeof value != "string") throw new InvalidUriPartError("workspace", value, WORKSPACE);
	    var result = value.match(new RegExp("^" + WORKSPACE + "$"));
	    if (!result) throw new InvalidUriPartError("workspace", value, WORKSPACE);
	    return { tid: result[2], awid: result[3] };
	  },
	  formatWorkspace: function formatWorkspace(tid, awid) {
	    if (!tid && !awid) return null;
	    if (tid) UriParser.validateTid(tid);
	    UriParser.validateAwid(awid);

	    var result = [];
	    if (tid) result.push(tid + "-");
	    result.push(awid);
	    return result.join("");
	  },
	  validateScheme: function validateScheme(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + SCHEME + "$"))) throw new InvalidUriPartError("scheme", value, SCHEME);
	  },
	  validateHostname: function validateHostname(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + HOSTNAME + "$"))) throw new InvalidUriPartError("hostname", value, HOSTNAME);
	  },
	  validatePort: function validatePort(value) {
	    value = typeof value == "number" ? value + "" : value;
	    if (typeof value != "string" || !value.match(new RegExp("^" + PORT + "$"))) throw new InvalidUriPartError("port", value, PORT);
	  },
	  validateGateway: function validateGateway(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + GATEWAY + "$"))) throw new InvalidUriPartError("gateway", value, GATEWAY);
	  },
	  validateVendor: function validateVendor(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + VENDOR + "$"))) throw new InvalidUriPartError("vendor", value, VENDOR);
	  },
	  validateApp: function validateApp(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + APP + "$"))) throw new InvalidUriPartError("app", value, APP);
	  },
	  validateSubApp: function validateSubApp(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + SUB_APP + "$"))) throw new InvalidUriPartError("subApp", value, SUB_APP);
	  },
	  validateSpp: function validateSpp(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + SPP + "$"))) throw new InvalidUriPartError("spp", value, SPP);
	  },
	  validateProduct: function validateProduct(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + PRODUCT + "$"))) throw new InvalidUriPartError("product", value, PRODUCT);
	  },
	  validateTid: function validateTid(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + TID + "$"))) throw new InvalidUriPartError("tid", value, TID);
	  },
	  validateAwid: function validateAwid(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + AWID + "$"))) throw new InvalidUriPartError("awid", value, AWID);
	  },
	  validateWorkspace: function validateWorkspace(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + WORKSPACE + "$"))) throw new InvalidUriPartError("workspace", value, WORKSPACE);
	  },
	  validateUseCase: function validateUseCase(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + USE_CASE + "$"))) throw new InvalidUriPartError("useCase", value, USE_CASE);
	  },
	  validateParameterName: function validateParameterName(value) {
	    if (typeof value != "string" || !value.match(new RegExp("^" + PARAMETER_NAME + "$"))) throw new InvalidUriPartError("parameterName", value, PARAMETER_NAME);
	  },
	  validateParameterValue: function validateParameterValue(value) {
	    if (value != null && typeof value != "string") throw new InvalidUriPartError("parameterValue", value, String);
	    // for our generic uuUri following check is always true; will skip for optimization
	    //      if (value != null && !encodeURIComponent(value).match(new RegExp("^" + PARAMETER_VALUE + "$"))) throw new InvalidUriPartError("parameterValue", value, PARAMETER_VALUE);
	  }
	};

	function InvalidUriPartError(partName, value, expected) {
	  var message;
	  if (typeof expected != "string") message = "Value \"" + value + "\" of URI part [" + partName + "] must be " + expected + " but is typeof " + (typeof value === "undefined" ? "undefined" : _typeof(value));else message = "Value \"" + value + "\" of URI part [" + partName + "] does not match regular expression /" + expected.replace(/\//g, "\\/") + "/";
	  Err.call(this, message);
	}
	InvalidUriPartError.prototype = Object.create(Err.prototype);
	InvalidUriPartError.prototype.constructor = InvalidUriPartError;

	module.exports = UriParser;

/***/ }
/******/ ])
});
;