"use strict";

var Err = require("../error/Error.js");

/**
 * @class UuApp.Uri.Uri
 * @classdesc
 * Immutable representation of uuUri. An instance of the Uri can be obtained either by
 * {@link UuApp.Uri.Uri.parse Uri.parse} or by using {@link UuApp.Uri.UriBuilder UriBuilder} class.
 * Note that minimal Uri consists of at least "app" and "tid".
 * 
 * Examples of usage:
 * 
 *     // uri from parsing current location
 *     var locationUri = Uri.parse(location.protocol + "//" + location.host + location.pathname); // "http://example.com/vendor-app/0-0/some/uc"
 *     var baseUri = locationUri.baseUri; // "http://example.com/vendor-app/0-0"
 *     var callUri = baseUri.join("+/getConfig"); // "http://example.com/vendor-app/0-0/getConfig"
 *    
 *     // uri from parsing
 *     var uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app-subapp-spp/tid-awid/useCase?p1=v1");
 *     console.log(uri.gateway, uri.product, uri.workspace, uri.useCase); 
 *     var params = uri.parameters; // always returns new copy of parameter map
 *     for (var k in params) console.log(k, "=", params[k]); // p1 = v1
 *     
 *     // uri from UriBuilder
 *     var uri2 = UuApp.Uri.UriBuilder.parse(uri).setWorkspace("0-0").setUseCase("sys/init").toUri();
 *     console.log(uri2.toString()); // https://uuos9.plus4u.net/vendor-app-subapp-spp/0-0/sys/init?p1=v1
 *     
 *     // uri from parsing (with ECMAScript6 template string, e.g. when using transpilers like Babel)
 *     // Note that query parameter values shouldn't be injected via template string as they might need
 *     // to be encoded first.
 *     var product = "vendor-app";
 *     var workspace = "tid-awid";
 *     var uri3 = UuApp.Uri.Uri.parse(`https://uuos9.plus4u.net/${product}/${workspace}`);
 *    
 * @see UuApp.Uri.UriBuilder
 */

// NOTE Constructor is "private".
var priv = Uri.priv = {}; // TODO This is not-so-ellegant solution for allowing UriBuilder to call Uri constructor (and forbid it for everyone else).
var EMPTY = {};
function Uri(scheme, hostname, port, vendor, app, subApp, spp, tid, awid, useCase, parameters) {
  var _this = this;

  if (!priv.allowNew) throw new Err("Use UuApp.Uri.Uri.parse to obtain an instance of uuUri.");

  useCase = useCase ? useCase.replace(/^\//, "") : useCase; // strip leading slash from useCase
  if (port && typeof port != "number") port = parseInt(port + "", 10);
  if ((port == null || port === "") && scheme) port = scheme.match(/^https$/) ? 443 : 80;
  var gateway = { value: EMPTY, lazyGet: function lazyGet() {
      return gateway.value !== EMPTY ? gateway.value : gateway.value = _this.Builder.formatGateway(scheme, hostname, port);
    } };
  var product = { value: EMPTY, lazyGet: function lazyGet() {
      return product.value !== EMPTY ? product.value : product.value = _this.Builder.formatProduct(vendor, app, subApp, spp);
    } };
  var workspace = { value: EMPTY, lazyGet: function lazyGet() {
      return workspace.value !== EMPTY ? workspace.value : workspace.value = _this.Builder.formatWorkspace(tid, awid);
    } };
  var params = Object.assign({}, parameters); // make a copy to guard against mutation of original "parameters" object
  var uri = this;

  // NOTE Attributes are defined as properties so that they throw error when developer
  // tries tu mutate them (even in non-strict mode).
  function throwOnSet(attr) {
    return function () {
      throw new Err("Cannot set " + attr + " on Uri because instances of Uri are immutable. Use UriBuilder instead.");
    };
  }
  Object.defineProperties(this, {
    /** @name UuApp.Uri.Uri#scheme */
    scheme: { get: function get() {
        return scheme;
      }, set: throwOnSet("scheme") },

    /** @name UuApp.Uri.Uri#hostname */
    hostname: { get: function get() {
        return hostname;
      }, set: throwOnSet("hostname") },

    /** @name UuApp.Uri.Uri#port */
    port: { get: function get() {
        return port;
      }, set: throwOnSet("port") },

    /**
     * Formatted string containing scheme, hostname and port. For example for scheme "https",
     * hostname "example.com" and port "123" it returns "https://example.com:123".
     * 
     * @name UuApp.Uri.Uri#gateway
     */
    gateway: { get: gateway.lazyGet, set: throwOnSet("gateway") },

    /** @name UuApp.Uri.Uri#vendor */
    vendor: { get: function get() {
        return vendor;
      }, set: throwOnSet("vendor") },

    /** @name UuApp.Uri.Uri#app */
    app: { get: function get() {
        return app;
      }, set: throwOnSet("app") },

    /** @name UuApp.Uri.Uri#subApp */
    subApp: { get: function get() {
        return subApp;
      }, set: throwOnSet("subApp") },

    /** @name UuApp.Uri.Uri#spp */
    spp: { get: function get() {
        return spp;
      }, set: throwOnSet("spp") },

    /** @name UuApp.Uri.Uri#product */
    product: { get: product.lazyGet, set: throwOnSet("product") },

    /** @name UuApp.Uri.Uri#tid */
    tid: { get: function get() {
        return tid;
      }, set: throwOnSet("tid") },

    /** @name UuApp.Uri.Uri#awid */
    awid: { get: function get() {
        return awid;
      }, set: throwOnSet("awid") },

    /** @name UuApp.Uri.Uri#workspace */
    workspace: { get: workspace.lazyGet, set: throwOnSet("workspace") },

    /** @name UuApp.Uri.Uri#useCase */
    useCase: { get: function get() {
        return useCase;
      }, set: throwOnSet("useCase") },

    /**
     * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
     * Note that each access returns new copy of the map (to achieve immutability of the Uri class),
     * therefore usage should look like this:
     * 
     *     // OPTIMAL (single read of "parameters" field on uri)
     *     var params = uri.parameters;
     *     for (var k in params) console.log(params[k]);
     *     
     *     // SUB-OPTIMAL (multiple reads and therefore multiple copying of parameter map)
     *     // for (var k in uri.parameters) console.log(uri.parameters[k]);
     * 
     * @name UuApp.Uri.Uri#parameters
     */
    parameters: { get: function get() {
        return Object.assign({}, params);
      }, set: throwOnSet("parameters") },

    /**
     * URI containing only mandatory routing data (includes only "gateway", "product" and "workspace").
     * @name UuApp.Uri.Uri#baseUri
     */
    baseUri: { get: getBaseUri, set: throwOnSet("baseUri") },
    /**
     * Relative URI (without "gateway").
     * @name UuApp.Uri.Uri#relativeUri
     */
    relativeUri: { get: getRelativeUri, set: throwOnSet("relativeUri") }
  });

  var baseUri, relativeUri;
  function getBaseUri() {
    if (baseUri !== undefined) return baseUri;
    if (uri.gateway == null || uri.product == null || uri.workspace == null) throw new Err("Insufficient URI - at least one of gateway, product and workspace is not set. Uri: " + uri.toString());
    baseUri = uri.Builder.parse(uri).set({ useCase: null }).clearParameters().toUri();
    return baseUri;
  }
  function getRelativeUri() {
    if (relativeUri !== undefined) return relativeUri;
    relativeUri = uri.Builder.parse(uri).set({ gateway: null }).toUri();
    return relativeUri;
  }

  var str;
  /**
   * Converts URI to string.
   * 
   * @return URI converted to string.
   * @method UuApp.Uri.Uri#toString
   */
  this.toString = function () {
    return str !== undefined ? str : str = _this.Builder.format(_this);
  };

  //    /**
  //     * Converts URI to an object literal (a map) containing keys scheme, hostname, ...
  //     * 
  //     * @function UuApp.Uri.Uri#toObject
  //     */
  //    this.toObject = () => ({
  //      scheme: scheme, hostname: hostname, port: port, vendor: vendor, app: app, subApp: subApp, spp: spp,
  //      tid: tid, awid: awid, useCase: useCase, parameters: Object.assign({}, params)
  //    });

  // serialize as string when stringifying to JSON
  this.toJSON = this.toString;

  // prevent any modification of the Uri object
  Object.freeze(this);
}

/**
 * Replaces current path with specified absolute path (or adds a relative path to the current path) returning new Uri.
 * Query parameters are preserved only on last path. Resolving relative path and usage of "./" and "../" works as in standard
 * URLs (see {@link https://tools.ietf.org/html/rfc2396#appendix-C RFC 2396, examples}).
 * 
 * Additionally, it's possible to use "+/" at the beginning of paths - paths starting
 * with "+/" are joined as if current path (to which new path is being joined) denoted a "folder", i.e. current path
 * is appended with slash (unless it already ends with slash) and new path is appended afterwards (see examples). 
 * 
 * @param {...string} path Absolute or relative paths to replace / add.
 * @return New Uri whose path is the result of the join.
 * @method UuApp.Uri.Uri#join
 * @example
 *  // replace path with an absolute path (effectively removing also query parameters)
 *  var uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1?a=b");
 *  var uri2 = uri.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
 *  
 *  // add relative paths
 *  var uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1");
 *  var uri2 = uri.join("sys/init?p=v");             // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init?p=v
 *  var uri3 = uri.join("+/sys/init?p=v");           // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?p=v
 *  var uri4 = uri.join("+/sys/?a=b", "init?c=d");   // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?c=d
 */
Uri.prototype.join = function () /* ... */{
  if (arguments.length <= 0) return this;
  var root = this.gateway || "";
  var path = this.toString().substr(root.length);

  for (var i = 0; i < arguments.length; ++i) {
    var pathPart = arguments[i];
    if (!pathPart) continue;
    path = path.replace(/[?#].*/, ""); // remove query part because we're going to add / replace path
    pathPart = pathPart.replace(/((^|\/)\.\.?)$/, "$1/"); // if new path part ends with two dots / one dot, treat it as a "folder", i.e. append "/"
    if (pathPart.charAt(0) == "/") path = pathPart; // new path part is absolute => replace whole path
    else if (pathPart.match(/^\+(\/|$)/)) path = path.replace(/\/?$/, "/") + pathPart; // new path part is relative with "+/" => append "/" and then new path
      else if (path.charAt(path.length - 1) == "/") path += pathPart; // new path part is relative and current path is a "folder" => append new path
        else path = path.replace(/(^|\/)[^\/]*$/, "$1") + pathPart; // new path part is relative and current path is not a "folder" => replace last segment of current path
  }

  // normalize (modify segments to eliminate "../" and "./" from the path)
  var segments = [];
  path.split("/").forEach(function (part) {
    if (part === "..") segments.pop();else if (part !== "." && part !== "+") segments.push(part);
  });
  if (segments[0] !== "") segments.unshift(""); // make sure that after "join" operation the path starts with "/"
  var resultPath = segments.join("/");
  return Uri.parse(root + resultPath);
};

/**
 * Checks whether the other URI is equal to this one and returns true iff it is.
 * 
 * @param {UuApp.Uri.Uri} uri Uri to check equality against.
 * @return True iff the specified uri is equal to this one.
 * @method UuApp.Uri.Uri#equals
 */
Uri.prototype.equals = function (aUri2) {
  return this.toString() === (aUri2 || "").toString();
};

/**
 * @param {(string|UuApp.Uri.Uri)} uriStr The string to parse as URI. If an instance of Uri class is given, it's returned as-is.
 * @return {UuApp.Uri.Uri} Parsed URI.
 * @method UuApp.Uri.Uri.parse
 * @example
 *    var uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app/tid-awid/useCase?p1=v1");
 *    console.log(uri.gateway, uri.product, uri.workspace, uri.useCase, uri.parameters);
 */
Uri.parse = function (uriStr) {
  if (uriStr instanceof Uri) return uriStr;
  return Uri.prototype.Builder.parse(uriStr).toUri();
};

module.exports = Uri;