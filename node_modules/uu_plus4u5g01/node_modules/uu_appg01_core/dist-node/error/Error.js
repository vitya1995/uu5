"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// make native Error-s (TypeError, ...) be converted to JSON "somehow", because right now they always end up as {}
try {
  if (JSON.stringify(new Error()) == "{}") {
    Error.prototype.toJSON = function () {
      if (Object.hasOwnProperty(this, "toJSON")) return this; // to be on the safe-side
      // we might be in a sub-classed error (TypeError, even custom Error) so temporarily override
      // toJSON with as-is serialization and use toString() only if we would get no information otherwise
      this.toJSON = function () {
        return this;
      };
      var useToString = JSON.stringify(this) == "{}";
      delete this.toJSON; // deletes override; toJSON on prototype chain (this one or any other) is preserved
      // use this or toString() for final serialization
      return useToString ? this.toString() + (this.stack != null ? "\n" + this.stack : "") : this;
    };
  }
} catch (e) {}
// ignore


//  /**
//   * Creates new Error.
//   * 
//   * This constructor can be also called with a single object literal containing any fields that
//   * are to be set to the Error object. 
//   *
//   * @param {string} message The message.
//   * @param {Error} cause (optional) The cause (original error).
//   * @constructor UuApp.Error.Error
//   */

// TODO JSDoc doesn't support describing multiple signatures for the same method :-(.
//  /**
//   * Creates new Error.
//   *
//   * @param {Object} errorObject Object with any attributes to set to the Error instance.
//   * @constructor UuApp.Error.Error
//   */
function _Error(msgOrObj) {
  var self = this;
  if (!(self instanceof _Error)) return new (_Error.bind.apply(_Error, arguments))(); // make an instance even if developer forgot to use "new" keyword
  var errorObject = msgOrObj;
  if (!errorObject || (typeof errorObject === "undefined" ? "undefined" : _typeof(errorObject)) != "object") {
    errorObject = {
      message: arguments[0],
      cause: arguments[1]
    };
  }
  Object.assign(this, errorObject);
  if (!this.id) this.id = generateUuid();
  if (!this.stack) this.stack = new Error().stack;
  /**
   * ID of the error. If not specified, it'll be automatically generated.
   * @name UuApp.Error.Error#id
   */
  /**
   * The message of the error.
   * @name UuApp.Error.Error#message
   */
  /**
   * The cause (nested error) of the error.
   * @name UuApp.Error.Error#cause
   */
  /**
   * Stacktrace of the error. If not specified, it'll be automatically filled via browser.
   * @name UuApp.Error.Error#stack
   */
}
_Error.prototype = Object.create(Error.prototype);
_Error.prototype.constructor = _Error;

function generateUuid() {
  // generate UUID (RFC4122 version 4 compliant) for the event ID
  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
  return uuid;
}

module.exports = _Error;