"use strict";

var Logger = require("./Logger.js");
var Config = require("../util/Config.js");

var loggers = {};
var LoggerFactory = {};
var loggerPriv = Logger.priv;
// delete Logger.priv;

/**
 * @class UuApp.Logging.LoggerFactory
 * @classdesc
 * Factory class for getting access to loggers. See {@link UuApp.Logging.Logger Logger} for more information.
 */

/**
 * Returns an instance of the logger with given name. Settings of the logger are
 * taken from global configuration (see {@link UuApp.Util.Config.init Config.init}).
 * Default global logLevel is Logger.{@link UuApp.Logging.Logger.LEVEL_WARN LEVEL_WARN}.
 * 
 * Successive calls with the same logger name return the same logger instance.
 * 
 * @param {string} name The name of the logger. Typically, it's a fully-qualified name of
 *   the component that uses the logger, e.g. "My.Namespace.Component".
 * @param {boolean} hierarchical Whether the logger shall inherit settings from its parent
 *   package names, e.g. whether logger with name "My.Namespace" should inherit logLevel from "My"
 *   or from root (hierarchical = true, default) or only settings directly for "My.Namespace" apply
 *   (hierarchical = false). The parameter is used only during 1st invocation for given logger name,
 *   in successive calls it's ignored.
 * @return {UuApp.Logging.Logger} An instance of the logger with given name.
 * @method UuApp.Logging.LoggerFactory.get
 */
LoggerFactory.get = function (name, hierarchical) {
  if (typeof name != "string") throw new Error("LoggerFactory.get() must be called with a string argument (logger name).");
  if (loggers[name]) return loggers[name].logger;
  loggerPriv.allowLoggerNew = true;
  var logger;
  try {
    // create & configure the logger (configure only if configuration is not being loaded at the moment)
    logger = new Logger(name);
    if (!Config.initInvoked || Config.initComplete) configure(logger, hierarchical, Config);
  } finally {
    loggerPriv.allowLoggerNew = false;
  }
  return (loggers[name] = { logger: logger, hierarchical: hierarchical }).logger;
};

// configures logger from given environment object
function configure(logger, hierarchical, env) {
  // only "logLevel" is currently recognized
  var logLevel = env.get(logger.name + ".logLevel", hierarchical !== false);
  logger.setLevel(logLevel);

  logger.ready = true;
}

// create root logger
Logger.getRootLogger = function () {
  return rootLogger;
};
loggerPriv.allowLoggerNew = true;
loggers[""] = { logger: new Logger(""), hierarchical: false };
var rootLogger = loggers[""].logger;
loggerPriv.allowLoggerNew = false;

// re-configure existing loggers after global configuration is loaded (if loggers were created sooner than
// configuration got loaded)
if (!Config.initComplete) {
  Config.initInvokedPromise.then(function () {
    // change loggers to "not-ready" state (they'll buffer logging calls)
    for (var k in loggers) {
      loggers[k].logger.ready = false;
    }
  });
  Config.initCompletePromise.then(function (env) {
    // re-configure loggers and switch to "ready" state
    for (var k in loggers) {
      configure(loggers[k].logger, loggers[k].hierarchical, env);
    }
  });
}

module.exports = LoggerFactory;