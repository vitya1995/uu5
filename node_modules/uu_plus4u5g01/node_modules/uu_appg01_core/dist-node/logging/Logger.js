"use strict";

// TODO Change into ES6 imports / exports. Beware that some tests are run via Node environment
// and it doesn't recognize import / export statements (so tests will stop working). Might get it working
// by running tests against dist-node/ folder (where the files are downcompiled to ES5).
var Config = require("../util/Config.js");

/**
 * @class UuApp.Logging.Logger
 * @classdesc
 * Component for logging. Each logged message has a severity level and each logger can be
 * configured to process only messages with sufficient severity level. Loggers are hierarchical,
 * i.e. when configuration is processed they inherit severity level from parent modules/packages.
 * 
 * Contrary to usual <code>console.log</code>, <code>console.error</code>, ... statements (which
 * are typically removed from production code), statements using Logger-s are intended to be
 * preserved in the production environment and turned on/off via {@link UuApp.Util.Config Config}
 * configuration.
 * 
 * **Configuration**
 * 
 * Default severity level for loggers is Logger.LEVEL_WARN. Logging is automatically configured from the
 * global configuration (initialized via {@link UuApp.Util.Config Config.init} call).
 * Supported environment options:
 * 
 *     {
 *       "logLevel": "ERROR",
 *       "My.Namespace.logLevel": "WARN"
 *     }
 * 
 * As already said, loggers are hierarchical - with configuration above, logger "My.Namespace.Component"
 * would have logLevel "WARN" whereas logger "My" would have logLevel "ERROR". Hierarchical logging can
 * be turned off when initializing a logger - see {@link UuApp.Logging.LoggerFactory.get LoggerFactory.get}.
 * 
 * **Typical usage**
 * 
 *     // get logger instance and log a message
 *     var logger = UuApp.Logging.LoggerFactory.get("My.Namespace.Component");
 *     logger.warn("Universe expansion is accelerating.", {speedBefore: 68, speedAfter: 68.01});
 *     
 *     // if logging requires lenghty computation, it can be made conditional so that it
 *     // doesn't slow down the rest of page if the message wouldn't get logged in the end
 *     if (logger.isDebugLoggable()) {
 *       var computedValue = ...; // some lenghty computation
 *       logger.debug("Value computed to", computedValue);
 *     }
 *     
 */
function Logger(name) {
  var _this = this;

  if (!priv.allowLoggerNew) throw new Error("Use UuApp.Logging.LoggerFactory.get(name) to get an instance of Logger.");
  this.name = name;

  // logger can be configured after delay because Util.Config can be loaded asynchronously,
  // therefore we'll buffer the debug/info/warn/error calls until the configuration is ready
  var ready = false;
  this._buffer = [];
  Object.defineProperty(this, "ready", {
    get: function get() {
      return ready && (!Config.initInvoked || Config.initComplete);
    },
    set: function set(value) {
      ready = value;
      if (ready) flushBuffer.call(_this);
    }
  });
}
var priv = Logger.priv = {}; // TODO This is not-so-ellegant solution for allowing UriBuilder to call Uri constructor (and forbid it for everyone else).

/** @name UuApp.Logging.Logger.LEVEL_DEBUG */
/** @name UuApp.Logging.Logger.LEVEL_INFO */
/** @name UuApp.Logging.Logger.LEVEL_WARN */
/** @name UuApp.Logging.Logger.LEVEL_ERROR */
/** @name UuApp.Logging.Logger.LEVEL_OFF */
var levels = { DEBUG: 100, INFO: 200, WARN: 300, ERROR: 400, OFF: Math.MAX_VALUE };
var levelsInverted = Object.keys(levels).reduce(function (r, name) {
  return r[levels[name]] = name, r;
}, {}); // { 100: "DEBUG", ...}
Object.keys(levels).forEach(function (level) {
  // publish levels as constants
  Logger["LEVEL_" + level.toUpperCase()] = levels[level];
});

/**
 * Sets severity level of this Logger to given value. Messages with lower (less important)
 * severity will be ignored when attempted to be logged via this logger. Order of importance:
 * DEBUG < INFO < WARN < ERROR < OFF.
 * 
 * **It's strongly advised not to configure loggers directly using this method** because
 * if such code gets deployed to production, it'll effectively override settings from
 * environment and therefore could prevent logging of necessary information.
 * **Use environment configuration instead - see Configuration chapter in {@link UuApp.Logging.Logger Logger}.
 * 
 * @param {(number|string)} level Severity level to set. See Logger.LEVEL_* constants. If null
 *   is given, default is used (LEVEL_WARN).
 * @method UuApp.Logging.Logger#setLevel
 */
Logger.prototype.setLevel = function (level) {
  if (level == null) level = Logger.LEVEL_WARN;
  var num = typeof level == "string" ? levels[level.toUpperCase()] : Number(level);
  if (typeof num != "number" || isNaN(num)) return; // ignore
  this.level = num;
};

/**
 * @return {number} Level of this logger.
 * @method UuApp.Logging.Logger#getLevel
 */
Logger.prototype.getLevel = function () {
  return this.level;
};

/**
 * @return {string} Upper-cased name of the level, such as "ERROR".
 * @method UuApp.Logging.Logger#getLevelName
 */
Logger.prototype.getLevelName = function () {
  return levelsInverted[this.level];
};
Logger.prototype.level = levels.WARN;

/**
 * Logs message with severity level "DEBUG".
 * 
 * @param {string} message The message to log.
 * @param {...Object} any Additional values to log with the message.
 * @method UuApp.Logging.Logger#debug
 */
Logger.prototype.debug = function () /* ... */{
  if (!this.ready) return logToBuffer.call(this, "debug", Array.prototype.slice.call(arguments));
  if (this.level <= levels.DEBUG) logToAppenders.call(this, { level: levels.DEBUG, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
};

/**
 * @return {boolean} Whether this logger logs message with severity level "DEBUG".
 * @method UuApp.Logging.Logger#isDebugLoggable
 */
Logger.prototype.isDebugLoggable = function () {
  return !this.ready || this.level <= levels.DEBUG;
};

/**
 * Logs message with severity level "INFO".
 * 
 * @param {string} message The message to log.
 * @param {...Object} any Additional values to log with the message.
 * @method UuApp.Logging.Logger#info
 */
Logger.prototype.info = function () /* ... */{
  if (!this.ready) return logToBuffer.call(this, "info", Array.prototype.slice.call(arguments));
  if (this.level <= levels.INFO) logToAppenders.call(this, { level: levels.INFO, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
};
/**
 * @return {boolean} Whether this logger logs message with severity level "INFO".
 * @method UuApp.Logging.Logger#isInfoLoggable
 */
Logger.prototype.isInfoLoggable = function () {
  return !this.ready || this.level <= levels.INFO;
};
/**
 * Logs message with severity level "WARN".
 * 
 * @param {string} message The message to log.
 * @param {...Object} any Additional values to log with the message.
 * @method UuApp.Logging.Logger#warn
 */
Logger.prototype.warn = function () /* ... */{
  if (!this.ready) return logToBuffer.call(this, "warn", Array.prototype.slice.call(arguments));
  if (this.level <= levels.WARN) logToAppenders.call(this, { level: levels.WARN, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
};
/**
 * @return {boolean} Whether this logger logs message with severity level "WARN".
 * @method UuApp.Logging.Logger#isWarnLoggable
 */
Logger.prototype.isWarnLoggable = function () {
  return !this.ready || this.level <= levels.WARN;
};
/**
 * Logs message with severity level "ERROR".
 * 
 * @param {string} message The message to log.
 * @param {...Object} any Additional values to log with the message.
 * @method UuApp.Logging.Logger#error
 */
Logger.prototype.error = function () /* ... */{
  if (!this.ready) return logToBuffer.call(this, "error", Array.prototype.slice.call(arguments));
  if (this.level <= levels.ERROR) logToAppenders.call(this, { level: levels.ERROR, message: arguments[0] != null ? arguments[0] + "" : "", args: Array.prototype.slice.call(arguments, 1) });
};
/**
 * @return {boolean} Whether this logger logs message with severity level "ERROR".
 * @method UuApp.Logging.Logger#isErrorLoggable
 */
Logger.prototype.isErrorLoggable = function () {
  return !this.ready || this.level <= levels.ERROR;
};

function logToAppenders(opts) {
  // TODO Add support for appenders. Currently we'll log only to the console.
  // TODO Might want to collect additional information (stack frames, ...) - https://github.com/stacktracejs/stacktrace.js
  // log to console
  var msg = this.name + ": " + opts.message;
  Logger.console[levelsInverted[opts.level].toLowerCase()].apply(Logger.console, [msg].concat(opts.args));
}
function logToBuffer(method, args) {
  this._buffer.push({ method: method, args: args });
}
function flushBuffer() {
  var _this2 = this;

  var v = this._buffer;
  this._buffer = [];
  v.forEach(function (it) {
    return _this2[it.method].apply(_this2, it.args);
  }); // re-run each method
}

// NOTE Logger-s append to Logger.console instead of directly console object
// so that this can be mocked in tests.
Logger.console = console;

// export
module.exports = Logger;