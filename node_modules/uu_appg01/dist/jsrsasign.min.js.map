{"version":3,"sources":["webpack:///uu_oidcg01@3.1.1/srcwebpack/universalModuleDefinition","webpack:///uu_oidcg01@3.1.1/srcjsrsasign.min.js","webpack:///uu_oidcg01@3.1.1/srcwebpack/bootstrap 632b44c7b952fd2e4442","webpack:///uu_oidcg01@3.1.1/src../.tmp/lib/jsrsasign.js","webpack:///uu_oidcg01@3.1.1/src../~/buffer/index.js","webpack:///uu_oidcg01@3.1.1/src../~/base64-js/index.js","webpack:///uu_oidcg01@3.1.1/src../~/ieee754/index.js","webpack:///uu_oidcg01@3.1.1/src../~/isarray/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Buffer","BigInteger","a","b","fromNumber","fromString","nbi","am1","i","x","w","j","n","v","Math","floor","am2","xl","xh","l","h","am3","int2char","BI_RM","charAt","intAt","s","BI_RC","charCodeAt","bnpCopyTo","r","t","bnpFromInt","DV","nbv","fromInt","bnpFromString","k","fromRadix","length","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toString","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","max","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","min","bnpMultiplyTo","abs","y","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","e","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","hex2b64","ret","parseInt","substring","b64map","b64pad","b64tohex","slop","indexOf","stoBA","Array","BAtohex","hex1","stohex","b64tob64u","replace","b64utob64","hextob64u","b64utohex","utf8tohex","uricmptohex","encodeURIComponentAll","hextorstr","sHex","String","fromCharCode","substr","rstrtohex","result","slice","hextouricmp","u8","encodeURIComponent","s2","parseBigInt","str","pkcs1pad2","alert","ba","rng","SecureRandom","nextBytes","oaep_mgf1_arr","seed","len","hash","mask","apply","concat","oaep_pad","hashLen","MD","KJUR","crypto","MessageDigest","Util","algName","getCanonicalAlgName","getHashLength","hashString","PS","dbMask","maskedDB","seedMask","maskedSeed","RSAKey","dmp1","dmq1","coeff","RSASetPublic","N","E","isPublic","RSADoPublic","modPowInt","RSAEncrypt","text","bitLength","doPublic","RSAEncryptOAEP","_zeroPaddingOfSignature","hex","nZero","_rsasign_signString","hashAlg","hashFunc","sHashHex","signWithMessageHash","_rsasign_signWithMessageHash","hPM","getPaddedDigestInfoHex","biPaddedMessage","biSign","doPrivate","hexSign","_rsasign_signStringWithSHA1","_rsasign_signStringWithSHA256","pss_mgf1_str","_rsasign_signStringPSS","sLen","hashHex","hHash","undefined","signWithMessageHashPSS","_rsasign_signWithMessageHashPSS","mHash","hLen","emBits","emLen","ceil","salt","H","push","_rsasign_getDecryptSignatureBI","biSig","hN","hE","rsa","setPublic","biDecryptedSig","_rsasign_getHexDigestInfoFromSig","hDigestInfo","_rsasign_getAlgNameAndHashFromHexDisgestInfo","DIGESTINFOHEAD","head","_rsasign_verifySignatureWithArgs","sMsg","digestInfoAry","diHashValue","ff","msgHashValue","_rsasign_verifyHexSignatureForMessage","hSig","_rsasign_verifyString","_RE_HEXDECONLY","_rsasign_verifyWithMessageHash","_rsasign_verifyStringPSS","verifyWithMessageHashPSS","_rsasign_verifyWithMessageHashPSS","em","toByteArray","unshift","checkLen","dbits","canary","j_lm","navigator","appName","prototype","BI_FP","pow","rr","vv","jsonParse","unescapeOne","_","ch","escapes","number","oneChar","string","jsonToken","RegExp","escapeSequence","\"","/","\\","f","EMPTY_STRING","SLASH","hop","{","Object","[","hasOwnProperty","json","opt_reviver","toks","match","tok","topLevelPrimitive","key","stack","cont","shift","Error","walk","holder","value","toDelete","","lang","utf8tob64u","b64utoutf8","decodeURIComponent","isInteger","isHex","isBase64","isBase64URL","isIntegerArray","jws","JWS","ns1","parseJWS","sJWS","sigValNotNeeded","parsedJWS","sigvalH","matchResult","b6Head","b6Payload","b6SigVal","sSI","headB64U","payloadB64U","sigvalB64U","si","hSigVal","biSigVal","sigvalBI","sHead","sPayload","headS","payloadS","isSafeJSONString","sign","alg","spHeader","spPayload","pass","sHeader","pHeader","JSON","stringify","readSafeJSONString","sigAlg","jwsalg2sigalg","uHeader","uPayload","uSignatureInput","mac","Mac","prov","updateString","doFinal","sig","Signature","init","hASN1Sig","ECDSA","asn1SigToConcatSig","uSig","verify","acceptAlgs","split","algType","acceptAlgStr","join","KEYUTIL","getKey","hSig2","concatSigToASN1Sig","ex","parse","headerObj","payloadObj","headerPP","payloadPP","sigHex","verifyJWT","sJWT","acceptField","pPayload","inArray","iss","sub","aud","includedArray","now","IntDate","getNow","verifyAt","gracePeriod","nbf","iat","jti","a1","a2","item","HS256","HS384","HS512","RS256","RS384","RS512","ES256","ES384","PS256","PS384","PS512","none","o","constructor","getEncodedSignatureValueFromJWS","getJWKthumbprint","kty","crv","hJWK","hashB64U","get","getZulu","sYear","year","month","day","hour","sec","Date","UTC","intDate2UTCString","intDate","toUTCString","intDate2Zulu","getUTCFullYear","mon","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","encrypt","encryptOAEP","type","CryptoJS","C","C_lib","lib","Base","F","extend","overrides","subtype","mixIn","$super","arguments","create","instance","properties","propertyName","clone","WordArray","words","sigBytes","encoder","Hex","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","thatByte","random","nBytes","C_enc","enc","hexChars","bite","hexStr","hexStrLength","Latin1","latin1Chars","latin1Str","latin1StrLength","Utf8","escape","utf8Str","unescape","BufferedBlockAlgorithm","reset","_data","_nDataBytes","_append","data","_process","doFlush","dataWords","dataSigBytes","blockSize","blockSizeBytes","nBlocksReady","_minBufferSize","nWordsReady","nBytesReady","offset","_doProcessBlock","processedWords","splice","C_algo","Hasher","cfg","_doReset","update","messageUpdate","finalize","_doFinalize","_createHelper","hasher","message","_createHmacHelper","HMAC","algo","K","isPrime","sqrtN","sqrt","factor","getFractionalBits","nPrime","W","SHA256","_hash","M","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","sigma1","t1","t2","nBitsTotal","nBitsLeft","HmacSHA256","decryptAES","dataHex","keyHex","ivHex","decryptGeneral","AES","decrypt3DES","TripleDES","decryptDES","DES","iv","encrypted","ciphertext","decrypted","decrypt","encryptAES","encryptGeneral","encrypt3DES","encryptDES","encryptedHex","encryptedWA","encryptedB64","Base64","ALGLIST","AES-256-CBC","proc","eproc","keylen","ivlen","AES-192-CBC","AES-128-CBC","DES-EDE3-CBC","DES-CBC","getFuncByName","_generateIvSaltHex","numBytes","wa","_parsePKCS5PEM","sPKCS5PEM","info","matchResult1","cipher","ivsalt","matchResult2","i1","lenNEWLINE","i2","_getKeyAndUnusedIvByPasscodeAndIvsalt","passcode","ivsaltHex","saltHex","nRequiredBytes","hHexValueJoined","hLastValue","MD5","keyhex","ivhex","_decryptKeyB64","privateKeyB64","sharedKeyAlgName","sharedKeyHex","privateKeyWA","privateKeyHex","decryptedKeyHex","_encryptKeyHex","encryptedKeyB64","version","getHexFromPEM","sPEM","sB64","getDecryptedKeyHexByKeyIV","encryptedKeyHex","f1","parsePKCS5PEM","getKeyAndUnusedIvByPasscodeAndIvsalt","decryptKeyB64","getDecryptedKeyHex","sEncryptedPEM","sharedKeyInfo","decryptedKey","getRSAKeyFromEncryptedPKCS5PEM","sEncryptedP5PEM","hPKey","rsaKey","readPrivateKeyFromASN1HexString","getEncryptedPKCS5PEMFromPrvKeyHex","pemHeadAlg","hPrvKey","randIV","toUpperCase","pemBody","getEncryptedPKCS5PEMFromRSAKey","pKey","asn1","DERInteger","int","bigint","seq","DERSequence","array","getEncodedHex","newEncryptedPKCS5PEM","keyLen","hPublicExponent","generate","pem","getRSAKeyFromPlainPKCS8PEM","pkcs8PEM","prvKeyHex","getRSAKeyFromPlainPKCS8Hex","ASN1HEX","getPosArrayOfChildren_AtObj","algIdTLV","getHexOfTLV_AtObj","octetStr","p5KeyHex","getHexOfV_AtObj","parseHexOfEncryptedPKCS8","sHEX","a0","a0_0","a0_0_1","a0_0_1_1","encryptionSchemeAlg","encryptionSchemeIV","a0_0_1_0","a0_0_1_0_1","pbkdf2Salt","iterNumHex","pbkdf2Iter","getPBKDF2KeyHexFromParam","pbkdf2SaltWS","pbkdf2KeyWS","PBKDF2","keySize","iterations","pbkdf2KeyHex","getPlainPKCS8HexFromEncryptedPKCS8PEM","derHex","des3IVWS","decWS","decHex","getRSAKeyFromEncryptedPKCS8PEM","getKeyFromEncryptedPKCS8PEM","getKeyFromPlainPrivatePKCS8Hex","parsePlainPrivatePKCS8Hex","pkcs8PrvHex","algparam","algoid","keyidx","getStartPosOfV_AtObj","getKeyFromPlainPrivatePKCS8PEM","prvKeyPEM","p8","parsePrivateRawRSAKeyHexAtObj","setPrivateEx","dp","dq","co","parsePrivateRawECKeyHexAtObj","OID","oidhex2name","curveName","curve","setPublicKeyHex","pubkey","setPrivateKeyHex","hP","getVbyList","hQ","hG","hX","biP","biQ","biG","biX","DSA","setPrivate","getRSAKeyFromPublicPKCS8PEM","pkcs8PubPEM","pubKeyHex","getRSAKeyFromPublicPKCS8Hex","getKeyFromPublicPKCS8PEM","getKeyFromPublicPKCS8Hex","pkcs8PubHex","parsePublicPKCS8Hex","aRSA","parsePublicRawRSAKeyHex","pub","param","pubRawRSAHex","keyIdx","idxAlgIdTLV","idxPub","pubKey","hextype","xy","prv","qi","ec","charlen","ecparams","hY","hPub","hPrv","X509","getPublicKeyFromCertPEM","hKey","curveNameOidHex","name","generateKeypair","keylenOrCurve","prvKey","isPrivate","prvKeyObj","pubKeyObj","keypairHex","generateKeyPairHex","ecpubhex","ecprvhex","getPEM","keyObjOrHex","formatType","passwd","encAlg","hexType","_rsaprv2asn1obj","asn1Obj","ASN1Util","newObject","_ecdsaprv2asn1obj","asn1Obj2","octstr","tag","oid","bitstr","_dsaprv2asn1obj","ns2","x509","SubjectPublicKeyInfo","asn1Hex","getPEMStringFromHex","asn1Obj1","DERObjectIdentifier","asn1Hex1","asn1Hex2","_getEncryptedPKCS8","plainKeyHex","_getEencryptedPKCS8Info","encryptionSchemeIVWS","plainKeyWS","keyObj","null","getKeyFromCSRPEM","csrPEM","csrHex","getKeyFromCSRHex","parseCSRHex","p8pubkeyhex","getJWKFromKey","jwk","getShortNISTPCurveName","getPublicKeyXYHex","sha1","sha224","sha256","sha384","sha512","md2","md5","ripemd160","DEFAULTPROVIDER","hmacmd5","hmacsha1","hmacsha224","hmacsha256","hmacsha384","hmacsha512","hmacripemd160","MD5withRSA","SHA1withRSA","SHA224withRSA","SHA256withRSA","SHA384withRSA","SHA512withRSA","RIPEMD160withRSA","MD5withECDSA","SHA1withECDSA","SHA224withECDSA","SHA256withECDSA","SHA384withECDSA","SHA512withECDSA","RIPEMD160withECDSA","SHA1withDSA","SHA224withDSA","SHA256withDSA","MD5withRSAandMGF1","SHA1withRSAandMGF1","SHA224withRSAandMGF1","SHA256withRSAandMGF1","SHA384withRSAandMGF1","SHA512withRSAandMGF1","RIPEMD160withRSAandMGF1","CRYPTOJSMESSAGEDIGESTNAME","SHA1","SHA224","SHA384","SHA512","RIPEMD160","getDigestInfoHex","pmStrLen","hHead","hTail","hMid","fLen","hPaddedMessage","md","digestString","digestHex","sha256Hex","sha512Hex","getCryptoJSMDByName","params","setAlgAndProvider","updateHex","wHex","digest","sjcl","baHex","codec","toBits","fromBits","provName","toLowerCase","alg2","HASHLENGTH","algProv","mdObj","doFinalString","doFinalHex","setPassword","hPass","utf8","rstr","b64","b64u","_setAlgNames","mdAlgName","pubkeyAlgName","keyparam","state","initSign","eccurvename","initVerifyByPublicKey","initVerifyByCertificatePEM","certPEM","readCertPEM","subjectPublicKeyRSA","hSign","signHex","pssSaltLen","signString","verifyHex","verifyWithMessageHash","algProvName","rsaPubKey","initParams","readPrivateKeyFromPEMString","Cipher","algName2","getAlgByKeyAndName","decryptOAEP","2a864886f70d010101","2a8648ce3d0201","2a8648ce380401","2a8648ce3d030107","2b8104001f","2b81040021","2b8104000a","2b81040023","2b81040022","2a8648ce380403","608648016503040301","608648016503040302","compile","signStringWithSHA1","signStringWithSHA256","signWithSHA1","signWithSHA256","signStringPSS","signPSS","SALT_LEN_HLEN","SALT_LEN_MAX","verifyString","verifyHexSignatureForMessage","verifyHexSignatureForByteArrayMessage","verifyStringPSS","verifyPSS","SALT_LEN_RECOVER","global","typedArraySupport","arr","Uint8Array","__proto__","foo","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","arg","encodingOrOffset","allocUnsafe","from","TypeError","ArrayBuffer","fromArrayBuffer","fromObject","assertSize","size","alloc","fill","encoding","checked","isEncoding","actual","write","fromArrayLike","byteOffset","obj","isBuffer","copy","buffer","isnan","isArray","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","val","dir","isNaN","arrayIndexOf","lastIndexOf","read","buf","indexSize","readUInt16BE","arrLength","valLength","foundIndex","found","hexWrite","Number","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","out","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","trim","units","Infinity","leadSurrogate","byteArray","hi","lo","src","dst","INSPECT_MAX_BYTES","poolSize","_augment","Symbol","species","defineProperty","configurable","allocUnsafeSlow","_isBuffer","compare","list","pos","swap16","swap32","swap64","equals","inspect","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","placeHoldersCount","tmp","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","extraBytes","parts","maxChunkLength","len2","isLE","mLen","eLen","eMax","eBias","nBits","NaN","rt","log","LN2"],"mappings":"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","file":"jsrsasign.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Jsrsasign\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Jsrsasign\"] = factory();\n\telse\n\t\troot[\"Jsrsasign\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Jsrsasign\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Jsrsasign\"] = factory();\n\telse\n\t\troot[\"Jsrsasign\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n\t */\n\t// Copyright (c) 2005  Tom Wu\n\t// All Rights Reserved.\n\t// See \"LICENSE\" for details.\n\t\n\t// Basic JavaScript BN library - subset useful for RSA encryption.\n\t\n\t// Bits per digit\n\tvar dbits;\n\t\n\t// JavaScript engine analysis\n\tvar canary = 0xdeadbeefcafe;\n\tvar j_lm = ((canary&0xffffff)==0xefcafe);\n\t\n\t// (public) Constructor\n\tfunction BigInteger(a,b,c) {\n\t  if(a != null)\n\t    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n\t    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n\t    else this.fromString(a,b);\n\t}\n\t\n\t// return new, unset BigInteger\n\tfunction nbi() { return new BigInteger(null); }\n\t\n\t// am: Compute w_j += (x*this_i), propagate carries,\n\t// c is initial carry, returns final carry.\n\t// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t// We need to select the fastest one that works in this environment.\n\t\n\t// am1: use a single mult and divide to get the high bits,\n\t// max digit bits should be 26 because\n\t// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\tfunction am1(i,x,w,j,c,n) {\n\t  while(--n >= 0) {\n\t    var v = x*this[i++]+w[j]+c;\n\t    c = Math.floor(v/0x4000000);\n\t    w[j++] = v&0x3ffffff;\n\t  }\n\t  return c;\n\t}\n\t// am2 avoids a big mult-and-extract completely.\n\t// Max digit bits should be <= 30 because we do bitwise ops\n\t// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\tfunction am2(i,x,w,j,c,n) {\n\t  var xl = x&0x7fff, xh = x>>15;\n\t  while(--n >= 0) {\n\t    var l = this[i]&0x7fff;\n\t    var h = this[i++]>>15;\n\t    var m = xh*l+h*xl;\n\t    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n\t    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n\t    w[j++] = l&0x3fffffff;\n\t  }\n\t  return c;\n\t}\n\t// Alternately, set max digit bits to 28 since some\n\t// browsers slow down when dealing with 32-bit numbers.\n\tfunction am3(i,x,w,j,c,n) {\n\t  var xl = x&0x3fff, xh = x>>14;\n\t  while(--n >= 0) {\n\t    var l = this[i]&0x3fff;\n\t    var h = this[i++]>>14;\n\t    var m = xh*l+h*xl;\n\t    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n\t    c = (l>>28)+(m>>14)+xh*h;\n\t    w[j++] = l&0xfffffff;\n\t  }\n\t  return c;\n\t}\n\tif(j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n\t  BigInteger.prototype.am = am2;\n\t  dbits = 30;\n\t}\n\telse if(j_lm && (navigator.appName != \"Netscape\")) {\n\t  BigInteger.prototype.am = am1;\n\t  dbits = 26;\n\t}\n\telse { // Mozilla/Netscape seems to prefer am3\n\t  BigInteger.prototype.am = am3;\n\t  dbits = 28;\n\t}\n\t\n\tBigInteger.prototype.DB = dbits;\n\tBigInteger.prototype.DM = ((1<<dbits)-1);\n\tBigInteger.prototype.DV = (1<<dbits);\n\t\n\tvar BI_FP = 52;\n\tBigInteger.prototype.FV = Math.pow(2,BI_FP);\n\tBigInteger.prototype.F1 = BI_FP-dbits;\n\tBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\t\n\t// Digit conversions\n\tvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\tvar BI_RC = new Array();\n\tvar rr,vv;\n\trr = \"0\".charCodeAt(0);\n\tfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\trr = \"a\".charCodeAt(0);\n\tfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\trr = \"A\".charCodeAt(0);\n\tfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\tfunction int2char(n) { return BI_RM.charAt(n); }\n\tfunction intAt(s,i) {\n\t  var c = BI_RC[s.charCodeAt(i)];\n\t  return (c==null)?-1:c;\n\t}\n\t\n\t// (protected) copy this to r\n\tfunction bnpCopyTo(r) {\n\t  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n\t  r.t = this.t;\n\t  r.s = this.s;\n\t}\n\t\n\t// (protected) set from integer value x, -DV <= x < DV\n\tfunction bnpFromInt(x) {\n\t  this.t = 1;\n\t  this.s = (x<0)?-1:0;\n\t  if(x > 0) this[0] = x;\n\t  else if(x < -1) this[0] = x+this.DV;\n\t  else this.t = 0;\n\t}\n\t\n\t// return bigint initialized to value\n\tfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\t\n\t// (protected) set from string and radix\n\tfunction bnpFromString(s,b) {\n\t  var k;\n\t  if(b == 16) k = 4;\n\t  else if(b == 8) k = 3;\n\t  else if(b == 256) k = 8; // byte array\n\t  else if(b == 2) k = 1;\n\t  else if(b == 32) k = 5;\n\t  else if(b == 4) k = 2;\n\t  else { this.fromRadix(s,b); return; }\n\t  this.t = 0;\n\t  this.s = 0;\n\t  var i = s.length, mi = false, sh = 0;\n\t  while(--i >= 0) {\n\t    var x = (k==8)?s[i]&0xff:intAt(s,i);\n\t    if(x < 0) {\n\t      if(s.charAt(i) == \"-\") mi = true;\n\t      continue;\n\t    }\n\t    mi = false;\n\t    if(sh == 0)\n\t      this[this.t++] = x;\n\t    else if(sh+k > this.DB) {\n\t      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n\t      this[this.t++] = (x>>(this.DB-sh));\n\t    }\n\t    else\n\t      this[this.t-1] |= x<<sh;\n\t    sh += k;\n\t    if(sh >= this.DB) sh -= this.DB;\n\t  }\n\t  if(k == 8 && (s[0]&0x80) != 0) {\n\t    this.s = -1;\n\t    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n\t  }\n\t  this.clamp();\n\t  if(mi) BigInteger.ZERO.subTo(this,this);\n\t}\n\t\n\t// (protected) clamp off excess high words\n\tfunction bnpClamp() {\n\t  var c = this.s&this.DM;\n\t  while(this.t > 0 && this[this.t-1] == c) --this.t;\n\t}\n\t\n\t// (public) return string representation in given radix\n\tfunction bnToString(b) {\n\t  if(this.s < 0) return \"-\"+this.negate().toString(b);\n\t  var k;\n\t  if(b == 16) k = 4;\n\t  else if(b == 8) k = 3;\n\t  else if(b == 2) k = 1;\n\t  else if(b == 32) k = 5;\n\t  else if(b == 4) k = 2;\n\t  else return this.toRadix(b);\n\t  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n\t  var p = this.DB-(i*this.DB)%k;\n\t  if(i-- > 0) {\n\t    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n\t    while(i >= 0) {\n\t      if(p < k) {\n\t        d = (this[i]&((1<<p)-1))<<(k-p);\n\t        d |= this[--i]>>(p+=this.DB-k);\n\t      }\n\t      else {\n\t        d = (this[i]>>(p-=k))&km;\n\t        if(p <= 0) { p += this.DB; --i; }\n\t      }\n\t      if(d > 0) m = true;\n\t      if(m) r += int2char(d);\n\t    }\n\t  }\n\t  return m?r:\"0\";\n\t}\n\t\n\t// (public) -this\n\tfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\t\n\t// (public) |this|\n\tfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\t\n\t// (public) return + if this > a, - if this < a, 0 if equal\n\tfunction bnCompareTo(a) {\n\t  var r = this.s-a.s;\n\t  if(r != 0) return r;\n\t  var i = this.t;\n\t  r = i-a.t;\n\t  if(r != 0) return (this.s<0)?-r:r;\n\t  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n\t  return 0;\n\t}\n\t\n\t// returns bit length of the integer x\n\tfunction nbits(x) {\n\t  var r = 1, t;\n\t  if((t=x>>>16) != 0) { x = t; r += 16; }\n\t  if((t=x>>8) != 0) { x = t; r += 8; }\n\t  if((t=x>>4) != 0) { x = t; r += 4; }\n\t  if((t=x>>2) != 0) { x = t; r += 2; }\n\t  if((t=x>>1) != 0) { x = t; r += 1; }\n\t  return r;\n\t}\n\t\n\t// (public) return the number of bits in \"this\"\n\tfunction bnBitLength() {\n\t  if(this.t <= 0) return 0;\n\t  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n\t}\n\t\n\t// (protected) r = this << n*DB\n\tfunction bnpDLShiftTo(n,r) {\n\t  var i;\n\t  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n\t  for(i = n-1; i >= 0; --i) r[i] = 0;\n\t  r.t = this.t+n;\n\t  r.s = this.s;\n\t}\n\t\n\t// (protected) r = this >> n*DB\n\tfunction bnpDRShiftTo(n,r) {\n\t  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n\t  r.t = Math.max(this.t-n,0);\n\t  r.s = this.s;\n\t}\n\t\n\t// (protected) r = this << n\n\tfunction bnpLShiftTo(n,r) {\n\t  var bs = n%this.DB;\n\t  var cbs = this.DB-bs;\n\t  var bm = (1<<cbs)-1;\n\t  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n\t  for(i = this.t-1; i >= 0; --i) {\n\t    r[i+ds+1] = (this[i]>>cbs)|c;\n\t    c = (this[i]&bm)<<bs;\n\t  }\n\t  for(i = ds-1; i >= 0; --i) r[i] = 0;\n\t  r[ds] = c;\n\t  r.t = this.t+ds+1;\n\t  r.s = this.s;\n\t  r.clamp();\n\t}\n\t\n\t// (protected) r = this >> n\n\tfunction bnpRShiftTo(n,r) {\n\t  r.s = this.s;\n\t  var ds = Math.floor(n/this.DB);\n\t  if(ds >= this.t) { r.t = 0; return; }\n\t  var bs = n%this.DB;\n\t  var cbs = this.DB-bs;\n\t  var bm = (1<<bs)-1;\n\t  r[0] = this[ds]>>bs;\n\t  for(var i = ds+1; i < this.t; ++i) {\n\t    r[i-ds-1] |= (this[i]&bm)<<cbs;\n\t    r[i-ds] = this[i]>>bs;\n\t  }\n\t  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n\t  r.t = this.t-ds;\n\t  r.clamp();\n\t}\n\t\n\t// (protected) r = this - a\n\tfunction bnpSubTo(a,r) {\n\t  var i = 0, c = 0, m = Math.min(a.t,this.t);\n\t  while(i < m) {\n\t    c += this[i]-a[i];\n\t    r[i++] = c&this.DM;\n\t    c >>= this.DB;\n\t  }\n\t  if(a.t < this.t) {\n\t    c -= a.s;\n\t    while(i < this.t) {\n\t      c += this[i];\n\t      r[i++] = c&this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    c += this.s;\n\t  }\n\t  else {\n\t    c += this.s;\n\t    while(i < a.t) {\n\t      c -= a[i];\n\t      r[i++] = c&this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    c -= a.s;\n\t  }\n\t  r.s = (c<0)?-1:0;\n\t  if(c < -1) r[i++] = this.DV+c;\n\t  else if(c > 0) r[i++] = c;\n\t  r.t = i;\n\t  r.clamp();\n\t}\n\t\n\t// (protected) r = this * a, r != this,a (HAC 14.12)\n\t// \"this\" should be the larger one if appropriate.\n\tfunction bnpMultiplyTo(a,r) {\n\t  var x = this.abs(), y = a.abs();\n\t  var i = x.t;\n\t  r.t = i+y.t;\n\t  while(--i >= 0) r[i] = 0;\n\t  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n\t  r.s = 0;\n\t  r.clamp();\n\t  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n\t}\n\t\n\t// (protected) r = this^2, r != this (HAC 14.16)\n\tfunction bnpSquareTo(r) {\n\t  var x = this.abs();\n\t  var i = r.t = 2*x.t;\n\t  while(--i >= 0) r[i] = 0;\n\t  for(i = 0; i < x.t-1; ++i) {\n\t    var c = x.am(i,x[i],r,2*i,0,1);\n\t    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n\t      r[i+x.t] -= x.DV;\n\t      r[i+x.t+1] = 1;\n\t    }\n\t  }\n\t  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n\t  r.s = 0;\n\t  r.clamp();\n\t}\n\t\n\t// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t// r != q, this != m.  q or r may be null.\n\tfunction bnpDivRemTo(m,q,r) {\n\t  var pm = m.abs();\n\t  if(pm.t <= 0) return;\n\t  var pt = this.abs();\n\t  if(pt.t < pm.t) {\n\t    if(q != null) q.fromInt(0);\n\t    if(r != null) this.copyTo(r);\n\t    return;\n\t  }\n\t  if(r == null) r = nbi();\n\t  var y = nbi(), ts = this.s, ms = m.s;\n\t  var nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n\t  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n\t  else { pm.copyTo(y); pt.copyTo(r); }\n\t  var ys = y.t;\n\t  var y0 = y[ys-1];\n\t  if(y0 == 0) return;\n\t  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n\t  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n\t  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n\t  y.dlShiftTo(j,t);\n\t  if(r.compareTo(t) >= 0) {\n\t    r[r.t++] = 1;\n\t    r.subTo(t,r);\n\t  }\n\t  BigInteger.ONE.dlShiftTo(ys,t);\n\t  t.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\n\t  while(y.t < ys) y[y.t++] = 0;\n\t  while(--j >= 0) {\n\t    // Estimate quotient digit\n\t    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n\t    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n\t      y.dlShiftTo(j,t);\n\t      r.subTo(t,r);\n\t      while(r[i] < --qd) r.subTo(t,r);\n\t    }\n\t  }\n\t  if(q != null) {\n\t    r.drShiftTo(ys,q);\n\t    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n\t  }\n\t  r.t = ys;\n\t  r.clamp();\n\t  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n\t  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n\t}\n\t\n\t// (public) this mod a\n\tfunction bnMod(a) {\n\t  var r = nbi();\n\t  this.abs().divRemTo(a,null,r);\n\t  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n\t  return r;\n\t}\n\t\n\t// Modular reduction using \"classic\" algorithm\n\tfunction Classic(m) { this.m = m; }\n\tfunction cConvert(x) {\n\t  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t  else return x;\n\t}\n\tfunction cRevert(x) { return x; }\n\tfunction cReduce(x) { x.divRemTo(this.m,null,x); }\n\tfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\tfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\t\n\tClassic.prototype.convert = cConvert;\n\tClassic.prototype.revert = cRevert;\n\tClassic.prototype.reduce = cReduce;\n\tClassic.prototype.mulTo = cMulTo;\n\tClassic.prototype.sqrTo = cSqrTo;\n\t\n\t// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t// justification:\n\t//         xy == 1 (mod m)\n\t//         xy =  1+km\n\t//   xy(2-xy) = (1+km)(1-km)\n\t// x[y(2-xy)] = 1-k^2m^2\n\t// x[y(2-xy)] == 1 (mod m^2)\n\t// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t// JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\tfunction bnpInvDigit() {\n\t  if(this.t < 1) return 0;\n\t  var x = this[0];\n\t  if((x&1) == 0) return 0;\n\t  var y = x&3;\t\t// y == 1/x mod 2^2\n\t  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n\t  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n\t  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n\t  // last step - calculate inverse mod DV directly;\n\t  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n\t  // we really want the negative inverse, and -DV < y < DV\n\t  return (y>0)?this.DV-y:-y;\n\t}\n\t\n\t// Montgomery reduction\n\tfunction Montgomery(m) {\n\t  this.m = m;\n\t  this.mp = m.invDigit();\n\t  this.mpl = this.mp&0x7fff;\n\t  this.mph = this.mp>>15;\n\t  this.um = (1<<(m.DB-15))-1;\n\t  this.mt2 = 2*m.t;\n\t}\n\t\n\t// xR mod m\n\tfunction montConvert(x) {\n\t  var r = nbi();\n\t  x.abs().dlShiftTo(this.m.t,r);\n\t  r.divRemTo(this.m,null,r);\n\t  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n\t  return r;\n\t}\n\t\n\t// x/R mod m\n\tfunction montRevert(x) {\n\t  var r = nbi();\n\t  x.copyTo(r);\n\t  this.reduce(r);\n\t  return r;\n\t}\n\t\n\t// x = x/R mod m (HAC 14.32)\n\tfunction montReduce(x) {\n\t  while(x.t <= this.mt2)\t// pad x so am has enough room later\n\t    x[x.t++] = 0;\n\t  for(var i = 0; i < this.m.t; ++i) {\n\t    // faster way of calculating u0 = x[i]*mp mod DV\n\t    var j = x[i]&0x7fff;\n\t    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n\t    // use am to combine the multiply-shift-add into one call\n\t    j = i+this.m.t;\n\t    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n\t    // propagate carry\n\t    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n\t  }\n\t  x.clamp();\n\t  x.drShiftTo(this.m.t,x);\n\t  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n\t}\n\t\n\t// r = \"x^2/R mod m\"; x != r\n\tfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\t\n\t// r = \"xy/R mod m\"; x,y != r\n\tfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\t\n\tMontgomery.prototype.convert = montConvert;\n\tMontgomery.prototype.revert = montRevert;\n\tMontgomery.prototype.reduce = montReduce;\n\tMontgomery.prototype.mulTo = montMulTo;\n\tMontgomery.prototype.sqrTo = montSqrTo;\n\t\n\t// (protected) true iff this is even\n\tfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\t\n\t// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\tfunction bnpExp(e,z) {\n\t  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n\t  g.copyTo(r);\n\t  while(--i >= 0) {\n\t    z.sqrTo(r,r2);\n\t    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n\t    else { var t = r; r = r2; r2 = t; }\n\t  }\n\t  return z.revert(r);\n\t}\n\t\n\t// (public) this^e % m, 0 <= e < 2^32\n\tfunction bnModPowInt(e,m) {\n\t  var z;\n\t  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n\t  return this.exp(e,z);\n\t}\n\t\n\t// protected\n\tBigInteger.prototype.copyTo = bnpCopyTo;\n\tBigInteger.prototype.fromInt = bnpFromInt;\n\tBigInteger.prototype.fromString = bnpFromString;\n\tBigInteger.prototype.clamp = bnpClamp;\n\tBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\tBigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\tBigInteger.prototype.lShiftTo = bnpLShiftTo;\n\tBigInteger.prototype.rShiftTo = bnpRShiftTo;\n\tBigInteger.prototype.subTo = bnpSubTo;\n\tBigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\tBigInteger.prototype.squareTo = bnpSquareTo;\n\tBigInteger.prototype.divRemTo = bnpDivRemTo;\n\tBigInteger.prototype.invDigit = bnpInvDigit;\n\tBigInteger.prototype.isEven = bnpIsEven;\n\tBigInteger.prototype.exp = bnpExp;\n\t\n\t// public\n\tBigInteger.prototype.toString = bnToString;\n\tBigInteger.prototype.negate = bnNegate;\n\tBigInteger.prototype.abs = bnAbs;\n\tBigInteger.prototype.compareTo = bnCompareTo;\n\tBigInteger.prototype.bitLength = bnBitLength;\n\tBigInteger.prototype.mod = bnMod;\n\tBigInteger.prototype.modPowInt = bnModPowInt;\n\t\n\t// \"constants\"\n\tBigInteger.ZERO = nbv(0);\n\tBigInteger.ONE = nbv(1);\n\t\n\t/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n\t */\n\tvar b64map=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tvar b64pad=\"=\";\n\t\n\tfunction hex2b64(h) {\n\t  var i;\n\t  var c;\n\t  var ret = \"\";\n\t  for(i = 0; i+3 <= h.length; i+=3) {\n\t    c = parseInt(h.substring(i,i+3),16);\n\t    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n\t  }\n\t  if(i+1 == h.length) {\n\t    c = parseInt(h.substring(i,i+1),16);\n\t    ret += b64map.charAt(c << 2);\n\t  }\n\t  else if(i+2 == h.length) {\n\t    c = parseInt(h.substring(i,i+2),16);\n\t    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n\t  }\n\t  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n\t  return ret;\n\t}\n\t\n\t// convert a base64 string to hex\n\tfunction b64tohex(s) {\n\t  var ret = \"\"\n\t  var i;\n\t  var k = 0; // b64 state, 0-3\n\t  var slop;\n\t  var v;\n\t  for(i = 0; i < s.length; ++i) {\n\t    if(s.charAt(i) == b64pad) break;\n\t    v = b64map.indexOf(s.charAt(i));\n\t    if(v < 0) continue;\n\t    if(k == 0) {\n\t      ret += int2char(v >> 2);\n\t      slop = v & 3;\n\t      k = 1;\n\t    }\n\t    else if(k == 1) {\n\t      ret += int2char((slop << 2) | (v >> 4));\n\t      slop = v & 0xf;\n\t      k = 2;\n\t    }\n\t    else if(k == 2) {\n\t      ret += int2char(slop);\n\t      ret += int2char(v >> 2);\n\t      slop = v & 3;\n\t      k = 3;\n\t    }\n\t    else {\n\t      ret += int2char((slop << 2) | (v >> 4));\n\t      ret += int2char(v & 0xf);\n\t      k = 0;\n\t    }\n\t  }\n\t  if(k == 1)\n\t    ret += int2char(slop << 2);\n\t  return ret;\n\t}\n\t\n\t// convert a base64 string to a byte/number array\n\tfunction b64toBA(s) {\n\t  //piggyback on b64tohex for now, optimize later\n\t  var h = b64tohex(s);\n\t  var i;\n\t  var a = new Array();\n\t  for(i = 0; 2*i < h.length; ++i) {\n\t    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n\t  }\n\t  return a;\n\t}\n\t\n\t/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval\n\t */\n\t// This source code is free for use in the public domain.\n\t// NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\t\n\t// http://code.google.com/p/json-sans-eval/\n\t\n\t/**\n\t * Parses a string of well-formed JSON text.\n\t *\n\t * If the input is not well-formed, then behavior is undefined, but it is\n\t * deterministic and is guaranteed not to modify any object other than its\n\t * return value.\n\t *\n\t * This does not use `eval` so is less likely to have obscure security bugs than\n\t * json2.js.\n\t * It is optimized for speed, so is much faster than json_parse.js.\n\t *\n\t * This library should be used whenever security is a concern (when JSON may\n\t * come from an untrusted source), speed is a concern, and erroring on malformed\n\t * JSON is *not* a concern.\n\t *\n\t *                      Pros                   Cons\n\t *                    +-----------------------+-----------------------+\n\t * json_sans_eval.js  | Fast, secure          | Not validating        |\n\t *                    +-----------------------+-----------------------+\n\t * json_parse.js      | Validating, secure    | Slow                  |\n\t *                    +-----------------------+-----------------------+\n\t * json2.js           | Fast, some validation | Potentially insecure  |\n\t *                    +-----------------------+-----------------------+\n\t *\n\t * json2.js is very fast, but potentially insecure since it calls `eval` to\n\t * parse JSON data, so an attacker might be able to supply strange JS that\n\t * looks like JSON, but that executes arbitrary javascript.\n\t * If you do have to use json2.js with untrusted data, make sure you keep\n\t * your version of json2.js up to date so that you get patches as they're\n\t * released.\n\t *\n\t * @param {string} json per RFC 4627\n\t * @param {function (this:Object, string, *):*} opt_reviver optional function\n\t *     that reworks JSON objects post-parse per Chapter 15.12 of EcmaScript3.1.\n\t *     If supplied, the function is called with a string key, and a value.\n\t *     The value is the property of 'this'.  The reviver should return\n\t *     the value to use in its place.  So if dates were serialized as\n\t *     {@code { \"type\": \"Date\", \"time\": 1234 }}, then a reviver might look like\n\t *     {@code\n\t *     function (key, value) {\n\t *       if (value && typeof value === 'object' && 'Date' === value.type) {\n\t *         return new Date(value.time);\n\t *       } else {\n\t *         return value;\n\t *       }\n\t *     }}.\n\t *     If the reviver returns {@code undefined} then the property named by key\n\t *     will be deleted from its container.\n\t *     {@code this} is bound to the object containing the specified property.\n\t * @return {Object|Array}\n\t * @author Mike Samuel <mikesamuel@gmail.com>\n\t */\n\tvar jsonParse = (function () {\n\t  var number\n\t      = '(?:-?\\\\b(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\\\b)';\n\t  var oneChar = '(?:[^\\\\0-\\\\x08\\\\x0a-\\\\x1f\\\"\\\\\\\\]'\n\t      + '|\\\\\\\\(?:[\\\"/\\\\\\\\bfnrt]|u[0-9A-Fa-f]{4}))';\n\t  var string = '(?:\\\"' + oneChar + '*\\\")';\n\t\n\t  // Will match a value in a well-formed JSON file.\n\t  // If the input is not well-formed, may match strangely, but not in an unsafe\n\t  // way.\n\t  // Since this only matches value tokens, it does not match whitespace, colons,\n\t  // or commas.\n\t  var jsonToken = new RegExp(\n\t      '(?:false|true|null|[\\\\{\\\\}\\\\[\\\\]]'\n\t      + '|' + number\n\t      + '|' + string\n\t      + ')', 'g');\n\t\n\t  // Matches escape sequences in a string literal\n\t  var escapeSequence = new RegExp('\\\\\\\\(?:([^u])|u(.{4}))', 'g');\n\t\n\t  // Decodes escape sequences in object literals\n\t  var escapes = {\n\t    '\"': '\"',\n\t    '/': '/',\n\t    '\\\\': '\\\\',\n\t    'b': '\\b',\n\t    'f': '\\f',\n\t    'n': '\\n',\n\t    'r': '\\r',\n\t    't': '\\t'\n\t  };\n\t  function unescapeOne(_, ch, hex) {\n\t    return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));\n\t  }\n\t\n\t  // A non-falsy value that coerces to the empty string when used as a key.\n\t  var EMPTY_STRING = new String('');\n\t  var SLASH = '\\\\';\n\t\n\t  // Constructor to use based on an open token.\n\t  var firstTokenCtors = { '{': Object, '[': Array };\n\t\n\t  var hop = Object.hasOwnProperty;\n\t\n\t  return function (json, opt_reviver) {\n\t    // Split into tokens\n\t    var toks = json.match(jsonToken);\n\t    // Construct the object to return\n\t    var result;\n\t    var tok = toks[0];\n\t    var topLevelPrimitive = false;\n\t    if ('{' === tok) {\n\t      result = {};\n\t    } else if ('[' === tok) {\n\t      result = [];\n\t    } else {\n\t      // The RFC only allows arrays or objects at the top level, but the JSON.parse\n\t      // defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null\n\t      // at the top level.\n\t      result = [];\n\t      topLevelPrimitive = true;\n\t    }\n\t\n\t    // If undefined, the key in an object key/value record to use for the next\n\t    // value parsed.\n\t    var key;\n\t    // Loop over remaining tokens maintaining a stack of uncompleted objects and\n\t    // arrays.\n\t    var stack = [result];\n\t    for (var i = 1 - topLevelPrimitive, n = toks.length; i < n; ++i) {\n\t      tok = toks[i];\n\t\n\t      var cont;\n\t      switch (tok.charCodeAt(0)) {\n\t        default:  // sign or digit\n\t          cont = stack[0];\n\t          cont[key || cont.length] = +(tok);\n\t          key = void 0;\n\t          break;\n\t        case 0x22:  // '\"'\n\t          tok = tok.substring(1, tok.length - 1);\n\t          if (tok.indexOf(SLASH) !== -1) {\n\t            tok = tok.replace(escapeSequence, unescapeOne);\n\t          }\n\t          cont = stack[0];\n\t          if (!key) {\n\t            if (cont instanceof Array) {\n\t              key = cont.length;\n\t            } else {\n\t              key = tok || EMPTY_STRING;  // Use as key for next value seen.\n\t              break;\n\t            }\n\t          }\n\t          cont[key] = tok;\n\t          key = void 0;\n\t          break;\n\t        case 0x5b:  // '['\n\t          cont = stack[0];\n\t          stack.unshift(cont[key || cont.length] = []);\n\t          key = void 0;\n\t          break;\n\t        case 0x5d:  // ']'\n\t          stack.shift();\n\t          break;\n\t        case 0x66:  // 'f'\n\t          cont = stack[0];\n\t          cont[key || cont.length] = false;\n\t          key = void 0;\n\t          break;\n\t        case 0x6e:  // 'n'\n\t          cont = stack[0];\n\t          cont[key || cont.length] = null;\n\t          key = void 0;\n\t          break;\n\t        case 0x74:  // 't'\n\t          cont = stack[0];\n\t          cont[key || cont.length] = true;\n\t          key = void 0;\n\t          break;\n\t        case 0x7b:  // '{'\n\t          cont = stack[0];\n\t          stack.unshift(cont[key || cont.length] = {});\n\t          key = void 0;\n\t          break;\n\t        case 0x7d:  // '}'\n\t          stack.shift();\n\t          break;\n\t      }\n\t    }\n\t    // Fail if we've got an uncompleted object.\n\t    if (topLevelPrimitive) {\n\t      if (stack.length !== 1) { throw new Error(); }\n\t      result = result[0];\n\t    } else {\n\t      if (stack.length) { throw new Error(); }\n\t    }\n\t\n\t    if (opt_reviver) {\n\t      // Based on walk as implemented in http://www.json.org/json2.js\n\t      var walk = function (holder, key) {\n\t        var value = holder[key];\n\t        if (value && typeof value === 'object') {\n\t          var toDelete = null;\n\t          for (var k in value) {\n\t            if (hop.call(value, k) && value !== holder) {\n\t              // Recurse to properties first.  This has the effect of causing\n\t              // the reviver to be called on the object graph depth-first.\n\t\n\t              // Since 'this' is bound to the holder of the property, the\n\t              // reviver can access sibling properties of k including ones\n\t              // that have not yet been revived.\n\t\n\t              // The value returned by the reviver is used in place of the\n\t              // current value of property k.\n\t              // If it returns undefined then the property is deleted.\n\t              var v = walk(value, k);\n\t              if (v !== void 0) {\n\t                value[k] = v;\n\t              } else {\n\t                // Deleting properties inside the loop has vaguely defined\n\t                // semantics in ES3 and ES3.1.\n\t                if (!toDelete) { toDelete = []; }\n\t                toDelete.push(k);\n\t              }\n\t            }\n\t          }\n\t          if (toDelete) {\n\t            for (var i = toDelete.length; --i >= 0;) {\n\t              delete value[toDelete[i]];\n\t            }\n\t          }\n\t        }\n\t        return opt_reviver.call(holder, key, value);\n\t      };\n\t      result = walk({ '': result }, '');\n\t    }\n\t\n\t    return result;\n\t  };\n\t})();\n\t\n\t/*! base64x-1.1.8 (c) 2012-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n\t */\n\t/*\n\t * base64x.js - Base64url and supplementary functions for Tom Wu's base64.js library\n\t *\n\t * version: 1.1.8 (2016-Oct-16)\n\t *\n\t * Copyright (c) 2012-2016 Kenji Urushima (kenji.urushima@gmail.com)\n\t *\n\t * This software is licensed under the terms of the MIT License.\n\t * http://kjur.github.com/jsjws/license/\n\t *\n\t * The above copyright and license notice shall be \n\t * included in all copies or substantial portions of the Software.\n\t *\n\t * DEPENDS ON:\n\t *   - base64.js - Tom Wu's Base64 library\n\t */\n\t\n\t/**\n\t * @fileOverview\n\t * @name base64x-1.1.js\n\t * @author Kenji Urushima kenji.urushima@gmail.com\n\t * @version asn1 1.1.8 (2016-Oct-16)\n\t * @since jsrsasign 2.1\n\t * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n\t */\n\t\n\tvar KJUR;\n\tif (typeof KJUR == \"undefined\" || !KJUR) KJUR = {};\n\tif (typeof KJUR.lang == \"undefined\" || !KJUR.lang) KJUR.lang = {};\n\t\n\t/**\n\t * String and its utility class <br/>\n\t * This class provides some static utility methods for string.\n\t * @class String and its utility class\n\t * @author Kenji Urushima\n\t * @version 1.0 (2016-Aug-05)\n\t * @since base64x 1.1.7 jsrsasign 5.0.13\n\t * @description\n\t * <br/>\n\t * This class provides static methods for string utility.\n\t * <dl>\n\t * <dt><b>STRING TYPE CHECKERS</b>\n\t * <dd>\n\t * <ul>\n\t * <li>{@link KJUR.lang.String.isInteger} - check whether argument is an integer</li>\n\t * <li>{@link KJUR.lang.String.isHex} - check whether argument is a hexadecimal string</li>\n\t * <li>{@link KJUR.lang.String.isBase64} - check whether argument is a Base64 encoded string</li>\n\t * <li>{@link KJUR.lang.String.isBase64URL} - check whether argument is a Base64URL encoded string</li>\n\t * <li>{@link KJUR.lang.String.isIntegerArray} - check whether argument is an array of integers</li>\n\t * </ul>\n\t * </dl>\n\t */\n\tKJUR.lang.String = function() {};\n\t\n\t/**\n\t * Base64URL and supplementary functions for Tom Wu's base64.js library.<br/>\n\t * This class is just provide information about global functions\n\t * defined in 'base64x.js'. The 'base64x.js' script file provides\n\t * global functions for converting following data each other.\n\t * <ul>\n\t * <li>(ASCII) String</li>\n\t * <li>UTF8 String including CJK, Latin and other characters</li>\n\t * <li>byte array</li>\n\t * <li>hexadecimal encoded String</li>\n\t * <li>Full URIComponent encoded String (such like \"%69%94\")</li>\n\t * <li>Base64 encoded String</li>\n\t * <li>Base64URL encoded String</li>\n\t * </ul>\n\t * All functions in 'base64x.js' are defined in {@link _global_} and not\n\t * in this class.\n\t * \n\t * @class Base64URL and supplementary functions for Tom Wu's base64.js library\n\t * @author Kenji Urushima\n\t * @version 1.1 (07 May 2012)\n\t * @requires base64.js\n\t * @see <a href=\"http://kjur.github.com/jsjws/\">'jwjws'(JWS JavaScript Library) home page http://kjur.github.com/jsjws/</a>\n\t * @see <a href=\"http://kjur.github.com/jsrsasigns/\">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n\t */\n\tfunction Base64x() {\n\t}\n\t\n\t// ==== string / byte array ================================\n\t/**\n\t * convert a string to an array of character codes\n\t * @param {String} s\n\t * @return {Array of Numbers} \n\t */\n\tfunction stoBA(s) {\n\t    var a = new Array();\n\t    for (var i = 0; i < s.length; i++) {\n\t\ta[i] = s.charCodeAt(i);\n\t    }\n\t    return a;\n\t}\n\t\n\t/**\n\t * convert an array of character codes to a string\n\t * @param {Array of Numbers} a array of character codes\n\t * @return {String} s\n\t */\n\tfunction BAtos(a) {\n\t    var s = \"\";\n\t    for (var i = 0; i < a.length; i++) {\n\t\ts = s + String.fromCharCode(a[i]);\n\t    }\n\t    return s;\n\t}\n\t\n\t// ==== byte array / hex ================================\n\t/**\n\t * convert an array of bytes(Number) to hexadecimal string.<br/>\n\t * @param {Array of Numbers} a array of bytes\n\t * @return {String} hexadecimal string\n\t */\n\tfunction BAtohex(a) {\n\t    var s = \"\";\n\t    for (var i = 0; i < a.length; i++) {\n\t\tvar hex1 = a[i].toString(16);\n\t\tif (hex1.length == 1) hex1 = \"0\" + hex1;\n\t\ts = s + hex1;\n\t    }\n\t    return s;\n\t}\n\t\n\t// ==== string / hex ================================\n\t/**\n\t * convert a ASCII string to a hexadecimal string of ASCII codes.<br/>\n\t * NOTE: This can't be used for non ASCII characters.\n\t * @param {s} s ASCII string\n\t * @return {String} hexadecimal string\n\t */\n\tfunction stohex(s) {\n\t    return BAtohex(stoBA(s));\n\t}\n\t\n\t// ==== string / base64 ================================\n\t/**\n\t * convert a ASCII string to a Base64 encoded string.<br/>\n\t * NOTE: This can't be used for non ASCII characters.\n\t * @param {s} s ASCII string\n\t * @return {String} Base64 encoded string\n\t */\n\tfunction stob64(s) {\n\t    return hex2b64(stohex(s));\n\t}\n\t\n\t// ==== string / base64url ================================\n\t/**\n\t * convert a ASCII string to a Base64URL encoded string.<br/>\n\t * NOTE: This can't be used for non ASCII characters.\n\t * @param {s} s ASCII string\n\t * @return {String} Base64URL encoded string\n\t */\n\tfunction stob64u(s) {\n\t    return b64tob64u(hex2b64(stohex(s)));\n\t}\n\t\n\t/**\n\t * convert a Base64URL encoded string to a ASCII string.<br/>\n\t * NOTE: This can't be used for Base64URL encoded non ASCII characters.\n\t * @param {s} s Base64URL encoded string\n\t * @return {String} ASCII string\n\t */\n\tfunction b64utos(s) {\n\t    return BAtos(b64toBA(b64utob64(s)));\n\t}\n\t\n\t// ==== base64 / base64url ================================\n\t/**\n\t * convert a Base64 encoded string to a Base64URL encoded string.<br/>\n\t * @param {String} s Base64 encoded string\n\t * @return {String} Base64URL encoded string\n\t * @example\n\t * b64tob64u(\"ab+c3f/==\") &rarr; \"ab-c3f_\"\n\t */\n\tfunction b64tob64u(s) {\n\t    s = s.replace(/\\=/g, \"\");\n\t    s = s.replace(/\\+/g, \"-\");\n\t    s = s.replace(/\\//g, \"_\");\n\t    return s;\n\t}\n\t\n\t/**\n\t * convert a Base64URL encoded string to a Base64 encoded string.<br/>\n\t * @param {String} s Base64URL encoded string\n\t * @return {String} Base64 encoded string\n\t * @example\n\t * b64utob64(\"ab-c3f_\") &rarr; \"ab+c3f/==\"\n\t */\n\tfunction b64utob64(s) {\n\t    if (s.length % 4 == 2) s = s + \"==\";\n\t    else if (s.length % 4 == 3) s = s + \"=\";\n\t    s = s.replace(/-/g, \"+\");\n\t    s = s.replace(/_/g, \"/\");\n\t    return s;\n\t}\n\t\n\t// ==== hex / base64url ================================\n\t/**\n\t * convert a hexadecimal string to a Base64URL encoded string.<br/>\n\t * @param {String} s hexadecimal string\n\t * @return {String} Base64URL encoded string\n\t * @description\n\t * convert a hexadecimal string to a Base64URL encoded string.\n\t * NOTE: If leading \"0\" is omitted and odd number length for\n\t * hexadecimal leading \"0\" is automatically added.\n\t */\n\tfunction hextob64u(s) {\n\t    if (s.length % 2 == 1) s = \"0\" + s;\n\t    return b64tob64u(hex2b64(s));\n\t}\n\t\n\t/**\n\t * convert a Base64URL encoded string to a hexadecimal string.<br/>\n\t * @param {String} s Base64URL encoded string\n\t * @return {String} hexadecimal string\n\t */\n\tfunction b64utohex(s) {\n\t    return b64tohex(b64utob64(s));\n\t}\n\t\n\t// ==== utf8 / base64url ================================\n\t\n\t/**\n\t * convert a UTF-8 encoded string including CJK or Latin to a Base64URL encoded string.<br/>\n\t * @param {String} s UTF-8 encoded string\n\t * @return {String} Base64URL encoded string\n\t * @since 1.1\n\t */\n\t\n\t/**\n\t * convert a Base64URL encoded string to a UTF-8 encoded string including CJK or Latin.<br/>\n\t * @param {String} s Base64URL encoded string\n\t * @return {String} UTF-8 encoded string\n\t * @since 1.1\n\t */\n\t\n\tvar utf8tob64u, b64utoutf8;\n\t\n\tif (typeof Buffer === 'function') {\n\t  utf8tob64u = function (s) {\n\t    return b64tob64u(new Buffer(s, 'utf8').toString('base64'));\n\t  };\n\t\n\t  b64utoutf8 = function (s) {\n\t    return new Buffer(b64utob64(s), 'base64').toString('utf8');\n\t  };\n\t} else {\n\t  utf8tob64u = function (s) {\n\t    return hextob64u(uricmptohex(encodeURIComponentAll(s)));\n\t  };\n\t\n\t  b64utoutf8 = function (s) {\n\t    return decodeURIComponent(hextouricmp(b64utohex(s)));\n\t  };\n\t}\n\t\n\t// ==== utf8 / base64url ================================\n\t/**\n\t * convert a UTF-8 encoded string including CJK or Latin to a Base64 encoded string.<br/>\n\t * @param {String} s UTF-8 encoded string\n\t * @return {String} Base64 encoded string\n\t * @since 1.1.1\n\t */\n\tfunction utf8tob64(s) {\n\t  return hex2b64(uricmptohex(encodeURIComponentAll(s)));\n\t}\n\t\n\t/**\n\t * convert a Base64 encoded string to a UTF-8 encoded string including CJK or Latin.<br/>\n\t * @param {String} s Base64 encoded string\n\t * @return {String} UTF-8 encoded string\n\t * @since 1.1.1\n\t */\n\tfunction b64toutf8(s) {\n\t  return decodeURIComponent(hextouricmp(b64tohex(s)));\n\t}\n\t\n\t// ==== utf8 / hex ================================\n\t/**\n\t * convert a UTF-8 encoded string including CJK or Latin to a hexadecimal encoded string.<br/>\n\t * @param {String} s UTF-8 encoded string\n\t * @return {String} hexadecimal encoded string\n\t * @since 1.1.1\n\t */\n\tfunction utf8tohex(s) {\n\t  return uricmptohex(encodeURIComponentAll(s));\n\t}\n\t\n\t/**\n\t * convert a hexadecimal encoded string to a UTF-8 encoded string including CJK or Latin.<br/>\n\t * Note that when input is improper hexadecimal string as UTF-8 string, this function returns\n\t * 'null'.\n\t * @param {String} s hexadecimal encoded string\n\t * @return {String} UTF-8 encoded string or null\n\t * @since 1.1.1\n\t */\n\tfunction hextoutf8(s) {\n\t  return decodeURIComponent(hextouricmp(s));\n\t}\n\t\n\t/**\n\t * convert a hexadecimal encoded string to raw string including non printable characters.<br/>\n\t * @param {String} s hexadecimal encoded string\n\t * @return {String} raw string\n\t * @since 1.1.2\n\t * @example\n\t * hextorstr(\"610061\") &rarr; \"a\\x00a\"\n\t */\n\tfunction hextorstr(sHex) {\n\t    var s = \"\";\n\t    for (var i = 0; i < sHex.length - 1; i += 2) {\n\t        s += String.fromCharCode(parseInt(sHex.substr(i, 2), 16));\n\t    }\n\t    return s;\n\t}\n\t\n\t/**\n\t * convert a raw string including non printable characters to hexadecimal encoded string.<br/>\n\t * @param {String} s raw string\n\t * @return {String} hexadecimal encoded string\n\t * @since 1.1.2\n\t * @example\n\t * rstrtohex(\"a\\x00a\") &rarr; \"610061\"\n\t */\n\tfunction rstrtohex(s) {\n\t    var result = \"\";\n\t    for (var i = 0; i < s.length; i++) {\n\t        result += (\"0\" + s.charCodeAt(i).toString(16)).slice(-2);\n\t    }\n\t    return result;\n\t}\n\t\n\t// ==== hex / b64nl =======================================\n\t\n\t/**\n\t * convert a hexadecimal string to Base64 encoded string<br/>\n\t * @param {String} s hexadecimal string\n\t * @return {String} resulted Base64 encoded string\n\t * @since base64x 1.1.3\n\t * @description\n\t * This function converts from a hexadecimal string to Base64 encoded\n\t * string without new lines.\n\t * @example\n\t * hextob64(\"616161\") &rarr; \"YWFh\"\n\t */\n\tfunction hextob64(s) {\n\t    return hex2b64(s);\n\t}\n\t\n\t/**\n\t * convert a hexadecimal string to Base64 encoded string with new lines<br/>\n\t * @param {String} s hexadecimal string\n\t * @return {String} resulted Base64 encoded string with new lines\n\t * @since base64x 1.1.3\n\t * @description\n\t * This function converts from a hexadecimal string to Base64 encoded\n\t * string with new lines for each 64 characters. This is useful for\n\t * PEM encoded file.\n\t * @example\n\t * hextob64nl(\"123456789012345678901234567890123456789012345678901234567890\")\n\t * &rarr;\n\t * MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4 // new line\n\t * OTAxMjM0NTY3ODkwCg==\n\t */\n\tfunction hextob64nl(s) {\n\t    var b64 = hextob64(s);\n\t    var b64nl = b64.replace(/(.{64})/g, \"$1\\r\\n\");\n\t    b64nl = b64nl.replace(/\\r\\n$/, '');\n\t    return b64nl;\n\t}\n\t\n\t/**\n\t * convert a Base64 encoded string with new lines to a hexadecimal string<br/>\n\t * @param {String} s Base64 encoded string with new lines\n\t * @return {String} hexadecimal string\n\t * @since base64x 1.1.3\n\t * @description\n\t * This function converts from a Base64 encoded\n\t * string with new lines to a hexadecimal string.\n\t * This is useful to handle PEM encoded file.\n\t * This function removes any non-Base64 characters (i.e. not 0-9,A-Z,a-z,\\,+,=)\n\t * including new line.\n\t * @example\n\t * hextob64nl(\n\t * \"MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4\\r\\n\" +\n\t * \"OTAxMjM0NTY3ODkwCg==\\r\\n\")\n\t * &rarr;\n\t * \"123456789012345678901234567890123456789012345678901234567890\"\n\t */\n\tfunction b64nltohex(s) {\n\t    var b64 = s.replace(/[^0-9A-Za-z\\/+=]*/g, '');\n\t    var hex = b64tohex(b64);\n\t    return hex;\n\t} \n\t\n\t// ==== hex / ArrayBuffer =================================\n\t\n\t/**\n\t * convert a ArrayBuffer to a hexadecimal string<br/>\n\t * @param {String} hex hexadecimal string\n\t * @return {ArrayBuffer} ArrayBuffer\n\t * @since jsrsasign 6.1.4 base64x 1.1.8\n\t * @description\n\t * This function converts from a ArrayBuffer to a hexadecimal string.\n\t * @example\n\t * var buffer = new ArrayBuffer(3);\n\t * var view = new DataView(buffer);\n\t * view.setUint8(0, 0xfa);\n\t * view.setUint8(1, 0xfb);\n\t * view.setUint8(2, 0x01);\n\t * ArrayBuffertohex(buffer) &rarr; \"fafb01\"\n\t */\n\tfunction hextoArrayBuffer(hex) {\n\t    if (hex.length % 2 != 0) throw \"input is not even length\";\n\t    if (hex.match(/^[0-9A-Fa-f]+$/) == null) throw \"input is not hexadecimal\";\n\t\n\t    var buffer = new ArrayBuffer(hex.length / 2);\n\t    var view = new DataView(buffer);\n\t\n\t    for (var i = 0; i < hex.length / 2; i++) {\n\t\tview.setUint8(i, parseInt(hex.substr(i * 2, 2), 16));\n\t    }\n\t\n\t    return buffer;\n\t}\n\t\n\t// ==== ArrayBuffer / hex =================================\n\t\n\t/**\n\t * convert a ArrayBuffer to a hexadecimal string<br/>\n\t * @param {ArrayBuffer} buffer ArrayBuffer\n\t * @return {String} hexadecimal string\n\t * @since jsrsasign 6.1.4 base64x 1.1.8\n\t * @description\n\t * This function converts from a ArrayBuffer to a hexadecimal string.\n\t * @example\n\t * hextoArrayBuffer(\"fffa01\") &rarr; ArrayBuffer of [255, 250, 1]\n\t */\n\tfunction ArrayBuffertohex(buffer) {\n\t    var hex = \"\";\n\t    var view = new DataView(buffer);\n\t\n\t    for (var i = 0; i < buffer.byteLength; i++) {\n\t\thex += (\"00\" + view.getUint8(i).toString(16)).slice(-2);\n\t    }\n\t\n\t    return hex;\n\t}\n\t\n\t// ==== URIComponent / hex ================================\n\t/**\n\t * convert a URLComponent string such like \"%67%68\" to a hexadecimal string.<br/>\n\t * @param {String} s URIComponent string such like \"%67%68\"\n\t * @return {String} hexadecimal string\n\t * @since 1.1\n\t */\n\tfunction uricmptohex(s) {\n\t  return s.replace(/%/g, \"\");\n\t}\n\t\n\t/**\n\t * convert a hexadecimal string to a URLComponent string such like \"%67%68\".<br/>\n\t * @param {String} s hexadecimal string\n\t * @return {String} URIComponent string such like \"%67%68\"\n\t * @since 1.1\n\t */\n\tfunction hextouricmp(s) {\n\t  return s.replace(/(..)/g, \"%$1\");\n\t}\n\t\n\t// ==== URIComponent ================================\n\t/**\n\t * convert UTFa hexadecimal string to a URLComponent string such like \"%67%68\".<br/>\n\t * Note that these \"<code>0-9A-Za-z!'()*-._~</code>\" characters will not\n\t * converted to \"%xx\" format by builtin 'encodeURIComponent()' function.\n\t * However this 'encodeURIComponentAll()' function will convert \n\t * all of characters into \"%xx\" format.\n\t * @param {String} s hexadecimal string\n\t * @return {String} URIComponent string such like \"%67%68\"\n\t * @since 1.1\n\t */\n\tfunction encodeURIComponentAll(u8) {\n\t  var s = encodeURIComponent(u8);\n\t  var s2 = \"\";\n\t  for (var i = 0; i < s.length; i++) {\n\t    if (s[i] == \"%\") {\n\t      s2 = s2 + s.substr(i, 3);\n\t      i = i + 2;\n\t    } else {\n\t      s2 = s2 + \"%\" + stohex(s[i]);\n\t    }\n\t  }\n\t  return s2;\n\t}\n\t\n\t// ==== new lines ================================\n\t/**\n\t * convert all DOS new line(\"\\r\\n\") to UNIX new line(\"\\n\") in \n\t * a String \"s\".\n\t * @param {String} s string \n\t * @return {String} converted string\n\t */\n\tfunction newline_toUnix(s) {\n\t    s = s.replace(/\\r\\n/mg, \"\\n\");\n\t    return s;\n\t}\n\t\n\t/**\n\t * convert all UNIX new line(\"\\r\\n\") to DOS new line(\"\\n\") in \n\t * a String \"s\".\n\t * @param {String} s string \n\t * @return {String} converted string\n\t */\n\tfunction newline_toDos(s) {\n\t    s = s.replace(/\\r\\n/mg, \"\\n\");\n\t    s = s.replace(/\\n/mg, \"\\r\\n\");\n\t    return s;\n\t}\n\t\n\t// ==== string type checker ===================\n\t\n\t/**\n\t * check whether a string is an integer string or not<br/>\n\t * @name isInteger\n\t * @memberOf KJUR.lang.String\n\t * @function\n\t * @static\n\t * @param {String} s input string\n\t * @return {Boolean} true if a string \"s\" is an integer string otherwise false\n\t * @since base64x 1.1.7 jsrsasign 5.0.13\n\t * @example\n\t * KJUR.lang.String.isInteger(\"12345\") &rarr; true\n\t * KJUR.lang.String.isInteger(\"123ab\") &rarr; false\n\t */\n\tKJUR.lang.String.isInteger = function(s) {\n\t    if (s.match(/^[0-9]+$/)) {\n\t\treturn true;\n\t    } else if (s.match(/^-[0-9]+$/)) {\n\t\treturn true;\n\t    } else {\n\t\treturn false;\n\t    }\n\t};\n\t\n\t/**\n\t * check whether a string is an hexadecimal string or not<br/>\n\t * @name isHex\n\t * @memberOf KJUR.lang.String\n\t * @function\n\t * @static\n\t * @param {String} s input string\n\t * @return {Boolean} true if a string \"s\" is an hexadecimal string otherwise false\n\t * @since base64x 1.1.7 jsrsasign 5.0.13\n\t * @example\n\t * KJUR.lang.String.isHex(\"1234\") &rarr; true\n\t * KJUR.lang.String.isHex(\"12ab\") &rarr; true\n\t * KJUR.lang.String.isHex(\"12AB\") &rarr; true\n\t * KJUR.lang.String.isHex(\"12ZY\") &rarr; false\n\t * KJUR.lang.String.isHex(\"121\") &rarr; false -- odd length\n\t */\n\tKJUR.lang.String.isHex = function(s) {\n\t    if (s.length % 2 == 0 &&\n\t\t(s.match(/^[0-9a-f]+$/) || s.match(/^[0-9A-F]+$/))) {\n\t\treturn true;\n\t    } else {\n\t\treturn false;\n\t    }\n\t};\n\t\n\t/**\n\t * check whether a string is a base64 encoded string or not<br/>\n\t * Input string can conclude new lines or space characters.\n\t * @name isBase64\n\t * @memberOf KJUR.lang.String\n\t * @function\n\t * @static\n\t * @param {String} s input string\n\t * @return {Boolean} true if a string \"s\" is a base64 encoded string otherwise false\n\t * @since base64x 1.1.7 jsrsasign 5.0.13\n\t * @example\n\t * KJUR.lang.String.isBase64(\"YWE=\") &rarr; true\n\t * KJUR.lang.String.isBase64(\"YW_=\") &rarr; false\n\t * KJUR.lang.String.isBase64(\"YWE\") &rarr; false -- length shall be multiples of 4\n\t */\n\tKJUR.lang.String.isBase64 = function(s) {\n\t    s = s.replace(/\\s+/g, \"\");\n\t    if (s.match(/^[0-9A-Za-z+\\/]+={0,3}$/) && s.length % 4 == 0) {\n\t\treturn true;\n\t    } else {\n\t\treturn false;\n\t    }\n\t};\n\t\n\t/**\n\t * check whether a string is a base64url encoded string or not<br/>\n\t * Input string can conclude new lines or space characters.\n\t * @name isBase64URL\n\t * @memberOf KJUR.lang.String\n\t * @function\n\t * @static\n\t * @param {String} s input string\n\t * @return {Boolean} true if a string \"s\" is a base64url encoded string otherwise false\n\t * @since base64x 1.1.7 jsrsasign 5.0.13\n\t * @example\n\t * KJUR.lang.String.isBase64URL(\"YWE\") &rarr; true\n\t * KJUR.lang.String.isBase64URL(\"YW-\") &rarr; true\n\t * KJUR.lang.String.isBase64URL(\"YW+\") &rarr; false\n\t */\n\tKJUR.lang.String.isBase64URL = function(s) {\n\t    if (s.match(/[+/=]/)) return false;\n\t    s = b64utob64(s);\n\t    return KJUR.lang.String.isBase64(s);\n\t};\n\t\n\t/**\n\t * check whether a string is a string of integer array or not<br/>\n\t * Input string can conclude new lines or space characters.\n\t * @name isIntegerArray\n\t * @memberOf KJUR.lang.String\n\t * @function\n\t * @static\n\t * @param {String} s input string\n\t * @return {Boolean} true if a string \"s\" is a string of integer array otherwise false\n\t * @since base64x 1.1.7 jsrsasign 5.0.13\n\t * @example\n\t * KJUR.lang.String.isIntegerArray(\"[1,2,3]\") &rarr; true\n\t * KJUR.lang.String.isIntegerArray(\"  [1, 2, 3  ] \") &rarr; true\n\t * KJUR.lang.String.isIntegerArray(\"[a,2]\") &rarr; false\n\t */\n\tKJUR.lang.String.isIntegerArray = function(s) {\n\t    s = s.replace(/\\s+/g, \"\");\n\t    if (s.match(/^\\[[0-9,]+\\]$/)) {\n\t\treturn true;\n\t    } else {\n\t\treturn false;\n\t    }\n\t};\n\t\n\t// ==== others ================================\n\t\n\t/**\n\t * convert string of integer array to hexadecimal string.<br/>\n\t * @param {String} s string of integer array\n\t * @return {String} hexadecimal string\n\t * @since base64x 1.1.6 jsrsasign 5.0.2\n\t * @throws \"malformed integer array string: *\" for wrong input\n\t * @description\n\t * This function converts a string of JavaScript integer array to\n\t * a hexadecimal string. Each integer value shall be in a range \n\t * from 0 to 255 otherwise it raise exception. Input string can\n\t * have extra space or newline string so that they will be ignored.\n\t * \n\t * @example\n\t * intarystrtohex(\" [123, 34, 101, 34, 58] \")\n\t * &rarr; 7b2265223a (i.e. '{\"e\":' as string)\n\t */\n\tfunction intarystrtohex(s) {\n\t  s = s.replace(/^\\s*\\[\\s*/, '');\n\t  s = s.replace(/\\s*\\]\\s*$/, '');\n\t  s = s.replace(/\\s*/g, '');\n\t  try {\n\t    var hex = s.split(/,/).map(function(element, index, array) {\n\t      var i = parseInt(element);\n\t      if (i < 0 || 255 < i) throw \"integer not in range 0-255\";\n\t      var hI = (\"00\" + i.toString(16)).slice(-2);\n\t      return hI;\n\t    }).join('');\n\t    return hex;\n\t  } catch(ex) {\n\t    throw \"malformed integer array string: \" + ex;\n\t  }\n\t}\n\t\n\t/**\n\t * find index of string where two string differs\n\t * @param {String} s1 string to compare\n\t * @param {String} s2 string to compare\n\t * @return {Number} string index of where character differs. Return -1 if same.\n\t * @since jsrsasign 4.9.0 base64x 1.1.5\n\t * @example\n\t * strdiffidx(\"abcdefg\", \"abcd4fg\") -> 4\n\t * strdiffidx(\"abcdefg\", \"abcdefg\") -> -1\n\t * strdiffidx(\"abcdefg\", \"abcdef\") -> 6\n\t * strdiffidx(\"abcdefgh\", \"abcdef\") -> 6\n\t */\n\tvar strdiffidx = function(s1, s2) {\n\t    var n = s1.length;\n\t    if (s1.length > s2.length) n = s2.length;\n\t    for (var i = 0; i < n; i++) {\n\t\tif (s1.charCodeAt(i) != s2.charCodeAt(i)) return i;\n\t    }\n\t    if (s1.length != s2.length) return n;\n\t    return -1; // same\n\t};\n\t\n\t\n\t\n\t/*! jws-3.3.5 (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n\t */\n\t/*\n\t * jws.js - JSON Web Signature(JWS) and JSON Web Token(JWT) Class\n\t *\n\t * version: 3.3.4 (2016 May 17)\n\t *\n\t * Copyright (c) 2010-2016 Kenji Urushima (kenji.urushima@gmail.com)\n\t *\n\t * This software is licensed under the terms of the MIT License.\n\t * http://kjur.github.com/jsrsasign/license/\n\t *\n\t * The above copyright and license notice shall be \n\t * included in all copies or substantial portions of the Software.\n\t */\n\t\n\t/**\n\t * @fileOverview\n\t * @name jws-3.3.js\n\t * @author Kenji Urushima kenji.urushima@gmail.com\n\t * @version 3.3.5 (2016-Oct-08)\n\t * @since jsjws 1.0, jsrsasign 4.8.0\n\t * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n\t */\n\t\n\tif (typeof KJUR == \"undefined\" || !KJUR) KJUR = {};\n\t\n\t/**\n\t * kjur's JSON Web Signature/Token(JWS/JWT) library name space\n\t * <p>\n\t * This namespace privides following JWS/JWS related classes.\n\t * <ul>\n\t * <li>{@link KJUR.jws.JWS} - JSON Web Signature/Token(JWS/JWT) class</li>\n\t * <li>{@link KJUR.jws.JWSJS} - JWS JSON Serialization(JWSJS) class</li>\n\t * <li>{@link KJUR.jws.IntDate} - UNIX origin time utility class</li>\n\t * </ul>\n\t * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n\t * </p>\n\t * @name KJUR.jws\n\t * @namespace\n\t */\n\tif (typeof KJUR.jws == \"undefined\" || !KJUR.jws) KJUR.jws = {};\n\t\n\t/**\n\t * JSON Web Signature(JWS) class.<br/>\n\t * @name KJUR.jws.JWS\n\t * @class JSON Web Signature(JWS) class\n\t * @see <a href=\"http://kjur.github.com/jsjws/\">'jwjws'(JWS JavaScript Library) home page http://kjur.github.com/jsjws/</a>\n\t * @see <a href=\"http://kjur.github.com/jsrsasigns/\">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n\t * @see <a href=\"http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-14\">IETF I-D JSON Web Algorithms (JWA)</a>\n\t * @since jsjws 1.0\n\t * @description\n\t * This class provides JSON Web Signature(JWS)/JSON Web Token(JWT) signing and validation.\n\t *\n\t * <h4>METHOD SUMMARY</h4>\n\t * Here is major methods of {@link KJUR.jws.JWS} class.\n\t * <ul>\n\t * <li><b>SIGN</b><br/>\n\t * <li>{@link KJUR.jws.JWS.sign} - sign JWS</li>\n\t * </li>\n\t * <li><b>VERIFY</b><br/>\n\t * <li>{@link KJUR.jws.JWS.verify} - verify JWS signature</li>\n\t * <li>{@link KJUR.jws.JWS.verifyJWT} - verify properties of JWT token at specified time</li>\n\t * </li>\n\t * <li><b>UTILITY</b><br/>\n\t * <li>{@link KJUR.jws.JWS.getJWKthumbprint} - get RFC 7638 JWK thumbprint</li>\n\t * <li>{@link KJUR.jws.JWS.isSafeJSONString} - check whether safe JSON string or not</li>\n\t * <li>{@link KJUR.jws.JWS.readSafeJSONString} - read safe JSON string only</li>\n\t * </li>\n\t * </ul> \n\t *\n\t * <h4>SUPPORTED SIGNATURE ALGORITHMS</h4>\n\t * Here is supported algorithm names for {@link KJUR.jws.JWS.sign} and\n\t * {@link KJUR.jws.JWS.verify} methods.\n\t * <table>\n\t * <tr><th>alg value</th><th>spec requirement</th><th>jsjws support</th></tr>\n\t * <tr><td>HS256</td><td>REQUIRED</td><td>SUPPORTED</td></tr>\n\t * <tr><td>HS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>HS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>RS256</td><td>RECOMMENDED</td><td>SUPPORTED</td></tr>\n\t * <tr><td>RS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>RS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>ES256</td><td>RECOMMENDED+</td><td>SUPPORTED</td></tr>\n\t * <tr><td>ES384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>ES512</td><td>OPTIONAL</td><td>-</td></tr>\n\t * <tr><td>PS256</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>PS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>PS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>none</td><td>REQUIRED</td><td>SUPPORTED(signature generation only)</td></tr>\n\t * </table>\n\t * <dl>\n\t * <dt><b>NOTE1</b>\n\t * <dd>HS384 is supported since jsjws 3.0.2 with jsrsasign 4.1.4.\n\t * <dt><b>NOTE2</b>\n\t * <dd>Some deprecated methods have been removed since jws 3.3 of jsrsasign 4.10.0.\n\t * Removed methods are following:\n\t * <ul>\n\t * <li>JWS.verifyJWSByNE</li>\n\t * <li>JWS.verifyJWSByKey</li>\n\t * <li>JWS.generateJWSByNED</li>\n\t * <li>JWS.generateJWSByKey</li>\n\t * <li>JWS.generateJWSByP1PrvKey</li>\n\t * </ul>\n\t * </dl>\n\t * <b>EXAMPLE</b><br/>\n\t * @example\n\t * // JWS signing \n\t * sJWS = KJUR.jws.JWS.sign(null, '{\"alg\":\"HS256\", \"cty\":\"JWT\"}', '{\"age\": 21}', {\"utf8\": \"password\"});\n\t * // JWS validation\n\t * isValid = KJUR.jws.JWS.verify('eyJjdHkiOiJKV1QiLCJhbGc...', {\"utf8\": \"password\"});\n\t * // JWT validation\n\t * isValid = KJUR.jws.JWS.verifyJWT('eyJh...', {\"utf8\": \"password\"}, {\n\t *   alg: ['HS256', 'HS384'],\n\t *   iss: ['http://foo.com']\n\t * });\n\t */\n\tKJUR.jws.JWS = function() {\n\t    var ns1 = KJUR.jws.JWS;\n\t\n\t    // === utility =============================================================\n\t\n\t    /**\n\t     * parse JWS string and set public property 'parsedJWS' dictionary.<br/>\n\t     * @name parseJWS\n\t     * @memberOf KJUR.jws.JWS\n\t     * @function\n\t     * @param {String} sJWS JWS signature string to be parsed.\n\t     * @throws if sJWS is not comma separated string such like \"Header.Payload.Signature\".\n\t     * @throws if JWS Header is a malformed JSON string.\n\t     * @since jws 1.1\n\t     */\n\t    this.parseJWS = function(sJWS, sigValNotNeeded) {\n\t\tif ((this.parsedJWS !== undefined) &&\n\t\t    (sigValNotNeeded || (this.parsedJWS.sigvalH !== undefined))) {\n\t\t    return;\n\t\t}\n\t    var matchResult = sJWS.match(/^([^.]+)\\.([^.]+)\\.([^.]+)$/);\n\t\tif (matchResult == null) {\n\t\t    throw \"JWS signature is not a form of 'Head.Payload.SigValue'.\";\n\t\t}\n\t\tvar b6Head = matchResult[1];\n\t\tvar b6Payload = matchResult[2];\n\t\tvar b6SigVal = matchResult[3];\n\t\tvar sSI = b6Head + \".\" + b6Payload;\n\t\tthis.parsedJWS = {};\n\t\tthis.parsedJWS.headB64U = b6Head;\n\t\tthis.parsedJWS.payloadB64U = b6Payload;\n\t\tthis.parsedJWS.sigvalB64U = b6SigVal;\n\t\tthis.parsedJWS.si = sSI;\n\t\n\t\tif (!sigValNotNeeded) {\n\t\t    var hSigVal = b64utohex(b6SigVal);\n\t\t    var biSigVal = parseBigInt(hSigVal, 16);\n\t\t    this.parsedJWS.sigvalH = hSigVal;\n\t\t    this.parsedJWS.sigvalBI = biSigVal;\n\t\t}\n\t\n\t\tvar sHead = b64utoutf8(b6Head);\n\t\tvar sPayload = b64utoutf8(b6Payload);\n\t\tthis.parsedJWS.headS = sHead;\n\t\tthis.parsedJWS.payloadS = sPayload;\n\t\n\t\tif (! ns1.isSafeJSONString(sHead, this.parsedJWS, 'headP'))\n\t\t    throw \"malformed JSON string for JWS Head: \" + sHead;\n\t    };\n\t};\n\t\n\t// === major static method ========================================================\n\t\n\t/**\n\t * generate JWS signature by specified key<br/>\n\t * @name sign\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} alg JWS algorithm name to sign and force set to sHead or null \n\t * @param {String} spHead string or object of JWS Header\n\t * @param {String} spPayload string or object of JWS Payload\n\t * @param {String} key string of private key or mac key object to sign\n\t * @param {String} pass (OPTION)passcode to use encrypted asymmetric private key \n\t * @return {String} JWS signature string\n\t * @since jws 3.0.0\n\t * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html\">jsrsasign KJUR.crypto.Signature method</a>\n\t * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Mac.html\">jsrsasign KJUR.crypto.Mac method</a>\n\t * @description\n\t * This method supports following algorithms.\n\t * <table>\n\t * <tr><th>alg value</th><th>spec requirement</th><th>jsjws support</th></tr>\n\t * <tr><td>HS256</td><td>REQUIRED</td><td>SUPPORTED</td></tr>\n\t * <tr><td>HS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>HS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>RS256</td><td>RECOMMENDED</td><td>SUPPORTED</td></tr>\n\t * <tr><td>RS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>RS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>ES256</td><td>RECOMMENDED+</td><td>SUPPORTED</td></tr>\n\t * <tr><td>ES384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>ES512</td><td>OPTIONAL</td><td>-</td></tr>\n\t * <tr><td>PS256</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>PS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>PS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n\t * <tr><td>none</td><td>REQUIRED</td><td>SUPPORTED(signature generation only)</td></tr>\n\t * </table>\n\t * <dl>\n\t * <dt>NOTE1:\n\t * <dd>salt length of RSAPSS signature is the same as the hash algorithm length\n\t * because of <a href=\"http://www.ietf.org/mail-archive/web/jose/current/msg02901.html\">IETF JOSE ML discussion</a>.\n\t * <dt>NOTE2:\n\t * <dd>To support HS384, patched version of CryptoJS is used.\n\t * <a href=\"https://code.google.com/p/crypto-js/issues/detail?id=84\">See here for detail</a>.\n\t * <dt>NOTE3:\n\t * From jsrsasign 4.10.0 jws 3.3.0, Way to provide password\n\t * for HS* algorithm is changed. The 'key' attribute value is\n\t * passed to {@link KJUR.crypto.Mac.setPassword} so please see\n\t * {@link KJUR.crypto.Mac.setPassword} for detail.\n\t * As for backword compatibility, if key is a string, has even length and\n\t * 0..9, A-F or a-f characters, key string is treated as a hexadecimal\n\t * otherwise it is treated as a raw string.\n\t * <dd>\n\t * </dl>\n\t * <b>EXAMPLE</b><br/>\n\t * @example\n\t * // sign HS256 signature with password \"aaa\" implicitly handled as string\n\t * sJWS = KJUR.jws.JWS.sign(null, {alg: \"HS256\", cty: \"JWT\"}, {age: 21}, \"aaa\");\n\t * // sign HS256 signature with password \"6161\" implicitly handled as hex\n\t * sJWS = KJUR.jws.JWS.sign(null, {alg: \"HS256\", cty: \"JWT\"}, {age: 21}, \"6161\");\n\t * // sign HS256 signature with base64 password\n\t * sJWS = KJUR.jws.JWS.sign(null, {alg: \"HS256\"}, {age: 21}, {b64: \"Mi/8..a=\"});\n\t * // sign RS256 signature with PKCS#8 PEM RSA private key\n\t * sJWS = KJUR.jws.JWS.sign(null, {alg: \"RS256\"}, {age: 21}, \"-----BEGIN PRIVATE KEY...\");\n\t * // sign RS256 signature with PKCS#8 PEM ECC private key with passcode\n\t * sJWS = KJUR.jws.JWS.sign(null, {alg: \"ES256\"}, {age: 21}, \n\t *                          \"-----BEGIN PRIVATE KEY...\", \"keypass\");\n\t * // header and payload can be passed by both string and object\n\t * sJWS = KJUR.jws.JWS.sign(null, '{alg:\"HS256\",cty:\"JWT\"}', '{age:21}', \"aaa\");\n\t */\n\tKJUR.jws.JWS.sign = function(alg, spHeader, spPayload, key, pass) {\n\t    var ns1 = KJUR.jws.JWS;\n\t    var sHeader, pHeader, sPayload;\n\t\n\t    // 1. check signatureInput(Header, Payload) is string or object\n\t    if (typeof spHeader != 'string' && typeof spHeader != 'object')\n\t\tthrow \"spHeader must be JSON string or object: \" + spHeader;\n\t\n\t    if (typeof spHeader == 'object') {\n\t\tpHeader = spHeader;\n\t\tsHeader = JSON.stringify(pHeader);\n\t    }\n\t\n\t    if (typeof spHeader == 'string') {\n\t\tsHeader = spHeader;\n\t\tif (! ns1.isSafeJSONString(sHeader))\n\t\t    throw \"JWS Head is not safe JSON string: \" + sHeader;\n\t\tpHeader = ns1.readSafeJSONString(sHeader);\n\t\n\t    }\n\t\n\t    sPayload = spPayload;\n\t    if (typeof spPayload == 'object') sPayload = JSON.stringify(spPayload);\n\t\n\t    // 2. use alg if defined in sHeader\n\t    if ((alg == '' || alg == null) &&\n\t\tpHeader['alg'] !== undefined) {\n\t\talg = pHeader['alg'];\n\t    }\n\t\n\t    // 3. update sHeader to add alg if alg undefined\n\t    if ((alg != '' && alg != null) &&\n\t\tpHeader['alg'] === undefined) {\n\t\tpHeader['alg'] = alg;\n\t\tsHeader = JSON.stringify(pHeader);\n\t    }\n\t\n\t    // 4. check explicit algorithm doesn't match with JWS header.\n\t    if (alg !== pHeader.alg)\n\t\tthrow \"alg and sHeader.alg doesn't match: \" + alg + \"!=\" + pHeader.alg;\n\t\n\t    // 5. set signature algorithm like SHA1withRSA\n\t    var sigAlg = null;\n\t    if (ns1.jwsalg2sigalg[alg] === undefined) {\n\t\tthrow \"unsupported alg name: \" + alg;\n\t    } else {\n\t\tsigAlg = ns1.jwsalg2sigalg[alg];\n\t    }\n\t    \n\t    var uHeader = utf8tob64u(sHeader);\n\t    var uPayload = utf8tob64u(sPayload);\n\t    var uSignatureInput = uHeader + \".\" + uPayload\n\t    // 6. sign\n\t    var hSig = \"\";\n\t    if (sigAlg.substr(0, 4) == \"Hmac\") {\n\t\tif (key === undefined)\n\t\t    throw \"mac key shall be specified for HS* alg\";\n\t\t//alert(\"sigAlg=\" + sigAlg);\n\t\tvar mac = new KJUR.crypto.Mac({'alg': sigAlg, 'prov': 'cryptojs', 'pass': key});\n\t\tmac.updateString(uSignatureInput);\n\t\thSig = mac.doFinal();\n\t    } else if (sigAlg.indexOf(\"withECDSA\") != -1) {\n\t\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\t\tsig.init(key, pass);\n\t\tsig.updateString(uSignatureInput);\n\t\thASN1Sig = sig.sign();\n\t\thSig = KJUR.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig);\n\t    } else if (sigAlg != \"none\") {\n\t\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\t\tsig.init(key, pass);\n\t\tsig.updateString(uSignatureInput);\n\t\thSig = sig.sign();\n\t    }\n\t\n\t    var uSig = hextob64u(hSig);\n\t    return uSignatureInput + \".\" + uSig;\n\t};\n\t\n\t/**\n\t * verify JWS signature by specified key or certificate<br/>\n\t * @name verify\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} sJWS string of JWS signature to verify\n\t * @param {Object} key string of public key, certificate or key object to verify\n\t * @param {String} acceptAlgs array of algorithm name strings (OPTION)\n\t * @return {Boolean} true if the signature is valid otherwise false\n\t * @since jws 3.0.0\n\t * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html\">jsrsasign KJUR.crypto.Signature method</a>\n\t * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Mac.html\">jsrsasign KJUR.crypto.Mac method</a>\n\t * @description\n\t * <p>\n\t * This method verifies a JSON Web Signature Compact Serialization string by the validation \n\t * algorithm as described in \n\t * <a href=\"http://self-issued.info/docs/draft-jones-json-web-signature-04.html#anchor5\">\n\t * the section 5 of Internet Draft draft-jones-json-web-signature-04.</a>\n\t * </p>\n\t * <p>\n\t * Since 3.2.0 strict key checking has been provided against a JWS algorithm\n\t * in a JWS header.\n\t * <ul>\n\t * <li>In case 'alg' is 'HS*' in the JWS header,\n\t * 'key' shall be hexadecimal string for Hmac{256,384,512} shared secret key.\n\t * Otherwise it raise an error.</li>\n\t * <li>In case 'alg' is 'RS*' or 'PS*' in the JWS header,\n\t * 'key' shall be a RSAKey object or a PEM string of\n\t * X.509 RSA public key certificate or PKCS#8 RSA public key.\n\t * Otherwise it raise an error.</li>\n\t * <li>In case 'alg' is 'ES*' in the JWS header,\n\t * 'key' shall be a KJUR.crypto.ECDSA object or a PEM string of\n\t * X.509 ECC public key certificate or PKCS#8 ECC public key.\n\t * Otherwise it raise an error.</li>\n\t * <li>In case 'alg' is 'none' in the JWS header,\n\t * validation not supported after jsjws 3.1.0.</li>\n\t * </ul>\n\t * </p>\n\t * <p>\n\t * NOTE1: The argument 'acceptAlgs' is supported since 3.2.0.\n\t * Strongly recommended to provide acceptAlgs to mitigate\n\t * signature replacement attacks.<br/>\n\t * </p>\n\t * <p>\n\t * NOTE2: From jsrsasign 4.9.0 jws 3.2.5, Way to provide password\n\t * for HS* algorithm is changed. The 'key' attribute value is\n\t * passed to {@link KJUR.crypto.Mac.setPassword} so please see\n\t * {@link KJUR.crypto.Mac.setPassword} for detail.\n\t * As for backword compatibility, if key is a string, has even length and\n\t * 0..9, A-F or a-f characters, key string is treated as a hexadecimal\n\t * otherwise it is treated as a raw string.\n\t * </p>\n\t * @example\n\t * // 1) verify a RS256 JWS signature by a certificate string.\n\t * isValid = KJUR.jws.JWS.verify('eyJh...', '-----BEGIN...', ['RS256']);\n\t * \n\t * // 2) verify a HS256 JWS signature by a certificate string.\n\t * isValid = KJUR.jws.JWS.verify('eyJh...', {hex: '6f62ad...'}, ['HS256']);\n\t * isValid = KJUR.jws.JWS.verify('eyJh...', {b64: 'Mi/ab8...a=='}, ['HS256']);\n\t * isValid = KJUR.jws.JWS.verify('eyJh...', {utf8: 'Secret秘密'}, ['HS256']);\n\t * isValid = KJUR.jws.JWS.verify('eyJh...', '6f62ad', ['HS256']); // implicit hex\n\t * isValid = KJUR.jws.JWS.verify('eyJh...', '6f62ada', ['HS256']); // implicit raw string\n\t *\n\t * // 3) verify a ES256 JWS signature by a KJUR.crypto.ECDSA key object.\n\t * var pubkey = KEYUTIL.getKey('-----BEGIN CERT...');\n\t * var isValid = KJUR.jws.JWS.verify('eyJh...', pubkey);\n\t */\n\tKJUR.jws.JWS.verify = function(sJWS, key, acceptAlgs) {\n\t    var jws = KJUR.jws.JWS;\n\t    var a = sJWS.split(\".\");\n\t    var uHeader = a[0];\n\t    var uPayload = a[1];\n\t    var uSignatureInput = uHeader + \".\" + uPayload;\n\t    var hSig = b64utohex(a[2]);\n\t\n\t    // 1. parse JWS header\n\t    var pHeader = jws.readSafeJSONString(b64utoutf8(a[0]));\n\t    var alg = null;\n\t    var algType = null; // HS|RS|PS|ES|no\n\t    if (pHeader.alg === undefined) {\n\t\tthrow \"algorithm not specified in header\";\n\t    } else {\n\t\talg = pHeader.alg;\n\t\talgType = alg.substr(0, 2);\n\t    }\n\t\n\t    // 2. check whether alg is acceptable algorithms\n\t    if (acceptAlgs != null &&\n\t        Object.prototype.toString.call(acceptAlgs) === '[object Array]' &&\n\t        acceptAlgs.length > 0) {\n\t\tvar acceptAlgStr = \":\" + acceptAlgs.join(\":\") + \":\";\n\t\tif (acceptAlgStr.indexOf(\":\" + alg + \":\") == -1) {\n\t\t    throw \"algorithm '\" + alg + \"' not accepted in the list\";\n\t\t}\n\t    }\n\t\n\t    // 3. check whether key is a proper key for alg.\n\t    if (alg != \"none\" && key === null) {\n\t\tthrow \"key shall be specified to verify.\";\n\t    }\n\t\n\t    // 3.1. There is no key check for HS* because Mac will check it.\n\t    //      since jsrsasign 5.0.0.\n\t\n\t    // 3.2. convert key object if key is a public key or cert PEM string\n\t    if (typeof key == \"string\" &&\n\t\tkey.indexOf(\"-----BEGIN \") != -1) {\n\t\tkey = KEYUTIL.getKey(key);\n\t    }\n\t\n\t    // 3.3. check whether key is RSAKey obj if alg is RS* or PS*.\n\t    if (algType == \"RS\" || algType == \"PS\") {\n\t\tif (!(key instanceof RSAKey)) {\n\t\t    throw \"key shall be a RSAKey obj for RS* and PS* algs\";\n\t\t}\n\t    }\n\t\n\t    // 3.4. check whether key is ECDSA obj if alg is ES*.\n\t    if (algType == \"ES\") {\n\t\tif (!(key instanceof KJUR.crypto.ECDSA)) {\n\t\t    throw \"key shall be a ECDSA obj for ES* algs\";\n\t\t}\n\t    }\n\t\n\t    // 3.5. check when alg is 'none'\n\t    if (alg == \"none\") {\n\t    }\n\t\n\t    // 4. check whether alg is supported alg in jsjws.\n\t    var sigAlg = null;\n\t    if (jws.jwsalg2sigalg[pHeader.alg] === undefined) {\n\t\tthrow \"unsupported alg name: \" + alg;\n\t    } else {\n\t\tsigAlg = jws.jwsalg2sigalg[alg];\n\t    }\n\t\n\t    // 5. verify\n\t    if (sigAlg == \"none\") {\n\t        throw \"not supported\";\n\t    } else if (sigAlg.substr(0, 4) == \"Hmac\") {\n\t\tvar hSig2 = null;\n\t\tif (key === undefined)\n\t\t    throw \"hexadecimal key shall be specified for HMAC\";\n\t\t//try {\n\t\t    var mac = new KJUR.crypto.Mac({'alg': sigAlg, 'pass': key});\n\t\t    mac.updateString(uSignatureInput);\n\t\t    hSig2 = mac.doFinal();\n\t\t//} catch(ex) {};\n\t\treturn hSig == hSig2;\n\t    } else if (sigAlg.indexOf(\"withECDSA\") != -1) {\n\t\tvar hASN1Sig = null;\n\t        try {\n\t\t    hASN1Sig = KJUR.crypto.ECDSA.concatSigToASN1Sig(hSig);\n\t\t} catch (ex) {\n\t\t    return false;\n\t\t}\n\t\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\t\tsig.init(key)\n\t\tsig.updateString(uSignatureInput);\n\t\treturn sig.verify(hASN1Sig);\n\t    } else {\n\t\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\t\tsig.init(key)\n\t\tsig.updateString(uSignatureInput);\n\t\treturn sig.verify(hSig);\n\t    }\n\t};\n\t\n\t/**\n\t * parse header and payload of JWS signature<br/>\n\t * @name parse\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} sJWS string of JWS signature to parse\n\t * @return {Array} associative array of parsed header and payload. See below.\n\t * @throws if sJWS is malformed JWS signature\n\t * @since jws 3.3.3\n\t * @description\n\t * This method parses JWS signature string. \n\t * Resulted associative array has following properties:\n\t * <ul>\n\t * <li>headerObj - JSON object of header</li>\n\t * <li>payloadObj - JSON object of payload if payload is JSON string otherwise undefined</li>\n\t * <li>headerPP - pretty printed JSON header by stringify</li>\n\t * <li>payloadPP - pretty printed JSON payload by stringify if payload is JSON otherwise Base64URL decoded raw string of payload</li>\n\t * <li>sigHex - hexadecimal string of signature</li>\n\t * </ul>\n\t * @example\n\t * KJUR.jws.JWS.parse(sJWS) ->\n\t * { \n\t *   headerObj: {\"alg\": \"RS256\", \"typ\": \"JWS\"},\n\t *   payloadObj: {\"product\": \"orange\", \"quantity\": 100},\n\t *   headerPP: \n\t *   '{\n\t *     \"alg\": \"RS256\",\n\t *     \"typ\": \"JWS\"\n\t *   }',\n\t *   payloadPP: \n\t *   '{\n\t *     \"product\": \"orange\",\n\t *     \"quantity\": 100\n\t *   }',\n\t *   sigHex: \"91f3cd...\" \n\t * }\n\t */\n\tKJUR.jws.JWS.parse = function(sJWS) {\n\t    var a = sJWS.split(\".\");\n\t    var result = {};\n\t    var uHeader, uPayload, uSig;\n\t    if (a.length != 2 && a.length != 3)\n\t\tthrow \"malformed sJWS: wrong number of '.' splitted elements\";\n\t\n\t    uHeader = a[0];\n\t    uPayload = a[1];\n\t    if (a.length == 3) uSig = a[2]; \n\t\n\t    result.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(uHeader));\n\t    result.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(uPayload));\n\t\n\t    result.headerPP = JSON.stringify(result.headerObj, null, \"  \");\n\t    if (result.payloadObj == null) {\n\t\tresult.payloadPP = b64utoutf8(uPayload);\n\t    } else {\n\t\tresult.payloadPP = JSON.stringify(result.payloadObj, null, \"  \");\n\t    }\n\t\n\t    if (uSig !== undefined) {\n\t\tresult.sigHex = b64utohex(uSig);\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\t/**\n\t * @name verifyJWT\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} sJWT string of JSON Web Token(JWT) to verify\n\t * @param {Object} key string of public key, certificate or key object to verify\n\t * @param {Array} acceptField associative array of acceptable fields (OPTION)\n\t * @return {Boolean} true if the JWT token is valid otherwise false\n\t * @since jws 3.2.3 jsrsasign 4.8.0\n\t *\n\t * @description\n\t * This method verifies a\n\t * <a href=\"https://tools.ietf.org/html/rfc7519\">RFC 7519</a> \n\t * JSON Web Token(JWT).\n\t * It will verify following:\n\t * <ul>\n\t * <li>Header.alg\n\t * <ul>\n\t * <li>alg is specified in JWT header.</li>\n\t * <li>alg is included in acceptField.alg array. (MANDATORY)</li>\n\t * <li>alg is proper for key.</li>\n\t * </ul>\n\t * </li>\n\t * <li>Payload.iss (issuer) - Payload.iss is included in acceptField.iss array if specified. (OPTION)</li>\n\t * <li>Payload.sub (subject) - Payload.sub is included in acceptField.sub array if specified. (OPTION)</li>\n\t * <li>Payload.aud (audience) - Payload.aud is included in acceptField.aud array or \n\t *     the same as value if specified. (OPTION)</li>\n\t * <li>Time validity\n\t * <ul>\n\t * <li>\n\t * If acceptField.verifyAt as number of UNIX origin time is specifed for validation time, \n\t * this method will verify at the time for it, otherwise current time will be used to verify.\n\t * </li>\n\t * <li>\n\t * Clock of JWT generator or verifier can be fast or slow. If these clocks are\n\t * very different, JWT validation may fail. To avoid such case, 'jsrsasign' supports\n\t * 'acceptField.gracePeriod' parameter which specifies acceptable time difference\n\t * of those clocks in seconds. So if you want to accept slow or fast in 2 hours,\n\t * you can specify <code>acceptField.gracePeriod = 2 * 60 * 60;</code>.\n\t * \"gracePeriod\" is zero by default.\n\t * \"gracePeriod\" is supported since jsrsasign 5.0.12.\n\t * </li>\n\t * <li>Payload.exp (expire) - Validation time is smaller than Payload.exp + gracePeriod.</li>\n\t * <li>Payload.nbf (not before) - Validation time is greater than Payload.nbf - gracePeriod.</li>\n\t * <li>Payload.iat (issued at) - Validation time is greater than Payload.iat - gracePeriod.</li>\n\t * </ul>\n\t * </li>\n\t * <li>Payload.jti (JWT id) - Payload.jti is included in acceptField.jti if specified. (OPTION)</li>\n\t * <li>JWS signature of JWS is valid for specified key.</li>\n\t * </ul>\n\t *\n\t * <h4>acceptField parameters</h4>\n\t * Here is available acceptField argument parameters:\n\t * <ul>\n\t * <li>alg - array of acceptable signature algorithm names (ex. [\"HS256\", \"HS384\"])</li>\n\t * <li>iss - array of acceptable issuer names (ex. ['http://foo.com'])</li>\n\t * <li>sub - array of acceptable subject names (ex. ['mailto:john@foo.com'])</li>\n\t * <li>aud - array or string of acceptable audience name(s) (ex. ['http://foo.com'])</li>\n\t * <li>jti - string of acceptable JWT ID (OPTION) (ex. 'id1234')</li>\n\t * <li>\n\t * verifyAt - time to verify 'nbf', 'iat' and 'exp' in UNIX seconds \n\t * (OPTION) (ex. 1377663900).  \n\t * If this is not specified, current time of verifier will be used. \n\t * {@link KJUR.jws.IntDate} may be useful to specify it.\n\t * </li>\n\t * <li>gracePeriod - acceptable time difference between signer and verifier\n\t * in seconds (ex. 3600). If this is not specified, zero will be used.</li>\n\t * </ul>\n\t *\n\t * @example\n\t * // simple validation for HS256\n\t * isValid = KJUR.jws.JWS.verifyJWT(\"eyJhbG...\", \"616161\", {alg: [\"HS256\"]}),\n\t *\n\t * // full validation for RS or PS\n\t * pubkey = KEYUTIL.getKey('-----BEGIN CERT...');\n\t * isValid = KJUR.jws.JWS.verifyJWT('eyJh...', pubkey, {\n\t *   alg: ['RS256', 'RS512', 'PS256', 'PS512'],\n\t *   iss: ['http://foo.com'],\n\t *   sub: ['mailto:john@foo.com', 'mailto:alice@foo.com'],\n\t *   verifyAt: KJUR.jws.IntDate.get('20150520235959Z'),\n\t *   aud: ['http://foo.com'], // aud: 'http://foo.com' is fine too.\n\t *   jti: 'id123456',\n\t *   gracePeriod: 1 * 60 * 60 // accept 1 hour slow or fast\n\t * });\n\t */\n\tKJUR.jws.JWS.verifyJWT = function(sJWT, key, acceptField) {\n\t    var ns1 = KJUR.jws.JWS;\n\t\n\t    // 1. parse JWT\n\t    var a = sJWT.split(\".\");\n\t    var uHeader = a[0];\n\t    var uPayload = a[1];\n\t    var uSignatureInput = uHeader + \".\" + uPayload;\n\t    var hSig = b64utohex(a[2]);\n\t\n\t    // 2. parse JWS header\n\t    var pHeader = ns1.readSafeJSONString(b64utoutf8(uHeader));\n\t\n\t    // 3. parse JWS payload\n\t    var pPayload = ns1.readSafeJSONString(b64utoutf8(uPayload));\n\t\n\t    // 4. algorithm ('alg' in header) check\n\t    if (pHeader.alg === undefined) return false;\n\t    if (acceptField.alg === undefined)\n\t\tthrow \"acceptField.alg shall be specified\";\n\t    if (! ns1.inArray(pHeader.alg, acceptField.alg)) return false;\n\t\n\t    // 5. issuer ('iss' in payload) check\n\t    if (pPayload.iss !== undefined && typeof acceptField.iss === \"object\") {\n\t\tif (! ns1.inArray(pPayload.iss, acceptField.iss)) return false;\n\t    }\n\t\n\t    // 6. subject ('sub' in payload) check\n\t    if (pPayload.sub !== undefined && typeof acceptField.sub === \"object\") {\n\t\tif (! ns1.inArray(pPayload.sub, acceptField.sub)) return false;\n\t    }\n\t\n\t    // 7. audience ('aud' in payload) check\n\t    if (pPayload.aud !== undefined && typeof acceptField.aud === \"object\") {\n\t\tif (typeof pPayload.aud == \"string\") {\n\t\t    if (! ns1.inArray(pPayload.aud, acceptField.aud))\n\t\t\treturn false;\n\t\t} else if (typeof pPayload.aud == \"object\") {\n\t\t    if (! ns1.includedArray(pPayload.aud, acceptField.aud))\n\t\t\treturn false;\n\t\t}\n\t    }\n\t\n\t    // 8. time validity \n\t    //   (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)\n\t    var now = KJUR.jws.IntDate.getNow();\n\t    if (acceptField.verifyAt !== undefined && typeof acceptField.verifyAt === \"number\") {\n\t\tnow = acceptField.verifyAt;\n\t    }\n\t    if (acceptField.gracePeriod === undefined || \n\t        typeof acceptField.gracePeriod !== \"number\") {\n\t\tacceptField.gracePeriod = 0;\n\t    }\n\t\n\t    // 8.1 expired time 'exp' check\n\t    if (pPayload.exp !== undefined && typeof pPayload.exp == \"number\") {\n\t\tif (pPayload.exp + acceptField.gracePeriod < now) return false;\n\t    }\n\t\n\t    // 8.2 not before time 'nbf' check\n\t    if (pPayload.nbf !== undefined && typeof pPayload.nbf == \"number\") {\n\t\tif (now < pPayload.nbf - acceptField.gracePeriod) return false;\n\t    }\n\t    \n\t    // 8.3 issued at time 'iat' check\n\t    if (pPayload.iat !== undefined && typeof pPayload.iat == \"number\") {\n\t\tif (now < pPayload.iat - acceptField.gracePeriod) return false;\n\t    }\n\t\n\t    // 9 JWT id 'jti' check\n\t    if (pPayload.jti !== undefined && acceptField.jti !== undefined) {\n\t      if (pPayload.jti !== acceptField.jti) return false;\n\t    }\n\t\n\t    // 10 JWS signature check\n\t    if (! KJUR.jws.JWS.verify(sJWT, key, acceptField.alg)) return false;\n\t\n\t    // 11 passed all check\n\t    return true;\n\t};\n\t\n\t/**\n\t * check whether array is included by another array\n\t * @name includedArray\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {Array} a1 check whether set a1 is included by a2\n\t * @param {Array} a2 check whether set a1 is included by a2\n\t * @return {Boolean} check whether set a1 is included by a2\n\t * @since jws 3.2.3\n\t * This method verifies whether an array is included by another array.\n\t * It doesn't care about item ordering in a array.\n\t * @example\n\t * KJUR.jws.JWS.includedArray(['b'], ['b', 'c', 'a']) => true\n\t * KJUR.jws.JWS.includedArray(['a', 'b'], ['b', 'c', 'a']) => true\n\t * KJUR.jws.JWS.includedArray(['a', 'b'], ['b', 'c']) => false\n\t */\n\tKJUR.jws.JWS.includedArray = function(a1, a2) {\n\t    var inArray = KJUR.jws.JWS.inArray;\n\t    if (a1 === null) return false;\n\t    if (typeof a1 !== \"object\") return false;\n\t    if (typeof a1.length !== \"number\") return false;\n\t\n\t    for (var i = 0; i < a1.length; i++) {\n\t\tif (! inArray(a1[i], a2)) return false;\n\t    }\n\t    return true;\n\t};\n\t\n\t/**\n\t * check whether item is included by array\n\t * @name inArray\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} item check whether item is included by array\n\t * @param {Array} a check whether item is included by array\n\t * @return {Boolean} check whether item is included by array\n\t * @since jws 3.2.3\n\t * This method verifies whether an item is included by an array.\n\t * It doesn't care about item ordering in an array.\n\t * @example\n\t * KJUR.jws.JWS.inArray('b', ['b', 'c', 'a']) => true\n\t * KJUR.jws.JWS.inArray('a', ['b', 'c', 'a']) => true\n\t * KJUR.jws.JWS.inArray('a', ['b', 'c']) => false\n\t */\n\tKJUR.jws.JWS.inArray = function(item, a) {\n\t    if (a === null) return false;\n\t    if (typeof a !== \"object\") return false;\n\t    if (typeof a.length !== \"number\") return false;\n\t    for (var i = 0; i < a.length; i++) {\n\t\tif (a[i] == item) return true;\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\n\t * static associative array of general signature algorithm name from JWS algorithm name\n\t * @since jws 3.0.0\n\t */\n\tKJUR.jws.JWS.jwsalg2sigalg = {\n\t    \"HS256\":\t\"HmacSHA256\",\n\t    \"HS384\":\t\"HmacSHA384\",\n\t    \"HS512\":\t\"HmacSHA512\",\n\t    \"RS256\":\t\"SHA256withRSA\",\n\t    \"RS384\":\t\"SHA384withRSA\",\n\t    \"RS512\":\t\"SHA512withRSA\",\n\t    \"ES256\":\t\"SHA256withECDSA\",\n\t    \"ES384\":\t\"SHA384withECDSA\",\n\t    //\"ES512\":\t\"SHA512withECDSA\", // unsupported because of jsrsasign's bug\n\t    \"PS256\":\t\"SHA256withRSAandMGF1\",\n\t    \"PS384\":\t\"SHA384withRSAandMGF1\",\n\t    \"PS512\":\t\"SHA512withRSAandMGF1\",\n\t    \"none\":\t\"none\",\n\t};\n\t\n\t// === utility static method ==================================================\n\t\n\t/**\n\t * check whether a String \"s\" is a safe JSON string or not.<br/>\n\t * If a String \"s\" is a malformed JSON string or an other object type\n\t * this returns 0, otherwise this returns 1.\n\t * @name isSafeJSONString\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} s JSON string\n\t * @return {Number} 1 or 0\n\t */\n\tKJUR.jws.JWS.isSafeJSONString = function(s, h, p) {\n\t    var o = null;\n\t    try {\n\t\to = jsonParse(s);\n\t\tif (typeof o != \"object\") return 0;\n\t\tif (o.constructor === Array) return 0;\n\t\tif (h) h[p] = o;\n\t\treturn 1;\n\t    } catch (ex) {\n\t\treturn 0;\n\t    }\n\t};\n\t\n\t/**\n\t * read a String \"s\" as JSON object if it is safe.<br/>\n\t * If a String \"s\" is a malformed JSON string or not JSON string,\n\t * this returns null, otherwise returns JSON object.\n\t * @name readSafeJSONString\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} s JSON string\n\t * @return {Object} JSON object or null\n\t * @since 1.1.1\n\t */\n\tKJUR.jws.JWS.readSafeJSONString = function(s) {\n\t    var o = null;\n\t    try {\n\t\to = jsonParse(s);\n\t\tif (typeof o != \"object\") return null;\n\t\tif (o.constructor === Array) return null;\n\t\treturn o;\n\t    } catch (ex) {\n\t\treturn null;\n\t    }\n\t};\n\t\n\t/**\n\t * get Encoed Signature Value from JWS string.<br/>\n\t * @name getEncodedSignatureValueFromJWS\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {String} sJWS JWS signature string to be verified\n\t * @return {String} string of Encoded Signature Value \n\t * @throws if sJWS is not comma separated string such like \"Header.Payload.Signature\".\n\t */\n\tKJUR.jws.JWS.getEncodedSignatureValueFromJWS = function(sJWS) {\n\t    var matchResult = sJWS.match(/^[^.]+\\.[^.]+\\.([^.]+)$/);\n\t    if (matchResult == null) {\n\t\tthrow \"JWS signature is not a form of 'Head.Payload.SigValue'.\";\n\t    }\n\t    return matchResult[1];\n\t};\n\t\n\t/**\n\t * get RFC 7638 JWK thumbprint from JWK object\n\t * @name getJWKthumbprint\n\t * @memberOf KJUR.jws.JWS\n\t * @function\n\t * @static\n\t * @param {Object} o JWK object to be calculated thumbprint\n\t * @return {String} Base64 URL encoded JWK thumbprint value\n\t * @since jsrsasign 5.0.2 jws 3.3.2\n\t * @description\n\t * This method calculates JWK thmubprint for specified JWK object\n\t * as described in \n\t * <a href=\"https://tools.ietf.org/html/rfc7638\">RFC 7638</a>.\n\t * It supports all type of \"kty\". (i.e. \"RSA\", \"EC\" and \"oct\"\n\t * (for symmetric key))\n\t * Working sample is \n\t * <a href=\"https://kjur.github.io/jsrsasign/sample/tool_jwktp.html\">here</a>.\n\t * @example\n\t * jwk = {\"kty\":\"RSA\", \"n\":\"0vx...\", \"e\":\"AQAB\", ...};\n\t * thumbprint = KJUR.jws.JWS.getJWKthumbprint(jwk);\n\t */\n\tKJUR.jws.JWS.getJWKthumbprint = function(o) {\n\t    if (o.kty !== \"RSA\" &&\n\t\to.kty !== \"EC\" &&\n\t\to.kty !== \"oct\")\n\t\tthrow \"unsupported algorithm for JWK Thumprint\";\n\t\n\t    // 1. get canonically ordered json string\n\t    var s = '{';\n\t    if (o.kty === \"RSA\") {\n\t\tif (typeof o.n != \"string\" || typeof o.e != \"string\")\n\t\t    throw \"wrong n and e value for RSA key\";\n\t\ts += '\"' + 'e' + '\":\"' + o.e + '\",';\n\t\ts += '\"' + 'kty' + '\":\"' + o.kty + '\",';\n\t\ts += '\"' + 'n' + '\":\"' + o.n + '\"}';\n\t    } else if (o.kty === \"EC\") {\n\t\tif (typeof o.crv != \"string\" || \n\t\t    typeof o.x != \"string\" ||\n\t\t    typeof o.y != \"string\")\n\t\t    throw \"wrong crv, x and y value for EC key\";\n\t\ts += '\"' + 'crv' + '\":\"' + o.crv + '\",';\n\t\ts += '\"' + 'kty' + '\":\"' + o.kty + '\",';\n\t\ts += '\"' + 'x' + '\":\"' + o.x + '\",';\n\t\ts += '\"' + 'y' + '\":\"' + o.y + '\"}';\n\t    } else if (o.kty === \"oct\") {\n\t\tif (typeof o.k != \"string\")\n\t\t    throw \"wrong k value for oct(symmetric) key\";\n\t\ts += '\"' + 'kty' + '\":\"' + o.kty + '\",';\n\t\ts += '\"' + 'k' + '\":\"' + o.k + '\"}';\n\t    }\n\t    //alert(s);\n\t\n\t    // 2. get thumb print\n\t    var hJWK = rstrtohex(s);\n\t    var hash = KJUR.crypto.Util.hashHex(hJWK, \"sha256\");\n\t    var hashB64U = hextob64u(hash);\n\t\n\t    return hashB64U;\n\t};\n\t\n\t/**\n\t * IntDate class for time representation for JSON Web Token(JWT)\n\t * @class KJUR.jws.IntDate class\n\t * @name KJUR.jws.IntDate\n\t * @since jws 3.0.1\n\t * @description\n\t * Utility class for IntDate which is integer representation of UNIX origin time\n\t * used in JSON Web Token(JWT).\n\t */\n\tKJUR.jws.IntDate = {};\n\t\n\t/**\n\t * get UNIX origin time from by string\n\t * @name get\n\t * @memberOf KJUR.jws.IntDate\n\t * @function\n\t * @static\n\t * @param {String} s string of time representation\n\t * @return {Integer} UNIX origin time in seconds for argument 's'\n\t * @since jws 3.0.1\n\t * @throws \"unsupported format: s\" when malformed format\n\t * @description\n\t * This method will accept following representation of time.\n\t * <ul>\n\t * <li>now - current time</li>\n\t * <li>now + 1hour - after 1 hour from now</li>\n\t * <li>now + 1day - after 1 day from now</li>\n\t * <li>now + 1month - after 30 days from now</li>\n\t * <li>now + 1year - after 365 days from now</li>\n\t * <li>YYYYmmDDHHMMSSZ - UTC time (ex. 20130828235959Z)</li>\n\t * <li>number - UNIX origin time (seconds from 1970-01-01 00:00:00) (ex. 1377714748)</li>\n\t * </ul>\n\t */\n\tKJUR.jws.IntDate.get = function(s) {\n\t    if (s == \"now\") {\n\t\treturn KJUR.jws.IntDate.getNow();\n\t    } else if (s == \"now + 1hour\") {\n\t\treturn KJUR.jws.IntDate.getNow() + 60 * 60;\n\t    } else if (s == \"now + 1day\") {\n\t\treturn KJUR.jws.IntDate.getNow() + 60 * 60 * 24;\n\t    } else if (s == \"now + 1month\") {\n\t\treturn KJUR.jws.IntDate.getNow() + 60 * 60 * 24 * 30;\n\t    } else if (s == \"now + 1year\") {\n\t\treturn KJUR.jws.IntDate.getNow() + 60 * 60 * 24 * 365;\n\t    } else if (s.match(/Z$/)) {\n\t\treturn KJUR.jws.IntDate.getZulu(s);\n\t    } else if (s.match(/^[0-9]+$/)) {\n\t\treturn parseInt(s);\n\t    }\n\t    throw \"unsupported format: \" + s;\n\t};\n\t\n\t/**\n\t * get UNIX origin time from Zulu time representation string\n\t * @name getZulu\n\t * @memberOf KJUR.jws.IntDate\n\t * @function\n\t * @static\n\t * @param {String} s string of Zulu time representation (ex. 20151012125959Z)\n\t * @return {Integer} UNIX origin time in seconds for argument 's'\n\t * @since jws 3.0.1\n\t * @throws \"unsupported format: s\" when malformed format\n\t * @description\n\t * This method provides UNIX origin time from Zulu time.\n\t * Following representations are supported:\n\t * <ul>\n\t * <li>YYYYMMDDHHmmSSZ - GeneralizedTime format</li>\n\t * <li>YYMMDDHHmmSSZ - UTCTime format. If YY is greater or equal to \n\t * 50 then it represents 19YY otherwise 20YY.</li>\n\t * </ul>\n\t * @example\n\t * KJUR.jws.IntDate.getZulu(\"20151012125959Z\") => 1478...\n\t * KJUR.jws.IntDate.getZulu(\"151012125959Z\") => 1478...\n\t */\n\tKJUR.jws.IntDate.getZulu = function(s) {\n\t    var matchResult = s.match(/(\\d+)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)Z/);\n\t    if (matchResult) {\n\t        var sYear = matchResult[1];\n\t\tvar year = parseInt(sYear);\n\t\tif (sYear.length == 4) {\n\t        } else if (sYear.length == 2) {\n\t\t    if (50 <= year && year < 100) {\n\t\t\tyear = 1900 + year;\n\t\t    } else if (0 <= year && year < 50) {\n\t\t\tyear = 2000 + year;\n\t\t    } else {\n\t\t\tthrow \"malformed year string for UTCTime\";\n\t\t    }\n\t\t} else {\n\t\t    throw \"malformed year string\";\n\t\t}\n\t\tvar month = parseInt(matchResult[2]) - 1;\n\t\tvar day = parseInt(matchResult[3]);\n\t\tvar hour = parseInt(matchResult[4]);\n\t\tvar min = parseInt(matchResult[5]);\n\t\tvar sec = parseInt(matchResult[6]);\n\t\tvar d = new Date(Date.UTC(year, month, day, hour, min, sec));\n\t\treturn ~~(d / 1000);\n\t    }\n\t    throw \"unsupported format: \" + s;\n\t};\n\t\n\t/**\n\t * get UNIX origin time of current time\n\t * @name getNow\n\t * @memberOf KJUR.jws.IntDate\n\t * @function\n\t * @static\n\t * @return {Integer} UNIX origin time for current time\n\t * @since jws 3.0.1\n\t * @description\n\t * This method provides UNIX origin time for current time\n\t * @example\n\t * KJUR.jws.IntDate.getNow() => 1478...\n\t */\n\tKJUR.jws.IntDate.getNow = function() {\n\t    var d = ~~(new Date() / 1000);\n\t    return d;\n\t};\n\t\n\t/**\n\t * get UTC time string from UNIX origin time value\n\t * @name intDate2UTCString\n\t * @memberOf KJUR.jws.IntDate\n\t * @function\n\t * @static\n\t * @param {Integer} intDate UNIX origin time value (ex. 1478...)\n\t * @return {String} UTC time string\n\t * @since jws 3.0.1\n\t * @description\n\t * This method provides UTC time string for UNIX origin time value.\n\t * @example\n\t * KJUR.jws.IntDate.intDate2UTCString(1478...) => \"2015 Oct ...\"\n\t */\n\tKJUR.jws.IntDate.intDate2UTCString = function(intDate) {\n\t    var d = new Date(intDate * 1000);\n\t    return d.toUTCString();\n\t};\n\t\n\t/**\n\t * get UTC time string from UNIX origin time value\n\t * @name intDate2Zulu\n\t * @memberOf KJUR.jws.IntDate\n\t * @function\n\t * @static\n\t * @param {Integer} intDate UNIX origin time value (ex. 1478...)\n\t * @return {String} Zulu time string\n\t * @since jws 3.0.1\n\t * @description\n\t * This method provides Zulu time string for UNIX origin time value.\n\t * @example\n\t * KJUR.jws.IntDate.intDate2UTCString(1478...) => \"20151012...Z\"\n\t */\n\tKJUR.jws.IntDate.intDate2Zulu = function(intDate) {\n\t    var d = new Date(intDate * 1000);\n\t    var year = (\"0000\" + d.getUTCFullYear()).slice(-4);    \n\t    var mon =  (\"00\" + (d.getUTCMonth() + 1)).slice(-2);    \n\t    var day =  (\"00\" + d.getUTCDate()).slice(-2);    \n\t    var hour = (\"00\" + d.getUTCHours()).slice(-2);    \n\t    var min =  (\"00\" + d.getUTCMinutes()).slice(-2);    \n\t    var sec =  (\"00\" + d.getUTCSeconds()).slice(-2);    \n\t    return year + mon + day + hour + min + sec + \"Z\";\n\t};\n\t\n\t\n\t/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n\t */\n\t// Depends on jsbn.js and rng.js\n\t\n\t// Version 1.1: support utf-8 encoding in pkcs1pad2\n\t\n\t// convert a (hex) string to a bignum object\n\tfunction parseBigInt(str,r) {\n\t  return new BigInteger(str,r);\n\t}\n\t\n\tfunction linebrk(s,n) {\n\t  var ret = \"\";\n\t  var i = 0;\n\t  while(i + n < s.length) {\n\t    ret += s.substring(i,i+n) + \"\\n\";\n\t    i += n;\n\t  }\n\t  return ret + s.substring(i,s.length);\n\t}\n\t\n\tfunction byte2Hex(b) {\n\t  if(b < 0x10)\n\t    return \"0\" + b.toString(16);\n\t  else\n\t    return b.toString(16);\n\t}\n\t\n\t// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\n\tfunction pkcs1pad2(s,n) {\n\t  if(n < s.length + 11) { // TODO: fix for utf-8\n\t    alert(\"Message too long for RSA\");\n\t    return null;\n\t  }\n\t  var ba = new Array();\n\t  var i = s.length - 1;\n\t  while(i >= 0 && n > 0) {\n\t    var c = s.charCodeAt(i--);\n\t    if(c < 128) { // encode using utf-8\n\t      ba[--n] = c;\n\t    }\n\t    else if((c > 127) && (c < 2048)) {\n\t      ba[--n] = (c & 63) | 128;\n\t      ba[--n] = (c >> 6) | 192;\n\t    }\n\t    else {\n\t      ba[--n] = (c & 63) | 128;\n\t      ba[--n] = ((c >> 6) & 63) | 128;\n\t      ba[--n] = (c >> 12) | 224;\n\t    }\n\t  }\n\t  ba[--n] = 0;\n\t  var rng = new SecureRandom();\n\t  var x = new Array();\n\t  while(n > 2) { // random non-zero pad\n\t    x[0] = 0;\n\t    while(x[0] == 0) rng.nextBytes(x);\n\t    ba[--n] = x[0];\n\t  }\n\t  ba[--n] = 2;\n\t  ba[--n] = 0;\n\t  return new BigInteger(ba);\n\t}\n\t\n\t// PKCS#1 (OAEP) mask generation function\n\tfunction oaep_mgf1_arr(seed, len, hash)\n\t{\n\t    var mask = '', i = 0;\n\t\n\t    while (mask.length < len)\n\t    {\n\t        mask += hash(String.fromCharCode.apply(String, seed.concat([\n\t                (i & 0xff000000) >> 24,\n\t                (i & 0x00ff0000) >> 16,\n\t                (i & 0x0000ff00) >> 8,\n\t                i & 0x000000ff])));\n\t        i += 1;\n\t    }\n\t\n\t    return mask;\n\t}\n\t\n\t/**\n\t * PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\n\t * @name oaep_pad\n\t * @param s raw string of message\n\t * @param n key length of RSA key\n\t * @param hash JavaScript function to calculate raw hash value from raw string or algorithm name (ex. \"SHA1\") \n\t * @param hashLen byte length of resulted hash value (ex. 20 for SHA1)\n\t * @return {BigInteger} BigInteger object of resulted PKCS#1 OAEP padded message\n\t * @description\n\t * This function calculates OAEP padded message from original message.<br/>\n\t * NOTE: Since jsrsasign 6.2.0, 'hash' argument can accept an algorithm name such as \"sha1\".\n\t * @example\n\t * oaep_pad(\"aaa\", 128) &rarr; big integer object // SHA-1 by default\n\t * oaep_pad(\"aaa\", 128, function(s) {...}, 20);\n\t * oaep_pad(\"aaa\", 128, \"sha1\");\n\t */\n\tfunction oaep_pad(s, n, hash, hashLen) {\n\t    var MD = KJUR.crypto.MessageDigest;\n\t    var Util = KJUR.crypto.Util;\n\t    var algName = null;\n\t\n\t    if (!hash) hash = \"sha1\";\n\t\n\t    if (typeof hash === \"string\") {\n\t\talgName = MD.getCanonicalAlgName(hash);\n\t\thashLen = MD.getHashLength(algName);\n\t        hash = function(s) { return hextorstr(Util.hashString(s, algName)); };\n\t    }\n\t\n\t    if (s.length + 2 * hashLen + 2 > n) {\n\t        throw \"Message too long for RSA\";\n\t    }\n\t\n\t    var PS = '', i;\n\t\n\t    for (i = 0; i < n - s.length - 2 * hashLen - 2; i += 1) {\n\t        PS += '\\x00';\n\t    }\n\t\n\t    var DB = hash('') + PS + '\\x01' + s;\n\t    var seed = new Array(hashLen);\n\t    new SecureRandom().nextBytes(seed);\n\t    \n\t    var dbMask = oaep_mgf1_arr(seed, DB.length, hash);\n\t    var maskedDB = [];\n\t\n\t    for (i = 0; i < DB.length; i += 1) {\n\t        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n\t    }\n\t\n\t    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, hash);\n\t    var maskedSeed = [0];\n\t\n\t    for (i = 0; i < seed.length; i += 1) {\n\t        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n\t    }\n\t\n\t    return new BigInteger(maskedSeed.concat(maskedDB));\n\t}\n\t\n\t// \"empty\" RSA key constructor\n\tfunction RSAKey() {\n\t  this.n = null;\n\t  this.e = 0;\n\t  this.d = null;\n\t  this.p = null;\n\t  this.q = null;\n\t  this.dmp1 = null;\n\t  this.dmq1 = null;\n\t  this.coeff = null;\n\t}\n\t\n\t// Set the public key fields N and e from hex strings\n\tfunction RSASetPublic(N,E) {\n\t  this.isPublic = true;\n\t  if (typeof N !== \"string\") \n\t  {\n\t    this.n = N;\n\t    this.e = E;\n\t  }\n\t  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n\t    this.n = parseBigInt(N,16);\n\t    this.e = parseInt(E,16);\n\t  }\n\t  else\n\t    alert(\"Invalid RSA public key\");\n\t}\n\t\n\t// Perform raw public operation on \"x\": return x^e (mod n)\n\tfunction RSADoPublic(x) {\n\t  return x.modPowInt(this.e, this.n);\n\t}\n\t\n\t// Return the PKCS#1 RSA encryption of \"text\" as an even-length hex string\n\tfunction RSAEncrypt(text) {\n\t  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n\t  if(m == null) return null;\n\t  var c = this.doPublic(m);\n\t  if(c == null) return null;\n\t  var h = c.toString(16);\n\t  if((h.length & 1) == 0) return h; else return \"0\" + h;\n\t}\n\t\n\t// Return the PKCS#1 OAEP RSA encryption of \"text\" as an even-length hex string\n\tfunction RSAEncryptOAEP(text, hash, hashLen) {\n\t  var m = oaep_pad(text, (this.n.bitLength() + 7) >> 3, hash, hashLen);\n\t  if(m == null) return null;\n\t  var c = this.doPublic(m);\n\t  if(c == null) return null;\n\t  var h = c.toString(16);\n\t  if((h.length & 1) == 0) return h; else return \"0\" + h;\n\t}\n\t\n\t// Return the PKCS#1 RSA encryption of \"text\" as a Base64-encoded string\n\t//function RSAEncryptB64(text) {\n\t//  var h = this.encrypt(text);\n\t//  if(h) return hex2b64(h); else return null;\n\t//}\n\t\n\t// protected\n\tRSAKey.prototype.doPublic = RSADoPublic;\n\t\n\t// public\n\tRSAKey.prototype.setPublic = RSASetPublic;\n\tRSAKey.prototype.encrypt = RSAEncrypt;\n\tRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n\t//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n\t\n\tRSAKey.prototype.type = \"RSA\";\n\t\n\t/*! CryptoJS v3.1.2 core-fix.js\n\t * code.google.com/p/crypto-js\n\t * (c) 2009-2013 by Jeff Mott. All rights reserved.\n\t * code.google.com/p/crypto-js/wiki/License\n\t * THIS IS FIX of 'core.js' to fix Hmac issue.\n\t * https://code.google.com/p/crypto-js/issues/detail?id=84\n\t * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js\n\t */\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\t\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\t\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\t        function F() {}\n\t\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                F.prototype = this;\n\t                var subtype = new F();\n\t\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\t\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init')) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\t\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\t\n\t                // Reference supertype\n\t                subtype.$super = this;\n\t\n\t                return subtype;\n\t            },\n\t\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\t\n\t                return instance;\n\t            },\n\t\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\t\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\t\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\t\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\t\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\t\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\t\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\t\n\t            // Clamp excess bits\n\t            this.clamp();\n\t\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\t\n\t            // Chainable\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\t\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\t\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\t\n\t            return clone;\n\t        },\n\t\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push((Math.random() * 0x100000000) | 0);\n\t            }\n\t\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\t\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\t\n\t            return hexChars.join('');\n\t        },\n\t\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\t\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\t\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\t\n\t            return latin1Chars.join('');\n\t        },\n\t\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\t\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\t\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\t\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\t\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\t\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\t\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\t\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\t\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\t\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\t\n\t                // Remove processed words\n\t                var processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\t\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\t\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\t\n\t            return clone;\n\t        },\n\t\n\t        _minBufferSize: 0\n\t    });\n\t\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\t\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\t\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\t\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\t\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\t\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\t\n\t            // Update the hash\n\t            this._process();\n\t\n\t            // Chainable\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\t\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\t\n\t            return hash;\n\t        },\n\t\n\t        blockSize: 512/32,\n\t\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\t\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\t\n\t    return C;\n\t}(Math));\n\t\n\t/*\n\tCryptoJS v3.1.2\n\tcode.google.com/p/crypto-js\n\t(c) 2009-2013 by Jeff Mott. All rights reserved.\n\tcode.google.com/p/crypto-js/wiki/License\n\t*/\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\t\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\t\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\t\n\t            return true;\n\t        }\n\t\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\t\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\t\n\t                nPrime++;\n\t            }\n\t\n\t            n++;\n\t        }\n\t    }());\n\t\n\t    // Reusable object\n\t    var W = [];\n\t\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\t\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\t\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\t\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\t\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\t\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\t\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\t\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\t\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\t\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\t\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\t\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\t\n\t            // Hash final blocks\n\t            this._process();\n\t\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\t\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\t\n\t            return clone;\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\t\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\t\n\t/*! keyutil-1.0.14.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n\t */\n\t/*\n\t * keyutil.js - key utility for PKCS#1/5/8 PEM, RSA/DSA/ECDSA key object\n\t *\n\t * Copyright (c) 2013-2016 Kenji Urushima (kenji.urushima@gmail.com)\n\t *\n\t * This software is licensed under the terms of the MIT License.\n\t * http://kjur.github.com/jsrsasign/license\n\t *\n\t * The above copyright and license notice shall be \n\t * included in all copies or substantial portions of the Software.\n\t */\n\t/**\n\t * @fileOverview\n\t * @name keyutil-1.0.js\n\t * @author Kenji Urushima kenji.urushima@gmail.com\n\t * @version keyutil 1.0.14 (2016-Oct-08)\n\t * @since jsrsasign 4.1.4\n\t * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n\t */\n\t\n\t/**\n\t * @name KEYUTIL\n\t * @class class for RSA/ECC/DSA key utility\n\t * @description \n\t * <br/>\n\t * {@link KEYUTIL} class is an update of former {@link PKCS5PKEY} class.\n\t * So for now, {@link PKCS5PKEY} is deprecated class.\n\t * {@link KEYUTIL} class has following features:\n\t * <dl>\n\t * <dt><b>key loading - {@link KEYUTIL.getKey}</b>\n\t * <dd>\n\t * <ul>\n\t * <li>supports RSAKey and KJUR.crypto.{ECDSA,DSA} key object</li>\n\t * <li>supports private key and public key</li>\n\t * <li>supports encrypted and plain private key</li>\n\t * <li>supports PKCS#1, PKCS#5 and PKCS#8 key</li>\n\t * <li>supports public key in X.509 certificate</li>\n\t * <li>key represented by JSON object</li>\n\t * </ul>\n\t * NOTE1: Encrypted PKCS#8 only supports PBKDF2/HmacSHA1/3DES <br/>\n\t * NOTE2: Encrypted PKCS#5 supports DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC <br/>\n\t *\n\t * <dt><b>exporting key - {@link KEYUTIL.getPEM}</b>\n\t * <dd>\n\t * {@link KEYUTIL.getPEM} method supports following formats:\n\t * <ul>\n\t * <li>supports RSA/EC/DSA keys</li>\n\t * <li>PKCS#1 plain RSA/EC/DSA private key</li>\n\t * <li>PKCS#5 encrypted RSA/EC/DSA private key with DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC</li>\n\t * <li>PKCS#8 plain RSA/EC/DSA private key</li>\n\t * <li>PKCS#8 encrypted RSA/EC/DSA private key with PBKDF2_HmacSHA1_3DES</li>\n\t * </ul>\n\t *\n\t * <dt><b>keypair generation - {@link KEYUTIL.generateKeypair}</b>\n\t * <ul>\n\t * <li>generate key pair of {@link RSAKey} or {@link KJUR.crypto.ECDSA}.</li>\n\t * <li>generate private key and convert it to PKCS#5 encrypted private key.</li>\n\t * </ul>\n\t * NOTE: {@link KJUR.crypto.DSA} is not yet supported.\n\t * </dl>\n\t * \n\t * @example\n\t * // 1. loading PEM private key\n\t * var key = KEYUTIL.getKey(pemPKCS1PrivateKey);\n\t * var key = KEYUTIL.getKey(pemPKCS5EncryptedPrivateKey, \"passcode\");\n\t * var key = KEYUTIL.getKey(pemPKC85PlainPrivateKey);\n\t * var key = KEYUTIL.getKey(pemPKC85EncryptedPrivateKey, \"passcode\");\n\t * // 2. loading PEM public key\n\t * var key = KEYUTIL.getKey(pemPKCS8PublicKey);\n\t * var key = KEYUTIL.getKey(pemX509Certificate);\n\t * // 3. exporting private key\n\t * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS1PRV\");\n\t * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS5PRV\", \"passcode\"); // DES-EDE3-CBC by default\n\t * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS5PRV\", \"passcode\", \"DES-CBC\");\n\t * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS8PRV\");\n\t * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS8PRV\", \"passcode\");\n\t * // 4. exporting public key\n\t * var pem = KEYUTIL.getPEM(publicKeyObj);\n\t */\n\t/*\n\t * DEPRECATED METHODS\n\t * GET PKCS8\n\t * KEYUTIL.getRSAKeyFromPlainPKCS8PEM\n\t * KEYUTIL.getRSAKeyFromPlainPKCS8Hex\n\t * KEYUTIL.getRSAKeyFromEncryptedPKCS8PEM\n\t * P8 UTIL (make internal use)\n\t * KEYUTIL.getPlainPKCS8HexFromEncryptedPKCS8PEM\n\t * GET PKCS8 PUB\n\t * KEYUTIL.getKeyFromPublicPKCS8PEM\n\t * KEYUTIL.getKeyFromPublicPKCS8Hex\n\t * KEYUTIL.getRSAKeyFromPublicPKCS8PEM\n\t * KEYUTIL.getRSAKeyFromPublicPKCS8Hex\n\t * GET PKCS5\n\t * KEYUTIL.getRSAKeyFromEncryptedPKCS5PEM\n\t * PUT PKCS5\n\t * KEYUTIL.getEncryptedPKCS5PEMFromRSAKey\n\t * OTHER METHODS (FOR INTERNAL?)\n\t * KEYUTIL.getHexFromPEM\n\t * KEYUTIL.getDecryptedKeyHexByKeyIV\n\t */\n\tvar KEYUTIL = function() {\n\t    // *****************************************************************\n\t    // *** PRIVATE PROPERTIES AND METHODS *******************************\n\t    // *****************************************************************\n\t    // shared key decryption ------------------------------------------\n\t    var decryptAES = function(dataHex, keyHex, ivHex) {\n\t        return decryptGeneral(CryptoJS.AES, dataHex, keyHex, ivHex);\n\t    };\n\t\n\t    var decrypt3DES = function(dataHex, keyHex, ivHex) {\n\t        return decryptGeneral(CryptoJS.TripleDES, dataHex, keyHex, ivHex);\n\t    };\n\t\n\t    var decryptDES = function(dataHex, keyHex, ivHex) {\n\t        return decryptGeneral(CryptoJS.DES, dataHex, keyHex, ivHex);\n\t    };\n\t\n\t    var decryptGeneral = function(f, dataHex, keyHex, ivHex) {\n\t        var data = CryptoJS.enc.Hex.parse(dataHex);\n\t        var key = CryptoJS.enc.Hex.parse(keyHex);\n\t        var iv = CryptoJS.enc.Hex.parse(ivHex);\n\t        var encrypted = {};\n\t        encrypted.key = key;\n\t        encrypted.iv = iv;\n\t        encrypted.ciphertext = data;\n\t        var decrypted = f.decrypt(encrypted, key, { iv: iv });\n\t        return CryptoJS.enc.Hex.stringify(decrypted);\n\t    };\n\t\n\t    // shared key decryption ------------------------------------------\n\t    var encryptAES = function(dataHex, keyHex, ivHex) {\n\t        return encryptGeneral(CryptoJS.AES, dataHex, keyHex, ivHex);\n\t    };\n\t\n\t    var encrypt3DES = function(dataHex, keyHex, ivHex) {\n\t        return encryptGeneral(CryptoJS.TripleDES, dataHex, keyHex, ivHex);\n\t    };\n\t\n\t    var encryptDES = function(dataHex, keyHex, ivHex) {\n\t        return encryptGeneral(CryptoJS.DES, dataHex, keyHex, ivHex);\n\t    };\n\t\n\t    var encryptGeneral = function(f, dataHex, keyHex, ivHex) {\n\t        var data = CryptoJS.enc.Hex.parse(dataHex);\n\t        var key = CryptoJS.enc.Hex.parse(keyHex);\n\t        var iv = CryptoJS.enc.Hex.parse(ivHex);\n\t        var encryptedHex = f.encrypt(data, key, { iv: iv });\n\t        var encryptedWA = CryptoJS.enc.Hex.parse(encryptedHex.toString());\n\t        var encryptedB64 = CryptoJS.enc.Base64.stringify(encryptedWA);\n\t        return encryptedB64;\n\t    };\n\t\n\t    // other methods and properties ----------------------------------------\n\t    var ALGLIST = {\n\t        'AES-256-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 32, ivlen: 16 },\n\t        'AES-192-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 24, ivlen: 16 },\n\t        'AES-128-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 16, ivlen: 16 },\n\t        'DES-EDE3-CBC': { 'proc': decrypt3DES, 'eproc': encrypt3DES, keylen: 24, ivlen: 8 },\n\t        'DES-CBC':      { 'proc': decryptDES,  'eproc': encryptDES,  keylen: 8,  ivlen: 8 }\n\t    };\n\t\n\t    var getFuncByName = function(algName) {\n\t        return ALGLIST[algName]['proc'];\n\t    };\n\t\n\t    var _generateIvSaltHex = function(numBytes) {\n\t        var wa = CryptoJS.lib.WordArray.random(numBytes);\n\t        var hex = CryptoJS.enc.Hex.stringify(wa);\n\t        return hex;\n\t    };\n\t\n\t    var _parsePKCS5PEM = function(sPKCS5PEM) {\n\t        var info = {};\n\t        var matchResult1 = sPKCS5PEM.match(new RegExp(\"DEK-Info: ([^,]+),([0-9A-Fa-f]+)\", \"m\"));\n\t        if (matchResult1) {\n\t            info.cipher = matchResult1[1];\n\t            info.ivsalt = matchResult1[2];\n\t        }\n\t        var matchResult2 = sPKCS5PEM.match(new RegExp(\"-----BEGIN ([A-Z]+) PRIVATE KEY-----\"));\n\t        if (matchResult2) {\n\t            info.type = matchResult2[1];\n\t        }\n\t        var i1 = -1;\n\t        var lenNEWLINE = 0;\n\t        if (sPKCS5PEM.indexOf(\"\\r\\n\\r\\n\") != -1) {\n\t            i1 = sPKCS5PEM.indexOf(\"\\r\\n\\r\\n\");\n\t            lenNEWLINE = 2;\n\t        }\n\t        if (sPKCS5PEM.indexOf(\"\\n\\n\") != -1) {\n\t            i1 = sPKCS5PEM.indexOf(\"\\n\\n\");\n\t            lenNEWLINE = 1;\n\t        }\n\t        var i2 = sPKCS5PEM.indexOf(\"-----END\");\n\t        if (i1 != -1 && i2 != -1) {\n\t            var s = sPKCS5PEM.substring(i1 + lenNEWLINE * 2, i2 - lenNEWLINE);\n\t            s = s.replace(/\\s+/g, '');\n\t            info.data = s;\n\t        }\n\t        return info;\n\t    };\n\t\n\t    var _getKeyAndUnusedIvByPasscodeAndIvsalt = function(algName, passcode, ivsaltHex) {\n\t        //alert(\"ivsaltHex(2) = \" + ivsaltHex);\n\t        var saltHex = ivsaltHex.substring(0, 16);\n\t        //alert(\"salt = \" + saltHex);\n\t        \n\t        var salt = CryptoJS.enc.Hex.parse(saltHex);\n\t        var data = CryptoJS.enc.Utf8.parse(passcode);\n\t        //alert(\"salt = \" + salt);\n\t        //alert(\"data = \" + data);\n\t\n\t        var nRequiredBytes = ALGLIST[algName]['keylen'] + ALGLIST[algName]['ivlen'];\n\t        var hHexValueJoined = '';\n\t        var hLastValue = null;\n\t        //alert(\"nRequiredBytes = \" + nRequiredBytes);\n\t        for (;;) {\n\t            var h = CryptoJS.algo.MD5.create();\n\t            if (hLastValue != null) {\n\t                h.update(hLastValue);\n\t            }\n\t            h.update(data);\n\t            h.update(salt);\n\t            hLastValue = h.finalize();\n\t            hHexValueJoined = hHexValueJoined + CryptoJS.enc.Hex.stringify(hLastValue);\n\t            //alert(\"joined = \" + hHexValueJoined);\n\t            if (hHexValueJoined.length >= nRequiredBytes * 2) {\n\t                break;\n\t            }\n\t        }\n\t        var result = {};\n\t        result.keyhex = hHexValueJoined.substr(0, ALGLIST[algName]['keylen'] * 2);\n\t        result.ivhex = hHexValueJoined.substr(ALGLIST[algName]['keylen'] * 2, ALGLIST[algName]['ivlen'] * 2);\n\t        return result;\n\t    };\n\t\n\t    /*\n\t     * @param {String} privateKeyB64 base64 string of encrypted private key\n\t     * @param {String} sharedKeyAlgName algorithm name of shared key encryption\n\t     * @param {String} sharedKeyHex hexadecimal string of shared key to encrypt\n\t     * @param {String} ivsaltHex hexadecimal string of IV and salt\n\t     * @param {String} hexadecimal string of decrypted private key\n\t     */\n\t    var _decryptKeyB64 = function(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {\n\t        var privateKeyWA = CryptoJS.enc.Base64.parse(privateKeyB64);\n\t        var privateKeyHex = CryptoJS.enc.Hex.stringify(privateKeyWA);\n\t        var f = ALGLIST[sharedKeyAlgName]['proc'];\n\t        var decryptedKeyHex = f(privateKeyHex, sharedKeyHex, ivsaltHex);\n\t        return decryptedKeyHex;\n\t    };\n\t    \n\t    /*\n\t     * @param {String} privateKeyHex hexadecimal string of private key\n\t     * @param {String} sharedKeyAlgName algorithm name of shared key encryption\n\t     * @param {String} sharedKeyHex hexadecimal string of shared key to encrypt\n\t     * @param {String} ivsaltHex hexadecimal string of IV and salt\n\t     * @param {String} base64 string of encrypted private key\n\t     */\n\t    var _encryptKeyHex = function(privateKeyHex, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {\n\t        var f = ALGLIST[sharedKeyAlgName]['eproc'];\n\t        var encryptedKeyB64 = f(privateKeyHex, sharedKeyHex, ivsaltHex);\n\t        return encryptedKeyB64;\n\t    };\n\t\n\t    // *****************************************************************\n\t    // *** PUBLIC PROPERTIES AND METHODS *******************************\n\t    // *****************************************************************\n\t    return {\n\t        // -- UTILITY METHODS ------------------------------------------------------------\n\t        /**\n\t         * decrypt private key by shared key\n\t         * @name version\n\t         * @memberOf KEYUTIL\n\t         * @property {String} version\n\t         * @description version string of KEYUTIL class\n\t         */\n\t        version: \"1.0.0\",\n\t\n\t        /**\n\t         * get hexacedimal string of PEM format\n\t         * @name getHexFromPEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} sPEM PEM formatted string\n\t         * @param {String} sHead PEM header string without BEGIN/END\n\t         * @return {String} hexadecimal string data of PEM contents\n\t         * @since pkcs5pkey 1.0.5\n\t         */\n\t        getHexFromPEM: function(sPEM, sHead) {\n\t            var s = sPEM;\n\t            if (s.indexOf(\"-----BEGIN \") == -1) {\n\t                throw \"can't find PEM header: \" + sHead;\n\t            }\n\t            if (typeof sHead == \"string\" && sHead != \"\") {\n\t                s = s.replace(\"-----BEGIN \" + sHead + \"-----\", \"\");\n\t                s = s.replace(\"-----END \" + sHead + \"-----\", \"\");\n\t            } else {\n\t                s = s.replace(/-----BEGIN [^-]+-----/, '');\n\t                s = s.replace(/-----END [^-]+-----/, '');\n\t            }\n\t            var sB64 = s.replace(/\\s+/g, '');\n\t            var dataHex = b64tohex(sB64);\n\t            return dataHex;\n\t        },\n\t\n\t        /**\n\t         * decrypt private key by shared key\n\t         * @name getDecryptedKeyHexByKeyIV\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} encryptedKeyHex hexadecimal string of encrypted private key\n\t         * @param {String} algName name of symmetric key algorithm (ex. 'DES-EBE3-CBC')\n\t         * @param {String} sharedKeyHex hexadecimal string of symmetric key\n\t         * @param {String} ivHex hexadecimal string of initial vector(IV).\n\t         * @return {String} hexadecimal string of decrypted privated key\n\t         */\n\t        getDecryptedKeyHexByKeyIV: function(encryptedKeyHex, algName, sharedKeyHex, ivHex) {\n\t            var f1 = getFuncByName(algName);\n\t            return f1(encryptedKeyHex, sharedKeyHex, ivHex);\n\t        },\n\t\n\t        /**\n\t         * parse PEM formatted passcode protected PKCS#5 private key\n\t         * @name parsePKCS5PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} sEncryptedPEM PEM formatted protected passcode protected PKCS#5 private key\n\t         * @return {Hash} hash of key information\n\t         * @description\n\t         * Resulted hash has following attributes.\n\t         * <ul>\n\t         * <li>cipher - symmetric key algorithm name (ex. 'DES-EBE3-CBC', 'AES-256-CBC')</li>\n\t         * <li>ivsalt - IV used for decrypt. Its heading 8 bytes will be used for passcode salt.</li>\n\t         * <li>type - asymmetric key algorithm name of private key described in PEM header.</li>\n\t         * <li>data - base64 encoded encrypted private key.</li>\n\t         * </ul>\n\t         *\n\t         */\n\t        parsePKCS5PEM: function(sPKCS5PEM) {\n\t            return _parsePKCS5PEM(sPKCS5PEM);\n\t        },\n\t\n\t        /**\n\t         * the same function as OpenSSL EVP_BytsToKey to generate shared key and IV\n\t         * @name getKeyAndUnusedIvByPasscodeAndIvsalt\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} algName name of symmetric key algorithm (ex. 'DES-EBE3-CBC')\n\t         * @param {String} passcode passcode to decrypt private key (ex. 'password')\n\t         * @param {String} hexadecimal string of IV. heading 8 bytes will be used for passcode salt\n\t         * @return {Hash} hash of key and unused IV (ex. {keyhex:2fe3..., ivhex:3fad..})\n\t         */\n\t        getKeyAndUnusedIvByPasscodeAndIvsalt: function(algName, passcode, ivsaltHex) {\n\t            return _getKeyAndUnusedIvByPasscodeAndIvsalt(algName, passcode, ivsaltHex);\n\t        },\n\t\n\t        decryptKeyB64: function(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {\n\t            return _decryptKeyB64(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex);\n\t        },\n\t\n\t        /**\n\t         * decrypt PEM formatted protected PKCS#5 private key with passcode\n\t         * @name getDecryptedKeyHex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} sEncryptedPEM PEM formatted protected passcode protected PKCS#5 private key\n\t         * @param {String} passcode passcode to decrypt private key (ex. 'password')\n\t         * @return {String} hexadecimal string of decrypted RSA priavte key\n\t         */\n\t        getDecryptedKeyHex: function(sEncryptedPEM, passcode) {\n\t            // 1. parse pem\n\t            var info = _parsePKCS5PEM(sEncryptedPEM);\n\t            var publicKeyAlgName = info.type;\n\t            var sharedKeyAlgName = info.cipher;\n\t            var ivsaltHex = info.ivsalt;\n\t            var privateKeyB64 = info.data;\n\t            //alert(\"ivsaltHex = \" + ivsaltHex);\n\t\n\t            // 2. generate shared key\n\t            var sharedKeyInfo = _getKeyAndUnusedIvByPasscodeAndIvsalt(sharedKeyAlgName, passcode, ivsaltHex);\n\t            var sharedKeyHex = sharedKeyInfo.keyhex;\n\t            //alert(\"sharedKeyHex = \" + sharedKeyHex);\n\t\n\t            // 3. decrypt private key\n\t            var decryptedKey = _decryptKeyB64(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex);\n\t            return decryptedKey;\n\t        },\n\t\n\t        /**\n\t         * (DEPRECATED) read PEM formatted encrypted PKCS#5 private key and returns RSAKey object\n\t         * @name getRSAKeyFromEncryptedPKCS5PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} sEncryptedP5PEM PEM formatted encrypted PKCS#5 private key\n\t         * @param {String} passcode passcode to decrypt private key\n\t         * @return {RSAKey} loaded RSAKey object of RSA private key\n\t         * @since pkcs5pkey 1.0.2\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         */\n\t        getRSAKeyFromEncryptedPKCS5PEM: function(sEncryptedP5PEM, passcode) {\n\t            var hPKey = this.getDecryptedKeyHex(sEncryptedP5PEM, passcode);\n\t            var rsaKey = new RSAKey();\n\t            rsaKey.readPrivateKeyFromASN1HexString(hPKey);\n\t            return rsaKey;\n\t        },\n\t\n\t        /*\n\t         * get PEM formatted encrypted PKCS#5 private key from hexadecimal string of plain private key\n\t         * @name getEncryptedPKCS5PEMFromPrvKeyHex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pemHeadAlg algorithm name in the pem header (i.e. RSA,EC or DSA)\n\t         * @param {String} hPrvKey hexadecimal string of plain private key\n\t         * @param {String} passcode pass code to protect private key (ex. password)\n\t         * @param {String} sharedKeyAlgName algorithm name to protect private key (ex. AES-256-CBC)\n\t         * @param {String} ivsaltHex hexadecimal string of IV and salt\n\t         * @return {String} string of PEM formatted encrypted PKCS#5 private key\n\t         * @since pkcs5pkey 1.0.2\n\t         * @description\n\t         * <br/>\n\t         * generate PEM formatted encrypted PKCS#5 private key by hexadecimal string encoded\n\t         * ASN.1 object of plain RSA private key.\n\t         * Following arguments can be omitted.\n\t         * <ul>\n\t         * <li>alg - AES-256-CBC will be used if omitted.</li>\n\t         * <li>ivsaltHex - automatically generate IV and salt which length depends on algorithm</li>\n\t         * </ul>\n\t         * NOTE1: DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC algorithm are supported.\n\t         * @example\n\t         * var pem = \n\t         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, \"password\");\n\t         * var pem2 = \n\t         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, \"password\", \"AES-128-CBC\");\n\t         * var pem3 = \n\t         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, \"password\", \"AES-128-CBC\", \"1f3d02...\");\n\t         */\n\t        getEncryptedPKCS5PEMFromPrvKeyHex: function(pemHeadAlg, hPrvKey, passcode, sharedKeyAlgName, ivsaltHex) {\n\t            var sPEM = \"\";\n\t\n\t            // 1. set sharedKeyAlgName if undefined (default AES-256-CBC)\n\t            if (typeof sharedKeyAlgName == \"undefined\" || sharedKeyAlgName == null) {\n\t                sharedKeyAlgName = \"AES-256-CBC\";\n\t            }\n\t            if (typeof ALGLIST[sharedKeyAlgName] == \"undefined\")\n\t                throw \"KEYUTIL unsupported algorithm: \" + sharedKeyAlgName;\n\t\n\t            // 2. set ivsaltHex if undefined\n\t            if (typeof ivsaltHex == \"undefined\" || ivsaltHex == null) {\n\t                var ivlen = ALGLIST[sharedKeyAlgName]['ivlen'];\n\t                var randIV = _generateIvSaltHex(ivlen);\n\t                ivsaltHex = randIV.toUpperCase();\n\t            }\n\t\n\t            // 3. get shared key\n\t            //alert(\"ivsalthex=\" + ivsaltHex);\n\t            var sharedKeyInfo = _getKeyAndUnusedIvByPasscodeAndIvsalt(sharedKeyAlgName, passcode, ivsaltHex);\n\t            var sharedKeyHex = sharedKeyInfo.keyhex;\n\t            // alert(\"sharedKeyHex = \" + sharedKeyHex);\n\t\n\t            // 3. get encrypted Key in Base64\n\t            var encryptedKeyB64 = _encryptKeyHex(hPrvKey, sharedKeyAlgName, sharedKeyHex, ivsaltHex);\n\t\n\t            var pemBody = encryptedKeyB64.replace(/(.{64})/g, \"$1\\r\\n\");\n\t            var sPEM = \"-----BEGIN \" + pemHeadAlg + \" PRIVATE KEY-----\\r\\n\";\n\t            sPEM += \"Proc-Type: 4,ENCRYPTED\\r\\n\";\n\t            sPEM += \"DEK-Info: \" + sharedKeyAlgName + \",\" + ivsaltHex + \"\\r\\n\";\n\t            sPEM += \"\\r\\n\";\n\t            sPEM += pemBody;\n\t            sPEM += \"\\r\\n-----END \" + pemHeadAlg + \" PRIVATE KEY-----\\r\\n\";\n\t\n\t            return sPEM;\n\t        },\n\t\n\t        /**\n\t         * (DEPRECATED) get PEM formatted encrypted PKCS#5 private key from RSAKey object of private key\n\t         * @name getEncryptedPKCS5PEMFromRSAKey\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {RSAKey} pKey RSAKey object of private key\n\t         * @param {String} passcode pass code to protect private key (ex. password)\n\t         * @param {String} alg algorithm name to protect private key (default AES-256-CBC)\n\t         * @param {String} ivsaltHex hexadecimal string of IV and salt (default generated random IV)\n\t         * @return {String} string of PEM formatted encrypted PKCS#5 private key\n\t         * @since pkcs5pkey 1.0.2\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getPEM#}.\n\t         * @description\n\t         * <br/>\n\t         * generate PEM formatted encrypted PKCS#5 private key by\n\t         * {@link RSAKey} object of RSA private key and passcode.\n\t         * Following argument can be omitted.\n\t         * <ul>\n\t         * <li>alg - AES-256-CBC will be used if omitted.</li>\n\t         * <li>ivsaltHex - automatically generate IV and salt which length depends on algorithm</li>\n\t         * </ul>\n\t         * @example\n\t         * var pkey = new RSAKey();\n\t         * pkey.generate(1024, '10001'); // generate 1024bit RSA private key with public exponent 'x010001'\n\t         * var pem = KEYUTIL.getEncryptedPKCS5PEMFromRSAKey(pkey, \"password\");\n\t         */\n\t        getEncryptedPKCS5PEMFromRSAKey: function(pKey, passcode, alg, ivsaltHex) {\n\t            var version = new KJUR.asn1.DERInteger({'int': 0});\n\t            var n = new KJUR.asn1.DERInteger({'bigint': pKey.n});\n\t            var e = new KJUR.asn1.DERInteger({'int': pKey.e});\n\t            var d = new KJUR.asn1.DERInteger({'bigint': pKey.d});\n\t            var p = new KJUR.asn1.DERInteger({'bigint': pKey.p});\n\t            var q = new KJUR.asn1.DERInteger({'bigint': pKey.q});\n\t            var dmp1 = new KJUR.asn1.DERInteger({'bigint': pKey.dmp1});\n\t            var dmq1 = new KJUR.asn1.DERInteger({'bigint': pKey.dmq1});\n\t            var coeff = new KJUR.asn1.DERInteger({'bigint': pKey.coeff});\n\t            var seq = new KJUR.asn1.DERSequence({'array': [version, n, e, d, p, q, dmp1, dmq1, coeff]});\n\t            var hex = seq.getEncodedHex();\n\t            return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"RSA\", hex, passcode, alg, ivsaltHex);\n\t        },\n\t\n\t        /**\n\t         * generate RSAKey and PEM formatted encrypted PKCS#5 private key\n\t         * @name newEncryptedPKCS5PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} passcode pass code to protect private key (ex. password)\n\t         * @param {Integer} keyLen key bit length of RSA key to be generated. (default 1024)\n\t         * @param {String} hPublicExponent hexadecimal string of public exponent (default 10001)\n\t         * @param {String} alg shared key algorithm to encrypt private key (default AES-258-CBC)\n\t         * @return {String} string of PEM formatted encrypted PKCS#5 private key\n\t         * @since pkcs5pkey 1.0.2\n\t         * @example\n\t         * var pem1 = KEYUTIL.newEncryptedPKCS5PEM(\"password\");           // RSA1024bit/10001/AES-256-CBC\n\t         * var pem2 = KEYUTIL.newEncryptedPKCS5PEM(\"password\", 512);      // RSA 512bit/10001/AES-256-CBC\n\t         * var pem3 = KEYUTIL.newEncryptedPKCS5PEM(\"password\", 512, '3'); // RSA 512bit/    3/AES-256-CBC\n\t         */\n\t        newEncryptedPKCS5PEM: function(passcode, keyLen, hPublicExponent, alg) {\n\t            if (typeof keyLen == \"undefined\" || keyLen == null) {\n\t                keyLen = 1024;\n\t            }\n\t            if (typeof hPublicExponent == \"undefined\" || hPublicExponent == null) {\n\t                hPublicExponent = '10001';\n\t            }\n\t            var pKey = new RSAKey();\n\t            pKey.generate(keyLen, hPublicExponent);\n\t            var pem = null;\n\t            if (typeof alg == \"undefined\" || alg == null) {\n\t                pem = this.getEncryptedPKCS5PEMFromRSAKey(pKey, passcode);\n\t            } else {\n\t                pem = this.getEncryptedPKCS5PEMFromRSAKey(pKey, passcode, alg);\n\t            }\n\t            return pem;\n\t        },\n\t\n\t        // === PKCS8 ===============================================================\n\t\n\t        /**\n\t         * (DEPRECATED) read PEM formatted unencrypted PKCS#8 private key and returns RSAKey object\n\t         * @name getRSAKeyFromPlainPKCS8PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PEM PEM formatted unencrypted PKCS#8 private key\n\t         * @return {RSAKey} loaded RSAKey object of RSA private key\n\t         * @since pkcs5pkey 1.0.1\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         */\n\t        getRSAKeyFromPlainPKCS8PEM: function(pkcs8PEM) {\n\t            if (pkcs8PEM.match(/ENCRYPTED/))\n\t                throw \"pem shall be not ENCRYPTED\";\n\t            var prvKeyHex = this.getHexFromPEM(pkcs8PEM, \"PRIVATE KEY\");\n\t            var rsaKey = this.getRSAKeyFromPlainPKCS8Hex(prvKeyHex);\n\t            return rsaKey;\n\t        },\n\t\n\t        /**\n\t         * (DEPRECATED) provide hexadecimal string of unencrypted PKCS#8 private key and returns RSAKey object\n\t         * @name getRSAKeyFromPlainPKCS8Hex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} prvKeyHex hexadecimal string of unencrypted PKCS#8 private key\n\t         * @return {RSAKey} loaded RSAKey object of RSA private key\n\t         * @since pkcs5pkey 1.0.3\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         */\n\t        getRSAKeyFromPlainPKCS8Hex: function(prvKeyHex) {\n\t            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(prvKeyHex, 0);\n\t            if (a1.length != 3)\n\t                throw \"outer DERSequence shall have 3 elements: \" + a1.length;\n\t            var algIdTLV =ASN1HEX.getHexOfTLV_AtObj(prvKeyHex, a1[1]);\n\t            if (algIdTLV != \"300d06092a864886f70d0101010500\") // AlgId rsaEncryption\n\t                throw \"PKCS8 AlgorithmIdentifier is not rsaEnc: \" + algIdTLV;\n\t            var algIdTLV = ASN1HEX.getHexOfTLV_AtObj(prvKeyHex, a1[1]);\n\t            var octetStr = ASN1HEX.getHexOfTLV_AtObj(prvKeyHex, a1[2]);\n\t            var p5KeyHex = ASN1HEX.getHexOfV_AtObj(octetStr, 0);\n\t            //alert(p5KeyHex);\n\t            var rsaKey = new RSAKey();\n\t            rsaKey.readPrivateKeyFromASN1HexString(p5KeyHex);\n\t            return rsaKey;\n\t        },\n\t\n\t        /**\n\t         * generate PBKDF2 key hexstring with specified passcode and information\n\t         * @name parseHexOfEncryptedPKCS8\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} passcode passcode to decrypto private key\n\t         * @return {Array} info associative array of PKCS#8 parameters\n\t         * @since pkcs5pkey 1.0.3\n\t         * @description\n\t         * The associative array which is returned by this method has following properties:\n\t         * <ul>\n\t         * <li>info.pbkdf2Salt - hexadecimal string of PBKDF2 salt</li>\n\t         * <li>info.pkbdf2Iter - iteration count</li>\n\t         * <li>info.ciphertext - hexadecimal string of encrypted private key</li>\n\t         * <li>info.encryptionSchemeAlg - encryption algorithm name (currently TripleDES only)</li>\n\t         * <li>info.encryptionSchemeIV - initial vector for encryption algorithm</li>\n\t         * </ul>\n\t         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n\t         * <ul>\n\t         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n\t         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n\t         * </ul>\n\t         * @example\n\t         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n\t         * // key with PBKDF2 with TripleDES\n\t         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n\t         */\n\t        parseHexOfEncryptedPKCS8: function(sHEX) {\n\t            var info = {};\n\t            \n\t            var a0 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, 0);\n\t            if (a0.length != 2)\n\t                throw \"malformed format: SEQUENCE(0).items != 2: \" + a0.length;\n\t\n\t            // 1. ciphertext\n\t            info.ciphertext = ASN1HEX.getHexOfV_AtObj(sHEX, a0[1]);\n\t\n\t            // 2. pkcs5PBES2\n\t            var a0_0 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0[0]); \n\t            if (a0_0.length != 2)\n\t                throw \"malformed format: SEQUENCE(0.0).items != 2: \" + a0_0.length;\n\t\n\t            // 2.1 check if pkcs5PBES2(1 2 840 113549 1 5 13)\n\t            if (ASN1HEX.getHexOfV_AtObj(sHEX, a0_0[0]) != \"2a864886f70d01050d\")\n\t                throw \"this only supports pkcs5PBES2\";\n\t\n\t            // 2.2 pkcs5PBES2 param\n\t            var a0_0_1 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0[1]); \n\t            if (a0_0.length != 2)\n\t                throw \"malformed format: SEQUENCE(0.0.1).items != 2: \" + a0_0_1.length;\n\t\n\t            // 2.2.1 encryptionScheme\n\t            var a0_0_1_1 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0_1[1]); \n\t            if (a0_0_1_1.length != 2)\n\t                throw \"malformed format: SEQUENCE(0.0.1.1).items != 2: \" + a0_0_1_1.length;\n\t            if (ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_1[0]) != \"2a864886f70d0307\")\n\t                throw \"this only supports TripleDES\";\n\t            info.encryptionSchemeAlg = \"TripleDES\";\n\t\n\t            // 2.2.1.1 IV of encryptionScheme\n\t            info.encryptionSchemeIV = ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_1[1]);\n\t\n\t            // 2.2.2 keyDerivationFunc\n\t            var a0_0_1_0 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0_1[0]); \n\t            if (a0_0_1_0.length != 2)\n\t                throw \"malformed format: SEQUENCE(0.0.1.0).items != 2: \" + a0_0_1_0.length;\n\t            if (ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_0[0]) != \"2a864886f70d01050c\")\n\t                throw \"this only supports pkcs5PBKDF2\";\n\t\n\t            // 2.2.2.1 pkcs5PBKDF2 param\n\t            var a0_0_1_0_1 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0_1_0[1]); \n\t            if (a0_0_1_0_1.length < 2)\n\t                throw \"malformed format: SEQUENCE(0.0.1.0.1).items < 2: \" + a0_0_1_0_1.length;\n\t\n\t            // 2.2.2.1.1 PBKDF2 salt\n\t            info.pbkdf2Salt = ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_0_1[0]);\n\t\n\t            // 2.2.2.1.2 PBKDF2 iter\n\t            var iterNumHex = ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_0_1[1]);\n\t            try {\n\t                info.pbkdf2Iter = parseInt(iterNumHex, 16);\n\t            } catch(ex) {\n\t                throw \"malformed format pbkdf2Iter: \" + iterNumHex;\n\t            }\n\t\n\t            return info;\n\t        },\n\t\n\t        /**\n\t         * generate PBKDF2 key hexstring with specified passcode and information\n\t         * @name getPBKDF2KeyHexFromParam\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {Array} info result of {@link parseHexOfEncryptedPKCS8} which has preference of PKCS#8 file\n\t         * @param {String} passcode passcode to decrypto private key\n\t         * @return {String} hexadecimal string of PBKDF2 key\n\t         * @since pkcs5pkey 1.0.3\n\t         * @description\n\t         * As for info, this uses following properties:\n\t         * <ul>\n\t         * <li>info.pbkdf2Salt - hexadecimal string of PBKDF2 salt</li>\n\t         * <li>info.pkbdf2Iter - iteration count</li>\n\t         * </ul>\n\t         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n\t         * <ul>\n\t         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n\t         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n\t         * </ul>\n\t         * @example\n\t         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n\t         * // key with PBKDF2 with TripleDES\n\t         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n\t         */\n\t        getPBKDF2KeyHexFromParam: function(info, passcode) {\n\t            var pbkdf2SaltWS = CryptoJS.enc.Hex.parse(info.pbkdf2Salt);\n\t            var pbkdf2Iter = info.pbkdf2Iter;\n\t            var pbkdf2KeyWS = CryptoJS.PBKDF2(passcode, \n\t                                              pbkdf2SaltWS, \n\t                                              { keySize: 192/32, iterations: pbkdf2Iter });\n\t            var pbkdf2KeyHex = CryptoJS.enc.Hex.stringify(pbkdf2KeyWS);\n\t            return pbkdf2KeyHex;\n\t        },\n\t\n\t        /**\n\t         * read PEM formatted encrypted PKCS#8 private key and returns hexadecimal string of plain PKCS#8 private key\n\t         * @name getPlainPKCS8HexFromEncryptedPKCS8PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PEM PEM formatted encrypted PKCS#8 private key\n\t         * @param {String} passcode passcode to decrypto private key\n\t         * @return {String} hexadecimal string of plain PKCS#8 private key\n\t         * @since pkcs5pkey 1.0.3\n\t         * @description\n\t         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n\t         * <ul>\n\t         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n\t         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n\t         * </ul>\n\t         * @example\n\t         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n\t         * // key with PBKDF2 with TripleDES\n\t         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n\t         */\n\t        getPlainPKCS8HexFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {\n\t            // 1. derHex - PKCS#8 private key encrypted by PBKDF2\n\t            var derHex = this.getHexFromPEM(pkcs8PEM, \"ENCRYPTED PRIVATE KEY\");\n\t            // 2. info - PKCS#5 PBES info\n\t            var info = this.parseHexOfEncryptedPKCS8(derHex);\n\t            // 3. hKey - PBKDF2 key\n\t            var pbkdf2KeyHex = KEYUTIL.getPBKDF2KeyHexFromParam(info, passcode);\n\t            // 4. decrypt ciphertext by PBKDF2 key\n\t            var encrypted = {};\n\t            encrypted.ciphertext = CryptoJS.enc.Hex.parse(info.ciphertext);\n\t            var pbkdf2KeyWS = CryptoJS.enc.Hex.parse(pbkdf2KeyHex);\n\t            var des3IVWS = CryptoJS.enc.Hex.parse(info.encryptionSchemeIV);\n\t            var decWS = CryptoJS.TripleDES.decrypt(encrypted, pbkdf2KeyWS, { iv: des3IVWS });\n\t            var decHex = CryptoJS.enc.Hex.stringify(decWS);\n\t            return decHex;\n\t        },\n\t\n\t        /**\n\t         * (DEPRECATED) read PEM formatted encrypted PKCS#8 private key and returns RSAKey object\n\t         * @name getRSAKeyFromEncryptedPKCS8PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PEM PEM formatted encrypted PKCS#8 private key\n\t         * @param {String} passcode passcode to decrypto private key\n\t         * @return {RSAKey} loaded RSAKey object of RSA private key\n\t         * @since pkcs5pkey 1.0.3\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         * @description\n\t         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n\t         * <ul>\n\t         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n\t         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n\t         * </ul>\n\t         * @example\n\t         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n\t         * // key with PBKDF2 with TripleDES\n\t         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n\t         */\n\t        getRSAKeyFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {\n\t            var prvKeyHex = this.getPlainPKCS8HexFromEncryptedPKCS8PEM(pkcs8PEM, passcode);\n\t            var rsaKey = this.getRSAKeyFromPlainPKCS8Hex(prvKeyHex);\n\t            return rsaKey;\n\t        },\n\t\n\t        /**\n\t         * get RSAKey/ECDSA private key object from encrypted PEM PKCS#8 private key\n\t         * @name getKeyFromEncryptedPKCS8PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PEM string of PEM formatted PKCS#8 private key\n\t         * @param {String} passcode passcode string to decrypt key\n\t         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n\t         * @since pkcs5pkey 1.0.5\n\t         */\n\t        getKeyFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {\n\t            var prvKeyHex = this.getPlainPKCS8HexFromEncryptedPKCS8PEM(pkcs8PEM, passcode);\n\t            var key = this.getKeyFromPlainPrivatePKCS8Hex(prvKeyHex);\n\t            return key;\n\t        },\n\t\n\t        /**\n\t         * parse hexadecimal string of plain PKCS#8 private key\n\t         * @name parsePlainPrivatePKCS8Hex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PrvHex hexadecimal string of PKCS#8 plain private key\n\t         * @return {Array} associative array of parsed key\n\t         * @since pkcs5pkey 1.0.5\n\t         * @description\n\t         * Resulted associative array has following properties:\n\t         * <ul>\n\t         * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>\n\t         * <li>algparam - hexadecimal string of OID of ECC curve name or null</li>\n\t         * <li>keyidx - string starting index of key in pkcs8PrvHex</li>\n\t         * </ul>\n\t         */\n\t        parsePlainPrivatePKCS8Hex: function(pkcs8PrvHex) {\n\t            var result = {};\n\t            result.algparam = null;\n\t\n\t            // 1. sequence\n\t            if (pkcs8PrvHex.substr(0, 2) != \"30\")\n\t                throw \"malformed plain PKCS8 private key(code:001)\"; // not sequence\n\t\n\t            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PrvHex, 0);\n\t            if (a1.length != 3)\n\t                throw \"malformed plain PKCS8 private key(code:002)\";\n\t\n\t            // 2. AlgID\n\t            if (pkcs8PrvHex.substr(a1[1], 2) != \"30\")\n\t                throw \"malformed PKCS8 private key(code:003)\"; // AlgId not sequence\n\t\n\t            var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PrvHex, a1[1]);\n\t            if (a2.length != 2)\n\t                throw \"malformed PKCS8 private key(code:004)\"; // AlgId not have two elements\n\t\n\t            // 2.1. AlgID OID\n\t            if (pkcs8PrvHex.substr(a2[0], 2) != \"06\")\n\t                throw \"malformed PKCS8 private key(code:005)\"; // AlgId.oid is not OID\n\t\n\t            result.algoid = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a2[0]);\n\t\n\t            // 2.2. AlgID param\n\t            if (pkcs8PrvHex.substr(a2[1], 2) == \"06\") {\n\t                result.algparam = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a2[1]);\n\t            }\n\t\n\t            // 3. Key index\n\t            if (pkcs8PrvHex.substr(a1[2], 2) != \"04\")\n\t                throw \"malformed PKCS8 private key(code:006)\"; // not octet string\n\t\n\t            result.keyidx = ASN1HEX.getStartPosOfV_AtObj(pkcs8PrvHex, a1[2]);\n\t\n\t            return result;\n\t        },\n\t\n\t        /**\n\t         * get RSAKey/ECDSA private key object from PEM plain PEM PKCS#8 private key\n\t         * @name getKeyFromPlainPrivatePKCS8PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PEM string of plain PEM formatted PKCS#8 private key\n\t         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n\t         * @since pkcs5pkey 1.0.5\n\t         */\n\t        getKeyFromPlainPrivatePKCS8PEM: function(prvKeyPEM) {\n\t            var prvKeyHex = this.getHexFromPEM(prvKeyPEM, \"PRIVATE KEY\");\n\t            var key = this.getKeyFromPlainPrivatePKCS8Hex(prvKeyHex);\n\t            return key;\n\t        },\n\t\n\t        /**\n\t         * get RSAKey/ECDSA private key object from HEX plain PEM PKCS#8 private key\n\t         * @name getKeyFromPlainPrivatePKCS8Hex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} prvKeyHex hexadecimal string of plain PKCS#8 private key\n\t         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n\t         * @since pkcs5pkey 1.0.5\n\t         */\n\t        getKeyFromPlainPrivatePKCS8Hex: function(prvKeyHex) {\n\t            var p8 = this.parsePlainPrivatePKCS8Hex(prvKeyHex);\n\t            \n\t            if (p8.algoid == \"2a864886f70d010101\") { // RSA\n\t                this.parsePrivateRawRSAKeyHexAtObj(prvKeyHex, p8);\n\t                var k = p8.key;\n\t                var key = new RSAKey();\n\t                key.setPrivateEx(k.n, k.e, k.d, k.p, k.q, k.dp, k.dq, k.co);\n\t                return key;\n\t            } else if (p8.algoid == \"2a8648ce3d0201\") { // ECC\n\t                this.parsePrivateRawECKeyHexAtObj(prvKeyHex, p8);\n\t                if (KJUR.crypto.OID.oidhex2name[p8.algparam] === undefined)\n\t                    throw \"KJUR.crypto.OID.oidhex2name undefined: \" + p8.algparam;\n\t                var curveName = KJUR.crypto.OID.oidhex2name[p8.algparam];\n\t                var key = new KJUR.crypto.ECDSA({'curve': curveName});\n\t                key.setPublicKeyHex(p8.pubkey);\n\t                key.setPrivateKeyHex(p8.key);\n\t                key.isPublic = false;\n\t                return key;\n\t            } else if (p8.algoid == \"2a8648ce380401\") { // DSA\n\t                var hP = ASN1HEX.getVbyList(prvKeyHex, 0, [1,1,0], \"02\");\n\t                var hQ = ASN1HEX.getVbyList(prvKeyHex, 0, [1,1,1], \"02\");\n\t                var hG = ASN1HEX.getVbyList(prvKeyHex, 0, [1,1,2], \"02\");\n\t                var hX = ASN1HEX.getVbyList(prvKeyHex, 0, [2,0], \"02\");\n\t                var biP = new BigInteger(hP, 16);\n\t                var biQ = new BigInteger(hQ, 16);\n\t                var biG = new BigInteger(hG, 16);\n\t                var biX = new BigInteger(hX, 16);\n\t                var key = new KJUR.crypto.DSA();\n\t                key.setPrivate(biP, biQ, biG, null, biX);\n\t                return key;\n\t            } else {\n\t                throw \"unsupported private key algorithm\";\n\t            }\n\t        },\n\t\n\t        // === PKCS8 RSA Public Key ================================================\n\t        /**\n\t         * (DEPRECATED) read PEM formatted PKCS#8 public key and returns RSAKey object\n\t         * @name getRSAKeyFromPublicPKCS8PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PubPEM PEM formatted PKCS#8 public key\n\t         * @return {RSAKey} loaded RSAKey object of RSA public key\n\t         * @since pkcs5pkey 1.0.4\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         */\n\t        getRSAKeyFromPublicPKCS8PEM: function(pkcs8PubPEM) {\n\t            var pubKeyHex = this.getHexFromPEM(pkcs8PubPEM, \"PUBLIC KEY\");\n\t            var rsaKey = this.getRSAKeyFromPublicPKCS8Hex(pubKeyHex);\n\t            return rsaKey;\n\t        },\n\t\n\t        /**\n\t         * (DEPRECATED) get RSAKey/ECDSA public key object from PEM PKCS#8 public key\n\t         * @name getKeyFromPublicPKCS8PEM\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcsPub8PEM string of PEM formatted PKCS#8 public key\n\t         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n\t         * @since pkcs5pkey 1.0.5\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         */\n\t        getKeyFromPublicPKCS8PEM: function(pkcs8PubPEM) {\n\t            var pubKeyHex = this.getHexFromPEM(pkcs8PubPEM, \"PUBLIC KEY\");\n\t            var key = this.getKeyFromPublicPKCS8Hex(pubKeyHex);\n\t            return key;\n\t        },\n\t\n\t        /**\n\t         * (DEPRECATED) get RSAKey/DSA/ECDSA public key object from hexadecimal string of PKCS#8 public key\n\t         * @name getKeyFromPublicPKCS8Hex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcsPub8Hex hexadecimal string of PKCS#8 public key\n\t         * @return {Object} RSAKey or KJUR.crypto.{ECDSA,DSA} private key object\n\t         * @since pkcs5pkey 1.0.5\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         */\n\t        getKeyFromPublicPKCS8Hex: function(pkcs8PubHex) {\n\t            var p8 = this.parsePublicPKCS8Hex(pkcs8PubHex);\n\t            \n\t            if (p8.algoid == \"2a864886f70d010101\") { // RSA\n\t                var aRSA = this.parsePublicRawRSAKeyHex(p8.key);\n\t                var key = new RSAKey();\n\t                key.setPublic(aRSA.n, aRSA.e);\n\t                return key;\n\t            } else if (p8.algoid == \"2a8648ce3d0201\") { // ECC\n\t                if (KJUR.crypto.OID.oidhex2name[p8.algparam] === undefined)\n\t                    throw \"KJUR.crypto.OID.oidhex2name undefined: \" + p8.algparam;\n\t                var curveName = KJUR.crypto.OID.oidhex2name[p8.algparam];\n\t                var key = new KJUR.crypto.ECDSA({'curve': curveName, 'pub': p8.key});\n\t                return key;\n\t            } else if (p8.algoid == \"2a8648ce380401\") { // DSA 1.2.840.10040.4.1\n\t                var param = p8.algparam;\n\t                var y = ASN1HEX.getHexOfV_AtObj(p8.key, 0);\n\t                var key = new KJUR.crypto.DSA();\n\t                key.setPublic(new BigInteger(param.p, 16),\n\t                              new BigInteger(param.q, 16),\n\t                              new BigInteger(param.g, 16),\n\t                              new BigInteger(y, 16));\n\t                return key;\n\t            } else {\n\t                throw \"unsupported public key algorithm\";\n\t            }\n\t        },\n\t\n\t        /**\n\t         * parse hexadecimal string of plain PKCS#8 private key\n\t         * @name parsePublicRawRSAKeyHex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pubRawRSAHex hexadecimal string of ASN.1 encoded PKCS#8 public key\n\t         * @return {Array} associative array of parsed key\n\t         * @since pkcs5pkey 1.0.5\n\t         * @description\n\t         * Resulted associative array has following properties:\n\t         * <ul>\n\t         * <li>n - hexadecimal string of public key\n\t         * <li>e - hexadecimal string of public exponent\n\t         * </ul>\n\t         */\n\t        parsePublicRawRSAKeyHex: function(pubRawRSAHex) {\n\t            var result = {};\n\t            \n\t            // 1. Sequence\n\t            if (pubRawRSAHex.substr(0, 2) != \"30\")\n\t                throw \"malformed RSA key(code:001)\"; // not sequence\n\t            \n\t            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pubRawRSAHex, 0);\n\t            if (a1.length != 2)\n\t                throw \"malformed RSA key(code:002)\"; // not 2 items in seq\n\t\n\t            // 2. public key \"N\"\n\t            if (pubRawRSAHex.substr(a1[0], 2) != \"02\")\n\t                throw \"malformed RSA key(code:003)\"; // 1st item is not integer\n\t\n\t            result.n = ASN1HEX.getHexOfV_AtObj(pubRawRSAHex, a1[0]);\n\t\n\t            // 3. public key \"E\"\n\t            if (pubRawRSAHex.substr(a1[1], 2) != \"02\")\n\t                throw \"malformed RSA key(code:004)\"; // 2nd item is not integer\n\t\n\t            result.e = ASN1HEX.getHexOfV_AtObj(pubRawRSAHex, a1[1]);\n\t\n\t            return result;\n\t        },\n\t\n\t        /**\n\t         * parse hexadecimal string of RSA private key\n\t         * @name parsePrivateRawRSAKeyHexAtObj\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PrvHex hexadecimal string of PKCS#8 private key concluding RSA private key\n\t         * @return {Array} info associative array to add parsed RSA private key information\n\t         * @since pkcs5pkey 1.0.5\n\t         * @description\n\t         * Following properties are added to associative array 'info'\n\t         * <ul>\n\t         * <li>n - hexadecimal string of public key\n\t         * <li>e - hexadecimal string of public exponent\n\t         * <li>d - hexadecimal string of private key\n\t         * <li>p - hexadecimal string\n\t         * <li>q - hexadecimal string\n\t         * <li>dp - hexadecimal string\n\t         * <li>dq - hexadecimal string\n\t         * <li>co - hexadecimal string\n\t         * </ul>\n\t         */\n\t        parsePrivateRawRSAKeyHexAtObj: function(pkcs8PrvHex, info) {\n\t            var keyIdx = info.keyidx;\n\t            \n\t            // 1. sequence\n\t            if (pkcs8PrvHex.substr(keyIdx, 2) != \"30\")\n\t                throw \"malformed RSA private key(code:001)\"; // not sequence\n\t\n\t            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PrvHex, keyIdx);\n\t            if (a1.length != 9)\n\t                throw \"malformed RSA private key(code:002)\"; // not sequence\n\t\n\t            // 2. RSA key\n\t            info.key = {};\n\t            info.key.n = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[1]);\n\t            info.key.e = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[2]);\n\t            info.key.d = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[3]);\n\t            info.key.p = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[4]);\n\t            info.key.q = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[5]);\n\t            info.key.dp = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[6]);\n\t            info.key.dq = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[7]);\n\t            info.key.co = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[8]);\n\t        },\n\t\n\t        /**\n\t         * parse hexadecimal string of ECC private key\n\t         * @name parsePrivateRawECKeyHexAtObj\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PrvHex hexadecimal string of PKCS#8 private key concluding EC private key\n\t         * @return {Array} info associative array to add parsed ECC private key information\n\t         * @since pkcs5pkey 1.0.5\n\t         * @description\n\t         * Following properties are added to associative array 'info'\n\t         * <ul>\n\t         * <li>key - hexadecimal string of ECC private key\n\t         * </ul>\n\t         */\n\t        parsePrivateRawECKeyHexAtObj: function(pkcs8PrvHex, info) {\n\t            var keyIdx = info.keyidx;\n\t            \n\t            var key = ASN1HEX.getVbyList(pkcs8PrvHex, keyIdx, [1], \"04\");\n\t            var pubkey = ASN1HEX.getVbyList(pkcs8PrvHex, keyIdx, [2,0], \"03\").substr(2);\n\t\n\t            info.key = key;\n\t            info.pubkey = pubkey;\n\t        },\n\t\n\t        /**\n\t         * parse hexadecimal string of PKCS#8 RSA/EC/DSA public key\n\t         * @name parsePublicPKCS8Hex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PubHex hexadecimal string of PKCS#8 public key\n\t         * @return {Hash} hash of key information\n\t         * @description\n\t         * Resulted hash has following attributes.\n\t         * <ul>\n\t         * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>\n\t         * <li>algparam - hexadecimal string of OID of ECC curve name, parameter SEQUENCE of DSA or null</li>\n\t         * <li>key - hexadecimal string of public key</li>\n\t         * </ul>\n\t         */\n\t        parsePublicPKCS8Hex: function(pkcs8PubHex) {\n\t            var result = {};\n\t            result.algparam = null;\n\t\n\t            // 1. AlgID and Key bit string\n\t            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, 0);\n\t            if (a1.length != 2)\n\t                throw \"outer DERSequence shall have 2 elements: \" + a1.length;\n\t\n\t            // 2. AlgID\n\t            var idxAlgIdTLV = a1[0];\n\t            if (pkcs8PubHex.substr(idxAlgIdTLV, 2) != \"30\")\n\t                throw \"malformed PKCS8 public key(code:001)\"; // AlgId not sequence\n\t\n\t            var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, idxAlgIdTLV);\n\t            if (a2.length != 2)\n\t                throw \"malformed PKCS8 public key(code:002)\"; // AlgId not have two elements\n\t\n\t            // 2.1. AlgID OID\n\t            if (pkcs8PubHex.substr(a2[0], 2) != \"06\")\n\t                throw \"malformed PKCS8 public key(code:003)\"; // AlgId.oid is not OID\n\t\n\t            result.algoid = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[0]);\n\t\n\t            // 2.2. AlgID param\n\t            if (pkcs8PubHex.substr(a2[1], 2) == \"06\") { // OID for EC\n\t                result.algparam = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[1]);\n\t            } else if (pkcs8PubHex.substr(a2[1], 2) == \"30\") { // SEQ for DSA\n\t                result.algparam = {};\n\t                result.algparam.p = ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [0], \"02\");\n\t                result.algparam.q = ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [1], \"02\");\n\t                result.algparam.g = ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [2], \"02\");\n\t            }\n\t\n\t            // 3. Key\n\t            if (pkcs8PubHex.substr(a1[1], 2) != \"03\")\n\t                throw \"malformed PKCS8 public key(code:004)\"; // Key is not bit string\n\t\n\t            result.key = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a1[1]).substr(2);\n\t            \n\t            // 4. return result assoc array\n\t            return result;\n\t        },\n\t\n\t        /**\n\t         * (DEPRECATED) provide hexadecimal string of unencrypted PKCS#8 private key and returns RSAKey object\n\t         * @name getRSAKeyFromPublicPKCS8Hex\n\t         * @memberOf KEYUTIL\n\t         * @function\n\t         * @param {String} pkcs8PubHex hexadecimal string of unencrypted PKCS#8 public key\n\t         * @return {RSAKey} loaded RSAKey object of RSA public key\n\t         * @since pkcs5pkey 1.0.4\n\t         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n\t         */\n\t        getRSAKeyFromPublicPKCS8Hex: function(pkcs8PubHex) {\n\t            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, 0);\n\t            if (a1.length != 2)\n\t                throw \"outer DERSequence shall have 2 elements: \" + a1.length;\n\t\n\t            var algIdTLV =ASN1HEX.getHexOfTLV_AtObj(pkcs8PubHex, a1[0]);\n\t            if (algIdTLV != \"300d06092a864886f70d0101010500\") // AlgId rsaEncryption\n\t                throw \"PKCS8 AlgorithmId is not rsaEncryption\";\n\t            \n\t            if (pkcs8PubHex.substr(a1[1], 2) != \"03\")\n\t                throw \"PKCS8 Public Key is not BITSTRING encapslated.\";\n\t\n\t            var idxPub = ASN1HEX.getStartPosOfV_AtObj(pkcs8PubHex, a1[1]) + 2; // 2 for unused bit\n\t            \n\t            if (pkcs8PubHex.substr(idxPub, 2) != \"30\")\n\t                throw \"PKCS8 Public Key is not SEQUENCE.\";\n\t\n\t            var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, idxPub);\n\t            if (a2.length != 2)\n\t                throw \"inner DERSequence shall have 2 elements: \" + a2.length;\n\t\n\t            if (pkcs8PubHex.substr(a2[0], 2) != \"02\") \n\t                throw \"N is not ASN.1 INTEGER\";\n\t            if (pkcs8PubHex.substr(a2[1], 2) != \"02\") \n\t                throw \"E is not ASN.1 INTEGER\";\n\t            \n\t            var hN = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[0]);\n\t            var hE = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[1]);\n\t\n\t            var pubKey = new RSAKey();\n\t            pubKey.setPublic(hN, hE);\n\t            \n\t            return pubKey;\n\t        },\n\t\n\t        //addAlgorithm: function(functionObject, algName, keyLen, ivLen) {\n\t        //}\n\t    };\n\t}();\n\t\n\t// -- MAJOR PUBLIC METHODS -------------------------------------------------------\n\t/**\n\t * get private or public key object from any arguments\n\t * @name getKey\n\t * @memberOf KEYUTIL\n\t * @function\n\t * @static\n\t * @param {Object} param parameter to get key object. see description in detail.\n\t * @param {String} passcode (OPTION) parameter to get key object. see description in detail.\n\t * @param {String} hextype (OPTOIN) parameter to get key object. see description in detail.\n\t * @return {Object} {@link RSAKey}, {@link KJUR.crypto.ECDSA} or {@link KJUR.crypto.ECDSA} object\n\t * @since keyutil 1.0.0\n\t * @description\n\t * This method gets private or public key object({@link RSAKey}, {@link KJUR.crypto.DSA} or {@link KJUR.crypto.ECDSA})\n\t * for RSA, DSA and ECC.\n\t * Arguments for this methods depends on a key format you specify.\n\t * Following key representations are supported.\n\t * <ul>\n\t * <li>ECC private/public key object(as is): param=KJUR.crypto.ECDSA</li>\n\t * <li>DSA private/public key object(as is): param=KJUR.crypto.DSA</li>\n\t * <li>RSA private/public key object(as is): param=RSAKey </li>\n\t * <li>ECC private key parameters: param={d: d, curve: curveName}</li>\n\t * <li>RSA private key parameters: param={n: n, e: e, d: d, p: p, q: q, dp: dp, dq: dq, co: co}<br/>\n\t * NOTE: Each value shall be hexadecimal string of key spec.</li>\n\t * <li>DSA private key parameters: param={p: p, q: q, g: g, y: y, x: x}<br/>\n\t * NOTE: Each value shall be hexadecimal string of key spec.</li>\n\t * <li>ECC public key parameters: param={xy: xy, curve: curveName}<br/>\n\t * NOTE: ECC public key 'xy' shall be concatination of \"04\", x-bytes-hex and y-bytes-hex.</li>\n\t * <li>DSA public key parameters: param={p: p, q: q, g: g, y: y}<br/>\n\t * NOTE: Each value shall be hexadecimal string of key spec.</li>\n\t * <li>RSA public key parameters: param={n: n, e: e} </li>\n\t * <li>X.509v1/v3 PEM certificate (RSA/DSA/ECC): param=pemString</li>\n\t * <li>PKCS#8 hexadecimal RSA/ECC public key: param=pemString, null, \"pkcs8pub\"</li>\n\t * <li>PKCS#8 PEM RSA/DSA/ECC public key: param=pemString</li>\n\t * <li>PKCS#5 plain hexadecimal RSA private key: param=hexString, null, \"pkcs5prv\"</li>\n\t * <li>PKCS#5 plain PEM DSA/RSA private key: param=pemString</li>\n\t * <li>PKCS#8 plain PEM RSA/ECDSA private key: param=pemString</li>\n\t * <li>PKCS#5 encrypted PEM RSA/DSA private key: param=pemString, passcode</li>\n\t * <li>PKCS#8 encrypted PEM RSA/ECDSA private key: param=pemString, passcode</li>\n\t * </ul>\n\t * Please note following limitation on encrypted keys:\n\t * <ul>\n\t * <li>Encrypted PKCS#8 only supports PBKDF2/HmacSHA1/3DES</li>\n\t * <li>Encrypted PKCS#5 supports DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC</li>\n\t * <li>JWT plain ECC private/public key</li>\n\t * <li>JWT plain RSA public key</li>\n\t * <li>JWT plain RSA private key with P/Q/DP/DQ/COEFF</li>\n\t * <li>JWT plain RSA private key without P/Q/DP/DQ/COEFF (since jsrsasign 5.0.0)</li>\n\t * </ul>\n\t * NOTE1: <a href=\"https://tools.ietf.org/html/rfc7517\">RFC 7517 JSON Web Key(JWK)</a> support for RSA/ECC private/public key from jsrsasign 4.8.1.<br/>\n\t * NOTE2: X509v1 support is added since jsrsasign 5.0.11.\n\t * \n\t * <h5>EXAMPLE</h5>\n\t * @example\n\t * // 1. loading private key from PEM string\n\t * keyObj = KEYUTIL.getKey(\"-----BEGIN RSA PRIVATE KEY...\");\n\t * keyObj = KEYUTIL.getKey(\"-----BEGIN RSA PRIVATE KEY..., \"passcode\");\n\t * keyObj = KEYUTIL.getKey(\"-----BEGIN PRIVATE KEY...\");\n\t * keyObj = KEYUTIL.getKey(\"-----BEGIN PRIVATE KEY...\", \"passcode\");\n\t * // 2. loading public key from PEM string\n\t * keyObj = KEYUTIL.getKey(\"-----BEGIN PUBLIC KEY...\");\n\t * keyObj = KEYUTIL.getKey(\"-----BEGIN X509 CERTIFICATE...\");\n\t * // 3. loading hexadecimal PKCS#5/PKCS#8 key\n\t * keyObj = KEYUTIL.getKey(\"308205c1...\", null, \"pkcs8pub\");\n\t * keyObj = KEYUTIL.getKey(\"3082048b...\", null, \"pkcs5prv\");\n\t * // 4. loading JSON Web Key(JWK)\n\t * keyObj = KEYUTIL.getKey({kty: \"RSA\", n: \"0vx7...\", e: \"AQAB\"});\n\t * keyObj = KEYUTIL.getKey({kty: \"EC\", crv: \"P-256\", \n\t *                          x: \"MKBC...\", y: \"4Etl6...\", d: \"870Mb...\"});\n\t * // 5. bare hexadecimal key\n\t * keyObj = KEYUTIL.getKey({n: \"75ab..\", e: \"010001\"});\n\t */\n\tKEYUTIL.getKey = function(param, passcode, hextype) {\n\t    // 1. by key RSAKey/KJUR.crypto.ECDSA/KJUR.crypto.DSA object\n\t    if (typeof RSAKey != 'undefined' && param instanceof RSAKey)\n\t        return param;\n\t    if (typeof KJUR.crypto.ECDSA != 'undefined' && param instanceof KJUR.crypto.ECDSA)\n\t        return param;\n\t    if (typeof KJUR.crypto.DSA != 'undefined' && param instanceof KJUR.crypto.DSA)\n\t        return param;\n\t\n\t    // 2. by parameters of key\n\t\n\t    // 2.1. bare ECC\n\t    // 2.1.1. bare ECC public key by hex values\n\t    if (param.curve !== undefined &&\n\t\tparam.xy !== undefined && param.d === undefined) {\n\t        return new KJUR.crypto.ECDSA({pub: param.xy, curve: param.curve});\n\t    }\n\t\n\t    // 2.1.2. bare ECC private key by hex values\n\t    if (param.curve !== undefined && param.d !== undefined) {\n\t        return new KJUR.crypto.ECDSA({prv: param.d, curve: param.curve});\n\t    }\n\t\n\t    // 2.2. bare RSA\n\t    // 2.2.1. bare RSA public key by hex values\n\t    if (param.kty === undefined &&\n\t\tparam.n !== undefined && param.e !== undefined &&\n\t        param.d === undefined) {\n\t        var key = new RSAKey();\n\t        key.setPublic(param.n, param.e);\n\t        return key;\n\t    }\n\t\n\t    // 2.2.2. bare RSA private key with P/Q/DP/DQ/COEFF by hex values\n\t    if (param.kty === undefined &&\n\t\tparam.n !== undefined &&\n\t\tparam.e !== undefined &&\n\t\tparam.d !== undefined &&\n\t        param.p !== undefined &&\n\t\tparam.q !== undefined &&\n\t        param.dp !== undefined &&\n\t\tparam.dq !== undefined &&\n\t\tparam.co !== undefined &&\n\t        param.qi === undefined) {\n\t        var key = new RSAKey();\n\t        key.setPrivateEx(param.n, param.e, param.d, param.p, param.q,\n\t                         param.dp, param.dq, param.co);\n\t        return key;\n\t    }\n\t\n\t    // 2.2.3. bare RSA public key without P/Q/DP/DQ/COEFF by hex values\n\t    if (param.kty === undefined &&\n\t\tparam.n !== undefined &&\n\t\tparam.e !== undefined &&\n\t\tparam.d !== undefined &&\n\t        param.p === undefined) {\n\t        var key = new RSAKey();\n\t        key.setPrivate(param.n, param.e, param.d);\n\t        return key;\n\t    }\n\t\n\t    // 2.3. bare DSA\n\t    // 2.3.1. bare DSA public key by hex values\n\t    if (param.p !== undefined && param.q !== undefined &&\n\t\tparam.g !== undefined &&\n\t        param.y !== undefined && param.x === undefined) {\n\t        var key = new KJUR.crypto.DSA();\n\t        key.setPublic(param.p, param.q, param.g, param.y);\n\t        return key;\n\t    }\n\t\n\t    // 2.3.2. bare DSA private key by hex values\n\t    if (param.p !== undefined && param.q !== undefined &&\n\t\tparam.g !== undefined &&\n\t        param.y !== undefined && param.x !== undefined) {\n\t        var key = new KJUR.crypto.DSA();\n\t        key.setPrivate(param.p, param.q, param.g, param.y, param.x);\n\t        return key;\n\t    }\n\t\n\t    // 3. JWK\n\t    // 3.1. JWK RSA\n\t    // 3.1.1. JWK RSA public key by b64u values\n\t    if (param.kty === \"RSA\" &&\n\t\tparam.n !== undefined &&\n\t\tparam.e !== undefined &&\n\t\tparam.d === undefined) {\n\t\tvar key = new RSAKey();\n\t\tkey.setPublic(b64utohex(param.n), b64utohex(param.e));\n\t\treturn key;\n\t    }\n\t\n\t    // 3.1.2. JWK RSA private key with p/q/dp/dq/coeff by b64u values\n\t    if (param.kty === \"RSA\" &&\n\t\tparam.n !== undefined &&\n\t\tparam.e !== undefined &&\n\t\tparam.d !== undefined &&\n\t\tparam.p !== undefined &&\n\t\tparam.q !== undefined &&\n\t\tparam.dp !== undefined &&\n\t\tparam.dq !== undefined &&\n\t\tparam.qi !== undefined) {\n\t\tvar key = new RSAKey();\n\t        key.setPrivateEx(b64utohex(param.n),\n\t\t\t\t b64utohex(param.e),\n\t\t\t\t b64utohex(param.d),\n\t\t\t\t b64utohex(param.p),\n\t\t\t\t b64utohex(param.q),\n\t                         b64utohex(param.dp),\n\t\t\t\t b64utohex(param.dq),\n\t\t\t\t b64utohex(param.qi));\n\t\treturn key;\n\t    }\n\t\n\t    // 3.1.3. JWK RSA private key without p/q/dp/dq/coeff by b64u\n\t    //        since jsrsasign 5.0.0 keyutil 1.0.11\n\t    if (param.kty === \"RSA\" &&\n\t\tparam.n !== undefined &&\n\t\tparam.e !== undefined &&\n\t\tparam.d !== undefined) {\n\t\tvar key = new RSAKey();\n\t        key.setPrivate(b64utohex(param.n),\n\t\t\t       b64utohex(param.e),\n\t\t\t       b64utohex(param.d));\n\t\treturn key;\n\t    }\n\t\n\t    // 3.2. JWK ECC\n\t    // 3.2.1. JWK ECC public key by b64u values\n\t    if (param.kty === \"EC\" &&\n\t\tparam.crv !== undefined &&\n\t\tparam.x !== undefined &&\n\t\tparam.y !== undefined &&\n\t        param.d === undefined) {\n\t\tvar ec = new KJUR.crypto.ECDSA({\"curve\": param.crv});\n\t\tvar charlen = ec.ecparams.keylen / 4;\n\t        var hX   = (\"0000000000\" + b64utohex(param.x)).slice(- charlen);\n\t        var hY   = (\"0000000000\" + b64utohex(param.y)).slice(- charlen);\n\t        var hPub = \"04\" + hX + hY;\n\t\tec.setPublicKeyHex(hPub);\n\t\treturn ec;\n\t    }\n\t\n\t    // 3.2.2. JWK ECC private key by b64u values\n\t    if (param.kty === \"EC\" &&\n\t\tparam.crv !== undefined &&\n\t\tparam.x !== undefined &&\n\t\tparam.y !== undefined &&\n\t        param.d !== undefined) {\n\t\tvar ec = new KJUR.crypto.ECDSA({\"curve\": param.crv});\n\t\tvar charlen = ec.ecparams.keylen / 4;\n\t        var hX   = (\"0000000000\" + b64utohex(param.x)).slice(- charlen);\n\t        var hY   = (\"0000000000\" + b64utohex(param.y)).slice(- charlen);\n\t        var hPub = \"04\" + hX + hY;\n\t        var hPrv = (\"0000000000\" + b64utohex(param.d)).slice(- charlen);\n\t\tec.setPublicKeyHex(hPub);\n\t\tec.setPrivateKeyHex(hPrv);\n\t\treturn ec;\n\t    }\n\t    \n\t    // 4. by PEM certificate (-----BEGIN ... CERTIFITE----)\n\t    if (param.indexOf(\"-END CERTIFICATE-\", 0) != -1 ||\n\t        param.indexOf(\"-END X509 CERTIFICATE-\", 0) != -1 ||\n\t        param.indexOf(\"-END TRUSTED CERTIFICATE-\", 0) != -1) {\n\t        return X509.getPublicKeyFromCertPEM(param);\n\t    }\n\t\n\t    // 4. public key by PKCS#8 hexadecimal string\n\t    if (hextype === \"pkcs8pub\") {\n\t        return KEYUTIL.getKeyFromPublicPKCS8Hex(param);\n\t    }\n\t\n\t    // 5. public key by PKCS#8 PEM string\n\t    if (param.indexOf(\"-END PUBLIC KEY-\") != -1) {\n\t        return KEYUTIL.getKeyFromPublicPKCS8PEM(param);\n\t    }\n\t    \n\t    // 6. private key by PKCS#5 plain hexadecimal RSA string\n\t    if (hextype === \"pkcs5prv\") {\n\t        var key = new RSAKey();\n\t        key.readPrivateKeyFromASN1HexString(param);\n\t        return key;\n\t    }\n\t\n\t    // 7. private key by plain PKCS#5 hexadecimal RSA string\n\t    if (hextype === \"pkcs5prv\") {\n\t        var key = new RSAKey();\n\t        key.readPrivateKeyFromASN1HexString(param);\n\t        return key;\n\t    }\n\t\n\t    // 8. private key by plain PKCS#5 PEM RSA string \n\t    //    getKey(\"-----BEGIN RSA PRIVATE KEY-...\")\n\t    if (param.indexOf(\"-END RSA PRIVATE KEY-\") != -1 &&\n\t        param.indexOf(\"4,ENCRYPTED\") == -1) {\n\t        var hex = KEYUTIL.getHexFromPEM(param, \"RSA PRIVATE KEY\");\n\t        return KEYUTIL.getKey(hex, null, \"pkcs5prv\");\n\t    }\n\t\n\t    // 8.2. private key by plain PKCS#5 PEM DSA string\n\t    if (param.indexOf(\"-END DSA PRIVATE KEY-\") != -1 &&\n\t        param.indexOf(\"4,ENCRYPTED\") == -1) {\n\t\n\t        var hKey = this.getHexFromPEM(param, \"DSA PRIVATE KEY\");\n\t        var p = ASN1HEX.getVbyList(hKey, 0, [1], \"02\");\n\t        var q = ASN1HEX.getVbyList(hKey, 0, [2], \"02\");\n\t        var g = ASN1HEX.getVbyList(hKey, 0, [3], \"02\");\n\t        var y = ASN1HEX.getVbyList(hKey, 0, [4], \"02\");\n\t        var x = ASN1HEX.getVbyList(hKey, 0, [5], \"02\");\n\t        var key = new KJUR.crypto.DSA();\n\t        key.setPrivate(new BigInteger(p, 16),\n\t                       new BigInteger(q, 16),\n\t                       new BigInteger(g, 16),\n\t                       new BigInteger(y, 16),\n\t                       new BigInteger(x, 16));\n\t        return key;\n\t    }\n\t\n\t    // 9. private key by plain PKCS#8 PEM ECC/RSA string\n\t    if (param.indexOf(\"-END PRIVATE KEY-\") != -1) {\n\t        return KEYUTIL.getKeyFromPlainPrivatePKCS8PEM(param);\n\t    }\n\t\n\t    // 10. private key by encrypted PKCS#5 PEM RSA string\n\t    if (param.indexOf(\"-END RSA PRIVATE KEY-\") != -1 &&\n\t        param.indexOf(\"4,ENCRYPTED\") != -1) {\n\t        return KEYUTIL.getRSAKeyFromEncryptedPKCS5PEM(param, passcode);\n\t    }\n\t\n\t    // 10.2. private key by encrypted PKCS#5 PEM ECDSA string\n\t    if (param.indexOf(\"-END EC PRIVATE KEY-\") != -1 &&\n\t        param.indexOf(\"4,ENCRYPTED\") != -1) {\n\t        var hKey = KEYUTIL.getDecryptedKeyHex(param, passcode);\n\t\n\t        var key = ASN1HEX.getVbyList(hKey, 0, [1], \"04\");\n\t        var curveNameOidHex = ASN1HEX.getVbyList(hKey, 0, [2,0], \"06\");\n\t        var pubkey = ASN1HEX.getVbyList(hKey, 0, [3,0], \"03\").substr(2);\n\t        var curveName = \"\";\n\t\n\t        if (KJUR.crypto.OID.oidhex2name[curveNameOidHex] !== undefined) {\n\t            curveName = KJUR.crypto.OID.oidhex2name[curveNameOidHex];\n\t        } else {\n\t            throw \"undefined OID(hex) in KJUR.crypto.OID: \" + curveNameOidHex;\n\t        }\n\t\n\t        var ec = new KJUR.crypto.ECDSA({'name': curveName});\n\t        ec.setPublicKeyHex(pubkey);\n\t        ec.setPrivateKeyHex(key);\n\t        ec.isPublic = false;\n\t        return ec;\n\t    }\n\t\n\t    // 10.3. private key by encrypted PKCS#5 PEM DSA string\n\t    if (param.indexOf(\"-END DSA PRIVATE KEY-\") != -1 &&\n\t        param.indexOf(\"4,ENCRYPTED\") != -1) {\n\t        var hKey = KEYUTIL.getDecryptedKeyHex(param, passcode);\n\t        var p = ASN1HEX.getVbyList(hKey, 0, [1], \"02\");\n\t        var q = ASN1HEX.getVbyList(hKey, 0, [2], \"02\");\n\t        var g = ASN1HEX.getVbyList(hKey, 0, [3], \"02\");\n\t        var y = ASN1HEX.getVbyList(hKey, 0, [4], \"02\");\n\t        var x = ASN1HEX.getVbyList(hKey, 0, [5], \"02\");\n\t        var key = new KJUR.crypto.DSA();\n\t        key.setPrivate(new BigInteger(p, 16),\n\t                       new BigInteger(q, 16),\n\t                       new BigInteger(g, 16),\n\t                       new BigInteger(y, 16),\n\t                       new BigInteger(x, 16));\n\t        return key;\n\t    }\n\t\n\t    // 11. private key by encrypted PKCS#8 hexadecimal RSA/ECDSA string\n\t    if (param.indexOf(\"-END ENCRYPTED PRIVATE KEY-\") != -1) {\n\t        return KEYUTIL.getKeyFromEncryptedPKCS8PEM(param, passcode);\n\t    }\n\t\n\t    throw \"not supported argument\";\n\t};\n\t\n\t/**\n\t * @name generateKeypair\n\t * @memberOf KEYUTIL\n\t * @function\n\t * @static\n\t * @param {String} alg 'RSA' or 'EC'\n\t * @param {Object} keylenOrCurve key length for RSA or curve name for EC\n\t * @return {Array} associative array of keypair which has prvKeyObj and pubKeyObj parameters\n\t * @since keyutil 1.0.1\n\t * @description\n\t * This method generates a key pair of public key algorithm.\n\t * The result will be an associative array which has following\n\t * parameters:\n\t * <ul>\n\t * <li>prvKeyObj - RSAKey or ECDSA object of private key</li>\n\t * <li>pubKeyObj - RSAKey or ECDSA object of public key</li>\n\t * </ul>\n\t * NOTE1: As for RSA algoirthm, public exponent has fixed\n\t * value '0x10001'.\n\t * NOTE2: As for EC algorithm, supported names of curve are\n\t * secp256r1, secp256k1 and secp384r1.\n\t * NOTE3: DSA is not supported yet.\n\t * @example\n\t * var rsaKeypair = KEYUTIL.generateKeypair(\"RSA\", 1024);\n\t * var ecKeypair = KEYUTIL.generateKeypair(\"EC\", \"secp256r1\");\n\t *\n\t */\n\tKEYUTIL.generateKeypair = function(alg, keylenOrCurve) {\n\t    if (alg == \"RSA\") {\n\t        var keylen = keylenOrCurve;\n\t        var prvKey = new RSAKey();\n\t        prvKey.generate(keylen, '10001');\n\t        prvKey.isPrivate = true;\n\t        prvKey.isPublic = true;\n\t        \n\t        var pubKey = new RSAKey();\n\t        var hN = prvKey.n.toString(16);\n\t        var hE = prvKey.e.toString(16);\n\t        pubKey.setPublic(hN, hE);\n\t        pubKey.isPrivate = false;\n\t        pubKey.isPublic = true;\n\t        \n\t        var result = {};\n\t        result.prvKeyObj = prvKey;\n\t        result.pubKeyObj = pubKey;\n\t        return result;\n\t    } else if (alg == \"EC\") {\n\t        var curve = keylenOrCurve;\n\t        var ec = new KJUR.crypto.ECDSA({curve: curve});\n\t        var keypairHex = ec.generateKeyPairHex();\n\t\n\t        var prvKey = new KJUR.crypto.ECDSA({curve: curve});\n\t        prvKey.setPublicKeyHex(keypairHex.ecpubhex);\n\t        prvKey.setPrivateKeyHex(keypairHex.ecprvhex);\n\t        prvKey.isPrivate = true;\n\t        prvKey.isPublic = false;\n\t\n\t        var pubKey = new KJUR.crypto.ECDSA({curve: curve});\n\t        pubKey.setPublicKeyHex(keypairHex.ecpubhex);\n\t        pubKey.isPrivate = false;\n\t        pubKey.isPublic = true;\n\t\n\t        var result = {};\n\t        result.prvKeyObj = prvKey;\n\t        result.pubKeyObj = pubKey;\n\t        return result;\n\t    } else {\n\t        throw \"unknown algorithm: \" + alg;\n\t    }\n\t};\n\t\n\t/**\n\t * get PEM formatted private or public key file from a RSA/ECDSA/DSA key object\n\t * @name getPEM\n\t * @memberOf KEYUTIL\n\t * @function\n\t * @static\n\t * @param {Object} keyObjOrHex key object {@link RSAKey}, {@link KJUR.crypto.ECDSA} or {@link KJUR.crypto.DSA} to encode to\n\t * @param {String} formatType (OPTION) output format type of \"PKCS1PRV\", \"PKCS5PRV\" or \"PKCS8PRV\" for private key\n\t * @param {String} passwd (OPTION) password to protect private key\n\t * @param {String} encAlg (OPTION) encryption algorithm for PKCS#5. currently supports DES-CBC, DES-EDE3-CBC and AES-{128,192,256}-CBC\n\t * @since keyutil 1.0.4\n\t * @description\n\t * <dl>\n\t * <dt><b>NOTE1:</b>\n\t * <dd>\n\t * PKCS#5 encrypted private key protection algorithm supports DES-CBC, \n\t * DES-EDE3-CBC and AES-{128,192,256}-CBC\n\t * <dt><b>NOTE2:</b>\n\t * <dd>\n\t * OpenSSL supports\n\t * </dl>\n\t * @example\n\t * KEUUTIL.getPEM(publicKey) =&gt; generates PEM PKCS#8 public key \n\t * KEUUTIL.getPEM(privateKey, \"PKCS1PRV\") =&gt; generates PEM PKCS#1 plain private key\n\t * KEUUTIL.getPEM(privateKey, \"PKCS5PRV\", \"pass\") =&gt; generates PEM PKCS#5 encrypted private key \n\t *                                                          with DES-EDE3-CBC (DEFAULT)\n\t * KEUUTIL.getPEM(privateKey, \"PKCS5PRV\", \"pass\", \"DES-CBC\") =&gt; generates PEM PKCS#5 encrypted \n\t *                                                                 private key with DES-CBC\n\t * KEUUTIL.getPEM(privateKey, \"PKCS8PRV\") =&gt; generates PEM PKCS#8 plain private key\n\t * KEUUTIL.getPEM(privateKey, \"PKCS8PRV\", \"pass\") =&gt; generates PEM PKCS#8 encrypted private key\n\t *                                                      with PBKDF2_HmacSHA1_3DES\n\t */\n\tKEYUTIL.getPEM = function(keyObjOrHex, formatType, passwd, encAlg, hexType) {\n\t    var ns1 = KJUR.asn1;\n\t    var ns2 = KJUR.crypto;\n\t\n\t    function _rsaprv2asn1obj(keyObjOrHex) {\n\t        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"int\": 0 },\n\t                {\"int\": {\"bigint\": keyObjOrHex.n}},\n\t                {\"int\": keyObjOrHex.e},\n\t                {\"int\": {\"bigint\": keyObjOrHex.d}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.p}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.q}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.dmp1}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.dmq1}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.coeff}}\n\t            ]\n\t        });\n\t        return asn1Obj;\n\t    };\n\t\n\t    function _ecdsaprv2asn1obj(keyObjOrHex) {\n\t        var asn1Obj2 = KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"int\": 1 },\n\t                {\"octstr\": {\"hex\": keyObjOrHex.prvKeyHex}},\n\t                {\"tag\": ['a0', true, {'oid': {'name': keyObjOrHex.curveName}}]},\n\t                {\"tag\": ['a1', true, {'bitstr': {'hex': '00' + keyObjOrHex.pubKeyHex}}]}\n\t            ]\n\t        });\n\t        return asn1Obj2;\n\t    };\n\t\n\t    function _dsaprv2asn1obj(keyObjOrHex) {\n\t        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"int\": 0 },\n\t                {\"int\": {\"bigint\": keyObjOrHex.p}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.q}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.g}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.y}},\n\t                {\"int\": {\"bigint\": keyObjOrHex.x}}\n\t            ]\n\t        });\n\t        return asn1Obj;\n\t    };\n\t\n\t    // 1. public key\n\t\n\t    // x. PEM PKCS#8 public key of RSA/ECDSA/DSA public key object\n\t    if (((typeof RSAKey != \"undefined\" && keyObjOrHex instanceof RSAKey) ||\n\t         (typeof ns2.DSA != \"undefined\" && keyObjOrHex instanceof ns2.DSA) ||\n\t         (typeof ns2.ECDSA != \"undefined\" && keyObjOrHex instanceof ns2.ECDSA)) &&\n\t        keyObjOrHex.isPublic == true &&\n\t        (formatType === undefined || formatType == \"PKCS8PUB\")) {\n\t        var asn1Obj = new KJUR.asn1.x509.SubjectPublicKeyInfo(keyObjOrHex);\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t        return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PUBLIC KEY\");\n\t    }\n\t    \n\t    // 2. private\n\t\n\t    // x. PEM PKCS#1 plain private key of RSA private key object\n\t    if (formatType == \"PKCS1PRV\" &&\n\t        typeof RSAKey != \"undefined\" &&\n\t        keyObjOrHex instanceof RSAKey &&\n\t        (passwd === undefined || passwd == null) &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var asn1Obj = _rsaprv2asn1obj(keyObjOrHex);\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t        return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"RSA PRIVATE KEY\");\n\t    }\n\t\n\t    // x. PEM PKCS#1 plain private key of ECDSA private key object\n\t    if (formatType == \"PKCS1PRV\" &&\n\t        typeof RSAKey != \"undefined\" &&\n\t        keyObjOrHex instanceof KJUR.crypto.ECDSA &&\n\t        (passwd === undefined || passwd == null) &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var asn1Obj1 = new KJUR.asn1.DERObjectIdentifier({'name': keyObjOrHex.curveName});\n\t        var asn1Hex1 = asn1Obj1.getEncodedHex();\n\t        var asn1Obj2 = _ecdsaprv2asn1obj(keyObjOrHex);\n\t        var asn1Hex2 = asn1Obj2.getEncodedHex();\n\t\n\t        var s = \"\";\n\t        s += ns1.ASN1Util.getPEMStringFromHex(asn1Hex1, \"EC PARAMETERS\");\n\t        s += ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"EC PRIVATE KEY\");\n\t        return s;\n\t    }\n\t\n\t    // x. PEM PKCS#1 plain private key of DSA private key object\n\t    if (formatType == \"PKCS1PRV\" &&\n\t        typeof KJUR.crypto.DSA != \"undefined\" &&\n\t        keyObjOrHex instanceof KJUR.crypto.DSA &&\n\t        (passwd === undefined || passwd == null) &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var asn1Obj = _dsaprv2asn1obj(keyObjOrHex);\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t        return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"DSA PRIVATE KEY\");\n\t    }\n\t\n\t    // 3. private\n\t\n\t    // x. PEM PKCS#5 encrypted private key of RSA private key object\n\t    if (formatType == \"PKCS5PRV\" &&\n\t        typeof RSAKey != \"undefined\" &&\n\t        keyObjOrHex instanceof RSAKey &&\n\t        (passwd !== undefined && passwd != null) &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var asn1Obj = _rsaprv2asn1obj(keyObjOrHex);\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t\n\t        if (encAlg === undefined) encAlg = \"DES-EDE3-CBC\";\n\t        return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"RSA\", asn1Hex, passwd, encAlg);\n\t    }\n\t\n\t    // x. PEM PKCS#5 encrypted private key of ECDSA private key object\n\t    if (formatType == \"PKCS5PRV\" &&\n\t        typeof KJUR.crypto.ECDSA != \"undefined\" &&\n\t        keyObjOrHex instanceof KJUR.crypto.ECDSA &&\n\t        (passwd !== undefined && passwd != null) &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var asn1Obj = _ecdsaprv2asn1obj(keyObjOrHex);\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t\n\t        if (encAlg === undefined) encAlg = \"DES-EDE3-CBC\";\n\t        return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"EC\", asn1Hex, passwd, encAlg);\n\t    }\n\t\n\t    // x. PEM PKCS#5 encrypted private key of DSA private key object\n\t    if (formatType == \"PKCS5PRV\" &&\n\t        typeof KJUR.crypto.DSA != \"undefined\" &&\n\t        keyObjOrHex instanceof KJUR.crypto.DSA &&\n\t        (passwd !== undefined && passwd != null) &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var asn1Obj = _dsaprv2asn1obj(keyObjOrHex);\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t\n\t        if (encAlg === undefined) encAlg = \"DES-EDE3-CBC\";\n\t        return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"DSA\", asn1Hex, passwd, encAlg);\n\t    }\n\t\n\t    // x. ======================================================================\n\t\n\t    var _getEncryptedPKCS8 = function(plainKeyHex, passcode) {\n\t        var info = _getEencryptedPKCS8Info(plainKeyHex, passcode);\n\t        //alert(\"iv=\" + info.encryptionSchemeIV);\n\t        //alert(\"info.ciphertext2[\" + info.ciphertext.length + \"=\" + info.ciphertext);\n\t        var asn1Obj = new KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"seq\": [\n\t                    {\"oid\": {\"name\": \"pkcs5PBES2\"}},\n\t                    {\"seq\": [\n\t                        {\"seq\": [\n\t                            {\"oid\": {\"name\": \"pkcs5PBKDF2\"}},\n\t                            {\"seq\": [\n\t                                {\"octstr\": {\"hex\": info.pbkdf2Salt}},\n\t                                {\"int\": info.pbkdf2Iter}\n\t                            ]}\n\t                        ]},\n\t                        {\"seq\": [\n\t                            {\"oid\": {\"name\": \"des-EDE3-CBC\"}},\n\t                            {\"octstr\": {\"hex\": info.encryptionSchemeIV}}\n\t                        ]}\n\t                    ]}\n\t                ]},\n\t                {\"octstr\": {\"hex\": info.ciphertext}}\n\t            ]\n\t        });\n\t        return asn1Obj.getEncodedHex();\n\t    };\n\t\n\t    var _getEencryptedPKCS8Info = function(plainKeyHex, passcode) {\n\t        var pbkdf2Iter = 100;\n\t        var pbkdf2SaltWS = CryptoJS.lib.WordArray.random(8);\n\t        var encryptionSchemeAlg = \"DES-EDE3-CBC\";\n\t        var encryptionSchemeIVWS = CryptoJS.lib.WordArray.random(8);\n\t        // PBKDF2 key\n\t        var pbkdf2KeyWS = CryptoJS.PBKDF2(passcode, \n\t                                          pbkdf2SaltWS, { \"keySize\": 192/32,\n\t                                                          \"iterations\": pbkdf2Iter });\n\t        // ENCRYPT\n\t        var plainKeyWS = CryptoJS.enc.Hex.parse(plainKeyHex);\n\t        var encryptedKeyHex = \n\t            CryptoJS.TripleDES.encrypt(plainKeyWS, pbkdf2KeyWS, { \"iv\": encryptionSchemeIVWS }) + \"\";\n\t\n\t        //alert(\"encryptedKeyHex=\" + encryptedKeyHex);\n\t\n\t        var info = {};\n\t        info.ciphertext = encryptedKeyHex;\n\t        //alert(\"info.ciphertext=\" + info.ciphertext);\n\t        info.pbkdf2Salt = CryptoJS.enc.Hex.stringify(pbkdf2SaltWS);\n\t        info.pbkdf2Iter = pbkdf2Iter;\n\t        info.encryptionSchemeAlg = encryptionSchemeAlg;\n\t        info.encryptionSchemeIV = CryptoJS.enc.Hex.stringify(encryptionSchemeIVWS);\n\t        return info;\n\t    };\n\t\n\t    // x. PEM PKCS#8 plain private key of RSA private key object\n\t    if (formatType == \"PKCS8PRV\" &&\n\t        typeof RSAKey != \"undefined\" &&\n\t        keyObjOrHex instanceof RSAKey &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var keyObj = _rsaprv2asn1obj(keyObjOrHex);\n\t        var keyHex = keyObj.getEncodedHex();\n\t\n\t        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"int\": 0},\n\t                {\"seq\": [{\"oid\": {\"name\": \"rsaEncryption\"}},{\"null\": true}]},\n\t                {\"octstr\": {\"hex\": keyHex}}\n\t            ]\n\t        });\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t\n\t        if (passwd === undefined || passwd == null) {\n\t            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PRIVATE KEY\");\n\t        } else {\n\t            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);\n\t            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"ENCRYPTED PRIVATE KEY\");\n\t        }\n\t    }\n\t\n\t    // x. PEM PKCS#8 plain private key of ECDSA private key object\n\t    if (formatType == \"PKCS8PRV\" &&\n\t        typeof KJUR.crypto.ECDSA != \"undefined\" &&\n\t        keyObjOrHex instanceof KJUR.crypto.ECDSA &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var keyObj = new KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"int\": 1},\n\t                {\"octstr\": {\"hex\": keyObjOrHex.prvKeyHex}},\n\t                {\"tag\": ['a1', true, {\"bitstr\": {\"hex\": \"00\" + keyObjOrHex.pubKeyHex}}]}\n\t            ]\n\t        });\n\t        var keyHex = keyObj.getEncodedHex();\n\t\n\t        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"int\": 0},\n\t                {\"seq\": [\n\t                    {\"oid\": {\"name\": \"ecPublicKey\"}},\n\t                    {\"oid\": {\"name\": keyObjOrHex.curveName}}\n\t                ]},\n\t                {\"octstr\": {\"hex\": keyHex}}\n\t            ]\n\t        });\n\t\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t        if (passwd === undefined || passwd == null) {\n\t            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PRIVATE KEY\");\n\t        } else {\n\t            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);\n\t            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"ENCRYPTED PRIVATE KEY\");\n\t        }\n\t    }\n\t\n\t    // x. PEM PKCS#8 plain private key of DSA private key object\n\t    if (formatType == \"PKCS8PRV\" &&\n\t        typeof KJUR.crypto.DSA != \"undefined\" &&\n\t        keyObjOrHex instanceof KJUR.crypto.DSA &&\n\t        keyObjOrHex.isPrivate  == true) {\n\t\n\t        var keyObj = new KJUR.asn1.DERInteger({'bigint': keyObjOrHex.x});\n\t        var keyHex = keyObj.getEncodedHex();\n\t\n\t        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n\t            \"seq\": [\n\t                {\"int\": 0},\n\t                {\"seq\": [\n\t                    {\"oid\": {\"name\": \"dsa\"}},\n\t                    {\"seq\": [\n\t                        {\"int\": {\"bigint\": keyObjOrHex.p}},\n\t                        {\"int\": {\"bigint\": keyObjOrHex.q}},\n\t                        {\"int\": {\"bigint\": keyObjOrHex.g}}\n\t                    ]}\n\t                ]},\n\t                {\"octstr\": {\"hex\": keyHex}}\n\t            ]\n\t        });\n\t\n\t        var asn1Hex = asn1Obj.getEncodedHex();\n\t        if (passwd === undefined || passwd == null) {\n\t            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PRIVATE KEY\");\n\t        } else {\n\t            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);\n\t            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"ENCRYPTED PRIVATE KEY\");\n\t        }\n\t    }\n\t\n\t    throw \"unsupported object nor format\";\n\t};\n\t\n\t// -- PUBLIC METHODS FOR CSR -------------------------------------------------------\n\t\n\t/**\n\t * get RSAKey/DSA/ECDSA public key object from PEM formatted PKCS#10 CSR string\n\t * @name getKeyFromCSRPEM\n\t * @memberOf KEYUTIL\n\t * @function\n\t * @param {String} csrPEM PEM formatted PKCS#10 CSR string\n\t * @return {Object} RSAKey/DSA/ECDSA public key object\n\t * @since keyutil 1.0.5\n\t */\n\tKEYUTIL.getKeyFromCSRPEM = function(csrPEM) {\n\t    var csrHex = KEYUTIL.getHexFromPEM(csrPEM, \"CERTIFICATE REQUEST\");\n\t    var key = KEYUTIL.getKeyFromCSRHex(csrHex);\n\t    return key;\n\t};\n\t\n\t/**\n\t * get RSAKey/DSA/ECDSA public key object from hexadecimal string of PKCS#10 CSR\n\t * @name getKeyFromCSRHex\n\t * @memberOf KEYUTIL\n\t * @function\n\t * @param {String} csrHex hexadecimal string of PKCS#10 CSR\n\t * @return {Object} RSAKey/DSA/ECDSA public key object\n\t * @since keyutil 1.0.5\n\t */\n\tKEYUTIL.getKeyFromCSRHex = function(csrHex) {\n\t    var info = KEYUTIL.parseCSRHex(csrHex);\n\t    var key = KEYUTIL.getKey(info.p8pubkeyhex, null, \"pkcs8pub\");\n\t    return key;\n\t};\n\t\n\t/**\n\t * parse hexadecimal string of PKCS#10 CSR (certificate signing request)\n\t * @name parseCSRHex\n\t * @memberOf KEYUTIL\n\t * @function\n\t * @param {String} csrHex hexadecimal string of PKCS#10 CSR\n\t * @return {Array} associative array of parsed CSR\n\t * @since keyutil 1.0.5\n\t * @description\n\t * Resulted associative array has following properties:\n\t * <ul>\n\t * <li>p8pubkeyhex - hexadecimal string of subject public key in PKCS#8</li>\n\t * </ul>\n\t */\n\tKEYUTIL.parseCSRHex = function(csrHex) {\n\t    var result = {};\n\t    var h = csrHex;\n\t\n\t    // 1. sequence\n\t    if (h.substr(0, 2) != \"30\")\n\t        throw \"malformed CSR(code:001)\"; // not sequence\n\t\n\t    var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(h, 0);\n\t    if (a1.length < 1)\n\t        throw \"malformed CSR(code:002)\"; // short length\n\t\n\t    // 2. 2nd sequence\n\t    if (h.substr(a1[0], 2) != \"30\")\n\t        throw \"malformed CSR(code:003)\"; // not sequence\n\t\n\t    var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(h, a1[0]);\n\t    if (a2.length < 3)\n\t        throw \"malformed CSR(code:004)\"; // 2nd seq short elem\n\t\n\t    result.p8pubkeyhex = ASN1HEX.getHexOfTLV_AtObj(h, a2[2]);\n\t\n\t    return result;\n\t};\n\t\n\t// -- OTHER STATIC PUBLIC METHODS  -------------------------------------------------\n\t\n\t/**\n\t * convert from RSAKey/KJUR.crypto.ECDSA public/private key object to RFC 7517 JSON Web Key(JWK)\n\t * @name getJWKFromKey\n\t * @memberOf KEYUTIL\n\t * @function\n\t * @static\n\t * @param {Object} RSAKey/KJUR.crypto.ECDSA public/private key object\n\t * @return {Object} JWK object\n\t * @since keyutil 1.0.13 jsrsasign 5.0.14\n\t * @description\n\t * This static method convert from RSAKey/KJUR.crypto.ECDSA public/private key object \n\t * to RFC 7517 JSON Web Key(JWK)\n\t * @example\n\t * kp1 = KEYUTIL.generateKeypair(\"EC\", \"P-256\");\n\t * jwkPrv1 = KEYUTIL.getJWKFromKey(kp1.prvKeyObj);\n\t * jwkPub1 = KEYUTIL.getJWKFromKey(kp1.pubKeyObj);\n\t *\n\t * kp2 = KEYUTIL.generateKeypair(\"RSA\", 2048);\n\t * jwkPrv2 = KEYUTIL.getJWKFromKey(kp2.prvKeyObj);\n\t * jwkPub2 = KEYUTIL.getJWKFromKey(kp2.pubKeyObj);\n\t *\n\t * // if you need RFC 7636 JWK thumprint as kid do like this:\n\t * jwkPub2.kid = KJUR.jws.JWS.getJWKthumbprint(jwkPub2);\n\t */\n\tKEYUTIL.getJWKFromKey = function(keyObj) {\n\t    var jwk = {};\n\t    if (keyObj instanceof RSAKey && keyObj.isPrivate) {\n\t\tjwk.kty = \"RSA\";\n\t\tjwk.n = hextob64u(keyObj.n.toString(16));\n\t\tjwk.e = hextob64u(keyObj.e.toString(16));\n\t\tjwk.d = hextob64u(keyObj.d.toString(16));\n\t\tjwk.p = hextob64u(keyObj.p.toString(16));\n\t\tjwk.q = hextob64u(keyObj.q.toString(16));\n\t\tjwk.dp = hextob64u(keyObj.dmp1.toString(16));\n\t\tjwk.dq = hextob64u(keyObj.dmq1.toString(16));\n\t\tjwk.qi = hextob64u(keyObj.coeff.toString(16));\n\t\treturn jwk;\n\t    } else if (keyObj instanceof RSAKey && keyObj.isPublic) {\n\t\tjwk.kty = \"RSA\";\n\t\tjwk.n = hextob64u(keyObj.n.toString(16));\n\t\tjwk.e = hextob64u(keyObj.e.toString(16));\n\t\treturn jwk;\n\t    } else if (keyObj instanceof KJUR.crypto.ECDSA && keyObj.isPrivate) {\n\t\tvar name = keyObj.getShortNISTPCurveName();\n\t\tif (name !== \"P-256\" && name !== \"P-384\")\n\t\t    throw \"unsupported curve name for JWT: \" + name;\n\t\tvar xy = keyObj.getPublicKeyXYHex();\n\t\tjwk.kty = \"EC\";\n\t\tjwk.crv =  name;\n\t\tjwk.x = hextob64u(xy.x);\n\t\tjwk.y = hextob64u(xy.y);\n\t\tjwk.d = hextob64u(keyObj.prvKeyHex);\n\t\treturn jwk;\n\t    } else if (keyObj instanceof KJUR.crypto.ECDSA && keyObj.isPublic) {\n\t\tvar name = keyObj.getShortNISTPCurveName();\n\t\tif (name !== \"P-256\" && name !== \"P-384\")\n\t\t    throw \"unsupported curve name for JWT: \" + name;\n\t\tvar xy = keyObj.getPublicKeyXYHex();\n\t\tjwk.kty = \"EC\";\n\t\tjwk.crv =  name;\n\t\tjwk.x = hextob64u(xy.x);\n\t\tjwk.y = hextob64u(xy.y);\n\t\treturn jwk;\n\t    }\n\t    throw \"not supported key object\";\n\t};\n\t\n\t\n\t\n\t/*! crypto-1.1.10.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n\t */\n\t/*\n\t * crypto.js - Cryptographic Algorithm Provider class\n\t *\n\t * Copyright (c) 2013-2016 Kenji Urushima (kenji.urushima@gmail.com)\n\t *\n\t * This software is licensed under the terms of the MIT License.\n\t * http://kjur.github.com/jsrsasign/license\n\t *\n\t * The above copyright and license notice shall be \n\t * included in all copies or substantial portions of the Software.\n\t */\n\t\n\t/**\n\t * @fileOverview\n\t * @name crypto-1.1.js\n\t * @author Kenji Urushima kenji.urushima@gmail.com\n\t * @version 1.1.10 (2016-Oct-29)\n\t * @since jsrsasign 2.2\n\t * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n\t */\n\t\n\t/** \n\t * kjur's class library name space\n\t * @name KJUR\n\t * @namespace kjur's class library name space\n\t */\n\tif (typeof KJUR == \"undefined\" || !KJUR) KJUR = {};\n\t/**\n\t * kjur's cryptographic algorithm provider library name space\n\t * <p>\n\t * This namespace privides following crytpgrahic classes.\n\t * <ul>\n\t * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n\t * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n\t * <li>{@link KJUR.crypto.Cipher} - class for encrypting and decrypting data</li>\n\t * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n\t * </ul>\n\t * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n\t * </p>\n\t * @name KJUR.crypto\n\t * @namespace\n\t */\n\tif (typeof KJUR.crypto == \"undefined\" || !KJUR.crypto) KJUR.crypto = {};\n\t\n\t/**\n\t * static object for cryptographic function utilities\n\t * @name KJUR.crypto.Util\n\t * @class static object for cryptographic function utilities\n\t * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n\t * @property {Array} DEFAULTPROVIDER associative array of default provider name for each hash and signature algorithms\n\t * @description\n\t */\n\tKJUR.crypto.Util = new function() {\n\t    this.DIGESTINFOHEAD = {\n\t\t'sha1':      \"3021300906052b0e03021a05000414\",\n\t        'sha224':    \"302d300d06096086480165030402040500041c\",\n\t\t'sha256':    \"3031300d060960864801650304020105000420\",\n\t\t'sha384':    \"3041300d060960864801650304020205000430\",\n\t\t'sha512':    \"3051300d060960864801650304020305000440\",\n\t\t'md2':       \"3020300c06082a864886f70d020205000410\",\n\t\t'md5':       \"3020300c06082a864886f70d020505000410\",\n\t\t'ripemd160': \"3021300906052b2403020105000414\",\n\t    };\n\t\n\t    /*\n\t     * @since crypto 1.1.1\n\t     */\n\t    this.DEFAULTPROVIDER = {\n\t\t'md5':\t\t\t'cryptojs',\n\t\t'sha1':\t\t\t'cryptojs',\n\t\t'sha224':\t\t'cryptojs',\n\t\t'sha256':\t\t'cryptojs',\n\t\t'sha384':\t\t'cryptojs',\n\t\t'sha512':\t\t'cryptojs',\n\t\t'ripemd160':\t\t'cryptojs',\n\t\t'hmacmd5':\t\t'cryptojs',\n\t\t'hmacsha1':\t\t'cryptojs',\n\t\t'hmacsha224':\t\t'cryptojs',\n\t\t'hmacsha256':\t\t'cryptojs',\n\t\t'hmacsha384':\t\t'cryptojs',\n\t\t'hmacsha512':\t\t'cryptojs',\n\t\t'hmacripemd160':\t'cryptojs',\n\t\n\t\t'MD5withRSA':\t\t'cryptojs/jsrsa',\n\t\t'SHA1withRSA':\t\t'cryptojs/jsrsa',\n\t\t'SHA224withRSA':\t'cryptojs/jsrsa',\n\t\t'SHA256withRSA':\t'cryptojs/jsrsa',\n\t\t'SHA384withRSA':\t'cryptojs/jsrsa',\n\t\t'SHA512withRSA':\t'cryptojs/jsrsa',\n\t\t'RIPEMD160withRSA':\t'cryptojs/jsrsa',\n\t\n\t\t'MD5withECDSA':\t\t'cryptojs/jsrsa',\n\t\t'SHA1withECDSA':\t'cryptojs/jsrsa',\n\t\t'SHA224withECDSA':\t'cryptojs/jsrsa',\n\t\t'SHA256withECDSA':\t'cryptojs/jsrsa',\n\t\t'SHA384withECDSA':\t'cryptojs/jsrsa',\n\t\t'SHA512withECDSA':\t'cryptojs/jsrsa',\n\t\t'RIPEMD160withECDSA':\t'cryptojs/jsrsa',\n\t\n\t\t'SHA1withDSA':\t\t'cryptojs/jsrsa',\n\t\t'SHA224withDSA':\t'cryptojs/jsrsa',\n\t\t'SHA256withDSA':\t'cryptojs/jsrsa',\n\t\n\t\t'MD5withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t\t'SHA1withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t\t'SHA224withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t\t'SHA256withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t\t'SHA384withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t\t'SHA512withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t\t'RIPEMD160withRSAandMGF1':\t'cryptojs/jsrsa',\n\t    };\n\t\n\t    /*\n\t     * @since crypto 1.1.2\n\t     */\n\t    this.CRYPTOJSMESSAGEDIGESTNAME = {\n\t\t'md5':\t\tCryptoJS.algo.MD5,\n\t\t'sha1':\t\tCryptoJS.algo.SHA1,\n\t\t'sha224':\tCryptoJS.algo.SHA224,\n\t\t'sha256':\tCryptoJS.algo.SHA256,\n\t\t'sha384':\tCryptoJS.algo.SHA384,\n\t\t'sha512':\tCryptoJS.algo.SHA512,\n\t\t'ripemd160':\tCryptoJS.algo.RIPEMD160\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal DigestInfo\n\t     * @name getDigestInfoHex\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} hHash hexadecimal hash value\n\t     * @param {String} alg hash algorithm name (ex. 'sha1')\n\t     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n\t     */\n\t    this.getDigestInfoHex = function(hHash, alg) {\n\t\tif (typeof this.DIGESTINFOHEAD[alg] == \"undefined\")\n\t\t    throw \"alg not supported in Util.DIGESTINFOHEAD: \" + alg;\n\t\treturn this.DIGESTINFOHEAD[alg] + hHash;\n\t    };\n\t\n\t    /**\n\t     * get PKCS#1 padded hexadecimal DigestInfo\n\t     * @name getPaddedDigestInfoHex\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} hHash hexadecimal hash value of message to be signed\n\t     * @param {String} alg hash algorithm name (ex. 'sha1')\n\t     * @param {Integer} keySize key bit length (ex. 1024)\n\t     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n\t     */\n\t    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\t\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\t\tvar pmStrLen = keySize / 4; // minimum PM length\n\t\n\t\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t\t    throw \"key is too short for SigAlg: keylen=\" + keySize + \",\" + alg;\n\t\n\t\tvar hHead = \"0001\";\n\t\tvar hTail = \"00\" + hDigestInfo;\n\t\tvar hMid = \"\";\n\t\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\t\tfor (var i = 0; i < fLen; i += 2) {\n\t\t    hMid += \"ff\";\n\t\t}\n\t\tvar hPaddedMessage = hHead + hMid + hTail;\n\t\treturn hPaddedMessage;\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal hash of string with specified algorithm\n\t     * @name hashString\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} s input string to be hashed\n\t     * @param {String} alg hash algorithm name\n\t     * @return {String} hexadecimal string of hash value\n\t     * @since 1.1.1\n\t     */\n\t    this.hashString = function(s, alg) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg': alg});\n\t        return md.digestString(s);\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal hash of hexadecimal string with specified algorithm\n\t     * @name hashHex\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} sHex input hexadecimal string to be hashed\n\t     * @param {String} alg hash algorithm name\n\t     * @return {String} hexadecimal string of hash value\n\t     * @since 1.1.1\n\t     */\n\t    this.hashHex = function(sHex, alg) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg': alg});\n\t        return md.digestHex(sHex);\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal SHA1 hash of string\n\t     * @name sha1\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} s input string to be hashed\n\t     * @return {String} hexadecimal string of hash value\n\t     * @since 1.0.3\n\t     */\n\t    this.sha1 = function(s) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg':'sha1', 'prov':'cryptojs'});\n\t        return md.digestString(s);\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal SHA256 hash of string\n\t     * @name sha256\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} s input string to be hashed\n\t     * @return {String} hexadecimal string of hash value\n\t     * @since 1.0.3\n\t     */\n\t    this.sha256 = function(s) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg':'sha256', 'prov':'cryptojs'});\n\t        return md.digestString(s);\n\t    };\n\t\n\t    this.sha256Hex = function(s) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg':'sha256', 'prov':'cryptojs'});\n\t        return md.digestHex(s);\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal SHA512 hash of string\n\t     * @name sha512\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} s input string to be hashed\n\t     * @return {String} hexadecimal string of hash value\n\t     * @since 1.0.3\n\t     */\n\t    this.sha512 = function(s) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg':'sha512', 'prov':'cryptojs'});\n\t        return md.digestString(s);\n\t    };\n\t\n\t    this.sha512Hex = function(s) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg':'sha512', 'prov':'cryptojs'});\n\t        return md.digestHex(s);\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal MD5 hash of string\n\t     * @name md5\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} s input string to be hashed\n\t     * @return {String} hexadecimal string of hash value\n\t     * @since 1.0.3\n\t     */\n\t    this.md5 = function(s) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg':'md5', 'prov':'cryptojs'});\n\t        return md.digestString(s);\n\t    };\n\t\n\t    /**\n\t     * get hexadecimal RIPEMD160 hash of string\n\t     * @name ripemd160\n\t     * @memberOf KJUR.crypto.Util\n\t     * @function\n\t     * @param {String} s input string to be hashed\n\t     * @return {String} hexadecimal string of hash value\n\t     * @since 1.0.3\n\t     */\n\t    this.ripemd160 = function(s) {\n\t        var md = new KJUR.crypto.MessageDigest({'alg':'ripemd160', 'prov':'cryptojs'});\n\t        return md.digestString(s);\n\t    };\n\t\n\t    /*\n\t     * @since 1.1.2\n\t     */\n\t    this.getCryptoJSMDByName = function(s) {\n\t\t\n\t    };\n\t};\n\t\n\t// === Mac ===============================================================\n\t\n\t/**\n\t * MessageDigest class which is very similar to java.security.MessageDigest class<br/>\n\t * @name KJUR.crypto.MessageDigest\n\t * @class MessageDigest class which is very similar to java.security.MessageDigest class\n\t * @param {Array} params parameters for constructor\n\t * @property {Array} HASHLENGTH static Array of resulted byte length of hash (ex. HASHLENGTH[\"sha1\"] == 20)\n\t * @description\n\t * <br/>\n\t * Currently this supports following algorithm and providers combination:\n\t * <ul>\n\t * <li>md5 - cryptojs</li>\n\t * <li>sha1 - cryptojs</li>\n\t * <li>sha224 - cryptojs</li>\n\t * <li>sha256 - cryptojs</li>\n\t * <li>sha384 - cryptojs</li>\n\t * <li>sha512 - cryptojs</li>\n\t * <li>ripemd160 - cryptojs</li>\n\t * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n\t * </ul>\n\t * @example\n\t * // CryptoJS provider sample\n\t * var md = new KJUR.crypto.MessageDigest({alg: \"sha1\", prov: \"cryptojs\"});\n\t * md.updateString('aaa')\n\t * var mdHex = md.digest()\n\t *\n\t * // SJCL(Stanford JavaScript Crypto Library) provider sample\n\t * var md = new KJUR.crypto.MessageDigest({alg: \"sha256\", prov: \"sjcl\"}); // sjcl supports sha256 only\n\t * md.updateString('aaa')\n\t * var mdHex = md.digest()\n\t *\n\t * // HASHLENGTH property\n\t * KJUR.crypto.MessageDigest.HASHLENGTH['sha1'] &rarr 20\n\t * KJUR.crypto.MessageDigest.HASHLENGTH['sha512'] &rarr 64\n\t */\n\tKJUR.crypto.MessageDigest = function(params) {\n\t    var md = null;\n\t    var algName = null;\n\t    var provName = null;\n\t\n\t    /**\n\t     * set hash algorithm and provider<br/>\n\t     * @name setAlgAndProvider\n\t     * @memberOf KJUR.crypto.MessageDigest#\n\t     * @function\n\t     * @param {String} alg hash algorithm name\n\t     * @param {String} prov provider name\n\t     * @description\n\t     * This methods set an algorithm and a cryptographic provider.<br/>\n\t     * Here is acceptable algorithm names ignoring cases and hyphens:\n\t     * <ul>\n\t     * <li>MD5</li>\n\t     * <li>SHA1</li>\n\t     * <li>SHA224</li>\n\t     * <li>SHA256</li>\n\t     * <li>SHA384</li>\n\t     * <li>SHA512</li>\n\t     * <li>RIPEMD160</li>\n\t     * </ul>\n\t     * NOTE: Since jsrsasign 6.2.0 crypto 1.1.10, this method ignores\n\t     * upper or lower cases. Also any hyphens (i.e. \"-\") will be ignored\n\t     * so that \"SHA1\" or \"SHA-1\" will be acceptable.\n\t     * @example\n\t     * // for SHA1\n\t     * md.setAlgAndProvider('sha1', 'cryptojs');\n\t     * md.setAlgAndProvider('SHA1');\n\t     * // for RIPEMD160\n\t     * md.setAlgAndProvider('ripemd160', 'cryptojs');\n\t     */\n\t    this.setAlgAndProvider = function(alg, prov) {\n\t\talg = KJUR.crypto.MessageDigest.getCanonicalAlgName(alg);\n\t\n\t\tif (alg !== null && prov === undefined) prov = KJUR.crypto.Util.DEFAULTPROVIDER[alg];\n\t\n\t\t// for cryptojs\n\t\tif (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(alg) != -1 &&\n\t\t    prov == 'cryptojs') {\n\t\t    try {\n\t\t\tthis.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[alg].create();\n\t\t    } catch (ex) {\n\t\t\tthrow \"setAlgAndProvider hash alg set fail alg=\" + alg + \"/\" + ex;\n\t\t    }\n\t\t    this.updateString = function(str) {\n\t\t\tthis.md.update(str);\n\t\t    };\n\t\t    this.updateHex = function(hex) {\n\t\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\t\tthis.md.update(wHex);\n\t\t    };\n\t\t    this.digest = function() {\n\t\t\tvar hash = this.md.finalize();\n\t\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t\t    };\n\t\t    this.digestString = function(str) {\n\t\t\tthis.updateString(str);\n\t\t\treturn this.digest();\n\t\t    };\n\t\t    this.digestHex = function(hex) {\n\t\t\tthis.updateHex(hex);\n\t\t\treturn this.digest();\n\t\t    };\n\t\t}\n\t\tif (':sha256:'.indexOf(alg) != -1 &&\n\t\t    prov == 'sjcl') {\n\t\t    try {\n\t\t\tthis.md = new sjcl.hash.sha256();\n\t\t    } catch (ex) {\n\t\t\tthrow \"setAlgAndProvider hash alg set fail alg=\" + alg + \"/\" + ex;\n\t\t    }\n\t\t    this.updateString = function(str) {\n\t\t\tthis.md.update(str);\n\t\t    };\n\t\t    this.updateHex = function(hex) {\n\t\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\t\tthis.md.update(baHex);\n\t\t    };\n\t\t    this.digest = function() {\n\t\t\tvar hash = this.md.finalize();\n\t\t\treturn sjcl.codec.hex.fromBits(hash);\n\t\t    };\n\t\t    this.digestString = function(str) {\n\t\t\tthis.updateString(str);\n\t\t\treturn this.digest();\n\t\t    };\n\t\t    this.digestHex = function(hex) {\n\t\t\tthis.updateHex(hex);\n\t\t\treturn this.digest();\n\t\t    };\n\t\t}\n\t    };\n\t\n\t    /**\n\t     * update digest by specified string\n\t     * @name updateString\n\t     * @memberOf KJUR.crypto.MessageDigest#\n\t     * @function\n\t     * @param {String} str string to update\n\t     * @description\n\t     * @example\n\t     * md.updateString('New York');\n\t     */\n\t    this.updateString = function(str) {\n\t\tthrow \"updateString(str) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n\t    };\n\t\n\t    /**\n\t     * update digest by specified hexadecimal string\n\t     * @name updateHex\n\t     * @memberOf KJUR.crypto.MessageDigest#\n\t     * @function\n\t     * @param {String} hex hexadecimal string to update\n\t     * @description\n\t     * @example\n\t     * md.updateHex('0afe36');\n\t     */\n\t    this.updateHex = function(hex) {\n\t\tthrow \"updateHex(hex) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n\t    };\n\t\n\t    /**\n\t     * completes hash calculation and returns hash result\n\t     * @name digest\n\t     * @memberOf KJUR.crypto.MessageDigest#\n\t     * @function\n\t     * @description\n\t     * @example\n\t     * md.digest()\n\t     */\n\t    this.digest = function() {\n\t\tthrow \"digest() not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n\t    };\n\t\n\t    /**\n\t     * performs final update on the digest using string, then completes the digest computation\n\t     * @name digestString\n\t     * @memberOf KJUR.crypto.MessageDigest#\n\t     * @function\n\t     * @param {String} str string to final update\n\t     * @description\n\t     * @example\n\t     * md.digestString('aaa')\n\t     */\n\t    this.digestString = function(str) {\n\t\tthrow \"digestString(str) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n\t    };\n\t\n\t    /**\n\t     * performs final update on the digest using hexadecimal string, then completes the digest computation\n\t     * @name digestHex\n\t     * @memberOf KJUR.crypto.MessageDigest#\n\t     * @function\n\t     * @param {String} hex hexadecimal string to final update\n\t     * @description\n\t     * @example\n\t     * md.digestHex('0f2abd')\n\t     */\n\t    this.digestHex = function(hex) {\n\t\tthrow \"digestHex(hex) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n\t    };\n\t\n\t    if (params !== undefined) {\n\t\tif (params['alg'] !== undefined) {\n\t\t    this.algName = params['alg'];\n\t\t    if (params['prov'] === undefined)\n\t\t\tthis.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];\n\t\t    this.setAlgAndProvider(this.algName, this.provName);\n\t\t}\n\t    }\n\t};\n\t\n\t/**\n\t * get canonical hash algorithm name<br/>\n\t * @name getCanonicalAlgName\n\t * @memberOf KJUR.crypto.MessageDigest\n\t * @function\n\t * @param {String} alg hash algorithm name (ex. MD5, SHA-1, SHA1, SHA512 et.al.)\n\t * @return {String} canonical hash algorithm name\n\t * @since jsrsasign 6.2.0 crypto 1.1.10\n\t * @description\n\t * This static method normalizes from any hash algorithm name such as\n\t * \"SHA-1\", \"SHA1\", \"MD5\", \"sha512\" to lower case name without hyphens\n\t * such as \"sha1\".\n\t * @example\n\t * KJUR.crypto.MessageDigest.getCanonicalAlgName(\"SHA-1\") &rarr \"sha1\"\n\t * KJUR.crypto.MessageDigest.getCanonicalAlgName(\"MD5\")   &rarr \"md5\"\n\t */\n\tKJUR.crypto.MessageDigest.getCanonicalAlgName = function(alg) {\n\t    if (typeof alg === \"string\") {\n\t\talg = alg.toLowerCase();\n\t\talg = alg.replace(/-/, '');\n\t    }\n\t    return alg;\n\t};\n\t\n\t/**\n\t * get resulted hash byte length for specified algorithm name<br/>\n\t * @name getHashLength\n\t * @memberOf KJUR.crypto.MessageDigest\n\t * @function\n\t * @param {String} alg non-canonicalized hash algorithm name (ex. MD5, SHA-1, SHA1, SHA512 et.al.)\n\t * @return {Integer} resulted hash byte length\n\t * @since jsrsasign 6.2.0 crypto 1.1.10\n\t * @description\n\t * This static method returns resulted byte length for specified algorithm name such as \"SHA-1\".\n\t * @example\n\t * KJUR.crypto.MessageDigest.getHashLength(\"SHA-1\") &rarr 20\n\t * KJUR.crypto.MessageDigest.getHashLength(\"sha1\") &rarr 20\n\t */\n\tKJUR.crypto.MessageDigest.getHashLength = function(alg) {\n\t    var MD = KJUR.crypto.MessageDigest\n\t    var alg2 = MD.getCanonicalAlgName(alg);\n\t    if (MD.HASHLENGTH[alg2] === undefined)\n\t\tthrow \"not supported algorithm: \" + alg;\n\t    return MD.HASHLENGTH[alg2];\n\t};\n\t\n\t// described in KJUR.crypto.MessageDigest class (since jsrsasign 6.2.0 crypto 1.1.10)\n\tKJUR.crypto.MessageDigest.HASHLENGTH = {\n\t    'md5':\t\t16,\n\t    'sha1':\t\t20,\n\t    'sha224':\t\t28,\n\t    'sha256':\t\t32,\n\t    'sha384':\t\t48,\n\t    'sha512':\t\t64,\n\t    'ripemd160':\t20\n\t};\n\t\n\t// === Mac ===============================================================\n\t\n\t/**\n\t * Mac(Message Authentication Code) class which is very similar to java.security.Mac class \n\t * @name KJUR.crypto.Mac\n\t * @class Mac class which is very similar to java.security.Mac class\n\t * @param {Array} params parameters for constructor\n\t * @description\n\t * <br/>\n\t * Currently this supports following algorithm and providers combination:\n\t * <ul>\n\t * <li>hmacmd5 - cryptojs</li>\n\t * <li>hmacsha1 - cryptojs</li>\n\t * <li>hmacsha224 - cryptojs</li>\n\t * <li>hmacsha256 - cryptojs</li>\n\t * <li>hmacsha384 - cryptojs</li>\n\t * <li>hmacsha512 - cryptojs</li>\n\t * </ul>\n\t * NOTE: HmacSHA224 and HmacSHA384 issue was fixed since jsrsasign 4.1.4.\n\t * Please use 'ext/cryptojs-312-core-fix*.js' instead of 'core.js' of original CryptoJS\n\t * to avoid those issue.\n\t * <br/>\n\t * NOTE2: Hmac signature bug was fixed in jsrsasign 4.9.0 by providing CryptoJS\n\t * bug workaround.\n\t * <br/>\n\t * Please see {@link KJUR.crypto.Mac.setPassword}, how to provide password\n\t * in various ways in detail.\n\t * @example\n\t * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA1\", \"pass\": \"pass\"});\n\t * mac.updateString('aaa')\n\t * var macHex = md.doFinal()\n\t *\n\t * // other password representation \n\t * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"hex\":  \"6161\"}});\n\t * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"utf8\": \"aa\"}});\n\t * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"rstr\": \"\\x61\\x61\"}});\n\t * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"b64\":  \"Mi02/+...a==\"}});\n\t * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"b64u\": \"Mi02_-...a\"}});\n\t */\n\tKJUR.crypto.Mac = function(params) {\n\t    var mac = null;\n\t    var pass = null;\n\t    var algName = null;\n\t    var provName = null;\n\t    var algProv = null;\n\t\n\t    this.setAlgAndProvider = function(alg, prov) {\n\t\talg = alg.toLowerCase();\n\t\n\t\tif (alg == null) alg = \"hmacsha1\";\n\t\n\t\talg = alg.toLowerCase();\n\t        if (alg.substr(0, 4) != \"hmac\") {\n\t\t    throw \"setAlgAndProvider unsupported HMAC alg: \" + alg;\n\t\t}\n\t\n\t\tif (prov === undefined) prov = KJUR.crypto.Util.DEFAULTPROVIDER[alg];\n\t\tthis.algProv = alg + \"/\" + prov;\n\t\n\t\tvar hashAlg = alg.substr(4);\n\t\n\t\t// for cryptojs\n\t\tif (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(hashAlg) != -1 &&\n\t\t    prov == 'cryptojs') {\n\t\t    try {\n\t\t\tvar mdObj = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[hashAlg];\n\t\t\tthis.mac = CryptoJS.algo.HMAC.create(mdObj, this.pass);\n\t\t    } catch (ex) {\n\t\t\tthrow \"setAlgAndProvider hash alg set fail hashAlg=\" + hashAlg + \"/\" + ex;\n\t\t    }\n\t\t    this.updateString = function(str) {\n\t\t\tthis.mac.update(str);\n\t\t    };\n\t\t    this.updateHex = function(hex) {\n\t\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\t\tthis.mac.update(wHex);\n\t\t    };\n\t\t    this.doFinal = function() {\n\t\t\tvar hash = this.mac.finalize();\n\t\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t\t    };\n\t\t    this.doFinalString = function(str) {\n\t\t\tthis.updateString(str);\n\t\t\treturn this.doFinal();\n\t\t    };\n\t\t    this.doFinalHex = function(hex) {\n\t\t\tthis.updateHex(hex);\n\t\t\treturn this.doFinal();\n\t\t    };\n\t\t}\n\t    };\n\t\n\t    /**\n\t     * update digest by specified string\n\t     * @name updateString\n\t     * @memberOf KJUR.crypto.Mac#\n\t     * @function\n\t     * @param {String} str string to update\n\t     * @description\n\t     * @example\n\t     * md.updateString('New York');\n\t     */\n\t    this.updateString = function(str) {\n\t\tthrow \"updateString(str) not supported for this alg/prov: \" + this.algProv;\n\t    };\n\t\n\t    /**\n\t     * update digest by specified hexadecimal string\n\t     * @name updateHex\n\t     * @memberOf KJUR.crypto.Mac#\n\t     * @function\n\t     * @param {String} hex hexadecimal string to update\n\t     * @description\n\t     * @example\n\t     * md.updateHex('0afe36');\n\t     */\n\t    this.updateHex = function(hex) {\n\t\tthrow \"updateHex(hex) not supported for this alg/prov: \" + this.algProv;\n\t    };\n\t\n\t    /**\n\t     * completes hash calculation and returns hash result\n\t     * @name doFinal\n\t     * @memberOf KJUR.crypto.Mac#\n\t     * @function\n\t     * @description\n\t     * @example\n\t     * md.digest()\n\t     */\n\t    this.doFinal = function() {\n\t\tthrow \"digest() not supported for this alg/prov: \" + this.algProv;\n\t    };\n\t\n\t    /**\n\t     * performs final update on the digest using string, then completes the digest computation\n\t     * @name doFinalString\n\t     * @memberOf KJUR.crypto.Mac#\n\t     * @function\n\t     * @param {String} str string to final update\n\t     * @description\n\t     * @example\n\t     * md.digestString('aaa')\n\t     */\n\t    this.doFinalString = function(str) {\n\t\tthrow \"digestString(str) not supported for this alg/prov: \" + this.algProv;\n\t    };\n\t\n\t    /**\n\t     * performs final update on the digest using hexadecimal string, \n\t     * then completes the digest computation\n\t     * @name doFinalHex\n\t     * @memberOf KJUR.crypto.Mac#\n\t     * @function\n\t     * @param {String} hex hexadecimal string to final update\n\t     * @description\n\t     * @example\n\t     * md.digestHex('0f2abd')\n\t     */\n\t    this.doFinalHex = function(hex) {\n\t\tthrow \"digestHex(hex) not supported for this alg/prov: \" + this.algProv;\n\t    };\n\t\n\t    /**\n\t     * set password for Mac\n\t     * @name setPassword\n\t     * @memberOf KJUR.crypto.Mac#\n\t     * @function\n\t     * @param {Object} pass password for Mac\n\t     * @since crypto 1.1.7 jsrsasign 4.9.0\n\t     * @description\n\t     * This method will set password for (H)Mac internally.\n\t     * Argument 'pass' can be specified as following:\n\t     * <ul>\n\t     * <li>even length string of 0..9, a..f or A-F: implicitly specified as hexadecimal string</li>\n\t     * <li>not above string: implicitly specified as raw string</li>\n\t     * <li>{rstr: \"\\x65\\x70\"}: explicitly specified as raw string</li>\n\t     * <li>{hex: \"6570\"}: explicitly specified as hexacedimal string</li>\n\t     * <li>{utf8: \"秘密\"}: explicitly specified as UTF8 string</li>\n\t     * <li>{b64: \"Mi78..==\"}: explicitly specified as Base64 string</li>\n\t     * <li>{b64u: \"Mi7-_\"}: explicitly specified as Base64URL string</li>\n\t     * </ul>\n\t     * It is *STRONGLY RECOMMENDED* that explicit representation of password argument\n\t     * to avoid ambiguity. For example string  \"6161\" can mean a string \"6161\" or \n\t     * a hexadecimal string of \"aa\" (i.e. \\x61\\x61).\n\t     * @example\n\t     * mac = KJUR.crypto.Mac({'alg': 'hmacsha256'});\n\t     * // set password by implicit raw string\n\t     * mac.setPassword(\"\\x65\\x70\\xb9\\x0b\");\n\t     * mac.setPassword(\"password\");\n\t     * // set password by implicit hexadecimal string\n\t     * mac.setPassword(\"6570b90b\");\n\t     * mac.setPassword(\"6570B90B\");\n\t     * // set password by explicit raw string\n\t     * mac.setPassword({\"rstr\": \"\\x65\\x70\\xb9\\x0b\"});\n\t     * // set password by explicit hexadecimal string\n\t     * mac.setPassword({\"hex\": \"6570b90b\"});\n\t     * // set password by explicit utf8 string\n\t     * mac.setPassword({\"utf8\": \"passwordパスワード\");\n\t     * // set password by explicit Base64 string\n\t     * mac.setPassword({\"b64\": \"Mb+c3f/==\"});\n\t     * // set password by explicit Base64URL string\n\t     * mac.setPassword({\"b64u\": \"Mb-c3f_\"});\n\t     */\n\t    this.setPassword = function(pass) {\n\t\t// internal this.pass shall be CryptoJS DWord Object for CryptoJS bug\n\t\t// work around. CrytoJS HMac password can be passed by\n\t\t// raw string as described in the manual however it doesn't\n\t\t// work properly in some case. If password was passed\n\t\t// by CryptoJS DWord which is not described in the manual\n\t\t// it seems to work. (fixed since crypto 1.1.7)\n\t\n\t\tif (typeof pass == 'string') {\n\t\t    var hPass = pass;\n\t\t    if (pass.length % 2 == 1 || ! pass.match(/^[0-9A-Fa-f]+$/)) { // raw str\n\t\t\thPass = rstrtohex(pass);\n\t\t    }\n\t\t    this.pass = CryptoJS.enc.Hex.parse(hPass);\n\t\t    return;\n\t\t}\n\t\n\t\tif (typeof pass != 'object')\n\t\t    throw \"KJUR.crypto.Mac unsupported password type: \" + pass;\n\t\t\n\t\tvar hPass = null;\n\t\tif (pass.hex  !== undefined) {\n\t\t    if (pass.hex.length % 2 != 0 || ! pass.hex.match(/^[0-9A-Fa-f]+$/))\n\t\t\tthrow \"Mac: wrong hex password: \" + pass.hex;\n\t\t    hPass = pass.hex;\n\t\t}\n\t\tif (pass.utf8 !== undefined) hPass = utf8tohex(pass.utf8);\n\t\tif (pass.rstr !== undefined) hPass = rstrtohex(pass.rstr);\n\t\tif (pass.b64  !== undefined) hPass = b64tohex(pass.b64);\n\t\tif (pass.b64u !== undefined) hPass = b64utohex(pass.b64u);\n\t\n\t\tif (hPass == null)\n\t\t    throw \"KJUR.crypto.Mac unsupported password type: \" + pass;\n\t\n\t\tthis.pass = CryptoJS.enc.Hex.parse(hPass);\n\t    };\n\t\n\t    if (params !== undefined) {\n\t\tif (params.pass !== undefined) {\n\t\t    this.setPassword(params.pass);\n\t\t}\n\t\tif (params.alg !== undefined) {\n\t\t    this.algName = params.alg;\n\t\t    if (params['prov'] === undefined)\n\t\t\tthis.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];\n\t\t    this.setAlgAndProvider(this.algName, this.provName);\n\t\t}\n\t    }\n\t};\n\t\n\t// ====== Signature class =========================================================\n\t/**\n\t * Signature class which is very similar to java.security.Signature class\n\t * @name KJUR.crypto.Signature\n\t * @class Signature class which is very similar to java.security.Signature class\n\t * @param {Array} params parameters for constructor\n\t * @property {String} state Current state of this signature object whether 'SIGN', 'VERIFY' or null\n\t * @description\n\t * <br/>\n\t * As for params of constructor's argument, it can be specify following attributes:\n\t * <ul>\n\t * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}with{RSA,ECDSA,DSA})</li>\n\t * <li>provider - currently 'cryptojs/jsrsa' only</li>\n\t * </ul>\n\t * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n\t * This Signature class supports following signature algorithm and provider names:\n\t * <ul>\n\t * <li>MD5withRSA - cryptojs/jsrsa</li>\n\t * <li>SHA1withRSA - cryptojs/jsrsa</li>\n\t * <li>SHA224withRSA - cryptojs/jsrsa</li>\n\t * <li>SHA256withRSA - cryptojs/jsrsa</li>\n\t * <li>SHA384withRSA - cryptojs/jsrsa</li>\n\t * <li>SHA512withRSA - cryptojs/jsrsa</li>\n\t * <li>RIPEMD160withRSA - cryptojs/jsrsa</li>\n\t * <li>MD5withECDSA - cryptojs/jsrsa</li>\n\t * <li>SHA1withECDSA - cryptojs/jsrsa</li>\n\t * <li>SHA224withECDSA - cryptojs/jsrsa</li>\n\t * <li>SHA256withECDSA - cryptojs/jsrsa</li>\n\t * <li>SHA384withECDSA - cryptojs/jsrsa</li>\n\t * <li>SHA512withECDSA - cryptojs/jsrsa</li>\n\t * <li>RIPEMD160withECDSA - cryptojs/jsrsa</li>\n\t * <li>MD5withRSAandMGF1 - cryptojs/jsrsa</li>\n\t * <li>SHA1withRSAandMGF1 - cryptojs/jsrsa</li>\n\t * <li>SHA224withRSAandMGF1 - cryptojs/jsrsa</li>\n\t * <li>SHA256withRSAandMGF1 - cryptojs/jsrsa</li>\n\t * <li>SHA384withRSAandMGF1 - cryptojs/jsrsa</li>\n\t * <li>SHA512withRSAandMGF1 - cryptojs/jsrsa</li>\n\t * <li>RIPEMD160withRSAandMGF1 - cryptojs/jsrsa</li>\n\t * <li>SHA1withDSA - cryptojs/jsrsa</li>\n\t * <li>SHA224withDSA - cryptojs/jsrsa</li>\n\t * <li>SHA256withDSA - cryptojs/jsrsa</li>\n\t * </ul>\n\t * Here are supported elliptic cryptographic curve names and their aliases for ECDSA:\n\t * <ul>\n\t * <li>secp256k1</li>\n\t * <li>secp256r1, NIST P-256, P-256, prime256v1</li>\n\t * <li>secp384r1, NIST P-384, P-384</li>\n\t * </ul>\n\t * NOTE1: DSA signing algorithm is also supported since crypto 1.1.5.\n\t * <h4>EXAMPLES</h4>\n\t * @example\n\t * // RSA signature generation\n\t * var sig = new KJUR.crypto.Signature({\"alg\": \"SHA1withRSA\"});\n\t * sig.init(prvKeyPEM);\n\t * sig.updateString('aaa');\n\t * var hSigVal = sig.sign();\n\t *\n\t * // DSA signature validation\n\t * var sig2 = new KJUR.crypto.Signature({\"alg\": \"SHA1withDSA\"});\n\t * sig2.init(certPEM);\n\t * sig.updateString('aaa');\n\t * var isValid = sig2.verify(hSigVal);\n\t * \n\t * // ECDSA signing\n\t * var sig = new KJUR.crypto.Signature({'alg':'SHA1withECDSA'});\n\t * sig.init(prvKeyPEM);\n\t * sig.updateString('aaa');\n\t * var sigValueHex = sig.sign();\n\t *\n\t * // ECDSA verifying\n\t * var sig2 = new KJUR.crypto.Signature({'alg':'SHA1withECDSA'});\n\t * sig.init(certPEM);\n\t * sig.updateString('aaa');\n\t * var isValid = sig.verify(sigValueHex);\n\t */\n\tKJUR.crypto.Signature = function(params) {\n\t    var prvKey = null; // RSAKey/KJUR.crypto.{ECDSA,DSA} object for signing\n\t    var pubKey = null; // RSAKey/KJUR.crypto.{ECDSA,DSA} object for verifying\n\t\n\t    var md = null; // KJUR.crypto.MessageDigest object\n\t    var sig = null;\n\t    var algName = null;\n\t    var provName = null;\n\t    var algProvName = null;\n\t    var mdAlgName = null;\n\t    var pubkeyAlgName = null;\t// rsa,ecdsa,rsaandmgf1(=rsapss)\n\t    var state = null;\n\t    var pssSaltLen = -1;\n\t    var initParams = null;\n\t\n\t    var sHashHex = null; // hex hash value for hex\n\t    var hDigestInfo = null;\n\t    var hPaddedDigestInfo = null;\n\t    var hSign = null;\n\t\n\t    this._setAlgNames = function() {\n\t    var matchResult = this.algName.match(/^(.+)with(.+)$/);\n\t\tif (matchResult) {\n\t\t    this.mdAlgName = matchResult[1].toLowerCase();\n\t\t    this.pubkeyAlgName = matchResult[2].toLowerCase();\n\t\t}\n\t    };\n\t\n\t    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\t\tvar s = \"\";\n\t\tvar nZero = bitLength / 4 - hex.length;\n\t\tfor (var i = 0; i < nZero; i++) {\n\t\t    s = s + \"0\";\n\t\t}\n\t\treturn s + hex;\n\t    };\n\t\n\t    /**\n\t     * set signature algorithm and provider\n\t     * @name setAlgAndProvider\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {String} alg signature algorithm name\n\t     * @param {String} prov provider name\n\t     * @description\n\t     * @example\n\t     * md.setAlgAndProvider('SHA1withRSA', 'cryptojs/jsrsa');\n\t     */\n\t    this.setAlgAndProvider = function(alg, prov) {\n\t\tthis._setAlgNames();\n\t\tif (prov != 'cryptojs/jsrsa')\n\t\t    throw \"provider not supported: \" + prov;\n\t\n\t\tif (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(this.mdAlgName) != -1) {\n\t\t    try {\n\t\t\tthis.md = new KJUR.crypto.MessageDigest({'alg':this.mdAlgName});\n\t\t    } catch (ex) {\n\t\t\tthrow \"setAlgAndProvider hash alg set fail alg=\" +\n\t                      this.mdAlgName + \"/\" + ex;\n\t\t    }\n\t\n\t\t    this.init = function(keyparam, pass) {\n\t\t\tvar keyObj = null;\n\t\t\ttry {\n\t\t\t    if (pass === undefined) {\n\t\t\t\tkeyObj = KEYUTIL.getKey(keyparam);\n\t\t\t    } else {\n\t\t\t\tkeyObj = KEYUTIL.getKey(keyparam, pass);\n\t\t\t    }\n\t\t\t} catch (ex) {\n\t\t\t    throw \"init failed:\" + ex;\n\t\t\t}\n\t\n\t\t\tif (keyObj.isPrivate === true) {\n\t\t\t    this.prvKey = keyObj;\n\t\t\t    this.state = \"SIGN\";\n\t\t\t} else if (keyObj.isPublic === true) {\n\t\t\t    this.pubKey = keyObj;\n\t\t\t    this.state = \"VERIFY\";\n\t\t\t} else {\n\t\t\t    throw \"init failed.:\" + keyObj;\n\t\t\t}\n\t\t    };\n\t\n\t\t    this.initSign = function(params) {\n\t\t\tif (typeof params['ecprvhex'] == 'string' &&\n\t                    typeof params['eccurvename'] == 'string') {\n\t\t\t    this.ecprvhex = params['ecprvhex'];\n\t\t\t    this.eccurvename = params['eccurvename'];\n\t\t\t} else {\n\t\t\t    this.prvKey = params;\n\t\t\t}\n\t\t\tthis.state = \"SIGN\";\n\t\t    };\n\t\n\t\t    this.initVerifyByPublicKey = function(params) {\n\t\t\tif (typeof params['ecpubhex'] == 'string' &&\n\t\t\t    typeof params['eccurvename'] == 'string') {\n\t\t\t    this.ecpubhex = params['ecpubhex'];\n\t\t\t    this.eccurvename = params['eccurvename'];\n\t\t\t} else if (params instanceof KJUR.crypto.ECDSA) {\n\t\t\t    this.pubKey = params;\n\t\t\t} else if (params instanceof RSAKey) {\n\t\t\t    this.pubKey = params;\n\t\t\t}\n\t\t\tthis.state = \"VERIFY\";\n\t\t    };\n\t\n\t\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\t\tvar x509 = new X509();\n\t\t\tx509.readCertPEM(certPEM);\n\t\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\t\tthis.state = \"VERIFY\";\n\t\t    };\n\t\n\t\t    this.updateString = function(str) {\n\t\t\tthis.md.updateString(str);\n\t\t    };\n\t\n\t\t    this.updateHex = function(hex) {\n\t\t\tthis.md.updateHex(hex);\n\t\t    };\n\t\n\t\t    this.sign = function() {\n\t\t\tthis.sHashHex = this.md.digest();\n\t\t\tif (typeof this.ecprvhex != \"undefined\" &&\n\t\t\t    typeof this.eccurvename != \"undefined\") {\n\t\t\t    var ec = new KJUR.crypto.ECDSA({'curve': this.eccurvename});\n\t\t\t    this.hSign = ec.signHex(this.sHashHex, this.ecprvhex);\n\t\t\t} else if (this.prvKey instanceof RSAKey &&\n\t\t\t           this.pubkeyAlgName == \"rsaandmgf1\") {\n\t\t\t    this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex,\n\t\t\t\t\t\t\t\t\t    this.mdAlgName,\n\t\t\t\t\t\t\t\t\t    this.pssSaltLen);\n\t\t\t} else if (this.prvKey instanceof RSAKey &&\n\t\t\t\t   this.pubkeyAlgName == \"rsa\") {\n\t\t\t    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex,\n\t\t\t\t\t\t\t\t\t this.mdAlgName);\n\t\t\t} else if (this.prvKey instanceof KJUR.crypto.ECDSA) {\n\t\t\t    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);\n\t\t\t} else if (this.prvKey instanceof KJUR.crypto.DSA) {\n\t\t\t    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);\n\t\t\t} else {\n\t\t\t    throw \"Signature: unsupported public key alg: \" + this.pubkeyAlgName;\n\t\t\t}\n\t\t\treturn this.hSign;\n\t\t    };\n\t\t    this.signString = function(str) {\n\t\t\tthis.updateString(str);\n\t\t\treturn this.sign();\n\t\t    };\n\t\t    this.signHex = function(hex) {\n\t\t\tthis.updateHex(hex);\n\t\t\treturn this.sign();\n\t\t    };\n\t\t    this.verify = function(hSigVal) {\n\t\t        this.sHashHex = this.md.digest();\n\t\t\tif (typeof this.ecpubhex != \"undefined\" &&\n\t\t\t    typeof this.eccurvename != \"undefined\") {\n\t\t\t    var ec = new KJUR.crypto.ECDSA({curve: this.eccurvename});\n\t\t\t    return ec.verifyHex(this.sHashHex, hSigVal, this.ecpubhex);\n\t\t\t} else if (this.pubKey instanceof RSAKey &&\n\t\t\t\t   this.pubkeyAlgName == \"rsaandmgf1\") {\n\t\t\t    return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, hSigVal, \n\t\t\t\t\t\t\t\t\tthis.mdAlgName,\n\t\t\t\t\t\t\t\t\tthis.pssSaltLen);\n\t\t\t} else if (this.pubKey instanceof RSAKey &&\n\t\t\t\t   this.pubkeyAlgName == \"rsa\") {\n\t\t\t    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);\n\t\t\t} else if (this.pubKey instanceof KJUR.crypto.ECDSA) {\n\t\t\t    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);\n\t\t\t} else if (this.pubKey instanceof KJUR.crypto.DSA) {\n\t\t\t    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);\n\t\t\t} else {\n\t\t\t    throw \"Signature: unsupported public key alg: \" + this.pubkeyAlgName;\n\t\t\t}\n\t\t    };\n\t\t}\n\t    };\n\t\n\t    /**\n\t     * Initialize this object for signing or verifying depends on key\n\t     * @name init\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {Object} key specifying public or private key as plain/encrypted PKCS#5/8 PEM file, certificate PEM or {@link RSAKey}, {@link KJUR.crypto.DSA} or {@link KJUR.crypto.ECDSA} object\n\t     * @param {String} pass (OPTION) passcode for encrypted private key\n\t     * @since crypto 1.1.3\n\t     * @description\n\t     * This method is very useful initialize method for Signature class since\n\t     * you just specify key then this method will automatically initialize it\n\t     * using {@link KEYUTIL.getKey} method.\n\t     * As for 'key',  following argument type are supported:\n\t     * <h5>signing</h5>\n\t     * <ul>\n\t     * <li>PEM formatted PKCS#8 encrypted RSA/ECDSA private key concluding \"BEGIN ENCRYPTED PRIVATE KEY\"</li>\n\t     * <li>PEM formatted PKCS#5 encrypted RSA/DSA private key concluding \"BEGIN RSA/DSA PRIVATE KEY\" and \",ENCRYPTED\"</li>\n\t     * <li>PEM formatted PKCS#8 plain RSA/ECDSA private key concluding \"BEGIN PRIVATE KEY\"</li>\n\t     * <li>PEM formatted PKCS#5 plain RSA/DSA private key concluding \"BEGIN RSA/DSA PRIVATE KEY\" without \",ENCRYPTED\"</li>\n\t     * <li>RSAKey object of private key</li>\n\t     * <li>KJUR.crypto.ECDSA object of private key</li>\n\t     * <li>KJUR.crypto.DSA object of private key</li>\n\t     * </ul>\n\t     * <h5>verification</h5>\n\t     * <ul>\n\t     * <li>PEM formatted PKCS#8 RSA/EC/DSA public key concluding \"BEGIN PUBLIC KEY\"</li>\n\t     * <li>PEM formatted X.509 certificate with RSA/EC/DSA public key concluding\n\t     *     \"BEGIN CERTIFICATE\", \"BEGIN X509 CERTIFICATE\" or \"BEGIN TRUSTED CERTIFICATE\".</li>\n\t     * <li>RSAKey object of public key</li>\n\t     * <li>KJUR.crypto.ECDSA object of public key</li>\n\t     * <li>KJUR.crypto.DSA object of public key</li>\n\t     * </ul>\n\t     * @example\n\t     * sig.init(sCertPEM)\n\t     */\n\t    this.init = function(key, pass) {\n\t\tthrow \"init(key, pass) not supported for this alg:prov=\" +\n\t\t      this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * Initialize this object for verifying with a public key\n\t     * @name initVerifyByPublicKey\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {Object} param RSAKey object of public key or associative array for ECDSA\n\t     * @since 1.0.2\n\t     * @deprecated from crypto 1.1.5. please use init() method instead.\n\t     * @description\n\t     * Public key information will be provided as 'param' parameter and the value will be\n\t     * following:\n\t     * <ul>\n\t     * <li>{@link RSAKey} object for RSA verification</li>\n\t     * <li>associative array for ECDSA verification\n\t     *     (ex. <code>{'ecpubhex': '041f..', 'eccurvename': 'secp256r1'}</code>)\n\t     * </li>\n\t     * </ul>\n\t     * @example\n\t     * sig.initVerifyByPublicKey(rsaPrvKey)\n\t     */\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthrow \"initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=\" +\n\t\t      this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * Initialize this object for verifying with a certficate\n\t     * @name initVerifyByCertificatePEM\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {String} certPEM PEM formatted string of certificate\n\t     * @since 1.0.2\n\t     * @deprecated from crypto 1.1.5. please use init() method instead.\n\t     * @description\n\t     * @example\n\t     * sig.initVerifyByCertificatePEM(certPEM)\n\t     */\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tthrow \"initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=\" +\n\t\t    this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * Initialize this object for signing\n\t     * @name initSign\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {Object} param RSAKey object of public key or associative array for ECDSA\n\t     * @deprecated from crypto 1.1.5. please use init() method instead.\n\t     * @description\n\t     * Private key information will be provided as 'param' parameter and the value will be\n\t     * following:\n\t     * <ul>\n\t     * <li>{@link RSAKey} object for RSA signing</li>\n\t     * <li>associative array for ECDSA signing\n\t     *     (ex. <code>{'ecprvhex': '1d3f..', 'eccurvename': 'secp256r1'}</code>)</li>\n\t     * </ul>\n\t     * @example\n\t     * sig.initSign(prvKey)\n\t     */\n\t    this.initSign = function(prvKey) {\n\t\tthrow \"initSign(prvKey) not supported for this alg:prov=\" + this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * Updates the data to be signed or verified by a string\n\t     * @name updateString\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {String} str string to use for the update\n\t     * @description\n\t     * @example\n\t     * sig.updateString('aaa')\n\t     */\n\t    this.updateString = function(str) {\n\t\tthrow \"updateString(str) not supported for this alg:prov=\" + this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * Updates the data to be signed or verified by a hexadecimal string\n\t     * @name updateHex\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {String} hex hexadecimal string to use for the update\n\t     * @description\n\t     * @example\n\t     * sig.updateHex('1f2f3f')\n\t     */\n\t    this.updateHex = function(hex) {\n\t\tthrow \"updateHex(hex) not supported for this alg:prov=\" + this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * Returns the signature bytes of all data updates as a hexadecimal string\n\t     * @name sign\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @return the signature bytes as a hexadecimal string\n\t     * @description\n\t     * @example\n\t     * var hSigValue = sig.sign()\n\t     */\n\t    this.sign = function() {\n\t\tthrow \"sign() not supported for this alg:prov=\" + this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n\t     * @name signString\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {String} str string to final update\n\t     * @return the signature bytes of a hexadecimal string\n\t     * @description\n\t     * @example\n\t     * var hSigValue = sig.signString('aaa')\n\t     */\n\t    this.signString = function(str) {\n\t\tthrow \"digestString(str) not supported for this alg:prov=\" + this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n\t     * @name signHex\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {String} hex hexadecimal string to final update\n\t     * @return the signature bytes of a hexadecimal string\n\t     * @description\n\t     * @example\n\t     * var hSigValue = sig.signHex('1fdc33')\n\t     */\n\t    this.signHex = function(hex) {\n\t\tthrow \"digestHex(hex) not supported for this alg:prov=\" + this.algProvName;\n\t    };\n\t\n\t    /**\n\t     * verifies the passed-in signature.\n\t     * @name verify\n\t     * @memberOf KJUR.crypto.Signature#\n\t     * @function\n\t     * @param {String} str string to final update\n\t     * @return {Boolean} true if the signature was verified, otherwise false\n\t     * @description\n\t     * @example\n\t     * var isValid = sig.verify('1fbcefdca4823a7(snip)')\n\t     */\n\t    this.verify = function(hSigVal) {\n\t\tthrow \"verify(hSigVal) not supported for this alg:prov=\" + this.algProvName;\n\t    };\n\t\n\t    this.initParams = params;\n\t\n\t    if (params !== undefined) {\n\t\tif (params['alg'] !== undefined) {\n\t\t    this.algName = params['alg'];\n\t\t    if (params['prov'] === undefined) {\n\t\t\tthis.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];\n\t\t    } else {\n\t\t\tthis.provName = params['prov'];\n\t\t    }\n\t\t    this.algProvName = this.algName + \":\" + this.provName;\n\t\t    this.setAlgAndProvider(this.algName, this.provName);\n\t\t    this._setAlgNames();\n\t\t}\n\t\n\t\tif (params['psssaltlen'] !== undefined) this.pssSaltLen = params['psssaltlen'];\n\t\n\t\tif (params['prvkeypem'] !== undefined) {\n\t\t    if (params['prvkeypas'] !== undefined) {\n\t\t\tthrow \"both prvkeypem and prvkeypas parameters not supported\";\n\t\t    } else {\n\t\t\ttry {\n\t\t\t    var prvKey = new RSAKey();\n\t\t\t    prvKey.readPrivateKeyFromPEMString(params['prvkeypem']);\n\t\t\t    this.initSign(prvKey);\n\t\t\t} catch (ex) {\n\t\t\t    throw \"fatal error to load pem private key: \" + ex;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t};\n\t\n\t// ====== Cipher class ============================================================\n\t/**\n\t * Cipher class to encrypt and decrypt data<br/>\n\t * @name KJUR.crypto.Cipher\n\t * @class Cipher class to encrypt and decrypt data<br/>\n\t * @param {Array} params parameters for constructor\n\t * @since jsrsasign 6.2.0 crypto 1.1.10\n\t * @description\n\t * Here is supported canonicalized cipher algorithm names and its standard names:\n\t * <ul>\n\t * <li>RSA - RSA/ECB/PKCS1Padding (default for RSAKey)</li>\n\t * <li>RSAOAEP - RSA/ECB/OAEPWithSHA-1AndMGF1Padding</li>\n\t * <li>RSAOAEP224 - RSA/ECB/OAEPWithSHA-224AndMGF1Padding(*)</li>\n\t * <li>RSAOAEP256 - RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li>\n\t * <li>RSAOAEP384 - RSA/ECB/OAEPWithSHA-384AndMGF1Padding(*)</li>\n\t * <li>RSAOAEP512 - RSA/ECB/OAEPWithSHA-512AndMGF1Padding(*)</li>\n\t * </ul>\n\t * NOTE: (*) is not supported in Java JCE.<br/>\n\t * Currently this class supports only RSA encryption and decryption. \n\t * However it is planning to implement also symmetric ciphers near in the future.\n\t * @example\n\t */\n\tKJUR.crypto.Cipher = function(params) {\n\t};\n\t\n\t/**\n\t * encrypt raw string by specified key and algorithm<br/>\n\t * @name encrypt\n\t * @memberOf KJUR.crypto.Cipher\n\t * @function\n\t * @param {String} s input string to encrypt\n\t * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key\n\t * @param {String} algName short/long algorithm name for encryption/decryption\n\t * @return {String} hexadecimal encrypted string\n\t * @since jsrsasign 6.2.0 crypto 1.1.10\n\t * @description\n\t * This static method encrypts raw string with specified key and algorithm.\n\t * @example \n\t * KJUR.crypto.Cipher.encrypt(\"aaa\", pubRSAKeyObj) &rarr; \"1abc2d...\"\n\t * KJUR.crypto.Cipher.encrypt(\"aaa\", pubRSAKeyObj, \"RSAOAEP) &rarr; \"23ab02...\"\n\t */\n\tKJUR.crypto.Cipher.encrypt = function(s, keyObj, algName) {\n\t    if (keyObj instanceof RSAKey && keyObj.isPublic) {\n\t\tvar algName2 = KJUR.crypto.Cipher.getAlgByKeyAndName(keyObj, algName);\n\t\tif (algName2 === \"RSA\") return keyObj.encrypt(s);\n\t\tif (algName2 === \"RSAOAEP\") return keyObj.encryptOAEP(s, \"sha1\");\n\t\n\t\tvar a = algName2.match(/^RSAOAEP(\\d+)$/);\n\t\tif (a !== null) return keyObj.encryptOAEP(s, \"sha\" + a[1]);\n\t\n\t\tthrow \"Cipher.encrypt: unsupported algorithm for RSAKey: \" + algName;\n\t    } else {\n\t\tthrow \"Cipher.encrypt: unsupported key or algorithm\";\n\t    }\n\t};\n\t\n\t/**\n\t * decrypt encrypted hexadecimal string with specified key and algorithm<br/>\n\t * @name decrypt\n\t * @memberOf KJUR.crypto.Cipher\n\t * @function\n\t * @param {String} hex hexadecial string of encrypted message\n\t * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key\n\t * @param {String} algName short/long algorithm name for encryption/decryption\n\t * @return {String} hexadecimal encrypted string\n\t * @since jsrsasign 6.2.0 crypto 1.1.10\n\t * @description\n\t * This static method decrypts encrypted hexadecimal string with specified key and algorithm.\n\t * @example \n\t * KJUR.crypto.Cipher.decrypt(\"aaa\", prvRSAKeyObj) &rarr; \"1abc2d...\"\n\t * KJUR.crypto.Cipher.decrypt(\"aaa\", prvRSAKeyObj, \"RSAOAEP) &rarr; \"23ab02...\"\n\t */\n\tKJUR.crypto.Cipher.decrypt = function(hex, keyObj, algName) {\n\t    if (keyObj instanceof RSAKey && keyObj.isPrivate) {\n\t\tvar algName2 = KJUR.crypto.Cipher.getAlgByKeyAndName(keyObj, algName);\n\t\tif (algName2 === \"RSA\") return keyObj.decrypt(hex);\n\t\tif (algName2 === \"RSAOAEP\") return keyObj.decryptOAEP(hex, \"sha1\");\n\t\n\t\tvar a = algName2.match(/^RSAOAEP(\\d+)$/);\n\t\tif (a !== null) return keyObj.decryptOAEP(hex, \"sha\" + a[1]);\n\t\n\t\tthrow \"Cipher.decrypt: unsupported algorithm for RSAKey: \" + algName;\n\t    } else {\n\t\tthrow \"Cipher.decrypt: unsupported key or algorithm\";\n\t    }\n\t};\n\t\n\t/**\n\t * get canonicalized encrypt/decrypt algorithm name by key and short/long algorithm name<br/>\n\t * @name getAlgByKeyAndName\n\t * @memberOf KJUR.crypto.Cipher\n\t * @function\n\t * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key\n\t * @param {String} algName short/long algorithm name for encryption/decryption\n\t * @return {String} canonicalized algorithm name for encryption/decryption\n\t * @since jsrsasign 6.2.0 crypto 1.1.10\n\t * @description\n\t * Here is supported canonicalized cipher algorithm names and its standard names:\n\t * <ul>\n\t * <li>RSA - RSA/ECB/PKCS1Padding (default for RSAKey)</li>\n\t * <li>RSAOAEP - RSA/ECB/OAEPWithSHA-1AndMGF1Padding</li>\n\t * <li>RSAOAEP224 - RSA/ECB/OAEPWithSHA-224AndMGF1Padding(*)</li>\n\t * <li>RSAOAEP256 - RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li>\n\t * <li>RSAOAEP384 - RSA/ECB/OAEPWithSHA-384AndMGF1Padding(*)</li>\n\t * <li>RSAOAEP512 - RSA/ECB/OAEPWithSHA-512AndMGF1Padding(*)</li>\n\t * </ul>\n\t * NOTE: (*) is not supported in Java JCE.\n\t * @example \n\t * KJUR.crypto.Cipher.getAlgByKeyAndName(objRSAKey) &rarr; \"RSA\"\n\t * KJUR.crypto.Cipher.getAlgByKeyAndName(objRSAKey, \"RSAOAEP\") &rarr; \"RSAOAEP\"\n\t */\n\tKJUR.crypto.Cipher.getAlgByKeyAndName = function(keyObj, algName) {\n\t    if (keyObj instanceof RSAKey) {\n\t\tif (\":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:\".indexOf(algName) != -1)\n\t\t    return algName;\n\t\tif (algName === null || algName === undefined) return \"RSA\";\n\t\tthrow \"getAlgByKeyAndName: not supported algorithm name for RSAKey: \" + algName;\n\t    }\n\t    throw \"getAlgByKeyAndName: not supported algorithm name: \" + algName;\n\t}\n\t\n\t// ====== Other Utility class =====================================================\n\t\n\t/**\n\t * static object for cryptographic function utilities\n\t * @name KJUR.crypto.OID\n\t * @class static object for cryptography related OIDs\n\t * @property {Array} oidhex2name key value of hexadecimal OID and its name\n\t *           (ex. '2a8648ce3d030107' and 'secp256r1')\n\t * @since crypto 1.1.3\n\t * @description\n\t */\n\tKJUR.crypto.OID = new function() {\n\t    this.oidhex2name = {\n\t\t'2a864886f70d010101': 'rsaEncryption',\n\t\t'2a8648ce3d0201': 'ecPublicKey',\n\t\t'2a8648ce380401': 'dsa',\n\t\t'2a8648ce3d030107': 'secp256r1',\n\t\t'2b8104001f': 'secp192k1',\n\t\t'2b81040021': 'secp224r1',\n\t\t'2b8104000a': 'secp256k1',\n\t\t'2b81040023': 'secp521r1',\n\t\t'2b81040022': 'secp384r1',\n\t\t'2a8648ce380403': 'SHA1withDSA', // 1.2.840.10040.4.3\n\t\t'608648016503040301': 'SHA224withDSA', // 2.16.840.1.101.3.4.3.1\n\t\t'608648016503040302': 'SHA256withDSA', // 2.16.840.1.101.3.4.3.2\n\t    };\n\t};\n\t\n\t/*! rsasign-1.2.7.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n\t */\n\t/*\n\t * rsa-sign.js - adding signing functions to RSAKey class.\n\t *\n\t * version: 1.2.7 (2013 Aug 25)\n\t *\n\t * Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n\t *\n\t * This software is licensed under the terms of the MIT License.\n\t * http://kjur.github.com/jsrsasign/license/\n\t *\n\t * The above copyright and license notice shall be \n\t * included in all copies or substantial portions of the Software.\n\t */\n\t\n\t/**\n\t * @fileOverview\n\t * @name rsasign-1.2.js\n\t * @author Kenji Urushima kenji.urushima@gmail.com\n\t * @version rsasign 1.2.7\n\t * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n\t */\n\t\n\tvar _RE_HEXDECONLY = new RegExp(\"\");\n\t_RE_HEXDECONLY.compile(\"[^0-9a-f]\", \"gi\");\n\t\n\t// ========================================================================\n\t// Signature Generation\n\t// ========================================================================\n\t\n\tfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n\t    var hashFunc = function(s) { return KJUR.crypto.Util.hashString(s, hashAlg); };\n\t    var sHashHex = hashFunc(s);\n\t\n\t    return KJUR.crypto.Util.getPaddedDigestInfoHex(sHashHex, hashAlg, keySize);\n\t}\n\t\n\tfunction _zeroPaddingOfSignature(hex, bitLength) {\n\t    var s = \"\";\n\t    var nZero = bitLength / 4 - hex.length;\n\t    for (var i = 0; i < nZero; i++) {\n\t\ts = s + \"0\";\n\t    }\n\t    return s + hex;\n\t}\n\t\n\t/**\n\t * sign for a message string with RSA private key.<br/>\n\t * @name signString\n\t * @memberOf RSAKey\n\t * @function\n\t * @param {String} s message string to be signed.\n\t * @param {String} hashAlg hash algorithm name for signing.<br/>\n\t * @return returns hexadecimal string of signature value.\n\t */\n\tfunction _rsasign_signString(s, hashAlg) {\n\t    var hashFunc = function(s) { return KJUR.crypto.Util.hashString(s, hashAlg); };\n\t    var sHashHex = hashFunc(s);\n\t\n\t    return this.signWithMessageHash(sHashHex, hashAlg);\n\t}\n\t\n\t/**\n\t * sign hash value of message to be signed with RSA private key.<br/>\n\t * @name signWithMessageHash\n\t * @memberOf RSAKey\n\t * @function\n\t * @param {String} sHashHex hexadecimal string of hash value of message to be signed.\n\t * @param {String} hashAlg hash algorithm name for signing.<br/>\n\t * @return returns hexadecimal string of signature value.\n\t * @since rsasign 1.2.6\n\t */\n\tfunction _rsasign_signWithMessageHash(sHashHex, hashAlg) {\n\t    var hPM = KJUR.crypto.Util.getPaddedDigestInfoHex(sHashHex, hashAlg, this.n.bitLength());\n\t    var biPaddedMessage = parseBigInt(hPM, 16);\n\t    var biSign = this.doPrivate(biPaddedMessage);\n\t    var hexSign = biSign.toString(16);\n\t    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n\t}\n\t\n\tfunction _rsasign_signStringWithSHA1(s) {\n\t    return _rsasign_signString.call(this, s, 'sha1');\n\t}\n\t\n\tfunction _rsasign_signStringWithSHA256(s) {\n\t    return _rsasign_signString.call(this, s, 'sha256');\n\t}\n\t\n\t// PKCS#1 (PSS) mask generation function\n\tfunction pss_mgf1_str(seed, len, hash) {\n\t    var mask = '', i = 0;\n\t\n\t    while (mask.length < len) {\n\t        mask += hextorstr(hash(rstrtohex(seed + String.fromCharCode.apply(String, [\n\t                (i & 0xff000000) >> 24,\n\t                (i & 0x00ff0000) >> 16,\n\t                (i & 0x0000ff00) >> 8,\n\t                i & 0x000000ff]))));\n\t        i += 1;\n\t    }\n\t\n\t    return mask;\n\t}\n\t\n\t/**\n\t * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n\t * @name signStringPSS\n\t * @memberOf RSAKey\n\t * @function\n\t * @param {String} s message string to be signed.\n\t * @param {String} hashAlg hash algorithm name for signing.\n\t * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n\t *        There are two special values:\n\t *        <ul>\n\t *        <li>-1: sets the salt length to the digest length</li>\n\t *        <li>-2: sets the salt length to maximum permissible value\n\t *           (i.e. keybytelen - hashbytelen - 2)</li>\n\t *        </ul>\n\t *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)\n\t * @return returns hexadecimal string of signature value.\n\t */\n\tfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n\t    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); } \n\t    var hHash = hashFunc(rstrtohex(s));\n\t\n\t    if (sLen === undefined) sLen = -1;\n\t    return this.signWithMessageHashPSS(hHash, hashAlg, sLen);\n\t}\n\t\n\t/**\n\t * sign hash value of message with RSA private key by PKCS#1 PSS signing.<br/>\n\t * @name signWithMessageHashPSS\n\t * @memberOf RSAKey\n\t * @function\n\t * @param {String} hHash hexadecimal hash value of message to be signed.\n\t * @param {String} hashAlg hash algorithm name for signing.\n\t * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n\t *        There are two special values:\n\t *        <ul>\n\t *        <li>-1: sets the salt length to the digest length</li>\n\t *        <li>-2: sets the salt length to maximum permissible value\n\t *           (i.e. keybytelen - hashbytelen - 2)</li>\n\t *        </ul>\n\t *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)\n\t * @return returns hexadecimal string of signature value.\n\t * @since rsasign 1.2.6\n\t */\n\tfunction _rsasign_signWithMessageHashPSS(hHash, hashAlg, sLen) {\n\t    var mHash = hextorstr(hHash);\n\t    var hLen = mHash.length;\n\t    var emBits = this.n.bitLength() - 1;\n\t    var emLen = Math.ceil(emBits / 8);\n\t    var i;\n\t    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); } \n\t\n\t    if (sLen === -1 || sLen === undefined) {\n\t        sLen = hLen; // same as hash length\n\t    } else if (sLen === -2) {\n\t        sLen = emLen - hLen - 2; // maximum\n\t    } else if (sLen < -2) {\n\t        throw \"invalid salt length\";\n\t    }\n\t\n\t    if (emLen < (hLen + sLen + 2)) {\n\t        throw \"data too long\";\n\t    }\n\t\n\t    var salt = '';\n\t\n\t    if (sLen > 0) {\n\t        salt = new Array(sLen);\n\t        new SecureRandom().nextBytes(salt);\n\t        salt = String.fromCharCode.apply(String, salt);\n\t    }\n\t\n\t    var H = hextorstr(hashFunc(rstrtohex('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' + mHash + salt)));\n\t    var PS = [];\n\t\n\t    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n\t        PS[i] = 0x00;\n\t    }\n\t\n\t    var DB = String.fromCharCode.apply(String, PS) + '\\x01' + salt;\n\t    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n\t    var maskedDB = [];\n\t\n\t    for (i = 0; i < DB.length; i += 1) {\n\t        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n\t    }\n\t\n\t    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\t    maskedDB[0] &= ~mask;\n\t\n\t    for (i = 0; i < hLen; i++) {\n\t        maskedDB.push(H.charCodeAt(i));\n\t    }\n\t\n\t    maskedDB.push(0xbc);\n\t\n\t    return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(maskedDB)).toString(16),\n\t\t\t\t\t   this.n.bitLength());\n\t}\n\t\n\t// ========================================================================\n\t// Signature Verification\n\t// ========================================================================\n\t\n\tfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n\t    var rsa = new RSAKey();\n\t    rsa.setPublic(hN, hE);\n\t    var biDecryptedSig = rsa.doPublic(biSig);\n\t    return biDecryptedSig;\n\t}\n\t\n\tfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n\t    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n\t    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');\n\t    return hDigestInfo;\n\t}\n\t\n\tfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n\t    for (var algName in KJUR.crypto.Util.DIGESTINFOHEAD) {\n\t\tvar head = KJUR.crypto.Util.DIGESTINFOHEAD[algName];\n\t\tvar len = head.length;\n\t\tif (hDigestInfo.substring(0, len) == head) {\n\t\t    var a = [algName, hDigestInfo.substring(len)];\n\t\t    return a;\n\t\t}\n\t    }\n\t    return [];\n\t}\n\t\n\tfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n\t    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n\t    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n\t    if (digestInfoAry.length == 0) return false;\n\t    var algName = digestInfoAry[0];\n\t    var diHashValue = digestInfoAry[1];\n\t    var ff = function(s) { return KJUR.crypto.Util.hashString(s, algName); };\n\t    var msgHashValue = ff(sMsg);\n\t    return (diHashValue == msgHashValue);\n\t}\n\t\n\tfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n\t    var biSig = parseBigInt(hSig, 16);\n\t    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t\t  this.e.toString(16));\n\t    return result;\n\t}\n\t\n\t/**\n\t * verifies a sigature for a message string with RSA public key.<br/>\n\t * @name verifyString\n\t * @memberOf RSAKey#\n\t * @function\n\t * @param {String} sMsg message string to be verified.\n\t * @param {String} hSig hexadecimal string of siganture.<br/>\n\t *                 non-hexadecimal charactors including new lines will be ignored.\n\t * @return returns 1 if valid, otherwise 0\n\t */\n\tfunction _rsasign_verifyString(sMsg, hSig) {\n\t    hSig = hSig.replace(_RE_HEXDECONLY, '');\n\t    hSig = hSig.replace(/[ \\n]+/g, \"\");\n\t    var biSig = parseBigInt(hSig, 16);\n\t    if (biSig.bitLength() > this.n.bitLength()) return 0;\n\t    var biDecryptedSig = this.doPublic(biSig);\n\t    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');\n\t    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n\t  \n\t    if (digestInfoAry.length == 0) return false;\n\t    var algName = digestInfoAry[0];\n\t    var diHashValue = digestInfoAry[1];\n\t    var ff = function(s) { return KJUR.crypto.Util.hashString(s, algName); };\n\t    var msgHashValue = ff(sMsg);\n\t    return (diHashValue == msgHashValue);\n\t}\n\t\n\t/**\n\t * verifies a sigature for a message string with RSA public key.<br/>\n\t * @name verifyWithMessageHash\n\t * @memberOf RSAKey\n\t * @function\n\t * @param {String} sHashHex hexadecimal hash value of message to be verified.\n\t * @param {String} hSig hexadecimal string of siganture.<br/>\n\t *                 non-hexadecimal charactors including new lines will be ignored.\n\t * @return returns 1 if valid, otherwise 0\n\t * @since rsasign 1.2.6\n\t */\n\tfunction _rsasign_verifyWithMessageHash(sHashHex, hSig) {\n\t    hSig = hSig.replace(_RE_HEXDECONLY, '');\n\t    hSig = hSig.replace(/[ \\n]+/g, \"\");\n\t    var biSig = parseBigInt(hSig, 16);\n\t    if (biSig.bitLength() > this.n.bitLength()) return 0;\n\t    var biDecryptedSig = this.doPublic(biSig);\n\t    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');\n\t    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n\t  \n\t    if (digestInfoAry.length == 0) return false;\n\t    var algName = digestInfoAry[0];\n\t    var diHashValue = digestInfoAry[1];\n\t    return (diHashValue == sHashHex);\n\t}\n\t\n\t/**\n\t * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n\t * @name verifyStringPSS\n\t * @memberOf RSAKey\n\t * @function\n\t * @param {String} sMsg message string to be verified.\n\t * @param {String} hSig hexadecimal string of signature value\n\t * @param {String} hashAlg hash algorithm name\n\t * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n\t *        There are two special values:\n\t *        <ul>\n\t *        <li>-1: sets the salt length to the digest length</li>\n\t *        <li>-2: sets the salt length to maximum permissible value\n\t *           (i.e. keybytelen - hashbytelen - 2)</li>\n\t *        </ul>\n\t *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)\n\t * @return returns true if valid, otherwise false\n\t */\n\tfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n\t    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); };\n\t    var hHash = hashFunc(rstrtohex(sMsg));\n\t\n\t    if (sLen === undefined) sLen = -1;\n\t    return this.verifyWithMessageHashPSS(hHash, hSig, hashAlg, sLen);\n\t}\n\t\n\t/**\n\t * verifies a sigature for a hash value of message string with RSA public key by PKCS#1 PSS sign.<br/>\n\t * @name verifyWithMessageHashPSS\n\t * @memberOf RSAKey\n\t * @function\n\t * @param {String} hHash hexadecimal hash value of message string to be verified.\n\t * @param {String} hSig hexadecimal string of signature value\n\t * @param {String} hashAlg hash algorithm name\n\t * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n\t *        There are two special values:\n\t *        <ul>\n\t *        <li>-1: sets the salt length to the digest length</li>\n\t *        <li>-2: sets the salt length to maximum permissible value\n\t *           (i.e. keybytelen - hashbytelen - 2)</li>\n\t *        </ul>\n\t *        DEFAULT is -1 (NOTE: OpenSSL's default is -2.)\n\t * @return returns true if valid, otherwise false\n\t * @since rsasign 1.2.6\n\t */\n\tfunction _rsasign_verifyWithMessageHashPSS(hHash, hSig, hashAlg, sLen) {\n\t    var biSig = new BigInteger(hSig, 16);\n\t\n\t    if (biSig.bitLength() > this.n.bitLength()) {\n\t        return false;\n\t    }\n\t\n\t    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); };\n\t    var mHash = hextorstr(hHash);\n\t    var hLen = mHash.length;\n\t    var emBits = this.n.bitLength() - 1;\n\t    var emLen = Math.ceil(emBits / 8);\n\t    var i;\n\t\n\t    if (sLen === -1 || sLen === undefined) {\n\t        sLen = hLen; // same as hash length\n\t    } else if (sLen === -2) {\n\t        sLen = emLen - hLen - 2; // recover\n\t    } else if (sLen < -2) {\n\t        throw \"invalid salt length\";\n\t    }\n\t\n\t    if (emLen < (hLen + sLen + 2)) {\n\t        throw \"data too long\";\n\t    }\n\t\n\t    var em = this.doPublic(biSig).toByteArray();\n\t\n\t    for (i = 0; i < em.length; i += 1) {\n\t        em[i] &= 0xff;\n\t    }\n\t\n\t    while (em.length < emLen) {\n\t        em.unshift(0);\n\t    }\n\t\n\t    if (em[emLen -1] !== 0xbc) {\n\t        throw \"encoded message does not end in 0xbc\";\n\t    }\n\t\n\t    em = String.fromCharCode.apply(String, em);\n\t\n\t    var maskedDB = em.substr(0, emLen - hLen - 1);\n\t    var H = em.substr(maskedDB.length, hLen);\n\t\n\t    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\t\n\t    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n\t        throw \"bits beyond keysize not zero\";\n\t    }\n\t\n\t    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n\t    var DB = [];\n\t\n\t    for (i = 0; i < maskedDB.length; i += 1) {\n\t        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n\t    }\n\t\n\t    DB[0] &= ~mask;\n\t\n\t    var checkLen = emLen - hLen - sLen - 2;\n\t\n\t    for (i = 0; i < checkLen; i += 1) {\n\t        if (DB[i] !== 0x00) {\n\t            throw \"leftmost octets not zero\";\n\t        }\n\t    }\n\t\n\t    if (DB[checkLen] !== 0x01) {\n\t        throw \"0x01 marker not found\";\n\t    }\n\t\n\t    return H === hextorstr(hashFunc(rstrtohex('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' + mHash +\n\t\t\t\t\t     String.fromCharCode.apply(String, DB.slice(-sLen)))));\n\t}\n\t\n\tRSAKey.prototype.signWithMessageHash = _rsasign_signWithMessageHash;\n\tRSAKey.prototype.signString = _rsasign_signString;\n\tRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\n\tRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\n\tRSAKey.prototype.sign = _rsasign_signString;\n\tRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\n\tRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\n\t\n\tRSAKey.prototype.signWithMessageHashPSS = _rsasign_signWithMessageHashPSS;\n\tRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\n\tRSAKey.prototype.signPSS = _rsasign_signStringPSS;\n\tRSAKey.SALT_LEN_HLEN = -1;\n\tRSAKey.SALT_LEN_MAX = -2;\n\t\n\tRSAKey.prototype.verifyWithMessageHash = _rsasign_verifyWithMessageHash;\n\tRSAKey.prototype.verifyString = _rsasign_verifyString;\n\tRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\n\tRSAKey.prototype.verify = _rsasign_verifyString;\n\tRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\n\t\n\tRSAKey.prototype.verifyWithMessageHashPSS = _rsasign_verifyWithMessageHashPSS;\n\tRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\n\tRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\n\tRSAKey.SALT_LEN_RECOVER = -2;\n\t\n\t/**\n\t * @name RSAKey\n\t * @class key of RSA public key algorithm\n\t * @description Tom Wu's RSA Key class and extension\n\t */\n\t\n\tmodule.exports = KJUR;\n\tmodule.exports.KEYUTIL = KEYUTIL;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(2)\n\tvar ieee754 = __webpack_require__(3)\n\tvar isArray = __webpack_require__(4)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\t\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\t\n\t  return that\n\t}\n\t\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\t\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\t\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\t\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\t\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\t\n\t  return fromObject(that, value)\n\t}\n\t\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\t\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\t\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\t\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\t\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\t\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\t\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\t\n\t  var actual = that.write(string, encoding)\n\t\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\t\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\t\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\t\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\t\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\t\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\t\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\t\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\t\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\t\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\t\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\t\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\t\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\t\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\t\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\t\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\t\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\t\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\t\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\t\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\t\n\t  if (this === target) return 0\n\t\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\t\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\t\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\t\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\t\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\t\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\t\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\t\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\t\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\t\n\t  return -1\n\t}\n\t\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\t\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\t\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\t\n\t  if (end <= start) {\n\t    return this\n\t  }\n\t\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t  if (!val) val = 0\n\t\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0; i < l; i += 4) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// jsrsasign.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 632b44c7b952fd2e4442","/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\n// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i,x,w,j,c,n) {\n  while(--n >= 0) {\n    var v = x*this[i++]+w[j]+c;\n    c = Math.floor(v/0x4000000);\n    w[j++] = v&0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i,x,w,j,c,n) {\n  var xl = x&0x7fff, xh = x>>15;\n  while(--n >= 0) {\n    var l = this[i]&0x7fff;\n    var h = this[i++]>>15;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n    w[j++] = l&0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nif(j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if(j_lm && (navigator.appName != \"Netscape\")) {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse { // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+this.DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:\"0\";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;\t\t// y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\nvar b64map=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar b64pad=\"=\";\n\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = \"\";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = \"\"\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  var v;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n\n/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval\n */\n// This source code is free for use in the public domain.\n// NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n// http://code.google.com/p/json-sans-eval/\n\n/**\n * Parses a string of well-formed JSON text.\n *\n * If the input is not well-formed, then behavior is undefined, but it is\n * deterministic and is guaranteed not to modify any object other than its\n * return value.\n *\n * This does not use `eval` so is less likely to have obscure security bugs than\n * json2.js.\n * It is optimized for speed, so is much faster than json_parse.js.\n *\n * This library should be used whenever security is a concern (when JSON may\n * come from an untrusted source), speed is a concern, and erroring on malformed\n * JSON is *not* a concern.\n *\n *                      Pros                   Cons\n *                    +-----------------------+-----------------------+\n * json_sans_eval.js  | Fast, secure          | Not validating        |\n *                    +-----------------------+-----------------------+\n * json_parse.js      | Validating, secure    | Slow                  |\n *                    +-----------------------+-----------------------+\n * json2.js           | Fast, some validation | Potentially insecure  |\n *                    +-----------------------+-----------------------+\n *\n * json2.js is very fast, but potentially insecure since it calls `eval` to\n * parse JSON data, so an attacker might be able to supply strange JS that\n * looks like JSON, but that executes arbitrary javascript.\n * If you do have to use json2.js with untrusted data, make sure you keep\n * your version of json2.js up to date so that you get patches as they're\n * released.\n *\n * @param {string} json per RFC 4627\n * @param {function (this:Object, string, *):*} opt_reviver optional function\n *     that reworks JSON objects post-parse per Chapter 15.12 of EcmaScript3.1.\n *     If supplied, the function is called with a string key, and a value.\n *     The value is the property of 'this'.  The reviver should return\n *     the value to use in its place.  So if dates were serialized as\n *     {@code { \"type\": \"Date\", \"time\": 1234 }}, then a reviver might look like\n *     {@code\n *     function (key, value) {\n *       if (value && typeof value === 'object' && 'Date' === value.type) {\n *         return new Date(value.time);\n *       } else {\n *         return value;\n *       }\n *     }}.\n *     If the reviver returns {@code undefined} then the property named by key\n *     will be deleted from its container.\n *     {@code this} is bound to the object containing the specified property.\n * @return {Object|Array}\n * @author Mike Samuel <mikesamuel@gmail.com>\n */\nvar jsonParse = (function () {\n  var number\n      = '(?:-?\\\\b(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\\\b)';\n  var oneChar = '(?:[^\\\\0-\\\\x08\\\\x0a-\\\\x1f\\\"\\\\\\\\]'\n      + '|\\\\\\\\(?:[\\\"/\\\\\\\\bfnrt]|u[0-9A-Fa-f]{4}))';\n  var string = '(?:\\\"' + oneChar + '*\\\")';\n\n  // Will match a value in a well-formed JSON file.\n  // If the input is not well-formed, may match strangely, but not in an unsafe\n  // way.\n  // Since this only matches value tokens, it does not match whitespace, colons,\n  // or commas.\n  var jsonToken = new RegExp(\n      '(?:false|true|null|[\\\\{\\\\}\\\\[\\\\]]'\n      + '|' + number\n      + '|' + string\n      + ')', 'g');\n\n  // Matches escape sequences in a string literal\n  var escapeSequence = new RegExp('\\\\\\\\(?:([^u])|u(.{4}))', 'g');\n\n  // Decodes escape sequences in object literals\n  var escapes = {\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    'b': '\\b',\n    'f': '\\f',\n    'n': '\\n',\n    'r': '\\r',\n    't': '\\t'\n  };\n  function unescapeOne(_, ch, hex) {\n    return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));\n  }\n\n  // A non-falsy value that coerces to the empty string when used as a key.\n  var EMPTY_STRING = new String('');\n  var SLASH = '\\\\';\n\n  // Constructor to use based on an open token.\n  var firstTokenCtors = { '{': Object, '[': Array };\n\n  var hop = Object.hasOwnProperty;\n\n  return function (json, opt_reviver) {\n    // Split into tokens\n    var toks = json.match(jsonToken);\n    // Construct the object to return\n    var result;\n    var tok = toks[0];\n    var topLevelPrimitive = false;\n    if ('{' === tok) {\n      result = {};\n    } else if ('[' === tok) {\n      result = [];\n    } else {\n      // The RFC only allows arrays or objects at the top level, but the JSON.parse\n      // defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null\n      // at the top level.\n      result = [];\n      topLevelPrimitive = true;\n    }\n\n    // If undefined, the key in an object key/value record to use for the next\n    // value parsed.\n    var key;\n    // Loop over remaining tokens maintaining a stack of uncompleted objects and\n    // arrays.\n    var stack = [result];\n    for (var i = 1 - topLevelPrimitive, n = toks.length; i < n; ++i) {\n      tok = toks[i];\n\n      var cont;\n      switch (tok.charCodeAt(0)) {\n        default:  // sign or digit\n          cont = stack[0];\n          cont[key || cont.length] = +(tok);\n          key = void 0;\n          break;\n        case 0x22:  // '\"'\n          tok = tok.substring(1, tok.length - 1);\n          if (tok.indexOf(SLASH) !== -1) {\n            tok = tok.replace(escapeSequence, unescapeOne);\n          }\n          cont = stack[0];\n          if (!key) {\n            if (cont instanceof Array) {\n              key = cont.length;\n            } else {\n              key = tok || EMPTY_STRING;  // Use as key for next value seen.\n              break;\n            }\n          }\n          cont[key] = tok;\n          key = void 0;\n          break;\n        case 0x5b:  // '['\n          cont = stack[0];\n          stack.unshift(cont[key || cont.length] = []);\n          key = void 0;\n          break;\n        case 0x5d:  // ']'\n          stack.shift();\n          break;\n        case 0x66:  // 'f'\n          cont = stack[0];\n          cont[key || cont.length] = false;\n          key = void 0;\n          break;\n        case 0x6e:  // 'n'\n          cont = stack[0];\n          cont[key || cont.length] = null;\n          key = void 0;\n          break;\n        case 0x74:  // 't'\n          cont = stack[0];\n          cont[key || cont.length] = true;\n          key = void 0;\n          break;\n        case 0x7b:  // '{'\n          cont = stack[0];\n          stack.unshift(cont[key || cont.length] = {});\n          key = void 0;\n          break;\n        case 0x7d:  // '}'\n          stack.shift();\n          break;\n      }\n    }\n    // Fail if we've got an uncompleted object.\n    if (topLevelPrimitive) {\n      if (stack.length !== 1) { throw new Error(); }\n      result = result[0];\n    } else {\n      if (stack.length) { throw new Error(); }\n    }\n\n    if (opt_reviver) {\n      // Based on walk as implemented in http://www.json.org/json2.js\n      var walk = function (holder, key) {\n        var value = holder[key];\n        if (value && typeof value === 'object') {\n          var toDelete = null;\n          for (var k in value) {\n            if (hop.call(value, k) && value !== holder) {\n              // Recurse to properties first.  This has the effect of causing\n              // the reviver to be called on the object graph depth-first.\n\n              // Since 'this' is bound to the holder of the property, the\n              // reviver can access sibling properties of k including ones\n              // that have not yet been revived.\n\n              // The value returned by the reviver is used in place of the\n              // current value of property k.\n              // If it returns undefined then the property is deleted.\n              var v = walk(value, k);\n              if (v !== void 0) {\n                value[k] = v;\n              } else {\n                // Deleting properties inside the loop has vaguely defined\n                // semantics in ES3 and ES3.1.\n                if (!toDelete) { toDelete = []; }\n                toDelete.push(k);\n              }\n            }\n          }\n          if (toDelete) {\n            for (var i = toDelete.length; --i >= 0;) {\n              delete value[toDelete[i]];\n            }\n          }\n        }\n        return opt_reviver.call(holder, key, value);\n      };\n      result = walk({ '': result }, '');\n    }\n\n    return result;\n  };\n})();\n\n/*! base64x-1.1.8 (c) 2012-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * base64x.js - Base64url and supplementary functions for Tom Wu's base64.js library\n *\n * version: 1.1.8 (2016-Oct-16)\n *\n * Copyright (c) 2012-2016 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsjws/license/\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n *\n * DEPENDS ON:\n *   - base64.js - Tom Wu's Base64 library\n */\n\n/**\n * @fileOverview\n * @name base64x-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version asn1 1.1.8 (2016-Oct-16)\n * @since jsrsasign 2.1\n * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n */\n\nvar KJUR;\nif (typeof KJUR == \"undefined\" || !KJUR) KJUR = {};\nif (typeof KJUR.lang == \"undefined\" || !KJUR.lang) KJUR.lang = {};\n\n/**\n * String and its utility class <br/>\n * This class provides some static utility methods for string.\n * @class String and its utility class\n * @author Kenji Urushima\n * @version 1.0 (2016-Aug-05)\n * @since base64x 1.1.7 jsrsasign 5.0.13\n * @description\n * <br/>\n * This class provides static methods for string utility.\n * <dl>\n * <dt><b>STRING TYPE CHECKERS</b>\n * <dd>\n * <ul>\n * <li>{@link KJUR.lang.String.isInteger} - check whether argument is an integer</li>\n * <li>{@link KJUR.lang.String.isHex} - check whether argument is a hexadecimal string</li>\n * <li>{@link KJUR.lang.String.isBase64} - check whether argument is a Base64 encoded string</li>\n * <li>{@link KJUR.lang.String.isBase64URL} - check whether argument is a Base64URL encoded string</li>\n * <li>{@link KJUR.lang.String.isIntegerArray} - check whether argument is an array of integers</li>\n * </ul>\n * </dl>\n */\nKJUR.lang.String = function() {};\n\n/**\n * Base64URL and supplementary functions for Tom Wu's base64.js library.<br/>\n * This class is just provide information about global functions\n * defined in 'base64x.js'. The 'base64x.js' script file provides\n * global functions for converting following data each other.\n * <ul>\n * <li>(ASCII) String</li>\n * <li>UTF8 String including CJK, Latin and other characters</li>\n * <li>byte array</li>\n * <li>hexadecimal encoded String</li>\n * <li>Full URIComponent encoded String (such like \"%69%94\")</li>\n * <li>Base64 encoded String</li>\n * <li>Base64URL encoded String</li>\n * </ul>\n * All functions in 'base64x.js' are defined in {@link _global_} and not\n * in this class.\n * \n * @class Base64URL and supplementary functions for Tom Wu's base64.js library\n * @author Kenji Urushima\n * @version 1.1 (07 May 2012)\n * @requires base64.js\n * @see <a href=\"http://kjur.github.com/jsjws/\">'jwjws'(JWS JavaScript Library) home page http://kjur.github.com/jsjws/</a>\n * @see <a href=\"http://kjur.github.com/jsrsasigns/\">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n */\nfunction Base64x() {\n}\n\n// ==== string / byte array ================================\n/**\n * convert a string to an array of character codes\n * @param {String} s\n * @return {Array of Numbers} \n */\nfunction stoBA(s) {\n    var a = new Array();\n    for (var i = 0; i < s.length; i++) {\n\ta[i] = s.charCodeAt(i);\n    }\n    return a;\n}\n\n/**\n * convert an array of character codes to a string\n * @param {Array of Numbers} a array of character codes\n * @return {String} s\n */\nfunction BAtos(a) {\n    var s = \"\";\n    for (var i = 0; i < a.length; i++) {\n\ts = s + String.fromCharCode(a[i]);\n    }\n    return s;\n}\n\n// ==== byte array / hex ================================\n/**\n * convert an array of bytes(Number) to hexadecimal string.<br/>\n * @param {Array of Numbers} a array of bytes\n * @return {String} hexadecimal string\n */\nfunction BAtohex(a) {\n    var s = \"\";\n    for (var i = 0; i < a.length; i++) {\n\tvar hex1 = a[i].toString(16);\n\tif (hex1.length == 1) hex1 = \"0\" + hex1;\n\ts = s + hex1;\n    }\n    return s;\n}\n\n// ==== string / hex ================================\n/**\n * convert a ASCII string to a hexadecimal string of ASCII codes.<br/>\n * NOTE: This can't be used for non ASCII characters.\n * @param {s} s ASCII string\n * @return {String} hexadecimal string\n */\nfunction stohex(s) {\n    return BAtohex(stoBA(s));\n}\n\n// ==== string / base64 ================================\n/**\n * convert a ASCII string to a Base64 encoded string.<br/>\n * NOTE: This can't be used for non ASCII characters.\n * @param {s} s ASCII string\n * @return {String} Base64 encoded string\n */\nfunction stob64(s) {\n    return hex2b64(stohex(s));\n}\n\n// ==== string / base64url ================================\n/**\n * convert a ASCII string to a Base64URL encoded string.<br/>\n * NOTE: This can't be used for non ASCII characters.\n * @param {s} s ASCII string\n * @return {String} Base64URL encoded string\n */\nfunction stob64u(s) {\n    return b64tob64u(hex2b64(stohex(s)));\n}\n\n/**\n * convert a Base64URL encoded string to a ASCII string.<br/>\n * NOTE: This can't be used for Base64URL encoded non ASCII characters.\n * @param {s} s Base64URL encoded string\n * @return {String} ASCII string\n */\nfunction b64utos(s) {\n    return BAtos(b64toBA(b64utob64(s)));\n}\n\n// ==== base64 / base64url ================================\n/**\n * convert a Base64 encoded string to a Base64URL encoded string.<br/>\n * @param {String} s Base64 encoded string\n * @return {String} Base64URL encoded string\n * @example\n * b64tob64u(\"ab+c3f/==\") &rarr; \"ab-c3f_\"\n */\nfunction b64tob64u(s) {\n    s = s.replace(/\\=/g, \"\");\n    s = s.replace(/\\+/g, \"-\");\n    s = s.replace(/\\//g, \"_\");\n    return s;\n}\n\n/**\n * convert a Base64URL encoded string to a Base64 encoded string.<br/>\n * @param {String} s Base64URL encoded string\n * @return {String} Base64 encoded string\n * @example\n * b64utob64(\"ab-c3f_\") &rarr; \"ab+c3f/==\"\n */\nfunction b64utob64(s) {\n    if (s.length % 4 == 2) s = s + \"==\";\n    else if (s.length % 4 == 3) s = s + \"=\";\n    s = s.replace(/-/g, \"+\");\n    s = s.replace(/_/g, \"/\");\n    return s;\n}\n\n// ==== hex / base64url ================================\n/**\n * convert a hexadecimal string to a Base64URL encoded string.<br/>\n * @param {String} s hexadecimal string\n * @return {String} Base64URL encoded string\n * @description\n * convert a hexadecimal string to a Base64URL encoded string.\n * NOTE: If leading \"0\" is omitted and odd number length for\n * hexadecimal leading \"0\" is automatically added.\n */\nfunction hextob64u(s) {\n    if (s.length % 2 == 1) s = \"0\" + s;\n    return b64tob64u(hex2b64(s));\n}\n\n/**\n * convert a Base64URL encoded string to a hexadecimal string.<br/>\n * @param {String} s Base64URL encoded string\n * @return {String} hexadecimal string\n */\nfunction b64utohex(s) {\n    return b64tohex(b64utob64(s));\n}\n\n// ==== utf8 / base64url ================================\n\n/**\n * convert a UTF-8 encoded string including CJK or Latin to a Base64URL encoded string.<br/>\n * @param {String} s UTF-8 encoded string\n * @return {String} Base64URL encoded string\n * @since 1.1\n */\n\n/**\n * convert a Base64URL encoded string to a UTF-8 encoded string including CJK or Latin.<br/>\n * @param {String} s Base64URL encoded string\n * @return {String} UTF-8 encoded string\n * @since 1.1\n */\n\nvar utf8tob64u, b64utoutf8;\n\nif (typeof Buffer === 'function') {\n  utf8tob64u = function (s) {\n    return b64tob64u(new Buffer(s, 'utf8').toString('base64'));\n  };\n\n  b64utoutf8 = function (s) {\n    return new Buffer(b64utob64(s), 'base64').toString('utf8');\n  };\n} else {\n  utf8tob64u = function (s) {\n    return hextob64u(uricmptohex(encodeURIComponentAll(s)));\n  };\n\n  b64utoutf8 = function (s) {\n    return decodeURIComponent(hextouricmp(b64utohex(s)));\n  };\n}\n\n// ==== utf8 / base64url ================================\n/**\n * convert a UTF-8 encoded string including CJK or Latin to a Base64 encoded string.<br/>\n * @param {String} s UTF-8 encoded string\n * @return {String} Base64 encoded string\n * @since 1.1.1\n */\nfunction utf8tob64(s) {\n  return hex2b64(uricmptohex(encodeURIComponentAll(s)));\n}\n\n/**\n * convert a Base64 encoded string to a UTF-8 encoded string including CJK or Latin.<br/>\n * @param {String} s Base64 encoded string\n * @return {String} UTF-8 encoded string\n * @since 1.1.1\n */\nfunction b64toutf8(s) {\n  return decodeURIComponent(hextouricmp(b64tohex(s)));\n}\n\n// ==== utf8 / hex ================================\n/**\n * convert a UTF-8 encoded string including CJK or Latin to a hexadecimal encoded string.<br/>\n * @param {String} s UTF-8 encoded string\n * @return {String} hexadecimal encoded string\n * @since 1.1.1\n */\nfunction utf8tohex(s) {\n  return uricmptohex(encodeURIComponentAll(s));\n}\n\n/**\n * convert a hexadecimal encoded string to a UTF-8 encoded string including CJK or Latin.<br/>\n * Note that when input is improper hexadecimal string as UTF-8 string, this function returns\n * 'null'.\n * @param {String} s hexadecimal encoded string\n * @return {String} UTF-8 encoded string or null\n * @since 1.1.1\n */\nfunction hextoutf8(s) {\n  return decodeURIComponent(hextouricmp(s));\n}\n\n/**\n * convert a hexadecimal encoded string to raw string including non printable characters.<br/>\n * @param {String} s hexadecimal encoded string\n * @return {String} raw string\n * @since 1.1.2\n * @example\n * hextorstr(\"610061\") &rarr; \"a\\x00a\"\n */\nfunction hextorstr(sHex) {\n    var s = \"\";\n    for (var i = 0; i < sHex.length - 1; i += 2) {\n        s += String.fromCharCode(parseInt(sHex.substr(i, 2), 16));\n    }\n    return s;\n}\n\n/**\n * convert a raw string including non printable characters to hexadecimal encoded string.<br/>\n * @param {String} s raw string\n * @return {String} hexadecimal encoded string\n * @since 1.1.2\n * @example\n * rstrtohex(\"a\\x00a\") &rarr; \"610061\"\n */\nfunction rstrtohex(s) {\n    var result = \"\";\n    for (var i = 0; i < s.length; i++) {\n        result += (\"0\" + s.charCodeAt(i).toString(16)).slice(-2);\n    }\n    return result;\n}\n\n// ==== hex / b64nl =======================================\n\n/**\n * convert a hexadecimal string to Base64 encoded string<br/>\n * @param {String} s hexadecimal string\n * @return {String} resulted Base64 encoded string\n * @since base64x 1.1.3\n * @description\n * This function converts from a hexadecimal string to Base64 encoded\n * string without new lines.\n * @example\n * hextob64(\"616161\") &rarr; \"YWFh\"\n */\nfunction hextob64(s) {\n    return hex2b64(s);\n}\n\n/**\n * convert a hexadecimal string to Base64 encoded string with new lines<br/>\n * @param {String} s hexadecimal string\n * @return {String} resulted Base64 encoded string with new lines\n * @since base64x 1.1.3\n * @description\n * This function converts from a hexadecimal string to Base64 encoded\n * string with new lines for each 64 characters. This is useful for\n * PEM encoded file.\n * @example\n * hextob64nl(\"123456789012345678901234567890123456789012345678901234567890\")\n * &rarr;\n * MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4 // new line\n * OTAxMjM0NTY3ODkwCg==\n */\nfunction hextob64nl(s) {\n    var b64 = hextob64(s);\n    var b64nl = b64.replace(/(.{64})/g, \"$1\\r\\n\");\n    b64nl = b64nl.replace(/\\r\\n$/, '');\n    return b64nl;\n}\n\n/**\n * convert a Base64 encoded string with new lines to a hexadecimal string<br/>\n * @param {String} s Base64 encoded string with new lines\n * @return {String} hexadecimal string\n * @since base64x 1.1.3\n * @description\n * This function converts from a Base64 encoded\n * string with new lines to a hexadecimal string.\n * This is useful to handle PEM encoded file.\n * This function removes any non-Base64 characters (i.e. not 0-9,A-Z,a-z,\\,+,=)\n * including new line.\n * @example\n * hextob64nl(\n * \"MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4\\r\\n\" +\n * \"OTAxMjM0NTY3ODkwCg==\\r\\n\")\n * &rarr;\n * \"123456789012345678901234567890123456789012345678901234567890\"\n */\nfunction b64nltohex(s) {\n    var b64 = s.replace(/[^0-9A-Za-z\\/+=]*/g, '');\n    var hex = b64tohex(b64);\n    return hex;\n} \n\n// ==== hex / ArrayBuffer =================================\n\n/**\n * convert a ArrayBuffer to a hexadecimal string<br/>\n * @param {String} hex hexadecimal string\n * @return {ArrayBuffer} ArrayBuffer\n * @since jsrsasign 6.1.4 base64x 1.1.8\n * @description\n * This function converts from a ArrayBuffer to a hexadecimal string.\n * @example\n * var buffer = new ArrayBuffer(3);\n * var view = new DataView(buffer);\n * view.setUint8(0, 0xfa);\n * view.setUint8(1, 0xfb);\n * view.setUint8(2, 0x01);\n * ArrayBuffertohex(buffer) &rarr; \"fafb01\"\n */\nfunction hextoArrayBuffer(hex) {\n    if (hex.length % 2 != 0) throw \"input is not even length\";\n    if (hex.match(/^[0-9A-Fa-f]+$/) == null) throw \"input is not hexadecimal\";\n\n    var buffer = new ArrayBuffer(hex.length / 2);\n    var view = new DataView(buffer);\n\n    for (var i = 0; i < hex.length / 2; i++) {\n\tview.setUint8(i, parseInt(hex.substr(i * 2, 2), 16));\n    }\n\n    return buffer;\n}\n\n// ==== ArrayBuffer / hex =================================\n\n/**\n * convert a ArrayBuffer to a hexadecimal string<br/>\n * @param {ArrayBuffer} buffer ArrayBuffer\n * @return {String} hexadecimal string\n * @since jsrsasign 6.1.4 base64x 1.1.8\n * @description\n * This function converts from a ArrayBuffer to a hexadecimal string.\n * @example\n * hextoArrayBuffer(\"fffa01\") &rarr; ArrayBuffer of [255, 250, 1]\n */\nfunction ArrayBuffertohex(buffer) {\n    var hex = \"\";\n    var view = new DataView(buffer);\n\n    for (var i = 0; i < buffer.byteLength; i++) {\n\thex += (\"00\" + view.getUint8(i).toString(16)).slice(-2);\n    }\n\n    return hex;\n}\n\n// ==== URIComponent / hex ================================\n/**\n * convert a URLComponent string such like \"%67%68\" to a hexadecimal string.<br/>\n * @param {String} s URIComponent string such like \"%67%68\"\n * @return {String} hexadecimal string\n * @since 1.1\n */\nfunction uricmptohex(s) {\n  return s.replace(/%/g, \"\");\n}\n\n/**\n * convert a hexadecimal string to a URLComponent string such like \"%67%68\".<br/>\n * @param {String} s hexadecimal string\n * @return {String} URIComponent string such like \"%67%68\"\n * @since 1.1\n */\nfunction hextouricmp(s) {\n  return s.replace(/(..)/g, \"%$1\");\n}\n\n// ==== URIComponent ================================\n/**\n * convert UTFa hexadecimal string to a URLComponent string such like \"%67%68\".<br/>\n * Note that these \"<code>0-9A-Za-z!'()*-._~</code>\" characters will not\n * converted to \"%xx\" format by builtin 'encodeURIComponent()' function.\n * However this 'encodeURIComponentAll()' function will convert \n * all of characters into \"%xx\" format.\n * @param {String} s hexadecimal string\n * @return {String} URIComponent string such like \"%67%68\"\n * @since 1.1\n */\nfunction encodeURIComponentAll(u8) {\n  var s = encodeURIComponent(u8);\n  var s2 = \"\";\n  for (var i = 0; i < s.length; i++) {\n    if (s[i] == \"%\") {\n      s2 = s2 + s.substr(i, 3);\n      i = i + 2;\n    } else {\n      s2 = s2 + \"%\" + stohex(s[i]);\n    }\n  }\n  return s2;\n}\n\n// ==== new lines ================================\n/**\n * convert all DOS new line(\"\\r\\n\") to UNIX new line(\"\\n\") in \n * a String \"s\".\n * @param {String} s string \n * @return {String} converted string\n */\nfunction newline_toUnix(s) {\n    s = s.replace(/\\r\\n/mg, \"\\n\");\n    return s;\n}\n\n/**\n * convert all UNIX new line(\"\\r\\n\") to DOS new line(\"\\n\") in \n * a String \"s\".\n * @param {String} s string \n * @return {String} converted string\n */\nfunction newline_toDos(s) {\n    s = s.replace(/\\r\\n/mg, \"\\n\");\n    s = s.replace(/\\n/mg, \"\\r\\n\");\n    return s;\n}\n\n// ==== string type checker ===================\n\n/**\n * check whether a string is an integer string or not<br/>\n * @name isInteger\n * @memberOf KJUR.lang.String\n * @function\n * @static\n * @param {String} s input string\n * @return {Boolean} true if a string \"s\" is an integer string otherwise false\n * @since base64x 1.1.7 jsrsasign 5.0.13\n * @example\n * KJUR.lang.String.isInteger(\"12345\") &rarr; true\n * KJUR.lang.String.isInteger(\"123ab\") &rarr; false\n */\nKJUR.lang.String.isInteger = function(s) {\n    if (s.match(/^[0-9]+$/)) {\n\treturn true;\n    } else if (s.match(/^-[0-9]+$/)) {\n\treturn true;\n    } else {\n\treturn false;\n    }\n};\n\n/**\n * check whether a string is an hexadecimal string or not<br/>\n * @name isHex\n * @memberOf KJUR.lang.String\n * @function\n * @static\n * @param {String} s input string\n * @return {Boolean} true if a string \"s\" is an hexadecimal string otherwise false\n * @since base64x 1.1.7 jsrsasign 5.0.13\n * @example\n * KJUR.lang.String.isHex(\"1234\") &rarr; true\n * KJUR.lang.String.isHex(\"12ab\") &rarr; true\n * KJUR.lang.String.isHex(\"12AB\") &rarr; true\n * KJUR.lang.String.isHex(\"12ZY\") &rarr; false\n * KJUR.lang.String.isHex(\"121\") &rarr; false -- odd length\n */\nKJUR.lang.String.isHex = function(s) {\n    if (s.length % 2 == 0 &&\n\t(s.match(/^[0-9a-f]+$/) || s.match(/^[0-9A-F]+$/))) {\n\treturn true;\n    } else {\n\treturn false;\n    }\n};\n\n/**\n * check whether a string is a base64 encoded string or not<br/>\n * Input string can conclude new lines or space characters.\n * @name isBase64\n * @memberOf KJUR.lang.String\n * @function\n * @static\n * @param {String} s input string\n * @return {Boolean} true if a string \"s\" is a base64 encoded string otherwise false\n * @since base64x 1.1.7 jsrsasign 5.0.13\n * @example\n * KJUR.lang.String.isBase64(\"YWE=\") &rarr; true\n * KJUR.lang.String.isBase64(\"YW_=\") &rarr; false\n * KJUR.lang.String.isBase64(\"YWE\") &rarr; false -- length shall be multiples of 4\n */\nKJUR.lang.String.isBase64 = function(s) {\n    s = s.replace(/\\s+/g, \"\");\n    if (s.match(/^[0-9A-Za-z+\\/]+={0,3}$/) && s.length % 4 == 0) {\n\treturn true;\n    } else {\n\treturn false;\n    }\n};\n\n/**\n * check whether a string is a base64url encoded string or not<br/>\n * Input string can conclude new lines or space characters.\n * @name isBase64URL\n * @memberOf KJUR.lang.String\n * @function\n * @static\n * @param {String} s input string\n * @return {Boolean} true if a string \"s\" is a base64url encoded string otherwise false\n * @since base64x 1.1.7 jsrsasign 5.0.13\n * @example\n * KJUR.lang.String.isBase64URL(\"YWE\") &rarr; true\n * KJUR.lang.String.isBase64URL(\"YW-\") &rarr; true\n * KJUR.lang.String.isBase64URL(\"YW+\") &rarr; false\n */\nKJUR.lang.String.isBase64URL = function(s) {\n    if (s.match(/[+/=]/)) return false;\n    s = b64utob64(s);\n    return KJUR.lang.String.isBase64(s);\n};\n\n/**\n * check whether a string is a string of integer array or not<br/>\n * Input string can conclude new lines or space characters.\n * @name isIntegerArray\n * @memberOf KJUR.lang.String\n * @function\n * @static\n * @param {String} s input string\n * @return {Boolean} true if a string \"s\" is a string of integer array otherwise false\n * @since base64x 1.1.7 jsrsasign 5.0.13\n * @example\n * KJUR.lang.String.isIntegerArray(\"[1,2,3]\") &rarr; true\n * KJUR.lang.String.isIntegerArray(\"  [1, 2, 3  ] \") &rarr; true\n * KJUR.lang.String.isIntegerArray(\"[a,2]\") &rarr; false\n */\nKJUR.lang.String.isIntegerArray = function(s) {\n    s = s.replace(/\\s+/g, \"\");\n    if (s.match(/^\\[[0-9,]+\\]$/)) {\n\treturn true;\n    } else {\n\treturn false;\n    }\n};\n\n// ==== others ================================\n\n/**\n * convert string of integer array to hexadecimal string.<br/>\n * @param {String} s string of integer array\n * @return {String} hexadecimal string\n * @since base64x 1.1.6 jsrsasign 5.0.2\n * @throws \"malformed integer array string: *\" for wrong input\n * @description\n * This function converts a string of JavaScript integer array to\n * a hexadecimal string. Each integer value shall be in a range \n * from 0 to 255 otherwise it raise exception. Input string can\n * have extra space or newline string so that they will be ignored.\n * \n * @example\n * intarystrtohex(\" [123, 34, 101, 34, 58] \")\n * &rarr; 7b2265223a (i.e. '{\"e\":' as string)\n */\nfunction intarystrtohex(s) {\n  s = s.replace(/^\\s*\\[\\s*/, '');\n  s = s.replace(/\\s*\\]\\s*$/, '');\n  s = s.replace(/\\s*/g, '');\n  try {\n    var hex = s.split(/,/).map(function(element, index, array) {\n      var i = parseInt(element);\n      if (i < 0 || 255 < i) throw \"integer not in range 0-255\";\n      var hI = (\"00\" + i.toString(16)).slice(-2);\n      return hI;\n    }).join('');\n    return hex;\n  } catch(ex) {\n    throw \"malformed integer array string: \" + ex;\n  }\n}\n\n/**\n * find index of string where two string differs\n * @param {String} s1 string to compare\n * @param {String} s2 string to compare\n * @return {Number} string index of where character differs. Return -1 if same.\n * @since jsrsasign 4.9.0 base64x 1.1.5\n * @example\n * strdiffidx(\"abcdefg\", \"abcd4fg\") -> 4\n * strdiffidx(\"abcdefg\", \"abcdefg\") -> -1\n * strdiffidx(\"abcdefg\", \"abcdef\") -> 6\n * strdiffidx(\"abcdefgh\", \"abcdef\") -> 6\n */\nvar strdiffidx = function(s1, s2) {\n    var n = s1.length;\n    if (s1.length > s2.length) n = s2.length;\n    for (var i = 0; i < n; i++) {\n\tif (s1.charCodeAt(i) != s2.charCodeAt(i)) return i;\n    }\n    if (s1.length != s2.length) return n;\n    return -1; // same\n};\n\n\n\n/*! jws-3.3.5 (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * jws.js - JSON Web Signature(JWS) and JSON Web Token(JWT) Class\n *\n * version: 3.3.4 (2016 May 17)\n *\n * Copyright (c) 2010-2016 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license/\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name jws-3.3.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 3.3.5 (2016-Oct-08)\n * @since jsjws 1.0, jsrsasign 4.8.0\n * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n */\n\nif (typeof KJUR == \"undefined\" || !KJUR) KJUR = {};\n\n/**\n * kjur's JSON Web Signature/Token(JWS/JWT) library name space\n * <p>\n * This namespace privides following JWS/JWS related classes.\n * <ul>\n * <li>{@link KJUR.jws.JWS} - JSON Web Signature/Token(JWS/JWT) class</li>\n * <li>{@link KJUR.jws.JWSJS} - JWS JSON Serialization(JWSJS) class</li>\n * <li>{@link KJUR.jws.IntDate} - UNIX origin time utility class</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.jws\n * @namespace\n */\nif (typeof KJUR.jws == \"undefined\" || !KJUR.jws) KJUR.jws = {};\n\n/**\n * JSON Web Signature(JWS) class.<br/>\n * @name KJUR.jws.JWS\n * @class JSON Web Signature(JWS) class\n * @see <a href=\"http://kjur.github.com/jsjws/\">'jwjws'(JWS JavaScript Library) home page http://kjur.github.com/jsjws/</a>\n * @see <a href=\"http://kjur.github.com/jsrsasigns/\">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @see <a href=\"http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-14\">IETF I-D JSON Web Algorithms (JWA)</a>\n * @since jsjws 1.0\n * @description\n * This class provides JSON Web Signature(JWS)/JSON Web Token(JWT) signing and validation.\n *\n * <h4>METHOD SUMMARY</h4>\n * Here is major methods of {@link KJUR.jws.JWS} class.\n * <ul>\n * <li><b>SIGN</b><br/>\n * <li>{@link KJUR.jws.JWS.sign} - sign JWS</li>\n * </li>\n * <li><b>VERIFY</b><br/>\n * <li>{@link KJUR.jws.JWS.verify} - verify JWS signature</li>\n * <li>{@link KJUR.jws.JWS.verifyJWT} - verify properties of JWT token at specified time</li>\n * </li>\n * <li><b>UTILITY</b><br/>\n * <li>{@link KJUR.jws.JWS.getJWKthumbprint} - get RFC 7638 JWK thumbprint</li>\n * <li>{@link KJUR.jws.JWS.isSafeJSONString} - check whether safe JSON string or not</li>\n * <li>{@link KJUR.jws.JWS.readSafeJSONString} - read safe JSON string only</li>\n * </li>\n * </ul> \n *\n * <h4>SUPPORTED SIGNATURE ALGORITHMS</h4>\n * Here is supported algorithm names for {@link KJUR.jws.JWS.sign} and\n * {@link KJUR.jws.JWS.verify} methods.\n * <table>\n * <tr><th>alg value</th><th>spec requirement</th><th>jsjws support</th></tr>\n * <tr><td>HS256</td><td>REQUIRED</td><td>SUPPORTED</td></tr>\n * <tr><td>HS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>HS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>RS256</td><td>RECOMMENDED</td><td>SUPPORTED</td></tr>\n * <tr><td>RS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>RS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>ES256</td><td>RECOMMENDED+</td><td>SUPPORTED</td></tr>\n * <tr><td>ES384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>ES512</td><td>OPTIONAL</td><td>-</td></tr>\n * <tr><td>PS256</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>PS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>PS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>none</td><td>REQUIRED</td><td>SUPPORTED(signature generation only)</td></tr>\n * </table>\n * <dl>\n * <dt><b>NOTE1</b>\n * <dd>HS384 is supported since jsjws 3.0.2 with jsrsasign 4.1.4.\n * <dt><b>NOTE2</b>\n * <dd>Some deprecated methods have been removed since jws 3.3 of jsrsasign 4.10.0.\n * Removed methods are following:\n * <ul>\n * <li>JWS.verifyJWSByNE</li>\n * <li>JWS.verifyJWSByKey</li>\n * <li>JWS.generateJWSByNED</li>\n * <li>JWS.generateJWSByKey</li>\n * <li>JWS.generateJWSByP1PrvKey</li>\n * </ul>\n * </dl>\n * <b>EXAMPLE</b><br/>\n * @example\n * // JWS signing \n * sJWS = KJUR.jws.JWS.sign(null, '{\"alg\":\"HS256\", \"cty\":\"JWT\"}', '{\"age\": 21}', {\"utf8\": \"password\"});\n * // JWS validation\n * isValid = KJUR.jws.JWS.verify('eyJjdHkiOiJKV1QiLCJhbGc...', {\"utf8\": \"password\"});\n * // JWT validation\n * isValid = KJUR.jws.JWS.verifyJWT('eyJh...', {\"utf8\": \"password\"}, {\n *   alg: ['HS256', 'HS384'],\n *   iss: ['http://foo.com']\n * });\n */\nKJUR.jws.JWS = function() {\n    var ns1 = KJUR.jws.JWS;\n\n    // === utility =============================================================\n\n    /**\n     * parse JWS string and set public property 'parsedJWS' dictionary.<br/>\n     * @name parseJWS\n     * @memberOf KJUR.jws.JWS\n     * @function\n     * @param {String} sJWS JWS signature string to be parsed.\n     * @throws if sJWS is not comma separated string such like \"Header.Payload.Signature\".\n     * @throws if JWS Header is a malformed JSON string.\n     * @since jws 1.1\n     */\n    this.parseJWS = function(sJWS, sigValNotNeeded) {\n\tif ((this.parsedJWS !== undefined) &&\n\t    (sigValNotNeeded || (this.parsedJWS.sigvalH !== undefined))) {\n\t    return;\n\t}\n    var matchResult = sJWS.match(/^([^.]+)\\.([^.]+)\\.([^.]+)$/);\n\tif (matchResult == null) {\n\t    throw \"JWS signature is not a form of 'Head.Payload.SigValue'.\";\n\t}\n\tvar b6Head = matchResult[1];\n\tvar b6Payload = matchResult[2];\n\tvar b6SigVal = matchResult[3];\n\tvar sSI = b6Head + \".\" + b6Payload;\n\tthis.parsedJWS = {};\n\tthis.parsedJWS.headB64U = b6Head;\n\tthis.parsedJWS.payloadB64U = b6Payload;\n\tthis.parsedJWS.sigvalB64U = b6SigVal;\n\tthis.parsedJWS.si = sSI;\n\n\tif (!sigValNotNeeded) {\n\t    var hSigVal = b64utohex(b6SigVal);\n\t    var biSigVal = parseBigInt(hSigVal, 16);\n\t    this.parsedJWS.sigvalH = hSigVal;\n\t    this.parsedJWS.sigvalBI = biSigVal;\n\t}\n\n\tvar sHead = b64utoutf8(b6Head);\n\tvar sPayload = b64utoutf8(b6Payload);\n\tthis.parsedJWS.headS = sHead;\n\tthis.parsedJWS.payloadS = sPayload;\n\n\tif (! ns1.isSafeJSONString(sHead, this.parsedJWS, 'headP'))\n\t    throw \"malformed JSON string for JWS Head: \" + sHead;\n    };\n};\n\n// === major static method ========================================================\n\n/**\n * generate JWS signature by specified key<br/>\n * @name sign\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} alg JWS algorithm name to sign and force set to sHead or null \n * @param {String} spHead string or object of JWS Header\n * @param {String} spPayload string or object of JWS Payload\n * @param {String} key string of private key or mac key object to sign\n * @param {String} pass (OPTION)passcode to use encrypted asymmetric private key \n * @return {String} JWS signature string\n * @since jws 3.0.0\n * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html\">jsrsasign KJUR.crypto.Signature method</a>\n * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Mac.html\">jsrsasign KJUR.crypto.Mac method</a>\n * @description\n * This method supports following algorithms.\n * <table>\n * <tr><th>alg value</th><th>spec requirement</th><th>jsjws support</th></tr>\n * <tr><td>HS256</td><td>REQUIRED</td><td>SUPPORTED</td></tr>\n * <tr><td>HS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>HS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>RS256</td><td>RECOMMENDED</td><td>SUPPORTED</td></tr>\n * <tr><td>RS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>RS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>ES256</td><td>RECOMMENDED+</td><td>SUPPORTED</td></tr>\n * <tr><td>ES384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>ES512</td><td>OPTIONAL</td><td>-</td></tr>\n * <tr><td>PS256</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>PS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>PS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>\n * <tr><td>none</td><td>REQUIRED</td><td>SUPPORTED(signature generation only)</td></tr>\n * </table>\n * <dl>\n * <dt>NOTE1:\n * <dd>salt length of RSAPSS signature is the same as the hash algorithm length\n * because of <a href=\"http://www.ietf.org/mail-archive/web/jose/current/msg02901.html\">IETF JOSE ML discussion</a>.\n * <dt>NOTE2:\n * <dd>To support HS384, patched version of CryptoJS is used.\n * <a href=\"https://code.google.com/p/crypto-js/issues/detail?id=84\">See here for detail</a>.\n * <dt>NOTE3:\n * From jsrsasign 4.10.0 jws 3.3.0, Way to provide password\n * for HS* algorithm is changed. The 'key' attribute value is\n * passed to {@link KJUR.crypto.Mac.setPassword} so please see\n * {@link KJUR.crypto.Mac.setPassword} for detail.\n * As for backword compatibility, if key is a string, has even length and\n * 0..9, A-F or a-f characters, key string is treated as a hexadecimal\n * otherwise it is treated as a raw string.\n * <dd>\n * </dl>\n * <b>EXAMPLE</b><br/>\n * @example\n * // sign HS256 signature with password \"aaa\" implicitly handled as string\n * sJWS = KJUR.jws.JWS.sign(null, {alg: \"HS256\", cty: \"JWT\"}, {age: 21}, \"aaa\");\n * // sign HS256 signature with password \"6161\" implicitly handled as hex\n * sJWS = KJUR.jws.JWS.sign(null, {alg: \"HS256\", cty: \"JWT\"}, {age: 21}, \"6161\");\n * // sign HS256 signature with base64 password\n * sJWS = KJUR.jws.JWS.sign(null, {alg: \"HS256\"}, {age: 21}, {b64: \"Mi/8..a=\"});\n * // sign RS256 signature with PKCS#8 PEM RSA private key\n * sJWS = KJUR.jws.JWS.sign(null, {alg: \"RS256\"}, {age: 21}, \"-----BEGIN PRIVATE KEY...\");\n * // sign RS256 signature with PKCS#8 PEM ECC private key with passcode\n * sJWS = KJUR.jws.JWS.sign(null, {alg: \"ES256\"}, {age: 21}, \n *                          \"-----BEGIN PRIVATE KEY...\", \"keypass\");\n * // header and payload can be passed by both string and object\n * sJWS = KJUR.jws.JWS.sign(null, '{alg:\"HS256\",cty:\"JWT\"}', '{age:21}', \"aaa\");\n */\nKJUR.jws.JWS.sign = function(alg, spHeader, spPayload, key, pass) {\n    var ns1 = KJUR.jws.JWS;\n    var sHeader, pHeader, sPayload;\n\n    // 1. check signatureInput(Header, Payload) is string or object\n    if (typeof spHeader != 'string' && typeof spHeader != 'object')\n\tthrow \"spHeader must be JSON string or object: \" + spHeader;\n\n    if (typeof spHeader == 'object') {\n\tpHeader = spHeader;\n\tsHeader = JSON.stringify(pHeader);\n    }\n\n    if (typeof spHeader == 'string') {\n\tsHeader = spHeader;\n\tif (! ns1.isSafeJSONString(sHeader))\n\t    throw \"JWS Head is not safe JSON string: \" + sHeader;\n\tpHeader = ns1.readSafeJSONString(sHeader);\n\n    }\n\n    sPayload = spPayload;\n    if (typeof spPayload == 'object') sPayload = JSON.stringify(spPayload);\n\n    // 2. use alg if defined in sHeader\n    if ((alg == '' || alg == null) &&\n\tpHeader['alg'] !== undefined) {\n\talg = pHeader['alg'];\n    }\n\n    // 3. update sHeader to add alg if alg undefined\n    if ((alg != '' && alg != null) &&\n\tpHeader['alg'] === undefined) {\n\tpHeader['alg'] = alg;\n\tsHeader = JSON.stringify(pHeader);\n    }\n\n    // 4. check explicit algorithm doesn't match with JWS header.\n    if (alg !== pHeader.alg)\n\tthrow \"alg and sHeader.alg doesn't match: \" + alg + \"!=\" + pHeader.alg;\n\n    // 5. set signature algorithm like SHA1withRSA\n    var sigAlg = null;\n    if (ns1.jwsalg2sigalg[alg] === undefined) {\n\tthrow \"unsupported alg name: \" + alg;\n    } else {\n\tsigAlg = ns1.jwsalg2sigalg[alg];\n    }\n    \n    var uHeader = utf8tob64u(sHeader);\n    var uPayload = utf8tob64u(sPayload);\n    var uSignatureInput = uHeader + \".\" + uPayload\n    // 6. sign\n    var hSig = \"\";\n    if (sigAlg.substr(0, 4) == \"Hmac\") {\n\tif (key === undefined)\n\t    throw \"mac key shall be specified for HS* alg\";\n\t//alert(\"sigAlg=\" + sigAlg);\n\tvar mac = new KJUR.crypto.Mac({'alg': sigAlg, 'prov': 'cryptojs', 'pass': key});\n\tmac.updateString(uSignatureInput);\n\thSig = mac.doFinal();\n    } else if (sigAlg.indexOf(\"withECDSA\") != -1) {\n\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\tsig.init(key, pass);\n\tsig.updateString(uSignatureInput);\n\thASN1Sig = sig.sign();\n\thSig = KJUR.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig);\n    } else if (sigAlg != \"none\") {\n\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\tsig.init(key, pass);\n\tsig.updateString(uSignatureInput);\n\thSig = sig.sign();\n    }\n\n    var uSig = hextob64u(hSig);\n    return uSignatureInput + \".\" + uSig;\n};\n\n/**\n * verify JWS signature by specified key or certificate<br/>\n * @name verify\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} sJWS string of JWS signature to verify\n * @param {Object} key string of public key, certificate or key object to verify\n * @param {String} acceptAlgs array of algorithm name strings (OPTION)\n * @return {Boolean} true if the signature is valid otherwise false\n * @since jws 3.0.0\n * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html\">jsrsasign KJUR.crypto.Signature method</a>\n * @see <a href=\"http://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Mac.html\">jsrsasign KJUR.crypto.Mac method</a>\n * @description\n * <p>\n * This method verifies a JSON Web Signature Compact Serialization string by the validation \n * algorithm as described in \n * <a href=\"http://self-issued.info/docs/draft-jones-json-web-signature-04.html#anchor5\">\n * the section 5 of Internet Draft draft-jones-json-web-signature-04.</a>\n * </p>\n * <p>\n * Since 3.2.0 strict key checking has been provided against a JWS algorithm\n * in a JWS header.\n * <ul>\n * <li>In case 'alg' is 'HS*' in the JWS header,\n * 'key' shall be hexadecimal string for Hmac{256,384,512} shared secret key.\n * Otherwise it raise an error.</li>\n * <li>In case 'alg' is 'RS*' or 'PS*' in the JWS header,\n * 'key' shall be a RSAKey object or a PEM string of\n * X.509 RSA public key certificate or PKCS#8 RSA public key.\n * Otherwise it raise an error.</li>\n * <li>In case 'alg' is 'ES*' in the JWS header,\n * 'key' shall be a KJUR.crypto.ECDSA object or a PEM string of\n * X.509 ECC public key certificate or PKCS#8 ECC public key.\n * Otherwise it raise an error.</li>\n * <li>In case 'alg' is 'none' in the JWS header,\n * validation not supported after jsjws 3.1.0.</li>\n * </ul>\n * </p>\n * <p>\n * NOTE1: The argument 'acceptAlgs' is supported since 3.2.0.\n * Strongly recommended to provide acceptAlgs to mitigate\n * signature replacement attacks.<br/>\n * </p>\n * <p>\n * NOTE2: From jsrsasign 4.9.0 jws 3.2.5, Way to provide password\n * for HS* algorithm is changed. The 'key' attribute value is\n * passed to {@link KJUR.crypto.Mac.setPassword} so please see\n * {@link KJUR.crypto.Mac.setPassword} for detail.\n * As for backword compatibility, if key is a string, has even length and\n * 0..9, A-F or a-f characters, key string is treated as a hexadecimal\n * otherwise it is treated as a raw string.\n * </p>\n * @example\n * // 1) verify a RS256 JWS signature by a certificate string.\n * isValid = KJUR.jws.JWS.verify('eyJh...', '-----BEGIN...', ['RS256']);\n * \n * // 2) verify a HS256 JWS signature by a certificate string.\n * isValid = KJUR.jws.JWS.verify('eyJh...', {hex: '6f62ad...'}, ['HS256']);\n * isValid = KJUR.jws.JWS.verify('eyJh...', {b64: 'Mi/ab8...a=='}, ['HS256']);\n * isValid = KJUR.jws.JWS.verify('eyJh...', {utf8: 'Secret秘密'}, ['HS256']);\n * isValid = KJUR.jws.JWS.verify('eyJh...', '6f62ad', ['HS256']); // implicit hex\n * isValid = KJUR.jws.JWS.verify('eyJh...', '6f62ada', ['HS256']); // implicit raw string\n *\n * // 3) verify a ES256 JWS signature by a KJUR.crypto.ECDSA key object.\n * var pubkey = KEYUTIL.getKey('-----BEGIN CERT...');\n * var isValid = KJUR.jws.JWS.verify('eyJh...', pubkey);\n */\nKJUR.jws.JWS.verify = function(sJWS, key, acceptAlgs) {\n    var jws = KJUR.jws.JWS;\n    var a = sJWS.split(\".\");\n    var uHeader = a[0];\n    var uPayload = a[1];\n    var uSignatureInput = uHeader + \".\" + uPayload;\n    var hSig = b64utohex(a[2]);\n\n    // 1. parse JWS header\n    var pHeader = jws.readSafeJSONString(b64utoutf8(a[0]));\n    var alg = null;\n    var algType = null; // HS|RS|PS|ES|no\n    if (pHeader.alg === undefined) {\n\tthrow \"algorithm not specified in header\";\n    } else {\n\talg = pHeader.alg;\n\talgType = alg.substr(0, 2);\n    }\n\n    // 2. check whether alg is acceptable algorithms\n    if (acceptAlgs != null &&\n        Object.prototype.toString.call(acceptAlgs) === '[object Array]' &&\n        acceptAlgs.length > 0) {\n\tvar acceptAlgStr = \":\" + acceptAlgs.join(\":\") + \":\";\n\tif (acceptAlgStr.indexOf(\":\" + alg + \":\") == -1) {\n\t    throw \"algorithm '\" + alg + \"' not accepted in the list\";\n\t}\n    }\n\n    // 3. check whether key is a proper key for alg.\n    if (alg != \"none\" && key === null) {\n\tthrow \"key shall be specified to verify.\";\n    }\n\n    // 3.1. There is no key check for HS* because Mac will check it.\n    //      since jsrsasign 5.0.0.\n\n    // 3.2. convert key object if key is a public key or cert PEM string\n    if (typeof key == \"string\" &&\n\tkey.indexOf(\"-----BEGIN \") != -1) {\n\tkey = KEYUTIL.getKey(key);\n    }\n\n    // 3.3. check whether key is RSAKey obj if alg is RS* or PS*.\n    if (algType == \"RS\" || algType == \"PS\") {\n\tif (!(key instanceof RSAKey)) {\n\t    throw \"key shall be a RSAKey obj for RS* and PS* algs\";\n\t}\n    }\n\n    // 3.4. check whether key is ECDSA obj if alg is ES*.\n    if (algType == \"ES\") {\n\tif (!(key instanceof KJUR.crypto.ECDSA)) {\n\t    throw \"key shall be a ECDSA obj for ES* algs\";\n\t}\n    }\n\n    // 3.5. check when alg is 'none'\n    if (alg == \"none\") {\n    }\n\n    // 4. check whether alg is supported alg in jsjws.\n    var sigAlg = null;\n    if (jws.jwsalg2sigalg[pHeader.alg] === undefined) {\n\tthrow \"unsupported alg name: \" + alg;\n    } else {\n\tsigAlg = jws.jwsalg2sigalg[alg];\n    }\n\n    // 5. verify\n    if (sigAlg == \"none\") {\n        throw \"not supported\";\n    } else if (sigAlg.substr(0, 4) == \"Hmac\") {\n\tvar hSig2 = null;\n\tif (key === undefined)\n\t    throw \"hexadecimal key shall be specified for HMAC\";\n\t//try {\n\t    var mac = new KJUR.crypto.Mac({'alg': sigAlg, 'pass': key});\n\t    mac.updateString(uSignatureInput);\n\t    hSig2 = mac.doFinal();\n\t//} catch(ex) {};\n\treturn hSig == hSig2;\n    } else if (sigAlg.indexOf(\"withECDSA\") != -1) {\n\tvar hASN1Sig = null;\n        try {\n\t    hASN1Sig = KJUR.crypto.ECDSA.concatSigToASN1Sig(hSig);\n\t} catch (ex) {\n\t    return false;\n\t}\n\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\tsig.init(key)\n\tsig.updateString(uSignatureInput);\n\treturn sig.verify(hASN1Sig);\n    } else {\n\tvar sig = new KJUR.crypto.Signature({'alg': sigAlg});\n\tsig.init(key)\n\tsig.updateString(uSignatureInput);\n\treturn sig.verify(hSig);\n    }\n};\n\n/**\n * parse header and payload of JWS signature<br/>\n * @name parse\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} sJWS string of JWS signature to parse\n * @return {Array} associative array of parsed header and payload. See below.\n * @throws if sJWS is malformed JWS signature\n * @since jws 3.3.3\n * @description\n * This method parses JWS signature string. \n * Resulted associative array has following properties:\n * <ul>\n * <li>headerObj - JSON object of header</li>\n * <li>payloadObj - JSON object of payload if payload is JSON string otherwise undefined</li>\n * <li>headerPP - pretty printed JSON header by stringify</li>\n * <li>payloadPP - pretty printed JSON payload by stringify if payload is JSON otherwise Base64URL decoded raw string of payload</li>\n * <li>sigHex - hexadecimal string of signature</li>\n * </ul>\n * @example\n * KJUR.jws.JWS.parse(sJWS) ->\n * { \n *   headerObj: {\"alg\": \"RS256\", \"typ\": \"JWS\"},\n *   payloadObj: {\"product\": \"orange\", \"quantity\": 100},\n *   headerPP: \n *   '{\n *     \"alg\": \"RS256\",\n *     \"typ\": \"JWS\"\n *   }',\n *   payloadPP: \n *   '{\n *     \"product\": \"orange\",\n *     \"quantity\": 100\n *   }',\n *   sigHex: \"91f3cd...\" \n * }\n */\nKJUR.jws.JWS.parse = function(sJWS) {\n    var a = sJWS.split(\".\");\n    var result = {};\n    var uHeader, uPayload, uSig;\n    if (a.length != 2 && a.length != 3)\n\tthrow \"malformed sJWS: wrong number of '.' splitted elements\";\n\n    uHeader = a[0];\n    uPayload = a[1];\n    if (a.length == 3) uSig = a[2]; \n\n    result.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(uHeader));\n    result.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(uPayload));\n\n    result.headerPP = JSON.stringify(result.headerObj, null, \"  \");\n    if (result.payloadObj == null) {\n\tresult.payloadPP = b64utoutf8(uPayload);\n    } else {\n\tresult.payloadPP = JSON.stringify(result.payloadObj, null, \"  \");\n    }\n\n    if (uSig !== undefined) {\n\tresult.sigHex = b64utohex(uSig);\n    }\n\n    return result;\n};\n\n/**\n * @name verifyJWT\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} sJWT string of JSON Web Token(JWT) to verify\n * @param {Object} key string of public key, certificate or key object to verify\n * @param {Array} acceptField associative array of acceptable fields (OPTION)\n * @return {Boolean} true if the JWT token is valid otherwise false\n * @since jws 3.2.3 jsrsasign 4.8.0\n *\n * @description\n * This method verifies a\n * <a href=\"https://tools.ietf.org/html/rfc7519\">RFC 7519</a> \n * JSON Web Token(JWT).\n * It will verify following:\n * <ul>\n * <li>Header.alg\n * <ul>\n * <li>alg is specified in JWT header.</li>\n * <li>alg is included in acceptField.alg array. (MANDATORY)</li>\n * <li>alg is proper for key.</li>\n * </ul>\n * </li>\n * <li>Payload.iss (issuer) - Payload.iss is included in acceptField.iss array if specified. (OPTION)</li>\n * <li>Payload.sub (subject) - Payload.sub is included in acceptField.sub array if specified. (OPTION)</li>\n * <li>Payload.aud (audience) - Payload.aud is included in acceptField.aud array or \n *     the same as value if specified. (OPTION)</li>\n * <li>Time validity\n * <ul>\n * <li>\n * If acceptField.verifyAt as number of UNIX origin time is specifed for validation time, \n * this method will verify at the time for it, otherwise current time will be used to verify.\n * </li>\n * <li>\n * Clock of JWT generator or verifier can be fast or slow. If these clocks are\n * very different, JWT validation may fail. To avoid such case, 'jsrsasign' supports\n * 'acceptField.gracePeriod' parameter which specifies acceptable time difference\n * of those clocks in seconds. So if you want to accept slow or fast in 2 hours,\n * you can specify <code>acceptField.gracePeriod = 2 * 60 * 60;</code>.\n * \"gracePeriod\" is zero by default.\n * \"gracePeriod\" is supported since jsrsasign 5.0.12.\n * </li>\n * <li>Payload.exp (expire) - Validation time is smaller than Payload.exp + gracePeriod.</li>\n * <li>Payload.nbf (not before) - Validation time is greater than Payload.nbf - gracePeriod.</li>\n * <li>Payload.iat (issued at) - Validation time is greater than Payload.iat - gracePeriod.</li>\n * </ul>\n * </li>\n * <li>Payload.jti (JWT id) - Payload.jti is included in acceptField.jti if specified. (OPTION)</li>\n * <li>JWS signature of JWS is valid for specified key.</li>\n * </ul>\n *\n * <h4>acceptField parameters</h4>\n * Here is available acceptField argument parameters:\n * <ul>\n * <li>alg - array of acceptable signature algorithm names (ex. [\"HS256\", \"HS384\"])</li>\n * <li>iss - array of acceptable issuer names (ex. ['http://foo.com'])</li>\n * <li>sub - array of acceptable subject names (ex. ['mailto:john@foo.com'])</li>\n * <li>aud - array or string of acceptable audience name(s) (ex. ['http://foo.com'])</li>\n * <li>jti - string of acceptable JWT ID (OPTION) (ex. 'id1234')</li>\n * <li>\n * verifyAt - time to verify 'nbf', 'iat' and 'exp' in UNIX seconds \n * (OPTION) (ex. 1377663900).  \n * If this is not specified, current time of verifier will be used. \n * {@link KJUR.jws.IntDate} may be useful to specify it.\n * </li>\n * <li>gracePeriod - acceptable time difference between signer and verifier\n * in seconds (ex. 3600). If this is not specified, zero will be used.</li>\n * </ul>\n *\n * @example\n * // simple validation for HS256\n * isValid = KJUR.jws.JWS.verifyJWT(\"eyJhbG...\", \"616161\", {alg: [\"HS256\"]}),\n *\n * // full validation for RS or PS\n * pubkey = KEYUTIL.getKey('-----BEGIN CERT...');\n * isValid = KJUR.jws.JWS.verifyJWT('eyJh...', pubkey, {\n *   alg: ['RS256', 'RS512', 'PS256', 'PS512'],\n *   iss: ['http://foo.com'],\n *   sub: ['mailto:john@foo.com', 'mailto:alice@foo.com'],\n *   verifyAt: KJUR.jws.IntDate.get('20150520235959Z'),\n *   aud: ['http://foo.com'], // aud: 'http://foo.com' is fine too.\n *   jti: 'id123456',\n *   gracePeriod: 1 * 60 * 60 // accept 1 hour slow or fast\n * });\n */\nKJUR.jws.JWS.verifyJWT = function(sJWT, key, acceptField) {\n    var ns1 = KJUR.jws.JWS;\n\n    // 1. parse JWT\n    var a = sJWT.split(\".\");\n    var uHeader = a[0];\n    var uPayload = a[1];\n    var uSignatureInput = uHeader + \".\" + uPayload;\n    var hSig = b64utohex(a[2]);\n\n    // 2. parse JWS header\n    var pHeader = ns1.readSafeJSONString(b64utoutf8(uHeader));\n\n    // 3. parse JWS payload\n    var pPayload = ns1.readSafeJSONString(b64utoutf8(uPayload));\n\n    // 4. algorithm ('alg' in header) check\n    if (pHeader.alg === undefined) return false;\n    if (acceptField.alg === undefined)\n\tthrow \"acceptField.alg shall be specified\";\n    if (! ns1.inArray(pHeader.alg, acceptField.alg)) return false;\n\n    // 5. issuer ('iss' in payload) check\n    if (pPayload.iss !== undefined && typeof acceptField.iss === \"object\") {\n\tif (! ns1.inArray(pPayload.iss, acceptField.iss)) return false;\n    }\n\n    // 6. subject ('sub' in payload) check\n    if (pPayload.sub !== undefined && typeof acceptField.sub === \"object\") {\n\tif (! ns1.inArray(pPayload.sub, acceptField.sub)) return false;\n    }\n\n    // 7. audience ('aud' in payload) check\n    if (pPayload.aud !== undefined && typeof acceptField.aud === \"object\") {\n\tif (typeof pPayload.aud == \"string\") {\n\t    if (! ns1.inArray(pPayload.aud, acceptField.aud))\n\t\treturn false;\n\t} else if (typeof pPayload.aud == \"object\") {\n\t    if (! ns1.includedArray(pPayload.aud, acceptField.aud))\n\t\treturn false;\n\t}\n    }\n\n    // 8. time validity \n    //   (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)\n    var now = KJUR.jws.IntDate.getNow();\n    if (acceptField.verifyAt !== undefined && typeof acceptField.verifyAt === \"number\") {\n\tnow = acceptField.verifyAt;\n    }\n    if (acceptField.gracePeriod === undefined || \n        typeof acceptField.gracePeriod !== \"number\") {\n\tacceptField.gracePeriod = 0;\n    }\n\n    // 8.1 expired time 'exp' check\n    if (pPayload.exp !== undefined && typeof pPayload.exp == \"number\") {\n\tif (pPayload.exp + acceptField.gracePeriod < now) return false;\n    }\n\n    // 8.2 not before time 'nbf' check\n    if (pPayload.nbf !== undefined && typeof pPayload.nbf == \"number\") {\n\tif (now < pPayload.nbf - acceptField.gracePeriod) return false;\n    }\n    \n    // 8.3 issued at time 'iat' check\n    if (pPayload.iat !== undefined && typeof pPayload.iat == \"number\") {\n\tif (now < pPayload.iat - acceptField.gracePeriod) return false;\n    }\n\n    // 9 JWT id 'jti' check\n    if (pPayload.jti !== undefined && acceptField.jti !== undefined) {\n      if (pPayload.jti !== acceptField.jti) return false;\n    }\n\n    // 10 JWS signature check\n    if (! KJUR.jws.JWS.verify(sJWT, key, acceptField.alg)) return false;\n\n    // 11 passed all check\n    return true;\n};\n\n/**\n * check whether array is included by another array\n * @name includedArray\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {Array} a1 check whether set a1 is included by a2\n * @param {Array} a2 check whether set a1 is included by a2\n * @return {Boolean} check whether set a1 is included by a2\n * @since jws 3.2.3\n * This method verifies whether an array is included by another array.\n * It doesn't care about item ordering in a array.\n * @example\n * KJUR.jws.JWS.includedArray(['b'], ['b', 'c', 'a']) => true\n * KJUR.jws.JWS.includedArray(['a', 'b'], ['b', 'c', 'a']) => true\n * KJUR.jws.JWS.includedArray(['a', 'b'], ['b', 'c']) => false\n */\nKJUR.jws.JWS.includedArray = function(a1, a2) {\n    var inArray = KJUR.jws.JWS.inArray;\n    if (a1 === null) return false;\n    if (typeof a1 !== \"object\") return false;\n    if (typeof a1.length !== \"number\") return false;\n\n    for (var i = 0; i < a1.length; i++) {\n\tif (! inArray(a1[i], a2)) return false;\n    }\n    return true;\n};\n\n/**\n * check whether item is included by array\n * @name inArray\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} item check whether item is included by array\n * @param {Array} a check whether item is included by array\n * @return {Boolean} check whether item is included by array\n * @since jws 3.2.3\n * This method verifies whether an item is included by an array.\n * It doesn't care about item ordering in an array.\n * @example\n * KJUR.jws.JWS.inArray('b', ['b', 'c', 'a']) => true\n * KJUR.jws.JWS.inArray('a', ['b', 'c', 'a']) => true\n * KJUR.jws.JWS.inArray('a', ['b', 'c']) => false\n */\nKJUR.jws.JWS.inArray = function(item, a) {\n    if (a === null) return false;\n    if (typeof a !== \"object\") return false;\n    if (typeof a.length !== \"number\") return false;\n    for (var i = 0; i < a.length; i++) {\n\tif (a[i] == item) return true;\n    }\n    return false;\n};\n\n/**\n * static associative array of general signature algorithm name from JWS algorithm name\n * @since jws 3.0.0\n */\nKJUR.jws.JWS.jwsalg2sigalg = {\n    \"HS256\":\t\"HmacSHA256\",\n    \"HS384\":\t\"HmacSHA384\",\n    \"HS512\":\t\"HmacSHA512\",\n    \"RS256\":\t\"SHA256withRSA\",\n    \"RS384\":\t\"SHA384withRSA\",\n    \"RS512\":\t\"SHA512withRSA\",\n    \"ES256\":\t\"SHA256withECDSA\",\n    \"ES384\":\t\"SHA384withECDSA\",\n    //\"ES512\":\t\"SHA512withECDSA\", // unsupported because of jsrsasign's bug\n    \"PS256\":\t\"SHA256withRSAandMGF1\",\n    \"PS384\":\t\"SHA384withRSAandMGF1\",\n    \"PS512\":\t\"SHA512withRSAandMGF1\",\n    \"none\":\t\"none\",\n};\n\n// === utility static method ==================================================\n\n/**\n * check whether a String \"s\" is a safe JSON string or not.<br/>\n * If a String \"s\" is a malformed JSON string or an other object type\n * this returns 0, otherwise this returns 1.\n * @name isSafeJSONString\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} s JSON string\n * @return {Number} 1 or 0\n */\nKJUR.jws.JWS.isSafeJSONString = function(s, h, p) {\n    var o = null;\n    try {\n\to = jsonParse(s);\n\tif (typeof o != \"object\") return 0;\n\tif (o.constructor === Array) return 0;\n\tif (h) h[p] = o;\n\treturn 1;\n    } catch (ex) {\n\treturn 0;\n    }\n};\n\n/**\n * read a String \"s\" as JSON object if it is safe.<br/>\n * If a String \"s\" is a malformed JSON string or not JSON string,\n * this returns null, otherwise returns JSON object.\n * @name readSafeJSONString\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} s JSON string\n * @return {Object} JSON object or null\n * @since 1.1.1\n */\nKJUR.jws.JWS.readSafeJSONString = function(s) {\n    var o = null;\n    try {\n\to = jsonParse(s);\n\tif (typeof o != \"object\") return null;\n\tif (o.constructor === Array) return null;\n\treturn o;\n    } catch (ex) {\n\treturn null;\n    }\n};\n\n/**\n * get Encoed Signature Value from JWS string.<br/>\n * @name getEncodedSignatureValueFromJWS\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {String} sJWS JWS signature string to be verified\n * @return {String} string of Encoded Signature Value \n * @throws if sJWS is not comma separated string such like \"Header.Payload.Signature\".\n */\nKJUR.jws.JWS.getEncodedSignatureValueFromJWS = function(sJWS) {\n    var matchResult = sJWS.match(/^[^.]+\\.[^.]+\\.([^.]+)$/);\n    if (matchResult == null) {\n\tthrow \"JWS signature is not a form of 'Head.Payload.SigValue'.\";\n    }\n    return matchResult[1];\n};\n\n/**\n * get RFC 7638 JWK thumbprint from JWK object\n * @name getJWKthumbprint\n * @memberOf KJUR.jws.JWS\n * @function\n * @static\n * @param {Object} o JWK object to be calculated thumbprint\n * @return {String} Base64 URL encoded JWK thumbprint value\n * @since jsrsasign 5.0.2 jws 3.3.2\n * @description\n * This method calculates JWK thmubprint for specified JWK object\n * as described in \n * <a href=\"https://tools.ietf.org/html/rfc7638\">RFC 7638</a>.\n * It supports all type of \"kty\". (i.e. \"RSA\", \"EC\" and \"oct\"\n * (for symmetric key))\n * Working sample is \n * <a href=\"https://kjur.github.io/jsrsasign/sample/tool_jwktp.html\">here</a>.\n * @example\n * jwk = {\"kty\":\"RSA\", \"n\":\"0vx...\", \"e\":\"AQAB\", ...};\n * thumbprint = KJUR.jws.JWS.getJWKthumbprint(jwk);\n */\nKJUR.jws.JWS.getJWKthumbprint = function(o) {\n    if (o.kty !== \"RSA\" &&\n\to.kty !== \"EC\" &&\n\to.kty !== \"oct\")\n\tthrow \"unsupported algorithm for JWK Thumprint\";\n\n    // 1. get canonically ordered json string\n    var s = '{';\n    if (o.kty === \"RSA\") {\n\tif (typeof o.n != \"string\" || typeof o.e != \"string\")\n\t    throw \"wrong n and e value for RSA key\";\n\ts += '\"' + 'e' + '\":\"' + o.e + '\",';\n\ts += '\"' + 'kty' + '\":\"' + o.kty + '\",';\n\ts += '\"' + 'n' + '\":\"' + o.n + '\"}';\n    } else if (o.kty === \"EC\") {\n\tif (typeof o.crv != \"string\" || \n\t    typeof o.x != \"string\" ||\n\t    typeof o.y != \"string\")\n\t    throw \"wrong crv, x and y value for EC key\";\n\ts += '\"' + 'crv' + '\":\"' + o.crv + '\",';\n\ts += '\"' + 'kty' + '\":\"' + o.kty + '\",';\n\ts += '\"' + 'x' + '\":\"' + o.x + '\",';\n\ts += '\"' + 'y' + '\":\"' + o.y + '\"}';\n    } else if (o.kty === \"oct\") {\n\tif (typeof o.k != \"string\")\n\t    throw \"wrong k value for oct(symmetric) key\";\n\ts += '\"' + 'kty' + '\":\"' + o.kty + '\",';\n\ts += '\"' + 'k' + '\":\"' + o.k + '\"}';\n    }\n    //alert(s);\n\n    // 2. get thumb print\n    var hJWK = rstrtohex(s);\n    var hash = KJUR.crypto.Util.hashHex(hJWK, \"sha256\");\n    var hashB64U = hextob64u(hash);\n\n    return hashB64U;\n};\n\n/**\n * IntDate class for time representation for JSON Web Token(JWT)\n * @class KJUR.jws.IntDate class\n * @name KJUR.jws.IntDate\n * @since jws 3.0.1\n * @description\n * Utility class for IntDate which is integer representation of UNIX origin time\n * used in JSON Web Token(JWT).\n */\nKJUR.jws.IntDate = {};\n\n/**\n * get UNIX origin time from by string\n * @name get\n * @memberOf KJUR.jws.IntDate\n * @function\n * @static\n * @param {String} s string of time representation\n * @return {Integer} UNIX origin time in seconds for argument 's'\n * @since jws 3.0.1\n * @throws \"unsupported format: s\" when malformed format\n * @description\n * This method will accept following representation of time.\n * <ul>\n * <li>now - current time</li>\n * <li>now + 1hour - after 1 hour from now</li>\n * <li>now + 1day - after 1 day from now</li>\n * <li>now + 1month - after 30 days from now</li>\n * <li>now + 1year - after 365 days from now</li>\n * <li>YYYYmmDDHHMMSSZ - UTC time (ex. 20130828235959Z)</li>\n * <li>number - UNIX origin time (seconds from 1970-01-01 00:00:00) (ex. 1377714748)</li>\n * </ul>\n */\nKJUR.jws.IntDate.get = function(s) {\n    if (s == \"now\") {\n\treturn KJUR.jws.IntDate.getNow();\n    } else if (s == \"now + 1hour\") {\n\treturn KJUR.jws.IntDate.getNow() + 60 * 60;\n    } else if (s == \"now + 1day\") {\n\treturn KJUR.jws.IntDate.getNow() + 60 * 60 * 24;\n    } else if (s == \"now + 1month\") {\n\treturn KJUR.jws.IntDate.getNow() + 60 * 60 * 24 * 30;\n    } else if (s == \"now + 1year\") {\n\treturn KJUR.jws.IntDate.getNow() + 60 * 60 * 24 * 365;\n    } else if (s.match(/Z$/)) {\n\treturn KJUR.jws.IntDate.getZulu(s);\n    } else if (s.match(/^[0-9]+$/)) {\n\treturn parseInt(s);\n    }\n    throw \"unsupported format: \" + s;\n};\n\n/**\n * get UNIX origin time from Zulu time representation string\n * @name getZulu\n * @memberOf KJUR.jws.IntDate\n * @function\n * @static\n * @param {String} s string of Zulu time representation (ex. 20151012125959Z)\n * @return {Integer} UNIX origin time in seconds for argument 's'\n * @since jws 3.0.1\n * @throws \"unsupported format: s\" when malformed format\n * @description\n * This method provides UNIX origin time from Zulu time.\n * Following representations are supported:\n * <ul>\n * <li>YYYYMMDDHHmmSSZ - GeneralizedTime format</li>\n * <li>YYMMDDHHmmSSZ - UTCTime format. If YY is greater or equal to \n * 50 then it represents 19YY otherwise 20YY.</li>\n * </ul>\n * @example\n * KJUR.jws.IntDate.getZulu(\"20151012125959Z\") => 1478...\n * KJUR.jws.IntDate.getZulu(\"151012125959Z\") => 1478...\n */\nKJUR.jws.IntDate.getZulu = function(s) {\n    var matchResult = s.match(/(\\d+)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)Z/);\n    if (matchResult) {\n        var sYear = matchResult[1];\n\tvar year = parseInt(sYear);\n\tif (sYear.length == 4) {\n        } else if (sYear.length == 2) {\n\t    if (50 <= year && year < 100) {\n\t\tyear = 1900 + year;\n\t    } else if (0 <= year && year < 50) {\n\t\tyear = 2000 + year;\n\t    } else {\n\t\tthrow \"malformed year string for UTCTime\";\n\t    }\n\t} else {\n\t    throw \"malformed year string\";\n\t}\n\tvar month = parseInt(matchResult[2]) - 1;\n\tvar day = parseInt(matchResult[3]);\n\tvar hour = parseInt(matchResult[4]);\n\tvar min = parseInt(matchResult[5]);\n\tvar sec = parseInt(matchResult[6]);\n\tvar d = new Date(Date.UTC(year, month, day, hour, min, sec));\n\treturn ~~(d / 1000);\n    }\n    throw \"unsupported format: \" + s;\n};\n\n/**\n * get UNIX origin time of current time\n * @name getNow\n * @memberOf KJUR.jws.IntDate\n * @function\n * @static\n * @return {Integer} UNIX origin time for current time\n * @since jws 3.0.1\n * @description\n * This method provides UNIX origin time for current time\n * @example\n * KJUR.jws.IntDate.getNow() => 1478...\n */\nKJUR.jws.IntDate.getNow = function() {\n    var d = ~~(new Date() / 1000);\n    return d;\n};\n\n/**\n * get UTC time string from UNIX origin time value\n * @name intDate2UTCString\n * @memberOf KJUR.jws.IntDate\n * @function\n * @static\n * @param {Integer} intDate UNIX origin time value (ex. 1478...)\n * @return {String} UTC time string\n * @since jws 3.0.1\n * @description\n * This method provides UTC time string for UNIX origin time value.\n * @example\n * KJUR.jws.IntDate.intDate2UTCString(1478...) => \"2015 Oct ...\"\n */\nKJUR.jws.IntDate.intDate2UTCString = function(intDate) {\n    var d = new Date(intDate * 1000);\n    return d.toUTCString();\n};\n\n/**\n * get UTC time string from UNIX origin time value\n * @name intDate2Zulu\n * @memberOf KJUR.jws.IntDate\n * @function\n * @static\n * @param {Integer} intDate UNIX origin time value (ex. 1478...)\n * @return {String} Zulu time string\n * @since jws 3.0.1\n * @description\n * This method provides Zulu time string for UNIX origin time value.\n * @example\n * KJUR.jws.IntDate.intDate2UTCString(1478...) => \"20151012...Z\"\n */\nKJUR.jws.IntDate.intDate2Zulu = function(intDate) {\n    var d = new Date(intDate * 1000);\n    var year = (\"0000\" + d.getUTCFullYear()).slice(-4);    \n    var mon =  (\"00\" + (d.getUTCMonth() + 1)).slice(-2);    \n    var day =  (\"00\" + d.getUTCDate()).slice(-2);    \n    var hour = (\"00\" + d.getUTCHours()).slice(-2);    \n    var min =  (\"00\" + d.getUTCMinutes()).slice(-2);    \n    var sec =  (\"00\" + d.getUTCSeconds()).slice(-2);    \n    return year + mon + day + hour + min + sec + \"Z\";\n};\n\n\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\n// Depends on jsbn.js and rng.js\n\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = \"\";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + \"\\n\";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return \"0\" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert(\"Message too long for RSA\");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = '', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\n * @name oaep_pad\n * @param s raw string of message\n * @param n key length of RSA key\n * @param hash JavaScript function to calculate raw hash value from raw string or algorithm name (ex. \"SHA1\") \n * @param hashLen byte length of resulted hash value (ex. 20 for SHA1)\n * @return {BigInteger} BigInteger object of resulted PKCS#1 OAEP padded message\n * @description\n * This function calculates OAEP padded message from original message.<br/>\n * NOTE: Since jsrsasign 6.2.0, 'hash' argument can accept an algorithm name such as \"sha1\".\n * @example\n * oaep_pad(\"aaa\", 128) &rarr; big integer object // SHA-1 by default\n * oaep_pad(\"aaa\", 128, function(s) {...}, 20);\n * oaep_pad(\"aaa\", 128, \"sha1\");\n */\nfunction oaep_pad(s, n, hash, hashLen) {\n    var MD = KJUR.crypto.MessageDigest;\n    var Util = KJUR.crypto.Util;\n    var algName = null;\n\n    if (!hash) hash = \"sha1\";\n\n    if (typeof hash === \"string\") {\n\talgName = MD.getCanonicalAlgName(hash);\n\thashLen = MD.getHashLength(algName);\n        hash = function(s) { return hextorstr(Util.hashString(s, algName)); };\n    }\n\n    if (s.length + 2 * hashLen + 2 > n) {\n        throw \"Message too long for RSA\";\n    }\n\n    var PS = '', i;\n\n    for (i = 0; i < n - s.length - 2 * hashLen - 2; i += 1) {\n        PS += '\\x00';\n    }\n\n    var DB = hash('') + PS + '\\x01' + s;\n    var seed = new Array(hashLen);\n    new SecureRandom().nextBytes(seed);\n    \n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, hash);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1) {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// \"empty\" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  this.isPublic = true;\n  if (typeof N !== \"string\") \n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert(\"Invalid RSA public key\");\n}\n\n// Perform raw public operation on \"x\": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of \"text\" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return \"0\" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of \"text\" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash, hashLen) {\n  var m = oaep_pad(text, (this.n.bitLength() + 7) >> 3, hash, hashLen);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return \"0\" + h;\n}\n\n// Return the PKCS#1 RSA encryption of \"text\" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n\nRSAKey.prototype.type = \"RSA\";\n\n/*! CryptoJS v3.1.2 core-fix.js\n * code.google.com/p/crypto-js\n * (c) 2009-2013 by Jeff Mott. All rights reserved.\n * code.google.com/p/crypto-js/wiki/License\n * THIS IS FIX of 'core.js' to fix Hmac issue.\n * https://code.google.com/p/crypto-js/issues/detail?id=84\n * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js\n */\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: 'value',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty('init')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer's prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: 'value'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won't copy toString using the loop above\n                if (properties.hasOwnProperty('toString')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + '';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join('');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join('');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error('Malformed UTF-8 data');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm's data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm's buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append('data');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == 'string') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update('message');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize('message');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher's object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC's object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n(function (Math) {\n    // Shortcuts\n    var C = CryptoJS;\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher's object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256('message');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC's object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n}(Math));\n\n/*! keyutil-1.0.14.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * keyutil.js - key utility for PKCS#1/5/8 PEM, RSA/DSA/ECDSA key object\n *\n * Copyright (c) 2013-2016 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n/**\n * @fileOverview\n * @name keyutil-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version keyutil 1.0.14 (2016-Oct-08)\n * @since jsrsasign 4.1.4\n * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n */\n\n/**\n * @name KEYUTIL\n * @class class for RSA/ECC/DSA key utility\n * @description \n * <br/>\n * {@link KEYUTIL} class is an update of former {@link PKCS5PKEY} class.\n * So for now, {@link PKCS5PKEY} is deprecated class.\n * {@link KEYUTIL} class has following features:\n * <dl>\n * <dt><b>key loading - {@link KEYUTIL.getKey}</b>\n * <dd>\n * <ul>\n * <li>supports RSAKey and KJUR.crypto.{ECDSA,DSA} key object</li>\n * <li>supports private key and public key</li>\n * <li>supports encrypted and plain private key</li>\n * <li>supports PKCS#1, PKCS#5 and PKCS#8 key</li>\n * <li>supports public key in X.509 certificate</li>\n * <li>key represented by JSON object</li>\n * </ul>\n * NOTE1: Encrypted PKCS#8 only supports PBKDF2/HmacSHA1/3DES <br/>\n * NOTE2: Encrypted PKCS#5 supports DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC <br/>\n *\n * <dt><b>exporting key - {@link KEYUTIL.getPEM}</b>\n * <dd>\n * {@link KEYUTIL.getPEM} method supports following formats:\n * <ul>\n * <li>supports RSA/EC/DSA keys</li>\n * <li>PKCS#1 plain RSA/EC/DSA private key</li>\n * <li>PKCS#5 encrypted RSA/EC/DSA private key with DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC</li>\n * <li>PKCS#8 plain RSA/EC/DSA private key</li>\n * <li>PKCS#8 encrypted RSA/EC/DSA private key with PBKDF2_HmacSHA1_3DES</li>\n * </ul>\n *\n * <dt><b>keypair generation - {@link KEYUTIL.generateKeypair}</b>\n * <ul>\n * <li>generate key pair of {@link RSAKey} or {@link KJUR.crypto.ECDSA}.</li>\n * <li>generate private key and convert it to PKCS#5 encrypted private key.</li>\n * </ul>\n * NOTE: {@link KJUR.crypto.DSA} is not yet supported.\n * </dl>\n * \n * @example\n * // 1. loading PEM private key\n * var key = KEYUTIL.getKey(pemPKCS1PrivateKey);\n * var key = KEYUTIL.getKey(pemPKCS5EncryptedPrivateKey, \"passcode\");\n * var key = KEYUTIL.getKey(pemPKC85PlainPrivateKey);\n * var key = KEYUTIL.getKey(pemPKC85EncryptedPrivateKey, \"passcode\");\n * // 2. loading PEM public key\n * var key = KEYUTIL.getKey(pemPKCS8PublicKey);\n * var key = KEYUTIL.getKey(pemX509Certificate);\n * // 3. exporting private key\n * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS1PRV\");\n * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS5PRV\", \"passcode\"); // DES-EDE3-CBC by default\n * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS5PRV\", \"passcode\", \"DES-CBC\");\n * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS8PRV\");\n * var pem = KEYUTIL.getPEM(privateKeyObj, \"PKCS8PRV\", \"passcode\");\n * // 4. exporting public key\n * var pem = KEYUTIL.getPEM(publicKeyObj);\n */\n/*\n * DEPRECATED METHODS\n * GET PKCS8\n * KEYUTIL.getRSAKeyFromPlainPKCS8PEM\n * KEYUTIL.getRSAKeyFromPlainPKCS8Hex\n * KEYUTIL.getRSAKeyFromEncryptedPKCS8PEM\n * P8 UTIL (make internal use)\n * KEYUTIL.getPlainPKCS8HexFromEncryptedPKCS8PEM\n * GET PKCS8 PUB\n * KEYUTIL.getKeyFromPublicPKCS8PEM\n * KEYUTIL.getKeyFromPublicPKCS8Hex\n * KEYUTIL.getRSAKeyFromPublicPKCS8PEM\n * KEYUTIL.getRSAKeyFromPublicPKCS8Hex\n * GET PKCS5\n * KEYUTIL.getRSAKeyFromEncryptedPKCS5PEM\n * PUT PKCS5\n * KEYUTIL.getEncryptedPKCS5PEMFromRSAKey\n * OTHER METHODS (FOR INTERNAL?)\n * KEYUTIL.getHexFromPEM\n * KEYUTIL.getDecryptedKeyHexByKeyIV\n */\nvar KEYUTIL = function() {\n    // *****************************************************************\n    // *** PRIVATE PROPERTIES AND METHODS *******************************\n    // *****************************************************************\n    // shared key decryption ------------------------------------------\n    var decryptAES = function(dataHex, keyHex, ivHex) {\n        return decryptGeneral(CryptoJS.AES, dataHex, keyHex, ivHex);\n    };\n\n    var decrypt3DES = function(dataHex, keyHex, ivHex) {\n        return decryptGeneral(CryptoJS.TripleDES, dataHex, keyHex, ivHex);\n    };\n\n    var decryptDES = function(dataHex, keyHex, ivHex) {\n        return decryptGeneral(CryptoJS.DES, dataHex, keyHex, ivHex);\n    };\n\n    var decryptGeneral = function(f, dataHex, keyHex, ivHex) {\n        var data = CryptoJS.enc.Hex.parse(dataHex);\n        var key = CryptoJS.enc.Hex.parse(keyHex);\n        var iv = CryptoJS.enc.Hex.parse(ivHex);\n        var encrypted = {};\n        encrypted.key = key;\n        encrypted.iv = iv;\n        encrypted.ciphertext = data;\n        var decrypted = f.decrypt(encrypted, key, { iv: iv });\n        return CryptoJS.enc.Hex.stringify(decrypted);\n    };\n\n    // shared key decryption ------------------------------------------\n    var encryptAES = function(dataHex, keyHex, ivHex) {\n        return encryptGeneral(CryptoJS.AES, dataHex, keyHex, ivHex);\n    };\n\n    var encrypt3DES = function(dataHex, keyHex, ivHex) {\n        return encryptGeneral(CryptoJS.TripleDES, dataHex, keyHex, ivHex);\n    };\n\n    var encryptDES = function(dataHex, keyHex, ivHex) {\n        return encryptGeneral(CryptoJS.DES, dataHex, keyHex, ivHex);\n    };\n\n    var encryptGeneral = function(f, dataHex, keyHex, ivHex) {\n        var data = CryptoJS.enc.Hex.parse(dataHex);\n        var key = CryptoJS.enc.Hex.parse(keyHex);\n        var iv = CryptoJS.enc.Hex.parse(ivHex);\n        var encryptedHex = f.encrypt(data, key, { iv: iv });\n        var encryptedWA = CryptoJS.enc.Hex.parse(encryptedHex.toString());\n        var encryptedB64 = CryptoJS.enc.Base64.stringify(encryptedWA);\n        return encryptedB64;\n    };\n\n    // other methods and properties ----------------------------------------\n    var ALGLIST = {\n        'AES-256-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 32, ivlen: 16 },\n        'AES-192-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 24, ivlen: 16 },\n        'AES-128-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 16, ivlen: 16 },\n        'DES-EDE3-CBC': { 'proc': decrypt3DES, 'eproc': encrypt3DES, keylen: 24, ivlen: 8 },\n        'DES-CBC':      { 'proc': decryptDES,  'eproc': encryptDES,  keylen: 8,  ivlen: 8 }\n    };\n\n    var getFuncByName = function(algName) {\n        return ALGLIST[algName]['proc'];\n    };\n\n    var _generateIvSaltHex = function(numBytes) {\n        var wa = CryptoJS.lib.WordArray.random(numBytes);\n        var hex = CryptoJS.enc.Hex.stringify(wa);\n        return hex;\n    };\n\n    var _parsePKCS5PEM = function(sPKCS5PEM) {\n        var info = {};\n        var matchResult1 = sPKCS5PEM.match(new RegExp(\"DEK-Info: ([^,]+),([0-9A-Fa-f]+)\", \"m\"));\n        if (matchResult1) {\n            info.cipher = matchResult1[1];\n            info.ivsalt = matchResult1[2];\n        }\n        var matchResult2 = sPKCS5PEM.match(new RegExp(\"-----BEGIN ([A-Z]+) PRIVATE KEY-----\"));\n        if (matchResult2) {\n            info.type = matchResult2[1];\n        }\n        var i1 = -1;\n        var lenNEWLINE = 0;\n        if (sPKCS5PEM.indexOf(\"\\r\\n\\r\\n\") != -1) {\n            i1 = sPKCS5PEM.indexOf(\"\\r\\n\\r\\n\");\n            lenNEWLINE = 2;\n        }\n        if (sPKCS5PEM.indexOf(\"\\n\\n\") != -1) {\n            i1 = sPKCS5PEM.indexOf(\"\\n\\n\");\n            lenNEWLINE = 1;\n        }\n        var i2 = sPKCS5PEM.indexOf(\"-----END\");\n        if (i1 != -1 && i2 != -1) {\n            var s = sPKCS5PEM.substring(i1 + lenNEWLINE * 2, i2 - lenNEWLINE);\n            s = s.replace(/\\s+/g, '');\n            info.data = s;\n        }\n        return info;\n    };\n\n    var _getKeyAndUnusedIvByPasscodeAndIvsalt = function(algName, passcode, ivsaltHex) {\n        //alert(\"ivsaltHex(2) = \" + ivsaltHex);\n        var saltHex = ivsaltHex.substring(0, 16);\n        //alert(\"salt = \" + saltHex);\n        \n        var salt = CryptoJS.enc.Hex.parse(saltHex);\n        var data = CryptoJS.enc.Utf8.parse(passcode);\n        //alert(\"salt = \" + salt);\n        //alert(\"data = \" + data);\n\n        var nRequiredBytes = ALGLIST[algName]['keylen'] + ALGLIST[algName]['ivlen'];\n        var hHexValueJoined = '';\n        var hLastValue = null;\n        //alert(\"nRequiredBytes = \" + nRequiredBytes);\n        for (;;) {\n            var h = CryptoJS.algo.MD5.create();\n            if (hLastValue != null) {\n                h.update(hLastValue);\n            }\n            h.update(data);\n            h.update(salt);\n            hLastValue = h.finalize();\n            hHexValueJoined = hHexValueJoined + CryptoJS.enc.Hex.stringify(hLastValue);\n            //alert(\"joined = \" + hHexValueJoined);\n            if (hHexValueJoined.length >= nRequiredBytes * 2) {\n                break;\n            }\n        }\n        var result = {};\n        result.keyhex = hHexValueJoined.substr(0, ALGLIST[algName]['keylen'] * 2);\n        result.ivhex = hHexValueJoined.substr(ALGLIST[algName]['keylen'] * 2, ALGLIST[algName]['ivlen'] * 2);\n        return result;\n    };\n\n    /*\n     * @param {String} privateKeyB64 base64 string of encrypted private key\n     * @param {String} sharedKeyAlgName algorithm name of shared key encryption\n     * @param {String} sharedKeyHex hexadecimal string of shared key to encrypt\n     * @param {String} ivsaltHex hexadecimal string of IV and salt\n     * @param {String} hexadecimal string of decrypted private key\n     */\n    var _decryptKeyB64 = function(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {\n        var privateKeyWA = CryptoJS.enc.Base64.parse(privateKeyB64);\n        var privateKeyHex = CryptoJS.enc.Hex.stringify(privateKeyWA);\n        var f = ALGLIST[sharedKeyAlgName]['proc'];\n        var decryptedKeyHex = f(privateKeyHex, sharedKeyHex, ivsaltHex);\n        return decryptedKeyHex;\n    };\n    \n    /*\n     * @param {String} privateKeyHex hexadecimal string of private key\n     * @param {String} sharedKeyAlgName algorithm name of shared key encryption\n     * @param {String} sharedKeyHex hexadecimal string of shared key to encrypt\n     * @param {String} ivsaltHex hexadecimal string of IV and salt\n     * @param {String} base64 string of encrypted private key\n     */\n    var _encryptKeyHex = function(privateKeyHex, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {\n        var f = ALGLIST[sharedKeyAlgName]['eproc'];\n        var encryptedKeyB64 = f(privateKeyHex, sharedKeyHex, ivsaltHex);\n        return encryptedKeyB64;\n    };\n\n    // *****************************************************************\n    // *** PUBLIC PROPERTIES AND METHODS *******************************\n    // *****************************************************************\n    return {\n        // -- UTILITY METHODS ------------------------------------------------------------\n        /**\n         * decrypt private key by shared key\n         * @name version\n         * @memberOf KEYUTIL\n         * @property {String} version\n         * @description version string of KEYUTIL class\n         */\n        version: \"1.0.0\",\n\n        /**\n         * get hexacedimal string of PEM format\n         * @name getHexFromPEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} sPEM PEM formatted string\n         * @param {String} sHead PEM header string without BEGIN/END\n         * @return {String} hexadecimal string data of PEM contents\n         * @since pkcs5pkey 1.0.5\n         */\n        getHexFromPEM: function(sPEM, sHead) {\n            var s = sPEM;\n            if (s.indexOf(\"-----BEGIN \") == -1) {\n                throw \"can't find PEM header: \" + sHead;\n            }\n            if (typeof sHead == \"string\" && sHead != \"\") {\n                s = s.replace(\"-----BEGIN \" + sHead + \"-----\", \"\");\n                s = s.replace(\"-----END \" + sHead + \"-----\", \"\");\n            } else {\n                s = s.replace(/-----BEGIN [^-]+-----/, '');\n                s = s.replace(/-----END [^-]+-----/, '');\n            }\n            var sB64 = s.replace(/\\s+/g, '');\n            var dataHex = b64tohex(sB64);\n            return dataHex;\n        },\n\n        /**\n         * decrypt private key by shared key\n         * @name getDecryptedKeyHexByKeyIV\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} encryptedKeyHex hexadecimal string of encrypted private key\n         * @param {String} algName name of symmetric key algorithm (ex. 'DES-EBE3-CBC')\n         * @param {String} sharedKeyHex hexadecimal string of symmetric key\n         * @param {String} ivHex hexadecimal string of initial vector(IV).\n         * @return {String} hexadecimal string of decrypted privated key\n         */\n        getDecryptedKeyHexByKeyIV: function(encryptedKeyHex, algName, sharedKeyHex, ivHex) {\n            var f1 = getFuncByName(algName);\n            return f1(encryptedKeyHex, sharedKeyHex, ivHex);\n        },\n\n        /**\n         * parse PEM formatted passcode protected PKCS#5 private key\n         * @name parsePKCS5PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} sEncryptedPEM PEM formatted protected passcode protected PKCS#5 private key\n         * @return {Hash} hash of key information\n         * @description\n         * Resulted hash has following attributes.\n         * <ul>\n         * <li>cipher - symmetric key algorithm name (ex. 'DES-EBE3-CBC', 'AES-256-CBC')</li>\n         * <li>ivsalt - IV used for decrypt. Its heading 8 bytes will be used for passcode salt.</li>\n         * <li>type - asymmetric key algorithm name of private key described in PEM header.</li>\n         * <li>data - base64 encoded encrypted private key.</li>\n         * </ul>\n         *\n         */\n        parsePKCS5PEM: function(sPKCS5PEM) {\n            return _parsePKCS5PEM(sPKCS5PEM);\n        },\n\n        /**\n         * the same function as OpenSSL EVP_BytsToKey to generate shared key and IV\n         * @name getKeyAndUnusedIvByPasscodeAndIvsalt\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} algName name of symmetric key algorithm (ex. 'DES-EBE3-CBC')\n         * @param {String} passcode passcode to decrypt private key (ex. 'password')\n         * @param {String} hexadecimal string of IV. heading 8 bytes will be used for passcode salt\n         * @return {Hash} hash of key and unused IV (ex. {keyhex:2fe3..., ivhex:3fad..})\n         */\n        getKeyAndUnusedIvByPasscodeAndIvsalt: function(algName, passcode, ivsaltHex) {\n            return _getKeyAndUnusedIvByPasscodeAndIvsalt(algName, passcode, ivsaltHex);\n        },\n\n        decryptKeyB64: function(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {\n            return _decryptKeyB64(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex);\n        },\n\n        /**\n         * decrypt PEM formatted protected PKCS#5 private key with passcode\n         * @name getDecryptedKeyHex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} sEncryptedPEM PEM formatted protected passcode protected PKCS#5 private key\n         * @param {String} passcode passcode to decrypt private key (ex. 'password')\n         * @return {String} hexadecimal string of decrypted RSA priavte key\n         */\n        getDecryptedKeyHex: function(sEncryptedPEM, passcode) {\n            // 1. parse pem\n            var info = _parsePKCS5PEM(sEncryptedPEM);\n            var publicKeyAlgName = info.type;\n            var sharedKeyAlgName = info.cipher;\n            var ivsaltHex = info.ivsalt;\n            var privateKeyB64 = info.data;\n            //alert(\"ivsaltHex = \" + ivsaltHex);\n\n            // 2. generate shared key\n            var sharedKeyInfo = _getKeyAndUnusedIvByPasscodeAndIvsalt(sharedKeyAlgName, passcode, ivsaltHex);\n            var sharedKeyHex = sharedKeyInfo.keyhex;\n            //alert(\"sharedKeyHex = \" + sharedKeyHex);\n\n            // 3. decrypt private key\n            var decryptedKey = _decryptKeyB64(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex);\n            return decryptedKey;\n        },\n\n        /**\n         * (DEPRECATED) read PEM formatted encrypted PKCS#5 private key and returns RSAKey object\n         * @name getRSAKeyFromEncryptedPKCS5PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} sEncryptedP5PEM PEM formatted encrypted PKCS#5 private key\n         * @param {String} passcode passcode to decrypt private key\n         * @return {RSAKey} loaded RSAKey object of RSA private key\n         * @since pkcs5pkey 1.0.2\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         */\n        getRSAKeyFromEncryptedPKCS5PEM: function(sEncryptedP5PEM, passcode) {\n            var hPKey = this.getDecryptedKeyHex(sEncryptedP5PEM, passcode);\n            var rsaKey = new RSAKey();\n            rsaKey.readPrivateKeyFromASN1HexString(hPKey);\n            return rsaKey;\n        },\n\n        /*\n         * get PEM formatted encrypted PKCS#5 private key from hexadecimal string of plain private key\n         * @name getEncryptedPKCS5PEMFromPrvKeyHex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pemHeadAlg algorithm name in the pem header (i.e. RSA,EC or DSA)\n         * @param {String} hPrvKey hexadecimal string of plain private key\n         * @param {String} passcode pass code to protect private key (ex. password)\n         * @param {String} sharedKeyAlgName algorithm name to protect private key (ex. AES-256-CBC)\n         * @param {String} ivsaltHex hexadecimal string of IV and salt\n         * @return {String} string of PEM formatted encrypted PKCS#5 private key\n         * @since pkcs5pkey 1.0.2\n         * @description\n         * <br/>\n         * generate PEM formatted encrypted PKCS#5 private key by hexadecimal string encoded\n         * ASN.1 object of plain RSA private key.\n         * Following arguments can be omitted.\n         * <ul>\n         * <li>alg - AES-256-CBC will be used if omitted.</li>\n         * <li>ivsaltHex - automatically generate IV and salt which length depends on algorithm</li>\n         * </ul>\n         * NOTE1: DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC algorithm are supported.\n         * @example\n         * var pem = \n         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, \"password\");\n         * var pem2 = \n         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, \"password\", \"AES-128-CBC\");\n         * var pem3 = \n         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, \"password\", \"AES-128-CBC\", \"1f3d02...\");\n         */\n        getEncryptedPKCS5PEMFromPrvKeyHex: function(pemHeadAlg, hPrvKey, passcode, sharedKeyAlgName, ivsaltHex) {\n            var sPEM = \"\";\n\n            // 1. set sharedKeyAlgName if undefined (default AES-256-CBC)\n            if (typeof sharedKeyAlgName == \"undefined\" || sharedKeyAlgName == null) {\n                sharedKeyAlgName = \"AES-256-CBC\";\n            }\n            if (typeof ALGLIST[sharedKeyAlgName] == \"undefined\")\n                throw \"KEYUTIL unsupported algorithm: \" + sharedKeyAlgName;\n\n            // 2. set ivsaltHex if undefined\n            if (typeof ivsaltHex == \"undefined\" || ivsaltHex == null) {\n                var ivlen = ALGLIST[sharedKeyAlgName]['ivlen'];\n                var randIV = _generateIvSaltHex(ivlen);\n                ivsaltHex = randIV.toUpperCase();\n            }\n\n            // 3. get shared key\n            //alert(\"ivsalthex=\" + ivsaltHex);\n            var sharedKeyInfo = _getKeyAndUnusedIvByPasscodeAndIvsalt(sharedKeyAlgName, passcode, ivsaltHex);\n            var sharedKeyHex = sharedKeyInfo.keyhex;\n            // alert(\"sharedKeyHex = \" + sharedKeyHex);\n\n            // 3. get encrypted Key in Base64\n            var encryptedKeyB64 = _encryptKeyHex(hPrvKey, sharedKeyAlgName, sharedKeyHex, ivsaltHex);\n\n            var pemBody = encryptedKeyB64.replace(/(.{64})/g, \"$1\\r\\n\");\n            var sPEM = \"-----BEGIN \" + pemHeadAlg + \" PRIVATE KEY-----\\r\\n\";\n            sPEM += \"Proc-Type: 4,ENCRYPTED\\r\\n\";\n            sPEM += \"DEK-Info: \" + sharedKeyAlgName + \",\" + ivsaltHex + \"\\r\\n\";\n            sPEM += \"\\r\\n\";\n            sPEM += pemBody;\n            sPEM += \"\\r\\n-----END \" + pemHeadAlg + \" PRIVATE KEY-----\\r\\n\";\n\n            return sPEM;\n        },\n\n        /**\n         * (DEPRECATED) get PEM formatted encrypted PKCS#5 private key from RSAKey object of private key\n         * @name getEncryptedPKCS5PEMFromRSAKey\n         * @memberOf KEYUTIL\n         * @function\n         * @param {RSAKey} pKey RSAKey object of private key\n         * @param {String} passcode pass code to protect private key (ex. password)\n         * @param {String} alg algorithm name to protect private key (default AES-256-CBC)\n         * @param {String} ivsaltHex hexadecimal string of IV and salt (default generated random IV)\n         * @return {String} string of PEM formatted encrypted PKCS#5 private key\n         * @since pkcs5pkey 1.0.2\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getPEM#}.\n         * @description\n         * <br/>\n         * generate PEM formatted encrypted PKCS#5 private key by\n         * {@link RSAKey} object of RSA private key and passcode.\n         * Following argument can be omitted.\n         * <ul>\n         * <li>alg - AES-256-CBC will be used if omitted.</li>\n         * <li>ivsaltHex - automatically generate IV and salt which length depends on algorithm</li>\n         * </ul>\n         * @example\n         * var pkey = new RSAKey();\n         * pkey.generate(1024, '10001'); // generate 1024bit RSA private key with public exponent 'x010001'\n         * var pem = KEYUTIL.getEncryptedPKCS5PEMFromRSAKey(pkey, \"password\");\n         */\n        getEncryptedPKCS5PEMFromRSAKey: function(pKey, passcode, alg, ivsaltHex) {\n            var version = new KJUR.asn1.DERInteger({'int': 0});\n            var n = new KJUR.asn1.DERInteger({'bigint': pKey.n});\n            var e = new KJUR.asn1.DERInteger({'int': pKey.e});\n            var d = new KJUR.asn1.DERInteger({'bigint': pKey.d});\n            var p = new KJUR.asn1.DERInteger({'bigint': pKey.p});\n            var q = new KJUR.asn1.DERInteger({'bigint': pKey.q});\n            var dmp1 = new KJUR.asn1.DERInteger({'bigint': pKey.dmp1});\n            var dmq1 = new KJUR.asn1.DERInteger({'bigint': pKey.dmq1});\n            var coeff = new KJUR.asn1.DERInteger({'bigint': pKey.coeff});\n            var seq = new KJUR.asn1.DERSequence({'array': [version, n, e, d, p, q, dmp1, dmq1, coeff]});\n            var hex = seq.getEncodedHex();\n            return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"RSA\", hex, passcode, alg, ivsaltHex);\n        },\n\n        /**\n         * generate RSAKey and PEM formatted encrypted PKCS#5 private key\n         * @name newEncryptedPKCS5PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} passcode pass code to protect private key (ex. password)\n         * @param {Integer} keyLen key bit length of RSA key to be generated. (default 1024)\n         * @param {String} hPublicExponent hexadecimal string of public exponent (default 10001)\n         * @param {String} alg shared key algorithm to encrypt private key (default AES-258-CBC)\n         * @return {String} string of PEM formatted encrypted PKCS#5 private key\n         * @since pkcs5pkey 1.0.2\n         * @example\n         * var pem1 = KEYUTIL.newEncryptedPKCS5PEM(\"password\");           // RSA1024bit/10001/AES-256-CBC\n         * var pem2 = KEYUTIL.newEncryptedPKCS5PEM(\"password\", 512);      // RSA 512bit/10001/AES-256-CBC\n         * var pem3 = KEYUTIL.newEncryptedPKCS5PEM(\"password\", 512, '3'); // RSA 512bit/    3/AES-256-CBC\n         */\n        newEncryptedPKCS5PEM: function(passcode, keyLen, hPublicExponent, alg) {\n            if (typeof keyLen == \"undefined\" || keyLen == null) {\n                keyLen = 1024;\n            }\n            if (typeof hPublicExponent == \"undefined\" || hPublicExponent == null) {\n                hPublicExponent = '10001';\n            }\n            var pKey = new RSAKey();\n            pKey.generate(keyLen, hPublicExponent);\n            var pem = null;\n            if (typeof alg == \"undefined\" || alg == null) {\n                pem = this.getEncryptedPKCS5PEMFromRSAKey(pKey, passcode);\n            } else {\n                pem = this.getEncryptedPKCS5PEMFromRSAKey(pKey, passcode, alg);\n            }\n            return pem;\n        },\n\n        // === PKCS8 ===============================================================\n\n        /**\n         * (DEPRECATED) read PEM formatted unencrypted PKCS#8 private key and returns RSAKey object\n         * @name getRSAKeyFromPlainPKCS8PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PEM PEM formatted unencrypted PKCS#8 private key\n         * @return {RSAKey} loaded RSAKey object of RSA private key\n         * @since pkcs5pkey 1.0.1\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         */\n        getRSAKeyFromPlainPKCS8PEM: function(pkcs8PEM) {\n            if (pkcs8PEM.match(/ENCRYPTED/))\n                throw \"pem shall be not ENCRYPTED\";\n            var prvKeyHex = this.getHexFromPEM(pkcs8PEM, \"PRIVATE KEY\");\n            var rsaKey = this.getRSAKeyFromPlainPKCS8Hex(prvKeyHex);\n            return rsaKey;\n        },\n\n        /**\n         * (DEPRECATED) provide hexadecimal string of unencrypted PKCS#8 private key and returns RSAKey object\n         * @name getRSAKeyFromPlainPKCS8Hex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} prvKeyHex hexadecimal string of unencrypted PKCS#8 private key\n         * @return {RSAKey} loaded RSAKey object of RSA private key\n         * @since pkcs5pkey 1.0.3\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         */\n        getRSAKeyFromPlainPKCS8Hex: function(prvKeyHex) {\n            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(prvKeyHex, 0);\n            if (a1.length != 3)\n                throw \"outer DERSequence shall have 3 elements: \" + a1.length;\n            var algIdTLV =ASN1HEX.getHexOfTLV_AtObj(prvKeyHex, a1[1]);\n            if (algIdTLV != \"300d06092a864886f70d0101010500\") // AlgId rsaEncryption\n                throw \"PKCS8 AlgorithmIdentifier is not rsaEnc: \" + algIdTLV;\n            var algIdTLV = ASN1HEX.getHexOfTLV_AtObj(prvKeyHex, a1[1]);\n            var octetStr = ASN1HEX.getHexOfTLV_AtObj(prvKeyHex, a1[2]);\n            var p5KeyHex = ASN1HEX.getHexOfV_AtObj(octetStr, 0);\n            //alert(p5KeyHex);\n            var rsaKey = new RSAKey();\n            rsaKey.readPrivateKeyFromASN1HexString(p5KeyHex);\n            return rsaKey;\n        },\n\n        /**\n         * generate PBKDF2 key hexstring with specified passcode and information\n         * @name parseHexOfEncryptedPKCS8\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} passcode passcode to decrypto private key\n         * @return {Array} info associative array of PKCS#8 parameters\n         * @since pkcs5pkey 1.0.3\n         * @description\n         * The associative array which is returned by this method has following properties:\n         * <ul>\n         * <li>info.pbkdf2Salt - hexadecimal string of PBKDF2 salt</li>\n         * <li>info.pkbdf2Iter - iteration count</li>\n         * <li>info.ciphertext - hexadecimal string of encrypted private key</li>\n         * <li>info.encryptionSchemeAlg - encryption algorithm name (currently TripleDES only)</li>\n         * <li>info.encryptionSchemeIV - initial vector for encryption algorithm</li>\n         * </ul>\n         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n         * <ul>\n         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n         * </ul>\n         * @example\n         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n         * // key with PBKDF2 with TripleDES\n         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n         */\n        parseHexOfEncryptedPKCS8: function(sHEX) {\n            var info = {};\n            \n            var a0 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, 0);\n            if (a0.length != 2)\n                throw \"malformed format: SEQUENCE(0).items != 2: \" + a0.length;\n\n            // 1. ciphertext\n            info.ciphertext = ASN1HEX.getHexOfV_AtObj(sHEX, a0[1]);\n\n            // 2. pkcs5PBES2\n            var a0_0 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0[0]); \n            if (a0_0.length != 2)\n                throw \"malformed format: SEQUENCE(0.0).items != 2: \" + a0_0.length;\n\n            // 2.1 check if pkcs5PBES2(1 2 840 113549 1 5 13)\n            if (ASN1HEX.getHexOfV_AtObj(sHEX, a0_0[0]) != \"2a864886f70d01050d\")\n                throw \"this only supports pkcs5PBES2\";\n\n            // 2.2 pkcs5PBES2 param\n            var a0_0_1 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0[1]); \n            if (a0_0.length != 2)\n                throw \"malformed format: SEQUENCE(0.0.1).items != 2: \" + a0_0_1.length;\n\n            // 2.2.1 encryptionScheme\n            var a0_0_1_1 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0_1[1]); \n            if (a0_0_1_1.length != 2)\n                throw \"malformed format: SEQUENCE(0.0.1.1).items != 2: \" + a0_0_1_1.length;\n            if (ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_1[0]) != \"2a864886f70d0307\")\n                throw \"this only supports TripleDES\";\n            info.encryptionSchemeAlg = \"TripleDES\";\n\n            // 2.2.1.1 IV of encryptionScheme\n            info.encryptionSchemeIV = ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_1[1]);\n\n            // 2.2.2 keyDerivationFunc\n            var a0_0_1_0 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0_1[0]); \n            if (a0_0_1_0.length != 2)\n                throw \"malformed format: SEQUENCE(0.0.1.0).items != 2: \" + a0_0_1_0.length;\n            if (ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_0[0]) != \"2a864886f70d01050c\")\n                throw \"this only supports pkcs5PBKDF2\";\n\n            // 2.2.2.1 pkcs5PBKDF2 param\n            var a0_0_1_0_1 = ASN1HEX.getPosArrayOfChildren_AtObj(sHEX, a0_0_1_0[1]); \n            if (a0_0_1_0_1.length < 2)\n                throw \"malformed format: SEQUENCE(0.0.1.0.1).items < 2: \" + a0_0_1_0_1.length;\n\n            // 2.2.2.1.1 PBKDF2 salt\n            info.pbkdf2Salt = ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_0_1[0]);\n\n            // 2.2.2.1.2 PBKDF2 iter\n            var iterNumHex = ASN1HEX.getHexOfV_AtObj(sHEX, a0_0_1_0_1[1]);\n            try {\n                info.pbkdf2Iter = parseInt(iterNumHex, 16);\n            } catch(ex) {\n                throw \"malformed format pbkdf2Iter: \" + iterNumHex;\n            }\n\n            return info;\n        },\n\n        /**\n         * generate PBKDF2 key hexstring with specified passcode and information\n         * @name getPBKDF2KeyHexFromParam\n         * @memberOf KEYUTIL\n         * @function\n         * @param {Array} info result of {@link parseHexOfEncryptedPKCS8} which has preference of PKCS#8 file\n         * @param {String} passcode passcode to decrypto private key\n         * @return {String} hexadecimal string of PBKDF2 key\n         * @since pkcs5pkey 1.0.3\n         * @description\n         * As for info, this uses following properties:\n         * <ul>\n         * <li>info.pbkdf2Salt - hexadecimal string of PBKDF2 salt</li>\n         * <li>info.pkbdf2Iter - iteration count</li>\n         * </ul>\n         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n         * <ul>\n         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n         * </ul>\n         * @example\n         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n         * // key with PBKDF2 with TripleDES\n         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n         */\n        getPBKDF2KeyHexFromParam: function(info, passcode) {\n            var pbkdf2SaltWS = CryptoJS.enc.Hex.parse(info.pbkdf2Salt);\n            var pbkdf2Iter = info.pbkdf2Iter;\n            var pbkdf2KeyWS = CryptoJS.PBKDF2(passcode, \n                                              pbkdf2SaltWS, \n                                              { keySize: 192/32, iterations: pbkdf2Iter });\n            var pbkdf2KeyHex = CryptoJS.enc.Hex.stringify(pbkdf2KeyWS);\n            return pbkdf2KeyHex;\n        },\n\n        /**\n         * read PEM formatted encrypted PKCS#8 private key and returns hexadecimal string of plain PKCS#8 private key\n         * @name getPlainPKCS8HexFromEncryptedPKCS8PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PEM PEM formatted encrypted PKCS#8 private key\n         * @param {String} passcode passcode to decrypto private key\n         * @return {String} hexadecimal string of plain PKCS#8 private key\n         * @since pkcs5pkey 1.0.3\n         * @description\n         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n         * <ul>\n         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n         * </ul>\n         * @example\n         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n         * // key with PBKDF2 with TripleDES\n         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n         */\n        getPlainPKCS8HexFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {\n            // 1. derHex - PKCS#8 private key encrypted by PBKDF2\n            var derHex = this.getHexFromPEM(pkcs8PEM, \"ENCRYPTED PRIVATE KEY\");\n            // 2. info - PKCS#5 PBES info\n            var info = this.parseHexOfEncryptedPKCS8(derHex);\n            // 3. hKey - PBKDF2 key\n            var pbkdf2KeyHex = KEYUTIL.getPBKDF2KeyHexFromParam(info, passcode);\n            // 4. decrypt ciphertext by PBKDF2 key\n            var encrypted = {};\n            encrypted.ciphertext = CryptoJS.enc.Hex.parse(info.ciphertext);\n            var pbkdf2KeyWS = CryptoJS.enc.Hex.parse(pbkdf2KeyHex);\n            var des3IVWS = CryptoJS.enc.Hex.parse(info.encryptionSchemeIV);\n            var decWS = CryptoJS.TripleDES.decrypt(encrypted, pbkdf2KeyWS, { iv: des3IVWS });\n            var decHex = CryptoJS.enc.Hex.stringify(decWS);\n            return decHex;\n        },\n\n        /**\n         * (DEPRECATED) read PEM formatted encrypted PKCS#8 private key and returns RSAKey object\n         * @name getRSAKeyFromEncryptedPKCS8PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PEM PEM formatted encrypted PKCS#8 private key\n         * @param {String} passcode passcode to decrypto private key\n         * @return {RSAKey} loaded RSAKey object of RSA private key\n         * @since pkcs5pkey 1.0.3\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         * @description\n         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.\n         * <ul>\n         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>\n         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>\n         * </ul>\n         * @example\n         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private\n         * // key with PBKDF2 with TripleDES\n         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem\n         */\n        getRSAKeyFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {\n            var prvKeyHex = this.getPlainPKCS8HexFromEncryptedPKCS8PEM(pkcs8PEM, passcode);\n            var rsaKey = this.getRSAKeyFromPlainPKCS8Hex(prvKeyHex);\n            return rsaKey;\n        },\n\n        /**\n         * get RSAKey/ECDSA private key object from encrypted PEM PKCS#8 private key\n         * @name getKeyFromEncryptedPKCS8PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PEM string of PEM formatted PKCS#8 private key\n         * @param {String} passcode passcode string to decrypt key\n         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n         * @since pkcs5pkey 1.0.5\n         */\n        getKeyFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {\n            var prvKeyHex = this.getPlainPKCS8HexFromEncryptedPKCS8PEM(pkcs8PEM, passcode);\n            var key = this.getKeyFromPlainPrivatePKCS8Hex(prvKeyHex);\n            return key;\n        },\n\n        /**\n         * parse hexadecimal string of plain PKCS#8 private key\n         * @name parsePlainPrivatePKCS8Hex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PrvHex hexadecimal string of PKCS#8 plain private key\n         * @return {Array} associative array of parsed key\n         * @since pkcs5pkey 1.0.5\n         * @description\n         * Resulted associative array has following properties:\n         * <ul>\n         * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>\n         * <li>algparam - hexadecimal string of OID of ECC curve name or null</li>\n         * <li>keyidx - string starting index of key in pkcs8PrvHex</li>\n         * </ul>\n         */\n        parsePlainPrivatePKCS8Hex: function(pkcs8PrvHex) {\n            var result = {};\n            result.algparam = null;\n\n            // 1. sequence\n            if (pkcs8PrvHex.substr(0, 2) != \"30\")\n                throw \"malformed plain PKCS8 private key(code:001)\"; // not sequence\n\n            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PrvHex, 0);\n            if (a1.length != 3)\n                throw \"malformed plain PKCS8 private key(code:002)\";\n\n            // 2. AlgID\n            if (pkcs8PrvHex.substr(a1[1], 2) != \"30\")\n                throw \"malformed PKCS8 private key(code:003)\"; // AlgId not sequence\n\n            var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PrvHex, a1[1]);\n            if (a2.length != 2)\n                throw \"malformed PKCS8 private key(code:004)\"; // AlgId not have two elements\n\n            // 2.1. AlgID OID\n            if (pkcs8PrvHex.substr(a2[0], 2) != \"06\")\n                throw \"malformed PKCS8 private key(code:005)\"; // AlgId.oid is not OID\n\n            result.algoid = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a2[0]);\n\n            // 2.2. AlgID param\n            if (pkcs8PrvHex.substr(a2[1], 2) == \"06\") {\n                result.algparam = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a2[1]);\n            }\n\n            // 3. Key index\n            if (pkcs8PrvHex.substr(a1[2], 2) != \"04\")\n                throw \"malformed PKCS8 private key(code:006)\"; // not octet string\n\n            result.keyidx = ASN1HEX.getStartPosOfV_AtObj(pkcs8PrvHex, a1[2]);\n\n            return result;\n        },\n\n        /**\n         * get RSAKey/ECDSA private key object from PEM plain PEM PKCS#8 private key\n         * @name getKeyFromPlainPrivatePKCS8PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PEM string of plain PEM formatted PKCS#8 private key\n         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n         * @since pkcs5pkey 1.0.5\n         */\n        getKeyFromPlainPrivatePKCS8PEM: function(prvKeyPEM) {\n            var prvKeyHex = this.getHexFromPEM(prvKeyPEM, \"PRIVATE KEY\");\n            var key = this.getKeyFromPlainPrivatePKCS8Hex(prvKeyHex);\n            return key;\n        },\n\n        /**\n         * get RSAKey/ECDSA private key object from HEX plain PEM PKCS#8 private key\n         * @name getKeyFromPlainPrivatePKCS8Hex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} prvKeyHex hexadecimal string of plain PKCS#8 private key\n         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n         * @since pkcs5pkey 1.0.5\n         */\n        getKeyFromPlainPrivatePKCS8Hex: function(prvKeyHex) {\n            var p8 = this.parsePlainPrivatePKCS8Hex(prvKeyHex);\n            \n            if (p8.algoid == \"2a864886f70d010101\") { // RSA\n                this.parsePrivateRawRSAKeyHexAtObj(prvKeyHex, p8);\n                var k = p8.key;\n                var key = new RSAKey();\n                key.setPrivateEx(k.n, k.e, k.d, k.p, k.q, k.dp, k.dq, k.co);\n                return key;\n            } else if (p8.algoid == \"2a8648ce3d0201\") { // ECC\n                this.parsePrivateRawECKeyHexAtObj(prvKeyHex, p8);\n                if (KJUR.crypto.OID.oidhex2name[p8.algparam] === undefined)\n                    throw \"KJUR.crypto.OID.oidhex2name undefined: \" + p8.algparam;\n                var curveName = KJUR.crypto.OID.oidhex2name[p8.algparam];\n                var key = new KJUR.crypto.ECDSA({'curve': curveName});\n                key.setPublicKeyHex(p8.pubkey);\n                key.setPrivateKeyHex(p8.key);\n                key.isPublic = false;\n                return key;\n            } else if (p8.algoid == \"2a8648ce380401\") { // DSA\n                var hP = ASN1HEX.getVbyList(prvKeyHex, 0, [1,1,0], \"02\");\n                var hQ = ASN1HEX.getVbyList(prvKeyHex, 0, [1,1,1], \"02\");\n                var hG = ASN1HEX.getVbyList(prvKeyHex, 0, [1,1,2], \"02\");\n                var hX = ASN1HEX.getVbyList(prvKeyHex, 0, [2,0], \"02\");\n                var biP = new BigInteger(hP, 16);\n                var biQ = new BigInteger(hQ, 16);\n                var biG = new BigInteger(hG, 16);\n                var biX = new BigInteger(hX, 16);\n                var key = new KJUR.crypto.DSA();\n                key.setPrivate(biP, biQ, biG, null, biX);\n                return key;\n            } else {\n                throw \"unsupported private key algorithm\";\n            }\n        },\n\n        // === PKCS8 RSA Public Key ================================================\n        /**\n         * (DEPRECATED) read PEM formatted PKCS#8 public key and returns RSAKey object\n         * @name getRSAKeyFromPublicPKCS8PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PubPEM PEM formatted PKCS#8 public key\n         * @return {RSAKey} loaded RSAKey object of RSA public key\n         * @since pkcs5pkey 1.0.4\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         */\n        getRSAKeyFromPublicPKCS8PEM: function(pkcs8PubPEM) {\n            var pubKeyHex = this.getHexFromPEM(pkcs8PubPEM, \"PUBLIC KEY\");\n            var rsaKey = this.getRSAKeyFromPublicPKCS8Hex(pubKeyHex);\n            return rsaKey;\n        },\n\n        /**\n         * (DEPRECATED) get RSAKey/ECDSA public key object from PEM PKCS#8 public key\n         * @name getKeyFromPublicPKCS8PEM\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcsPub8PEM string of PEM formatted PKCS#8 public key\n         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object\n         * @since pkcs5pkey 1.0.5\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         */\n        getKeyFromPublicPKCS8PEM: function(pkcs8PubPEM) {\n            var pubKeyHex = this.getHexFromPEM(pkcs8PubPEM, \"PUBLIC KEY\");\n            var key = this.getKeyFromPublicPKCS8Hex(pubKeyHex);\n            return key;\n        },\n\n        /**\n         * (DEPRECATED) get RSAKey/DSA/ECDSA public key object from hexadecimal string of PKCS#8 public key\n         * @name getKeyFromPublicPKCS8Hex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcsPub8Hex hexadecimal string of PKCS#8 public key\n         * @return {Object} RSAKey or KJUR.crypto.{ECDSA,DSA} private key object\n         * @since pkcs5pkey 1.0.5\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         */\n        getKeyFromPublicPKCS8Hex: function(pkcs8PubHex) {\n            var p8 = this.parsePublicPKCS8Hex(pkcs8PubHex);\n            \n            if (p8.algoid == \"2a864886f70d010101\") { // RSA\n                var aRSA = this.parsePublicRawRSAKeyHex(p8.key);\n                var key = new RSAKey();\n                key.setPublic(aRSA.n, aRSA.e);\n                return key;\n            } else if (p8.algoid == \"2a8648ce3d0201\") { // ECC\n                if (KJUR.crypto.OID.oidhex2name[p8.algparam] === undefined)\n                    throw \"KJUR.crypto.OID.oidhex2name undefined: \" + p8.algparam;\n                var curveName = KJUR.crypto.OID.oidhex2name[p8.algparam];\n                var key = new KJUR.crypto.ECDSA({'curve': curveName, 'pub': p8.key});\n                return key;\n            } else if (p8.algoid == \"2a8648ce380401\") { // DSA 1.2.840.10040.4.1\n                var param = p8.algparam;\n                var y = ASN1HEX.getHexOfV_AtObj(p8.key, 0);\n                var key = new KJUR.crypto.DSA();\n                key.setPublic(new BigInteger(param.p, 16),\n                              new BigInteger(param.q, 16),\n                              new BigInteger(param.g, 16),\n                              new BigInteger(y, 16));\n                return key;\n            } else {\n                throw \"unsupported public key algorithm\";\n            }\n        },\n\n        /**\n         * parse hexadecimal string of plain PKCS#8 private key\n         * @name parsePublicRawRSAKeyHex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pubRawRSAHex hexadecimal string of ASN.1 encoded PKCS#8 public key\n         * @return {Array} associative array of parsed key\n         * @since pkcs5pkey 1.0.5\n         * @description\n         * Resulted associative array has following properties:\n         * <ul>\n         * <li>n - hexadecimal string of public key\n         * <li>e - hexadecimal string of public exponent\n         * </ul>\n         */\n        parsePublicRawRSAKeyHex: function(pubRawRSAHex) {\n            var result = {};\n            \n            // 1. Sequence\n            if (pubRawRSAHex.substr(0, 2) != \"30\")\n                throw \"malformed RSA key(code:001)\"; // not sequence\n            \n            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pubRawRSAHex, 0);\n            if (a1.length != 2)\n                throw \"malformed RSA key(code:002)\"; // not 2 items in seq\n\n            // 2. public key \"N\"\n            if (pubRawRSAHex.substr(a1[0], 2) != \"02\")\n                throw \"malformed RSA key(code:003)\"; // 1st item is not integer\n\n            result.n = ASN1HEX.getHexOfV_AtObj(pubRawRSAHex, a1[0]);\n\n            // 3. public key \"E\"\n            if (pubRawRSAHex.substr(a1[1], 2) != \"02\")\n                throw \"malformed RSA key(code:004)\"; // 2nd item is not integer\n\n            result.e = ASN1HEX.getHexOfV_AtObj(pubRawRSAHex, a1[1]);\n\n            return result;\n        },\n\n        /**\n         * parse hexadecimal string of RSA private key\n         * @name parsePrivateRawRSAKeyHexAtObj\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PrvHex hexadecimal string of PKCS#8 private key concluding RSA private key\n         * @return {Array} info associative array to add parsed RSA private key information\n         * @since pkcs5pkey 1.0.5\n         * @description\n         * Following properties are added to associative array 'info'\n         * <ul>\n         * <li>n - hexadecimal string of public key\n         * <li>e - hexadecimal string of public exponent\n         * <li>d - hexadecimal string of private key\n         * <li>p - hexadecimal string\n         * <li>q - hexadecimal string\n         * <li>dp - hexadecimal string\n         * <li>dq - hexadecimal string\n         * <li>co - hexadecimal string\n         * </ul>\n         */\n        parsePrivateRawRSAKeyHexAtObj: function(pkcs8PrvHex, info) {\n            var keyIdx = info.keyidx;\n            \n            // 1. sequence\n            if (pkcs8PrvHex.substr(keyIdx, 2) != \"30\")\n                throw \"malformed RSA private key(code:001)\"; // not sequence\n\n            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PrvHex, keyIdx);\n            if (a1.length != 9)\n                throw \"malformed RSA private key(code:002)\"; // not sequence\n\n            // 2. RSA key\n            info.key = {};\n            info.key.n = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[1]);\n            info.key.e = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[2]);\n            info.key.d = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[3]);\n            info.key.p = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[4]);\n            info.key.q = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[5]);\n            info.key.dp = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[6]);\n            info.key.dq = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[7]);\n            info.key.co = ASN1HEX.getHexOfV_AtObj(pkcs8PrvHex, a1[8]);\n        },\n\n        /**\n         * parse hexadecimal string of ECC private key\n         * @name parsePrivateRawECKeyHexAtObj\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PrvHex hexadecimal string of PKCS#8 private key concluding EC private key\n         * @return {Array} info associative array to add parsed ECC private key information\n         * @since pkcs5pkey 1.0.5\n         * @description\n         * Following properties are added to associative array 'info'\n         * <ul>\n         * <li>key - hexadecimal string of ECC private key\n         * </ul>\n         */\n        parsePrivateRawECKeyHexAtObj: function(pkcs8PrvHex, info) {\n            var keyIdx = info.keyidx;\n            \n            var key = ASN1HEX.getVbyList(pkcs8PrvHex, keyIdx, [1], \"04\");\n            var pubkey = ASN1HEX.getVbyList(pkcs8PrvHex, keyIdx, [2,0], \"03\").substr(2);\n\n            info.key = key;\n            info.pubkey = pubkey;\n        },\n\n        /**\n         * parse hexadecimal string of PKCS#8 RSA/EC/DSA public key\n         * @name parsePublicPKCS8Hex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PubHex hexadecimal string of PKCS#8 public key\n         * @return {Hash} hash of key information\n         * @description\n         * Resulted hash has following attributes.\n         * <ul>\n         * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>\n         * <li>algparam - hexadecimal string of OID of ECC curve name, parameter SEQUENCE of DSA or null</li>\n         * <li>key - hexadecimal string of public key</li>\n         * </ul>\n         */\n        parsePublicPKCS8Hex: function(pkcs8PubHex) {\n            var result = {};\n            result.algparam = null;\n\n            // 1. AlgID and Key bit string\n            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, 0);\n            if (a1.length != 2)\n                throw \"outer DERSequence shall have 2 elements: \" + a1.length;\n\n            // 2. AlgID\n            var idxAlgIdTLV = a1[0];\n            if (pkcs8PubHex.substr(idxAlgIdTLV, 2) != \"30\")\n                throw \"malformed PKCS8 public key(code:001)\"; // AlgId not sequence\n\n            var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, idxAlgIdTLV);\n            if (a2.length != 2)\n                throw \"malformed PKCS8 public key(code:002)\"; // AlgId not have two elements\n\n            // 2.1. AlgID OID\n            if (pkcs8PubHex.substr(a2[0], 2) != \"06\")\n                throw \"malformed PKCS8 public key(code:003)\"; // AlgId.oid is not OID\n\n            result.algoid = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[0]);\n\n            // 2.2. AlgID param\n            if (pkcs8PubHex.substr(a2[1], 2) == \"06\") { // OID for EC\n                result.algparam = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[1]);\n            } else if (pkcs8PubHex.substr(a2[1], 2) == \"30\") { // SEQ for DSA\n                result.algparam = {};\n                result.algparam.p = ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [0], \"02\");\n                result.algparam.q = ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [1], \"02\");\n                result.algparam.g = ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [2], \"02\");\n            }\n\n            // 3. Key\n            if (pkcs8PubHex.substr(a1[1], 2) != \"03\")\n                throw \"malformed PKCS8 public key(code:004)\"; // Key is not bit string\n\n            result.key = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a1[1]).substr(2);\n            \n            // 4. return result assoc array\n            return result;\n        },\n\n        /**\n         * (DEPRECATED) provide hexadecimal string of unencrypted PKCS#8 private key and returns RSAKey object\n         * @name getRSAKeyFromPublicPKCS8Hex\n         * @memberOf KEYUTIL\n         * @function\n         * @param {String} pkcs8PubHex hexadecimal string of unencrypted PKCS#8 public key\n         * @return {RSAKey} loaded RSAKey object of RSA public key\n         * @since pkcs5pkey 1.0.4\n         * @deprecated From jsrsasign 4.2.1 please use {@link KEYUTIL.getKey#}.\n         */\n        getRSAKeyFromPublicPKCS8Hex: function(pkcs8PubHex) {\n            var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, 0);\n            if (a1.length != 2)\n                throw \"outer DERSequence shall have 2 elements: \" + a1.length;\n\n            var algIdTLV =ASN1HEX.getHexOfTLV_AtObj(pkcs8PubHex, a1[0]);\n            if (algIdTLV != \"300d06092a864886f70d0101010500\") // AlgId rsaEncryption\n                throw \"PKCS8 AlgorithmId is not rsaEncryption\";\n            \n            if (pkcs8PubHex.substr(a1[1], 2) != \"03\")\n                throw \"PKCS8 Public Key is not BITSTRING encapslated.\";\n\n            var idxPub = ASN1HEX.getStartPosOfV_AtObj(pkcs8PubHex, a1[1]) + 2; // 2 for unused bit\n            \n            if (pkcs8PubHex.substr(idxPub, 2) != \"30\")\n                throw \"PKCS8 Public Key is not SEQUENCE.\";\n\n            var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(pkcs8PubHex, idxPub);\n            if (a2.length != 2)\n                throw \"inner DERSequence shall have 2 elements: \" + a2.length;\n\n            if (pkcs8PubHex.substr(a2[0], 2) != \"02\") \n                throw \"N is not ASN.1 INTEGER\";\n            if (pkcs8PubHex.substr(a2[1], 2) != \"02\") \n                throw \"E is not ASN.1 INTEGER\";\n            \n            var hN = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[0]);\n            var hE = ASN1HEX.getHexOfV_AtObj(pkcs8PubHex, a2[1]);\n\n            var pubKey = new RSAKey();\n            pubKey.setPublic(hN, hE);\n            \n            return pubKey;\n        },\n\n        //addAlgorithm: function(functionObject, algName, keyLen, ivLen) {\n        //}\n    };\n}();\n\n// -- MAJOR PUBLIC METHODS -------------------------------------------------------\n/**\n * get private or public key object from any arguments\n * @name getKey\n * @memberOf KEYUTIL\n * @function\n * @static\n * @param {Object} param parameter to get key object. see description in detail.\n * @param {String} passcode (OPTION) parameter to get key object. see description in detail.\n * @param {String} hextype (OPTOIN) parameter to get key object. see description in detail.\n * @return {Object} {@link RSAKey}, {@link KJUR.crypto.ECDSA} or {@link KJUR.crypto.ECDSA} object\n * @since keyutil 1.0.0\n * @description\n * This method gets private or public key object({@link RSAKey}, {@link KJUR.crypto.DSA} or {@link KJUR.crypto.ECDSA})\n * for RSA, DSA and ECC.\n * Arguments for this methods depends on a key format you specify.\n * Following key representations are supported.\n * <ul>\n * <li>ECC private/public key object(as is): param=KJUR.crypto.ECDSA</li>\n * <li>DSA private/public key object(as is): param=KJUR.crypto.DSA</li>\n * <li>RSA private/public key object(as is): param=RSAKey </li>\n * <li>ECC private key parameters: param={d: d, curve: curveName}</li>\n * <li>RSA private key parameters: param={n: n, e: e, d: d, p: p, q: q, dp: dp, dq: dq, co: co}<br/>\n * NOTE: Each value shall be hexadecimal string of key spec.</li>\n * <li>DSA private key parameters: param={p: p, q: q, g: g, y: y, x: x}<br/>\n * NOTE: Each value shall be hexadecimal string of key spec.</li>\n * <li>ECC public key parameters: param={xy: xy, curve: curveName}<br/>\n * NOTE: ECC public key 'xy' shall be concatination of \"04\", x-bytes-hex and y-bytes-hex.</li>\n * <li>DSA public key parameters: param={p: p, q: q, g: g, y: y}<br/>\n * NOTE: Each value shall be hexadecimal string of key spec.</li>\n * <li>RSA public key parameters: param={n: n, e: e} </li>\n * <li>X.509v1/v3 PEM certificate (RSA/DSA/ECC): param=pemString</li>\n * <li>PKCS#8 hexadecimal RSA/ECC public key: param=pemString, null, \"pkcs8pub\"</li>\n * <li>PKCS#8 PEM RSA/DSA/ECC public key: param=pemString</li>\n * <li>PKCS#5 plain hexadecimal RSA private key: param=hexString, null, \"pkcs5prv\"</li>\n * <li>PKCS#5 plain PEM DSA/RSA private key: param=pemString</li>\n * <li>PKCS#8 plain PEM RSA/ECDSA private key: param=pemString</li>\n * <li>PKCS#5 encrypted PEM RSA/DSA private key: param=pemString, passcode</li>\n * <li>PKCS#8 encrypted PEM RSA/ECDSA private key: param=pemString, passcode</li>\n * </ul>\n * Please note following limitation on encrypted keys:\n * <ul>\n * <li>Encrypted PKCS#8 only supports PBKDF2/HmacSHA1/3DES</li>\n * <li>Encrypted PKCS#5 supports DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC</li>\n * <li>JWT plain ECC private/public key</li>\n * <li>JWT plain RSA public key</li>\n * <li>JWT plain RSA private key with P/Q/DP/DQ/COEFF</li>\n * <li>JWT plain RSA private key without P/Q/DP/DQ/COEFF (since jsrsasign 5.0.0)</li>\n * </ul>\n * NOTE1: <a href=\"https://tools.ietf.org/html/rfc7517\">RFC 7517 JSON Web Key(JWK)</a> support for RSA/ECC private/public key from jsrsasign 4.8.1.<br/>\n * NOTE2: X509v1 support is added since jsrsasign 5.0.11.\n * \n * <h5>EXAMPLE</h5>\n * @example\n * // 1. loading private key from PEM string\n * keyObj = KEYUTIL.getKey(\"-----BEGIN RSA PRIVATE KEY...\");\n * keyObj = KEYUTIL.getKey(\"-----BEGIN RSA PRIVATE KEY..., \"passcode\");\n * keyObj = KEYUTIL.getKey(\"-----BEGIN PRIVATE KEY...\");\n * keyObj = KEYUTIL.getKey(\"-----BEGIN PRIVATE KEY...\", \"passcode\");\n * // 2. loading public key from PEM string\n * keyObj = KEYUTIL.getKey(\"-----BEGIN PUBLIC KEY...\");\n * keyObj = KEYUTIL.getKey(\"-----BEGIN X509 CERTIFICATE...\");\n * // 3. loading hexadecimal PKCS#5/PKCS#8 key\n * keyObj = KEYUTIL.getKey(\"308205c1...\", null, \"pkcs8pub\");\n * keyObj = KEYUTIL.getKey(\"3082048b...\", null, \"pkcs5prv\");\n * // 4. loading JSON Web Key(JWK)\n * keyObj = KEYUTIL.getKey({kty: \"RSA\", n: \"0vx7...\", e: \"AQAB\"});\n * keyObj = KEYUTIL.getKey({kty: \"EC\", crv: \"P-256\", \n *                          x: \"MKBC...\", y: \"4Etl6...\", d: \"870Mb...\"});\n * // 5. bare hexadecimal key\n * keyObj = KEYUTIL.getKey({n: \"75ab..\", e: \"010001\"});\n */\nKEYUTIL.getKey = function(param, passcode, hextype) {\n    // 1. by key RSAKey/KJUR.crypto.ECDSA/KJUR.crypto.DSA object\n    if (typeof RSAKey != 'undefined' && param instanceof RSAKey)\n        return param;\n    if (typeof KJUR.crypto.ECDSA != 'undefined' && param instanceof KJUR.crypto.ECDSA)\n        return param;\n    if (typeof KJUR.crypto.DSA != 'undefined' && param instanceof KJUR.crypto.DSA)\n        return param;\n\n    // 2. by parameters of key\n\n    // 2.1. bare ECC\n    // 2.1.1. bare ECC public key by hex values\n    if (param.curve !== undefined &&\n\tparam.xy !== undefined && param.d === undefined) {\n        return new KJUR.crypto.ECDSA({pub: param.xy, curve: param.curve});\n    }\n\n    // 2.1.2. bare ECC private key by hex values\n    if (param.curve !== undefined && param.d !== undefined) {\n        return new KJUR.crypto.ECDSA({prv: param.d, curve: param.curve});\n    }\n\n    // 2.2. bare RSA\n    // 2.2.1. bare RSA public key by hex values\n    if (param.kty === undefined &&\n\tparam.n !== undefined && param.e !== undefined &&\n        param.d === undefined) {\n        var key = new RSAKey();\n        key.setPublic(param.n, param.e);\n        return key;\n    }\n\n    // 2.2.2. bare RSA private key with P/Q/DP/DQ/COEFF by hex values\n    if (param.kty === undefined &&\n\tparam.n !== undefined &&\n\tparam.e !== undefined &&\n\tparam.d !== undefined &&\n        param.p !== undefined &&\n\tparam.q !== undefined &&\n        param.dp !== undefined &&\n\tparam.dq !== undefined &&\n\tparam.co !== undefined &&\n        param.qi === undefined) {\n        var key = new RSAKey();\n        key.setPrivateEx(param.n, param.e, param.d, param.p, param.q,\n                         param.dp, param.dq, param.co);\n        return key;\n    }\n\n    // 2.2.3. bare RSA public key without P/Q/DP/DQ/COEFF by hex values\n    if (param.kty === undefined &&\n\tparam.n !== undefined &&\n\tparam.e !== undefined &&\n\tparam.d !== undefined &&\n        param.p === undefined) {\n        var key = new RSAKey();\n        key.setPrivate(param.n, param.e, param.d);\n        return key;\n    }\n\n    // 2.3. bare DSA\n    // 2.3.1. bare DSA public key by hex values\n    if (param.p !== undefined && param.q !== undefined &&\n\tparam.g !== undefined &&\n        param.y !== undefined && param.x === undefined) {\n        var key = new KJUR.crypto.DSA();\n        key.setPublic(param.p, param.q, param.g, param.y);\n        return key;\n    }\n\n    // 2.3.2. bare DSA private key by hex values\n    if (param.p !== undefined && param.q !== undefined &&\n\tparam.g !== undefined &&\n        param.y !== undefined && param.x !== undefined) {\n        var key = new KJUR.crypto.DSA();\n        key.setPrivate(param.p, param.q, param.g, param.y, param.x);\n        return key;\n    }\n\n    // 3. JWK\n    // 3.1. JWK RSA\n    // 3.1.1. JWK RSA public key by b64u values\n    if (param.kty === \"RSA\" &&\n\tparam.n !== undefined &&\n\tparam.e !== undefined &&\n\tparam.d === undefined) {\n\tvar key = new RSAKey();\n\tkey.setPublic(b64utohex(param.n), b64utohex(param.e));\n\treturn key;\n    }\n\n    // 3.1.2. JWK RSA private key with p/q/dp/dq/coeff by b64u values\n    if (param.kty === \"RSA\" &&\n\tparam.n !== undefined &&\n\tparam.e !== undefined &&\n\tparam.d !== undefined &&\n\tparam.p !== undefined &&\n\tparam.q !== undefined &&\n\tparam.dp !== undefined &&\n\tparam.dq !== undefined &&\n\tparam.qi !== undefined) {\n\tvar key = new RSAKey();\n        key.setPrivateEx(b64utohex(param.n),\n\t\t\t b64utohex(param.e),\n\t\t\t b64utohex(param.d),\n\t\t\t b64utohex(param.p),\n\t\t\t b64utohex(param.q),\n                         b64utohex(param.dp),\n\t\t\t b64utohex(param.dq),\n\t\t\t b64utohex(param.qi));\n\treturn key;\n    }\n\n    // 3.1.3. JWK RSA private key without p/q/dp/dq/coeff by b64u\n    //        since jsrsasign 5.0.0 keyutil 1.0.11\n    if (param.kty === \"RSA\" &&\n\tparam.n !== undefined &&\n\tparam.e !== undefined &&\n\tparam.d !== undefined) {\n\tvar key = new RSAKey();\n        key.setPrivate(b64utohex(param.n),\n\t\t       b64utohex(param.e),\n\t\t       b64utohex(param.d));\n\treturn key;\n    }\n\n    // 3.2. JWK ECC\n    // 3.2.1. JWK ECC public key by b64u values\n    if (param.kty === \"EC\" &&\n\tparam.crv !== undefined &&\n\tparam.x !== undefined &&\n\tparam.y !== undefined &&\n        param.d === undefined) {\n\tvar ec = new KJUR.crypto.ECDSA({\"curve\": param.crv});\n\tvar charlen = ec.ecparams.keylen / 4;\n        var hX   = (\"0000000000\" + b64utohex(param.x)).slice(- charlen);\n        var hY   = (\"0000000000\" + b64utohex(param.y)).slice(- charlen);\n        var hPub = \"04\" + hX + hY;\n\tec.setPublicKeyHex(hPub);\n\treturn ec;\n    }\n\n    // 3.2.2. JWK ECC private key by b64u values\n    if (param.kty === \"EC\" &&\n\tparam.crv !== undefined &&\n\tparam.x !== undefined &&\n\tparam.y !== undefined &&\n        param.d !== undefined) {\n\tvar ec = new KJUR.crypto.ECDSA({\"curve\": param.crv});\n\tvar charlen = ec.ecparams.keylen / 4;\n        var hX   = (\"0000000000\" + b64utohex(param.x)).slice(- charlen);\n        var hY   = (\"0000000000\" + b64utohex(param.y)).slice(- charlen);\n        var hPub = \"04\" + hX + hY;\n        var hPrv = (\"0000000000\" + b64utohex(param.d)).slice(- charlen);\n\tec.setPublicKeyHex(hPub);\n\tec.setPrivateKeyHex(hPrv);\n\treturn ec;\n    }\n    \n    // 4. by PEM certificate (-----BEGIN ... CERTIFITE----)\n    if (param.indexOf(\"-END CERTIFICATE-\", 0) != -1 ||\n        param.indexOf(\"-END X509 CERTIFICATE-\", 0) != -1 ||\n        param.indexOf(\"-END TRUSTED CERTIFICATE-\", 0) != -1) {\n        return X509.getPublicKeyFromCertPEM(param);\n    }\n\n    // 4. public key by PKCS#8 hexadecimal string\n    if (hextype === \"pkcs8pub\") {\n        return KEYUTIL.getKeyFromPublicPKCS8Hex(param);\n    }\n\n    // 5. public key by PKCS#8 PEM string\n    if (param.indexOf(\"-END PUBLIC KEY-\") != -1) {\n        return KEYUTIL.getKeyFromPublicPKCS8PEM(param);\n    }\n    \n    // 6. private key by PKCS#5 plain hexadecimal RSA string\n    if (hextype === \"pkcs5prv\") {\n        var key = new RSAKey();\n        key.readPrivateKeyFromASN1HexString(param);\n        return key;\n    }\n\n    // 7. private key by plain PKCS#5 hexadecimal RSA string\n    if (hextype === \"pkcs5prv\") {\n        var key = new RSAKey();\n        key.readPrivateKeyFromASN1HexString(param);\n        return key;\n    }\n\n    // 8. private key by plain PKCS#5 PEM RSA string \n    //    getKey(\"-----BEGIN RSA PRIVATE KEY-...\")\n    if (param.indexOf(\"-END RSA PRIVATE KEY-\") != -1 &&\n        param.indexOf(\"4,ENCRYPTED\") == -1) {\n        var hex = KEYUTIL.getHexFromPEM(param, \"RSA PRIVATE KEY\");\n        return KEYUTIL.getKey(hex, null, \"pkcs5prv\");\n    }\n\n    // 8.2. private key by plain PKCS#5 PEM DSA string\n    if (param.indexOf(\"-END DSA PRIVATE KEY-\") != -1 &&\n        param.indexOf(\"4,ENCRYPTED\") == -1) {\n\n        var hKey = this.getHexFromPEM(param, \"DSA PRIVATE KEY\");\n        var p = ASN1HEX.getVbyList(hKey, 0, [1], \"02\");\n        var q = ASN1HEX.getVbyList(hKey, 0, [2], \"02\");\n        var g = ASN1HEX.getVbyList(hKey, 0, [3], \"02\");\n        var y = ASN1HEX.getVbyList(hKey, 0, [4], \"02\");\n        var x = ASN1HEX.getVbyList(hKey, 0, [5], \"02\");\n        var key = new KJUR.crypto.DSA();\n        key.setPrivate(new BigInteger(p, 16),\n                       new BigInteger(q, 16),\n                       new BigInteger(g, 16),\n                       new BigInteger(y, 16),\n                       new BigInteger(x, 16));\n        return key;\n    }\n\n    // 9. private key by plain PKCS#8 PEM ECC/RSA string\n    if (param.indexOf(\"-END PRIVATE KEY-\") != -1) {\n        return KEYUTIL.getKeyFromPlainPrivatePKCS8PEM(param);\n    }\n\n    // 10. private key by encrypted PKCS#5 PEM RSA string\n    if (param.indexOf(\"-END RSA PRIVATE KEY-\") != -1 &&\n        param.indexOf(\"4,ENCRYPTED\") != -1) {\n        return KEYUTIL.getRSAKeyFromEncryptedPKCS5PEM(param, passcode);\n    }\n\n    // 10.2. private key by encrypted PKCS#5 PEM ECDSA string\n    if (param.indexOf(\"-END EC PRIVATE KEY-\") != -1 &&\n        param.indexOf(\"4,ENCRYPTED\") != -1) {\n        var hKey = KEYUTIL.getDecryptedKeyHex(param, passcode);\n\n        var key = ASN1HEX.getVbyList(hKey, 0, [1], \"04\");\n        var curveNameOidHex = ASN1HEX.getVbyList(hKey, 0, [2,0], \"06\");\n        var pubkey = ASN1HEX.getVbyList(hKey, 0, [3,0], \"03\").substr(2);\n        var curveName = \"\";\n\n        if (KJUR.crypto.OID.oidhex2name[curveNameOidHex] !== undefined) {\n            curveName = KJUR.crypto.OID.oidhex2name[curveNameOidHex];\n        } else {\n            throw \"undefined OID(hex) in KJUR.crypto.OID: \" + curveNameOidHex;\n        }\n\n        var ec = new KJUR.crypto.ECDSA({'name': curveName});\n        ec.setPublicKeyHex(pubkey);\n        ec.setPrivateKeyHex(key);\n        ec.isPublic = false;\n        return ec;\n    }\n\n    // 10.3. private key by encrypted PKCS#5 PEM DSA string\n    if (param.indexOf(\"-END DSA PRIVATE KEY-\") != -1 &&\n        param.indexOf(\"4,ENCRYPTED\") != -1) {\n        var hKey = KEYUTIL.getDecryptedKeyHex(param, passcode);\n        var p = ASN1HEX.getVbyList(hKey, 0, [1], \"02\");\n        var q = ASN1HEX.getVbyList(hKey, 0, [2], \"02\");\n        var g = ASN1HEX.getVbyList(hKey, 0, [3], \"02\");\n        var y = ASN1HEX.getVbyList(hKey, 0, [4], \"02\");\n        var x = ASN1HEX.getVbyList(hKey, 0, [5], \"02\");\n        var key = new KJUR.crypto.DSA();\n        key.setPrivate(new BigInteger(p, 16),\n                       new BigInteger(q, 16),\n                       new BigInteger(g, 16),\n                       new BigInteger(y, 16),\n                       new BigInteger(x, 16));\n        return key;\n    }\n\n    // 11. private key by encrypted PKCS#8 hexadecimal RSA/ECDSA string\n    if (param.indexOf(\"-END ENCRYPTED PRIVATE KEY-\") != -1) {\n        return KEYUTIL.getKeyFromEncryptedPKCS8PEM(param, passcode);\n    }\n\n    throw \"not supported argument\";\n};\n\n/**\n * @name generateKeypair\n * @memberOf KEYUTIL\n * @function\n * @static\n * @param {String} alg 'RSA' or 'EC'\n * @param {Object} keylenOrCurve key length for RSA or curve name for EC\n * @return {Array} associative array of keypair which has prvKeyObj and pubKeyObj parameters\n * @since keyutil 1.0.1\n * @description\n * This method generates a key pair of public key algorithm.\n * The result will be an associative array which has following\n * parameters:\n * <ul>\n * <li>prvKeyObj - RSAKey or ECDSA object of private key</li>\n * <li>pubKeyObj - RSAKey or ECDSA object of public key</li>\n * </ul>\n * NOTE1: As for RSA algoirthm, public exponent has fixed\n * value '0x10001'.\n * NOTE2: As for EC algorithm, supported names of curve are\n * secp256r1, secp256k1 and secp384r1.\n * NOTE3: DSA is not supported yet.\n * @example\n * var rsaKeypair = KEYUTIL.generateKeypair(\"RSA\", 1024);\n * var ecKeypair = KEYUTIL.generateKeypair(\"EC\", \"secp256r1\");\n *\n */\nKEYUTIL.generateKeypair = function(alg, keylenOrCurve) {\n    if (alg == \"RSA\") {\n        var keylen = keylenOrCurve;\n        var prvKey = new RSAKey();\n        prvKey.generate(keylen, '10001');\n        prvKey.isPrivate = true;\n        prvKey.isPublic = true;\n        \n        var pubKey = new RSAKey();\n        var hN = prvKey.n.toString(16);\n        var hE = prvKey.e.toString(16);\n        pubKey.setPublic(hN, hE);\n        pubKey.isPrivate = false;\n        pubKey.isPublic = true;\n        \n        var result = {};\n        result.prvKeyObj = prvKey;\n        result.pubKeyObj = pubKey;\n        return result;\n    } else if (alg == \"EC\") {\n        var curve = keylenOrCurve;\n        var ec = new KJUR.crypto.ECDSA({curve: curve});\n        var keypairHex = ec.generateKeyPairHex();\n\n        var prvKey = new KJUR.crypto.ECDSA({curve: curve});\n        prvKey.setPublicKeyHex(keypairHex.ecpubhex);\n        prvKey.setPrivateKeyHex(keypairHex.ecprvhex);\n        prvKey.isPrivate = true;\n        prvKey.isPublic = false;\n\n        var pubKey = new KJUR.crypto.ECDSA({curve: curve});\n        pubKey.setPublicKeyHex(keypairHex.ecpubhex);\n        pubKey.isPrivate = false;\n        pubKey.isPublic = true;\n\n        var result = {};\n        result.prvKeyObj = prvKey;\n        result.pubKeyObj = pubKey;\n        return result;\n    } else {\n        throw \"unknown algorithm: \" + alg;\n    }\n};\n\n/**\n * get PEM formatted private or public key file from a RSA/ECDSA/DSA key object\n * @name getPEM\n * @memberOf KEYUTIL\n * @function\n * @static\n * @param {Object} keyObjOrHex key object {@link RSAKey}, {@link KJUR.crypto.ECDSA} or {@link KJUR.crypto.DSA} to encode to\n * @param {String} formatType (OPTION) output format type of \"PKCS1PRV\", \"PKCS5PRV\" or \"PKCS8PRV\" for private key\n * @param {String} passwd (OPTION) password to protect private key\n * @param {String} encAlg (OPTION) encryption algorithm for PKCS#5. currently supports DES-CBC, DES-EDE3-CBC and AES-{128,192,256}-CBC\n * @since keyutil 1.0.4\n * @description\n * <dl>\n * <dt><b>NOTE1:</b>\n * <dd>\n * PKCS#5 encrypted private key protection algorithm supports DES-CBC, \n * DES-EDE3-CBC and AES-{128,192,256}-CBC\n * <dt><b>NOTE2:</b>\n * <dd>\n * OpenSSL supports\n * </dl>\n * @example\n * KEUUTIL.getPEM(publicKey) =&gt; generates PEM PKCS#8 public key \n * KEUUTIL.getPEM(privateKey, \"PKCS1PRV\") =&gt; generates PEM PKCS#1 plain private key\n * KEUUTIL.getPEM(privateKey, \"PKCS5PRV\", \"pass\") =&gt; generates PEM PKCS#5 encrypted private key \n *                                                          with DES-EDE3-CBC (DEFAULT)\n * KEUUTIL.getPEM(privateKey, \"PKCS5PRV\", \"pass\", \"DES-CBC\") =&gt; generates PEM PKCS#5 encrypted \n *                                                                 private key with DES-CBC\n * KEUUTIL.getPEM(privateKey, \"PKCS8PRV\") =&gt; generates PEM PKCS#8 plain private key\n * KEUUTIL.getPEM(privateKey, \"PKCS8PRV\", \"pass\") =&gt; generates PEM PKCS#8 encrypted private key\n *                                                      with PBKDF2_HmacSHA1_3DES\n */\nKEYUTIL.getPEM = function(keyObjOrHex, formatType, passwd, encAlg, hexType) {\n    var ns1 = KJUR.asn1;\n    var ns2 = KJUR.crypto;\n\n    function _rsaprv2asn1obj(keyObjOrHex) {\n        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"int\": 0 },\n                {\"int\": {\"bigint\": keyObjOrHex.n}},\n                {\"int\": keyObjOrHex.e},\n                {\"int\": {\"bigint\": keyObjOrHex.d}},\n                {\"int\": {\"bigint\": keyObjOrHex.p}},\n                {\"int\": {\"bigint\": keyObjOrHex.q}},\n                {\"int\": {\"bigint\": keyObjOrHex.dmp1}},\n                {\"int\": {\"bigint\": keyObjOrHex.dmq1}},\n                {\"int\": {\"bigint\": keyObjOrHex.coeff}}\n            ]\n        });\n        return asn1Obj;\n    };\n\n    function _ecdsaprv2asn1obj(keyObjOrHex) {\n        var asn1Obj2 = KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"int\": 1 },\n                {\"octstr\": {\"hex\": keyObjOrHex.prvKeyHex}},\n                {\"tag\": ['a0', true, {'oid': {'name': keyObjOrHex.curveName}}]},\n                {\"tag\": ['a1', true, {'bitstr': {'hex': '00' + keyObjOrHex.pubKeyHex}}]}\n            ]\n        });\n        return asn1Obj2;\n    };\n\n    function _dsaprv2asn1obj(keyObjOrHex) {\n        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"int\": 0 },\n                {\"int\": {\"bigint\": keyObjOrHex.p}},\n                {\"int\": {\"bigint\": keyObjOrHex.q}},\n                {\"int\": {\"bigint\": keyObjOrHex.g}},\n                {\"int\": {\"bigint\": keyObjOrHex.y}},\n                {\"int\": {\"bigint\": keyObjOrHex.x}}\n            ]\n        });\n        return asn1Obj;\n    };\n\n    // 1. public key\n\n    // x. PEM PKCS#8 public key of RSA/ECDSA/DSA public key object\n    if (((typeof RSAKey != \"undefined\" && keyObjOrHex instanceof RSAKey) ||\n         (typeof ns2.DSA != \"undefined\" && keyObjOrHex instanceof ns2.DSA) ||\n         (typeof ns2.ECDSA != \"undefined\" && keyObjOrHex instanceof ns2.ECDSA)) &&\n        keyObjOrHex.isPublic == true &&\n        (formatType === undefined || formatType == \"PKCS8PUB\")) {\n        var asn1Obj = new KJUR.asn1.x509.SubjectPublicKeyInfo(keyObjOrHex);\n        var asn1Hex = asn1Obj.getEncodedHex();\n        return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PUBLIC KEY\");\n    }\n    \n    // 2. private\n\n    // x. PEM PKCS#1 plain private key of RSA private key object\n    if (formatType == \"PKCS1PRV\" &&\n        typeof RSAKey != \"undefined\" &&\n        keyObjOrHex instanceof RSAKey &&\n        (passwd === undefined || passwd == null) &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var asn1Obj = _rsaprv2asn1obj(keyObjOrHex);\n        var asn1Hex = asn1Obj.getEncodedHex();\n        return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"RSA PRIVATE KEY\");\n    }\n\n    // x. PEM PKCS#1 plain private key of ECDSA private key object\n    if (formatType == \"PKCS1PRV\" &&\n        typeof RSAKey != \"undefined\" &&\n        keyObjOrHex instanceof KJUR.crypto.ECDSA &&\n        (passwd === undefined || passwd == null) &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var asn1Obj1 = new KJUR.asn1.DERObjectIdentifier({'name': keyObjOrHex.curveName});\n        var asn1Hex1 = asn1Obj1.getEncodedHex();\n        var asn1Obj2 = _ecdsaprv2asn1obj(keyObjOrHex);\n        var asn1Hex2 = asn1Obj2.getEncodedHex();\n\n        var s = \"\";\n        s += ns1.ASN1Util.getPEMStringFromHex(asn1Hex1, \"EC PARAMETERS\");\n        s += ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"EC PRIVATE KEY\");\n        return s;\n    }\n\n    // x. PEM PKCS#1 plain private key of DSA private key object\n    if (formatType == \"PKCS1PRV\" &&\n        typeof KJUR.crypto.DSA != \"undefined\" &&\n        keyObjOrHex instanceof KJUR.crypto.DSA &&\n        (passwd === undefined || passwd == null) &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var asn1Obj = _dsaprv2asn1obj(keyObjOrHex);\n        var asn1Hex = asn1Obj.getEncodedHex();\n        return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"DSA PRIVATE KEY\");\n    }\n\n    // 3. private\n\n    // x. PEM PKCS#5 encrypted private key of RSA private key object\n    if (formatType == \"PKCS5PRV\" &&\n        typeof RSAKey != \"undefined\" &&\n        keyObjOrHex instanceof RSAKey &&\n        (passwd !== undefined && passwd != null) &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var asn1Obj = _rsaprv2asn1obj(keyObjOrHex);\n        var asn1Hex = asn1Obj.getEncodedHex();\n\n        if (encAlg === undefined) encAlg = \"DES-EDE3-CBC\";\n        return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"RSA\", asn1Hex, passwd, encAlg);\n    }\n\n    // x. PEM PKCS#5 encrypted private key of ECDSA private key object\n    if (formatType == \"PKCS5PRV\" &&\n        typeof KJUR.crypto.ECDSA != \"undefined\" &&\n        keyObjOrHex instanceof KJUR.crypto.ECDSA &&\n        (passwd !== undefined && passwd != null) &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var asn1Obj = _ecdsaprv2asn1obj(keyObjOrHex);\n        var asn1Hex = asn1Obj.getEncodedHex();\n\n        if (encAlg === undefined) encAlg = \"DES-EDE3-CBC\";\n        return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"EC\", asn1Hex, passwd, encAlg);\n    }\n\n    // x. PEM PKCS#5 encrypted private key of DSA private key object\n    if (formatType == \"PKCS5PRV\" &&\n        typeof KJUR.crypto.DSA != \"undefined\" &&\n        keyObjOrHex instanceof KJUR.crypto.DSA &&\n        (passwd !== undefined && passwd != null) &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var asn1Obj = _dsaprv2asn1obj(keyObjOrHex);\n        var asn1Hex = asn1Obj.getEncodedHex();\n\n        if (encAlg === undefined) encAlg = \"DES-EDE3-CBC\";\n        return this.getEncryptedPKCS5PEMFromPrvKeyHex(\"DSA\", asn1Hex, passwd, encAlg);\n    }\n\n    // x. ======================================================================\n\n    var _getEncryptedPKCS8 = function(plainKeyHex, passcode) {\n        var info = _getEencryptedPKCS8Info(plainKeyHex, passcode);\n        //alert(\"iv=\" + info.encryptionSchemeIV);\n        //alert(\"info.ciphertext2[\" + info.ciphertext.length + \"=\" + info.ciphertext);\n        var asn1Obj = new KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"seq\": [\n                    {\"oid\": {\"name\": \"pkcs5PBES2\"}},\n                    {\"seq\": [\n                        {\"seq\": [\n                            {\"oid\": {\"name\": \"pkcs5PBKDF2\"}},\n                            {\"seq\": [\n                                {\"octstr\": {\"hex\": info.pbkdf2Salt}},\n                                {\"int\": info.pbkdf2Iter}\n                            ]}\n                        ]},\n                        {\"seq\": [\n                            {\"oid\": {\"name\": \"des-EDE3-CBC\"}},\n                            {\"octstr\": {\"hex\": info.encryptionSchemeIV}}\n                        ]}\n                    ]}\n                ]},\n                {\"octstr\": {\"hex\": info.ciphertext}}\n            ]\n        });\n        return asn1Obj.getEncodedHex();\n    };\n\n    var _getEencryptedPKCS8Info = function(plainKeyHex, passcode) {\n        var pbkdf2Iter = 100;\n        var pbkdf2SaltWS = CryptoJS.lib.WordArray.random(8);\n        var encryptionSchemeAlg = \"DES-EDE3-CBC\";\n        var encryptionSchemeIVWS = CryptoJS.lib.WordArray.random(8);\n        // PBKDF2 key\n        var pbkdf2KeyWS = CryptoJS.PBKDF2(passcode, \n                                          pbkdf2SaltWS, { \"keySize\": 192/32,\n                                                          \"iterations\": pbkdf2Iter });\n        // ENCRYPT\n        var plainKeyWS = CryptoJS.enc.Hex.parse(plainKeyHex);\n        var encryptedKeyHex = \n            CryptoJS.TripleDES.encrypt(plainKeyWS, pbkdf2KeyWS, { \"iv\": encryptionSchemeIVWS }) + \"\";\n\n        //alert(\"encryptedKeyHex=\" + encryptedKeyHex);\n\n        var info = {};\n        info.ciphertext = encryptedKeyHex;\n        //alert(\"info.ciphertext=\" + info.ciphertext);\n        info.pbkdf2Salt = CryptoJS.enc.Hex.stringify(pbkdf2SaltWS);\n        info.pbkdf2Iter = pbkdf2Iter;\n        info.encryptionSchemeAlg = encryptionSchemeAlg;\n        info.encryptionSchemeIV = CryptoJS.enc.Hex.stringify(encryptionSchemeIVWS);\n        return info;\n    };\n\n    // x. PEM PKCS#8 plain private key of RSA private key object\n    if (formatType == \"PKCS8PRV\" &&\n        typeof RSAKey != \"undefined\" &&\n        keyObjOrHex instanceof RSAKey &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var keyObj = _rsaprv2asn1obj(keyObjOrHex);\n        var keyHex = keyObj.getEncodedHex();\n\n        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"int\": 0},\n                {\"seq\": [{\"oid\": {\"name\": \"rsaEncryption\"}},{\"null\": true}]},\n                {\"octstr\": {\"hex\": keyHex}}\n            ]\n        });\n        var asn1Hex = asn1Obj.getEncodedHex();\n\n        if (passwd === undefined || passwd == null) {\n            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PRIVATE KEY\");\n        } else {\n            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);\n            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"ENCRYPTED PRIVATE KEY\");\n        }\n    }\n\n    // x. PEM PKCS#8 plain private key of ECDSA private key object\n    if (formatType == \"PKCS8PRV\" &&\n        typeof KJUR.crypto.ECDSA != \"undefined\" &&\n        keyObjOrHex instanceof KJUR.crypto.ECDSA &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var keyObj = new KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"int\": 1},\n                {\"octstr\": {\"hex\": keyObjOrHex.prvKeyHex}},\n                {\"tag\": ['a1', true, {\"bitstr\": {\"hex\": \"00\" + keyObjOrHex.pubKeyHex}}]}\n            ]\n        });\n        var keyHex = keyObj.getEncodedHex();\n\n        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"int\": 0},\n                {\"seq\": [\n                    {\"oid\": {\"name\": \"ecPublicKey\"}},\n                    {\"oid\": {\"name\": keyObjOrHex.curveName}}\n                ]},\n                {\"octstr\": {\"hex\": keyHex}}\n            ]\n        });\n\n        var asn1Hex = asn1Obj.getEncodedHex();\n        if (passwd === undefined || passwd == null) {\n            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PRIVATE KEY\");\n        } else {\n            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);\n            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"ENCRYPTED PRIVATE KEY\");\n        }\n    }\n\n    // x. PEM PKCS#8 plain private key of DSA private key object\n    if (formatType == \"PKCS8PRV\" &&\n        typeof KJUR.crypto.DSA != \"undefined\" &&\n        keyObjOrHex instanceof KJUR.crypto.DSA &&\n        keyObjOrHex.isPrivate  == true) {\n\n        var keyObj = new KJUR.asn1.DERInteger({'bigint': keyObjOrHex.x});\n        var keyHex = keyObj.getEncodedHex();\n\n        var asn1Obj = KJUR.asn1.ASN1Util.newObject({\n            \"seq\": [\n                {\"int\": 0},\n                {\"seq\": [\n                    {\"oid\": {\"name\": \"dsa\"}},\n                    {\"seq\": [\n                        {\"int\": {\"bigint\": keyObjOrHex.p}},\n                        {\"int\": {\"bigint\": keyObjOrHex.q}},\n                        {\"int\": {\"bigint\": keyObjOrHex.g}}\n                    ]}\n                ]},\n                {\"octstr\": {\"hex\": keyHex}}\n            ]\n        });\n\n        var asn1Hex = asn1Obj.getEncodedHex();\n        if (passwd === undefined || passwd == null) {\n            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex, \"PRIVATE KEY\");\n        } else {\n            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);\n            return ns1.ASN1Util.getPEMStringFromHex(asn1Hex2, \"ENCRYPTED PRIVATE KEY\");\n        }\n    }\n\n    throw \"unsupported object nor format\";\n};\n\n// -- PUBLIC METHODS FOR CSR -------------------------------------------------------\n\n/**\n * get RSAKey/DSA/ECDSA public key object from PEM formatted PKCS#10 CSR string\n * @name getKeyFromCSRPEM\n * @memberOf KEYUTIL\n * @function\n * @param {String} csrPEM PEM formatted PKCS#10 CSR string\n * @return {Object} RSAKey/DSA/ECDSA public key object\n * @since keyutil 1.0.5\n */\nKEYUTIL.getKeyFromCSRPEM = function(csrPEM) {\n    var csrHex = KEYUTIL.getHexFromPEM(csrPEM, \"CERTIFICATE REQUEST\");\n    var key = KEYUTIL.getKeyFromCSRHex(csrHex);\n    return key;\n};\n\n/**\n * get RSAKey/DSA/ECDSA public key object from hexadecimal string of PKCS#10 CSR\n * @name getKeyFromCSRHex\n * @memberOf KEYUTIL\n * @function\n * @param {String} csrHex hexadecimal string of PKCS#10 CSR\n * @return {Object} RSAKey/DSA/ECDSA public key object\n * @since keyutil 1.0.5\n */\nKEYUTIL.getKeyFromCSRHex = function(csrHex) {\n    var info = KEYUTIL.parseCSRHex(csrHex);\n    var key = KEYUTIL.getKey(info.p8pubkeyhex, null, \"pkcs8pub\");\n    return key;\n};\n\n/**\n * parse hexadecimal string of PKCS#10 CSR (certificate signing request)\n * @name parseCSRHex\n * @memberOf KEYUTIL\n * @function\n * @param {String} csrHex hexadecimal string of PKCS#10 CSR\n * @return {Array} associative array of parsed CSR\n * @since keyutil 1.0.5\n * @description\n * Resulted associative array has following properties:\n * <ul>\n * <li>p8pubkeyhex - hexadecimal string of subject public key in PKCS#8</li>\n * </ul>\n */\nKEYUTIL.parseCSRHex = function(csrHex) {\n    var result = {};\n    var h = csrHex;\n\n    // 1. sequence\n    if (h.substr(0, 2) != \"30\")\n        throw \"malformed CSR(code:001)\"; // not sequence\n\n    var a1 = ASN1HEX.getPosArrayOfChildren_AtObj(h, 0);\n    if (a1.length < 1)\n        throw \"malformed CSR(code:002)\"; // short length\n\n    // 2. 2nd sequence\n    if (h.substr(a1[0], 2) != \"30\")\n        throw \"malformed CSR(code:003)\"; // not sequence\n\n    var a2 = ASN1HEX.getPosArrayOfChildren_AtObj(h, a1[0]);\n    if (a2.length < 3)\n        throw \"malformed CSR(code:004)\"; // 2nd seq short elem\n\n    result.p8pubkeyhex = ASN1HEX.getHexOfTLV_AtObj(h, a2[2]);\n\n    return result;\n};\n\n// -- OTHER STATIC PUBLIC METHODS  -------------------------------------------------\n\n/**\n * convert from RSAKey/KJUR.crypto.ECDSA public/private key object to RFC 7517 JSON Web Key(JWK)\n * @name getJWKFromKey\n * @memberOf KEYUTIL\n * @function\n * @static\n * @param {Object} RSAKey/KJUR.crypto.ECDSA public/private key object\n * @return {Object} JWK object\n * @since keyutil 1.0.13 jsrsasign 5.0.14\n * @description\n * This static method convert from RSAKey/KJUR.crypto.ECDSA public/private key object \n * to RFC 7517 JSON Web Key(JWK)\n * @example\n * kp1 = KEYUTIL.generateKeypair(\"EC\", \"P-256\");\n * jwkPrv1 = KEYUTIL.getJWKFromKey(kp1.prvKeyObj);\n * jwkPub1 = KEYUTIL.getJWKFromKey(kp1.pubKeyObj);\n *\n * kp2 = KEYUTIL.generateKeypair(\"RSA\", 2048);\n * jwkPrv2 = KEYUTIL.getJWKFromKey(kp2.prvKeyObj);\n * jwkPub2 = KEYUTIL.getJWKFromKey(kp2.pubKeyObj);\n *\n * // if you need RFC 7636 JWK thumprint as kid do like this:\n * jwkPub2.kid = KJUR.jws.JWS.getJWKthumbprint(jwkPub2);\n */\nKEYUTIL.getJWKFromKey = function(keyObj) {\n    var jwk = {};\n    if (keyObj instanceof RSAKey && keyObj.isPrivate) {\n\tjwk.kty = \"RSA\";\n\tjwk.n = hextob64u(keyObj.n.toString(16));\n\tjwk.e = hextob64u(keyObj.e.toString(16));\n\tjwk.d = hextob64u(keyObj.d.toString(16));\n\tjwk.p = hextob64u(keyObj.p.toString(16));\n\tjwk.q = hextob64u(keyObj.q.toString(16));\n\tjwk.dp = hextob64u(keyObj.dmp1.toString(16));\n\tjwk.dq = hextob64u(keyObj.dmq1.toString(16));\n\tjwk.qi = hextob64u(keyObj.coeff.toString(16));\n\treturn jwk;\n    } else if (keyObj instanceof RSAKey && keyObj.isPublic) {\n\tjwk.kty = \"RSA\";\n\tjwk.n = hextob64u(keyObj.n.toString(16));\n\tjwk.e = hextob64u(keyObj.e.toString(16));\n\treturn jwk;\n    } else if (keyObj instanceof KJUR.crypto.ECDSA && keyObj.isPrivate) {\n\tvar name = keyObj.getShortNISTPCurveName();\n\tif (name !== \"P-256\" && name !== \"P-384\")\n\t    throw \"unsupported curve name for JWT: \" + name;\n\tvar xy = keyObj.getPublicKeyXYHex();\n\tjwk.kty = \"EC\";\n\tjwk.crv =  name;\n\tjwk.x = hextob64u(xy.x);\n\tjwk.y = hextob64u(xy.y);\n\tjwk.d = hextob64u(keyObj.prvKeyHex);\n\treturn jwk;\n    } else if (keyObj instanceof KJUR.crypto.ECDSA && keyObj.isPublic) {\n\tvar name = keyObj.getShortNISTPCurveName();\n\tif (name !== \"P-256\" && name !== \"P-384\")\n\t    throw \"unsupported curve name for JWT: \" + name;\n\tvar xy = keyObj.getPublicKeyXYHex();\n\tjwk.kty = \"EC\";\n\tjwk.crv =  name;\n\tjwk.x = hextob64u(xy.x);\n\tjwk.y = hextob64u(xy.y);\n\treturn jwk;\n    }\n    throw \"not supported key object\";\n};\n\n\n\n/*! crypto-1.1.10.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013-2016 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1.10 (2016-Oct-29)\n * @since jsrsasign 2.2\n * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n */\n\n/** \n * kjur's class library name space\n * @name KJUR\n * @namespace kjur's class library name space\n */\nif (typeof KJUR == \"undefined\" || !KJUR) KJUR = {};\n/**\n * kjur's cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Cipher} - class for encrypting and decrypting data</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == \"undefined\" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @property {Array} DEFAULTPROVIDER associative array of default provider name for each hash and signature algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t'sha1':      \"3021300906052b0e03021a05000414\",\n        'sha224':    \"302d300d06096086480165030402040500041c\",\n\t'sha256':    \"3031300d060960864801650304020105000420\",\n\t'sha384':    \"3041300d060960864801650304020205000430\",\n\t'sha512':    \"3051300d060960864801650304020305000440\",\n\t'md2':       \"3020300c06082a864886f70d020205000410\",\n\t'md5':       \"3020300c06082a864886f70d020505000410\",\n\t'ripemd160': \"3021300906052b2403020105000414\",\n    };\n\n    /*\n     * @since crypto 1.1.1\n     */\n    this.DEFAULTPROVIDER = {\n\t'md5':\t\t\t'cryptojs',\n\t'sha1':\t\t\t'cryptojs',\n\t'sha224':\t\t'cryptojs',\n\t'sha256':\t\t'cryptojs',\n\t'sha384':\t\t'cryptojs',\n\t'sha512':\t\t'cryptojs',\n\t'ripemd160':\t\t'cryptojs',\n\t'hmacmd5':\t\t'cryptojs',\n\t'hmacsha1':\t\t'cryptojs',\n\t'hmacsha224':\t\t'cryptojs',\n\t'hmacsha256':\t\t'cryptojs',\n\t'hmacsha384':\t\t'cryptojs',\n\t'hmacsha512':\t\t'cryptojs',\n\t'hmacripemd160':\t'cryptojs',\n\n\t'MD5withRSA':\t\t'cryptojs/jsrsa',\n\t'SHA1withRSA':\t\t'cryptojs/jsrsa',\n\t'SHA224withRSA':\t'cryptojs/jsrsa',\n\t'SHA256withRSA':\t'cryptojs/jsrsa',\n\t'SHA384withRSA':\t'cryptojs/jsrsa',\n\t'SHA512withRSA':\t'cryptojs/jsrsa',\n\t'RIPEMD160withRSA':\t'cryptojs/jsrsa',\n\n\t'MD5withECDSA':\t\t'cryptojs/jsrsa',\n\t'SHA1withECDSA':\t'cryptojs/jsrsa',\n\t'SHA224withECDSA':\t'cryptojs/jsrsa',\n\t'SHA256withECDSA':\t'cryptojs/jsrsa',\n\t'SHA384withECDSA':\t'cryptojs/jsrsa',\n\t'SHA512withECDSA':\t'cryptojs/jsrsa',\n\t'RIPEMD160withECDSA':\t'cryptojs/jsrsa',\n\n\t'SHA1withDSA':\t\t'cryptojs/jsrsa',\n\t'SHA224withDSA':\t'cryptojs/jsrsa',\n\t'SHA256withDSA':\t'cryptojs/jsrsa',\n\n\t'MD5withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t'SHA1withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t'SHA224withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t'SHA256withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t'SHA384withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t'SHA512withRSAandMGF1':\t\t'cryptojs/jsrsa',\n\t'RIPEMD160withRSAandMGF1':\t'cryptojs/jsrsa',\n    };\n\n    /*\n     * @since crypto 1.1.2\n     */\n    this.CRYPTOJSMESSAGEDIGESTNAME = {\n\t'md5':\t\tCryptoJS.algo.MD5,\n\t'sha1':\t\tCryptoJS.algo.SHA1,\n\t'sha224':\tCryptoJS.algo.SHA224,\n\t'sha256':\tCryptoJS.algo.SHA256,\n\t'sha384':\tCryptoJS.algo.SHA384,\n\t'sha512':\tCryptoJS.algo.SHA512,\n\t'ripemd160':\tCryptoJS.algo.RIPEMD160\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. 'sha1')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == \"undefined\")\n\t    throw \"alg not supported in Util.DIGESTINFOHEAD: \" + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value of message to be signed\n     * @param {String} alg hash algorithm name (ex. 'sha1')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw \"key is too short for SigAlg: keylen=\" + keySize + \",\" + alg;\n\n\tvar hHead = \"0001\";\n\tvar hTail = \"00\" + hDigestInfo;\n\tvar hMid = \"\";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += \"ff\";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal hash of string with specified algorithm\n     * @name hashString\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @param {String} alg hash algorithm name\n     * @return {String} hexadecimal string of hash value\n     * @since 1.1.1\n     */\n    this.hashString = function(s, alg) {\n        var md = new KJUR.crypto.MessageDigest({'alg': alg});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal hash of hexadecimal string with specified algorithm\n     * @name hashHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} sHex input hexadecimal string to be hashed\n     * @param {String} alg hash algorithm name\n     * @return {String} hexadecimal string of hash value\n     * @since 1.1.1\n     */\n    this.hashHex = function(sHex, alg) {\n        var md = new KJUR.crypto.MessageDigest({'alg': alg});\n        return md.digestHex(sHex);\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({'alg':'sha1', 'prov':'cryptojs'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({'alg':'sha256', 'prov':'cryptojs'});\n        return md.digestString(s);\n    };\n\n    this.sha256Hex = function(s) {\n        var md = new KJUR.crypto.MessageDigest({'alg':'sha256', 'prov':'cryptojs'});\n        return md.digestHex(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({'alg':'sha512', 'prov':'cryptojs'});\n        return md.digestString(s);\n    };\n\n    this.sha512Hex = function(s) {\n        var md = new KJUR.crypto.MessageDigest({'alg':'sha512', 'prov':'cryptojs'});\n        return md.digestHex(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({'alg':'md5', 'prov':'cryptojs'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({'alg':'ripemd160', 'prov':'cryptojs'});\n        return md.digestString(s);\n    };\n\n    /*\n     * @since 1.1.2\n     */\n    this.getCryptoJSMDByName = function(s) {\n\t\n    };\n};\n\n// === Mac ===============================================================\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class<br/>\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @property {Array} HASHLENGTH static Array of resulted byte length of hash (ex. HASHLENGTH[\"sha1\"] == 20)\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * var md = new KJUR.crypto.MessageDigest({alg: \"sha1\", prov: \"cryptojs\"});\n * md.updateString('aaa')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * var md = new KJUR.crypto.MessageDigest({alg: \"sha256\", prov: \"sjcl\"}); // sjcl supports sha256 only\n * md.updateString('aaa')\n * var mdHex = md.digest()\n *\n * // HASHLENGTH property\n * KJUR.crypto.MessageDigest.HASHLENGTH['sha1'] &rarr 20\n * KJUR.crypto.MessageDigest.HASHLENGTH['sha512'] &rarr 64\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n\n    /**\n     * set hash algorithm and provider<br/>\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest#\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * This methods set an algorithm and a cryptographic provider.<br/>\n     * Here is acceptable algorithm names ignoring cases and hyphens:\n     * <ul>\n     * <li>MD5</li>\n     * <li>SHA1</li>\n     * <li>SHA224</li>\n     * <li>SHA256</li>\n     * <li>SHA384</li>\n     * <li>SHA512</li>\n     * <li>RIPEMD160</li>\n     * </ul>\n     * NOTE: Since jsrsasign 6.2.0 crypto 1.1.10, this method ignores\n     * upper or lower cases. Also any hyphens (i.e. \"-\") will be ignored\n     * so that \"SHA1\" or \"SHA-1\" will be acceptable.\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider('sha1', 'cryptojs');\n     * md.setAlgAndProvider('SHA1');\n     * // for RIPEMD160\n     * md.setAlgAndProvider('ripemd160', 'cryptojs');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\talg = KJUR.crypto.MessageDigest.getCanonicalAlgName(alg);\n\n\tif (alg !== null && prov === undefined) prov = KJUR.crypto.Util.DEFAULTPROVIDER[alg];\n\n\t// for cryptojs\n\tif (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(alg) != -1 &&\n\t    prov == 'cryptojs') {\n\t    try {\n\t\tthis.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[alg].create();\n\t    } catch (ex) {\n\t\tthrow \"setAlgAndProvider hash alg set fail alg=\" + alg + \"/\" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (':sha256:'.indexOf(alg) != -1 &&\n\t    prov == 'sjcl') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow \"setAlgAndProvider hash alg set fail alg=\" + alg + \"/\" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest#\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString('New York');\n     */\n    this.updateString = function(str) {\n\tthrow \"updateString(str) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest#\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex('0afe36');\n     */\n    this.updateHex = function(hex) {\n\tthrow \"updateHex(hex) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest#\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow \"digest() not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest#\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString('aaa')\n     */\n    this.digestString = function(str) {\n\tthrow \"digestString(str) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest#\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex('0f2abd')\n     */\n    this.digestHex = function(hex) {\n\tthrow \"digestHex(hex) not supported for this alg/prov: \" + this.algName + \"/\" + this.provName;\n    };\n\n    if (params !== undefined) {\n\tif (params['alg'] !== undefined) {\n\t    this.algName = params['alg'];\n\t    if (params['prov'] === undefined)\n\t\tthis.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];\n\t    this.setAlgAndProvider(this.algName, this.provName);\n\t}\n    }\n};\n\n/**\n * get canonical hash algorithm name<br/>\n * @name getCanonicalAlgName\n * @memberOf KJUR.crypto.MessageDigest\n * @function\n * @param {String} alg hash algorithm name (ex. MD5, SHA-1, SHA1, SHA512 et.al.)\n * @return {String} canonical hash algorithm name\n * @since jsrsasign 6.2.0 crypto 1.1.10\n * @description\n * This static method normalizes from any hash algorithm name such as\n * \"SHA-1\", \"SHA1\", \"MD5\", \"sha512\" to lower case name without hyphens\n * such as \"sha1\".\n * @example\n * KJUR.crypto.MessageDigest.getCanonicalAlgName(\"SHA-1\") &rarr \"sha1\"\n * KJUR.crypto.MessageDigest.getCanonicalAlgName(\"MD5\")   &rarr \"md5\"\n */\nKJUR.crypto.MessageDigest.getCanonicalAlgName = function(alg) {\n    if (typeof alg === \"string\") {\n\talg = alg.toLowerCase();\n\talg = alg.replace(/-/, '');\n    }\n    return alg;\n};\n\n/**\n * get resulted hash byte length for specified algorithm name<br/>\n * @name getHashLength\n * @memberOf KJUR.crypto.MessageDigest\n * @function\n * @param {String} alg non-canonicalized hash algorithm name (ex. MD5, SHA-1, SHA1, SHA512 et.al.)\n * @return {Integer} resulted hash byte length\n * @since jsrsasign 6.2.0 crypto 1.1.10\n * @description\n * This static method returns resulted byte length for specified algorithm name such as \"SHA-1\".\n * @example\n * KJUR.crypto.MessageDigest.getHashLength(\"SHA-1\") &rarr 20\n * KJUR.crypto.MessageDigest.getHashLength(\"sha1\") &rarr 20\n */\nKJUR.crypto.MessageDigest.getHashLength = function(alg) {\n    var MD = KJUR.crypto.MessageDigest\n    var alg2 = MD.getCanonicalAlgName(alg);\n    if (MD.HASHLENGTH[alg2] === undefined)\n\tthrow \"not supported algorithm: \" + alg;\n    return MD.HASHLENGTH[alg2];\n};\n\n// described in KJUR.crypto.MessageDigest class (since jsrsasign 6.2.0 crypto 1.1.10)\nKJUR.crypto.MessageDigest.HASHLENGTH = {\n    'md5':\t\t16,\n    'sha1':\t\t20,\n    'sha224':\t\t28,\n    'sha256':\t\t32,\n    'sha384':\t\t48,\n    'sha512':\t\t64,\n    'ripemd160':\t20\n};\n\n// === Mac ===============================================================\n\n/**\n * Mac(Message Authentication Code) class which is very similar to java.security.Mac class \n * @name KJUR.crypto.Mac\n * @class Mac class which is very similar to java.security.Mac class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>hmacmd5 - cryptojs</li>\n * <li>hmacsha1 - cryptojs</li>\n * <li>hmacsha224 - cryptojs</li>\n * <li>hmacsha256 - cryptojs</li>\n * <li>hmacsha384 - cryptojs</li>\n * <li>hmacsha512 - cryptojs</li>\n * </ul>\n * NOTE: HmacSHA224 and HmacSHA384 issue was fixed since jsrsasign 4.1.4.\n * Please use 'ext/cryptojs-312-core-fix*.js' instead of 'core.js' of original CryptoJS\n * to avoid those issue.\n * <br/>\n * NOTE2: Hmac signature bug was fixed in jsrsasign 4.9.0 by providing CryptoJS\n * bug workaround.\n * <br/>\n * Please see {@link KJUR.crypto.Mac.setPassword}, how to provide password\n * in various ways in detail.\n * @example\n * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA1\", \"pass\": \"pass\"});\n * mac.updateString('aaa')\n * var macHex = md.doFinal()\n *\n * // other password representation \n * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"hex\":  \"6161\"}});\n * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"utf8\": \"aa\"}});\n * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"rstr\": \"\\x61\\x61\"}});\n * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"b64\":  \"Mi02/+...a==\"}});\n * var mac = new KJUR.crypto.Mac({alg: \"HmacSHA256\", \"pass\": {\"b64u\": \"Mi02_-...a\"}});\n */\nKJUR.crypto.Mac = function(params) {\n    var mac = null;\n    var pass = null;\n    var algName = null;\n    var provName = null;\n    var algProv = null;\n\n    this.setAlgAndProvider = function(alg, prov) {\n\talg = alg.toLowerCase();\n\n\tif (alg == null) alg = \"hmacsha1\";\n\n\talg = alg.toLowerCase();\n        if (alg.substr(0, 4) != \"hmac\") {\n\t    throw \"setAlgAndProvider unsupported HMAC alg: \" + alg;\n\t}\n\n\tif (prov === undefined) prov = KJUR.crypto.Util.DEFAULTPROVIDER[alg];\n\tthis.algProv = alg + \"/\" + prov;\n\n\tvar hashAlg = alg.substr(4);\n\n\t// for cryptojs\n\tif (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(hashAlg) != -1 &&\n\t    prov == 'cryptojs') {\n\t    try {\n\t\tvar mdObj = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[hashAlg];\n\t\tthis.mac = CryptoJS.algo.HMAC.create(mdObj, this.pass);\n\t    } catch (ex) {\n\t\tthrow \"setAlgAndProvider hash alg set fail hashAlg=\" + hashAlg + \"/\" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.mac.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.mac.update(wHex);\n\t    };\n\t    this.doFinal = function() {\n\t\tvar hash = this.mac.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.doFinalString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.doFinal();\n\t    };\n\t    this.doFinalHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.doFinal();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.Mac#\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString('New York');\n     */\n    this.updateString = function(str) {\n\tthrow \"updateString(str) not supported for this alg/prov: \" + this.algProv;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Mac#\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex('0afe36');\n     */\n    this.updateHex = function(hex) {\n\tthrow \"updateHex(hex) not supported for this alg/prov: \" + this.algProv;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name doFinal\n     * @memberOf KJUR.crypto.Mac#\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.doFinal = function() {\n\tthrow \"digest() not supported for this alg/prov: \" + this.algProv;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name doFinalString\n     * @memberOf KJUR.crypto.Mac#\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString('aaa')\n     */\n    this.doFinalString = function(str) {\n\tthrow \"digestString(str) not supported for this alg/prov: \" + this.algProv;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, \n     * then completes the digest computation\n     * @name doFinalHex\n     * @memberOf KJUR.crypto.Mac#\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex('0f2abd')\n     */\n    this.doFinalHex = function(hex) {\n\tthrow \"digestHex(hex) not supported for this alg/prov: \" + this.algProv;\n    };\n\n    /**\n     * set password for Mac\n     * @name setPassword\n     * @memberOf KJUR.crypto.Mac#\n     * @function\n     * @param {Object} pass password for Mac\n     * @since crypto 1.1.7 jsrsasign 4.9.0\n     * @description\n     * This method will set password for (H)Mac internally.\n     * Argument 'pass' can be specified as following:\n     * <ul>\n     * <li>even length string of 0..9, a..f or A-F: implicitly specified as hexadecimal string</li>\n     * <li>not above string: implicitly specified as raw string</li>\n     * <li>{rstr: \"\\x65\\x70\"}: explicitly specified as raw string</li>\n     * <li>{hex: \"6570\"}: explicitly specified as hexacedimal string</li>\n     * <li>{utf8: \"秘密\"}: explicitly specified as UTF8 string</li>\n     * <li>{b64: \"Mi78..==\"}: explicitly specified as Base64 string</li>\n     * <li>{b64u: \"Mi7-_\"}: explicitly specified as Base64URL string</li>\n     * </ul>\n     * It is *STRONGLY RECOMMENDED* that explicit representation of password argument\n     * to avoid ambiguity. For example string  \"6161\" can mean a string \"6161\" or \n     * a hexadecimal string of \"aa\" (i.e. \\x61\\x61).\n     * @example\n     * mac = KJUR.crypto.Mac({'alg': 'hmacsha256'});\n     * // set password by implicit raw string\n     * mac.setPassword(\"\\x65\\x70\\xb9\\x0b\");\n     * mac.setPassword(\"password\");\n     * // set password by implicit hexadecimal string\n     * mac.setPassword(\"6570b90b\");\n     * mac.setPassword(\"6570B90B\");\n     * // set password by explicit raw string\n     * mac.setPassword({\"rstr\": \"\\x65\\x70\\xb9\\x0b\"});\n     * // set password by explicit hexadecimal string\n     * mac.setPassword({\"hex\": \"6570b90b\"});\n     * // set password by explicit utf8 string\n     * mac.setPassword({\"utf8\": \"passwordパスワード\");\n     * // set password by explicit Base64 string\n     * mac.setPassword({\"b64\": \"Mb+c3f/==\"});\n     * // set password by explicit Base64URL string\n     * mac.setPassword({\"b64u\": \"Mb-c3f_\"});\n     */\n    this.setPassword = function(pass) {\n\t// internal this.pass shall be CryptoJS DWord Object for CryptoJS bug\n\t// work around. CrytoJS HMac password can be passed by\n\t// raw string as described in the manual however it doesn't\n\t// work properly in some case. If password was passed\n\t// by CryptoJS DWord which is not described in the manual\n\t// it seems to work. (fixed since crypto 1.1.7)\n\n\tif (typeof pass == 'string') {\n\t    var hPass = pass;\n\t    if (pass.length % 2 == 1 || ! pass.match(/^[0-9A-Fa-f]+$/)) { // raw str\n\t\thPass = rstrtohex(pass);\n\t    }\n\t    this.pass = CryptoJS.enc.Hex.parse(hPass);\n\t    return;\n\t}\n\n\tif (typeof pass != 'object')\n\t    throw \"KJUR.crypto.Mac unsupported password type: \" + pass;\n\t\n\tvar hPass = null;\n\tif (pass.hex  !== undefined) {\n\t    if (pass.hex.length % 2 != 0 || ! pass.hex.match(/^[0-9A-Fa-f]+$/))\n\t\tthrow \"Mac: wrong hex password: \" + pass.hex;\n\t    hPass = pass.hex;\n\t}\n\tif (pass.utf8 !== undefined) hPass = utf8tohex(pass.utf8);\n\tif (pass.rstr !== undefined) hPass = rstrtohex(pass.rstr);\n\tif (pass.b64  !== undefined) hPass = b64tohex(pass.b64);\n\tif (pass.b64u !== undefined) hPass = b64utohex(pass.b64u);\n\n\tif (hPass == null)\n\t    throw \"KJUR.crypto.Mac unsupported password type: \" + pass;\n\n\tthis.pass = CryptoJS.enc.Hex.parse(hPass);\n    };\n\n    if (params !== undefined) {\n\tif (params.pass !== undefined) {\n\t    this.setPassword(params.pass);\n\t}\n\tif (params.alg !== undefined) {\n\t    this.algName = params.alg;\n\t    if (params['prov'] === undefined)\n\t\tthis.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];\n\t    this.setAlgAndProvider(this.algName, this.provName);\n\t}\n    }\n};\n\n// ====== Signature class =========================================================\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether 'SIGN', 'VERIFY' or null\n * @description\n * <br/>\n * As for params of constructor's argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}with{RSA,ECDSA,DSA})</li>\n * <li>provider - currently 'cryptojs/jsrsa' only</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * This Signature class supports following signature algorithm and provider names:\n * <ul>\n * <li>MD5withRSA - cryptojs/jsrsa</li>\n * <li>SHA1withRSA - cryptojs/jsrsa</li>\n * <li>SHA224withRSA - cryptojs/jsrsa</li>\n * <li>SHA256withRSA - cryptojs/jsrsa</li>\n * <li>SHA384withRSA - cryptojs/jsrsa</li>\n * <li>SHA512withRSA - cryptojs/jsrsa</li>\n * <li>RIPEMD160withRSA - cryptojs/jsrsa</li>\n * <li>MD5withECDSA - cryptojs/jsrsa</li>\n * <li>SHA1withECDSA - cryptojs/jsrsa</li>\n * <li>SHA224withECDSA - cryptojs/jsrsa</li>\n * <li>SHA256withECDSA - cryptojs/jsrsa</li>\n * <li>SHA384withECDSA - cryptojs/jsrsa</li>\n * <li>SHA512withECDSA - cryptojs/jsrsa</li>\n * <li>RIPEMD160withECDSA - cryptojs/jsrsa</li>\n * <li>MD5withRSAandMGF1 - cryptojs/jsrsa</li>\n * <li>SHA1withRSAandMGF1 - cryptojs/jsrsa</li>\n * <li>SHA224withRSAandMGF1 - cryptojs/jsrsa</li>\n * <li>SHA256withRSAandMGF1 - cryptojs/jsrsa</li>\n * <li>SHA384withRSAandMGF1 - cryptojs/jsrsa</li>\n * <li>SHA512withRSAandMGF1 - cryptojs/jsrsa</li>\n * <li>RIPEMD160withRSAandMGF1 - cryptojs/jsrsa</li>\n * <li>SHA1withDSA - cryptojs/jsrsa</li>\n * <li>SHA224withDSA - cryptojs/jsrsa</li>\n * <li>SHA256withDSA - cryptojs/jsrsa</li>\n * </ul>\n * Here are supported elliptic cryptographic curve names and their aliases for ECDSA:\n * <ul>\n * <li>secp256k1</li>\n * <li>secp256r1, NIST P-256, P-256, prime256v1</li>\n * <li>secp384r1, NIST P-384, P-384</li>\n * </ul>\n * NOTE1: DSA signing algorithm is also supported since crypto 1.1.5.\n * <h4>EXAMPLES</h4>\n * @example\n * // RSA signature generation\n * var sig = new KJUR.crypto.Signature({\"alg\": \"SHA1withRSA\"});\n * sig.init(prvKeyPEM);\n * sig.updateString('aaa');\n * var hSigVal = sig.sign();\n *\n * // DSA signature validation\n * var sig2 = new KJUR.crypto.Signature({\"alg\": \"SHA1withDSA\"});\n * sig2.init(certPEM);\n * sig.updateString('aaa');\n * var isValid = sig2.verify(hSigVal);\n * \n * // ECDSA signing\n * var sig = new KJUR.crypto.Signature({'alg':'SHA1withECDSA'});\n * sig.init(prvKeyPEM);\n * sig.updateString('aaa');\n * var sigValueHex = sig.sign();\n *\n * // ECDSA verifying\n * var sig2 = new KJUR.crypto.Signature({'alg':'SHA1withECDSA'});\n * sig.init(certPEM);\n * sig.updateString('aaa');\n * var isValid = sig.verify(sigValueHex);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey/KJUR.crypto.{ECDSA,DSA} object for signing\n    var pubKey = null; // RSAKey/KJUR.crypto.{ECDSA,DSA} object for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\t// rsa,ecdsa,rsaandmgf1(=rsapss)\n    var state = null;\n    var pssSaltLen = -1;\n    var initParams = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n    var matchResult = this.algName.match(/^(.+)with(.+)$/);\n\tif (matchResult) {\n\t    this.mdAlgName = matchResult[1].toLowerCase();\n\t    this.pubkeyAlgName = matchResult[2].toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = \"\";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + \"0\";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider('SHA1withRSA', 'cryptojs/jsrsa');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != 'cryptojs/jsrsa')\n\t    throw \"provider not supported: \" + prov;\n\n\tif (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({'alg':this.mdAlgName});\n\t    } catch (ex) {\n\t\tthrow \"setAlgAndProvider hash alg set fail alg=\" +\n                      this.mdAlgName + \"/\" + ex;\n\t    }\n\n\t    this.init = function(keyparam, pass) {\n\t\tvar keyObj = null;\n\t\ttry {\n\t\t    if (pass === undefined) {\n\t\t\tkeyObj = KEYUTIL.getKey(keyparam);\n\t\t    } else {\n\t\t\tkeyObj = KEYUTIL.getKey(keyparam, pass);\n\t\t    }\n\t\t} catch (ex) {\n\t\t    throw \"init failed:\" + ex;\n\t\t}\n\n\t\tif (keyObj.isPrivate === true) {\n\t\t    this.prvKey = keyObj;\n\t\t    this.state = \"SIGN\";\n\t\t} else if (keyObj.isPublic === true) {\n\t\t    this.pubKey = keyObj;\n\t\t    this.state = \"VERIFY\";\n\t\t} else {\n\t\t    throw \"init failed.:\" + keyObj;\n\t\t}\n\t    };\n\n\t    this.initSign = function(params) {\n\t\tif (typeof params['ecprvhex'] == 'string' &&\n                    typeof params['eccurvename'] == 'string') {\n\t\t    this.ecprvhex = params['ecprvhex'];\n\t\t    this.eccurvename = params['eccurvename'];\n\t\t} else {\n\t\t    this.prvKey = params;\n\t\t}\n\t\tthis.state = \"SIGN\";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(params) {\n\t\tif (typeof params['ecpubhex'] == 'string' &&\n\t\t    typeof params['eccurvename'] == 'string') {\n\t\t    this.ecpubhex = params['ecpubhex'];\n\t\t    this.eccurvename = params['eccurvename'];\n\t\t} else if (params instanceof KJUR.crypto.ECDSA) {\n\t\t    this.pubKey = params;\n\t\t} else if (params instanceof RSAKey) {\n\t\t    this.pubKey = params;\n\t\t}\n\t\tthis.state = \"VERIFY\";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = \"VERIFY\";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\n\t    this.sign = function() {\n\t\tthis.sHashHex = this.md.digest();\n\t\tif (typeof this.ecprvhex != \"undefined\" &&\n\t\t    typeof this.eccurvename != \"undefined\") {\n\t\t    var ec = new KJUR.crypto.ECDSA({'curve': this.eccurvename});\n\t\t    this.hSign = ec.signHex(this.sHashHex, this.ecprvhex);\n\t\t} else if (this.prvKey instanceof RSAKey &&\n\t\t           this.pubkeyAlgName == \"rsaandmgf1\") {\n\t\t    this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex,\n\t\t\t\t\t\t\t\t    this.mdAlgName,\n\t\t\t\t\t\t\t\t    this.pssSaltLen);\n\t\t} else if (this.prvKey instanceof RSAKey &&\n\t\t\t   this.pubkeyAlgName == \"rsa\") {\n\t\t    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex,\n\t\t\t\t\t\t\t\t this.mdAlgName);\n\t\t} else if (this.prvKey instanceof KJUR.crypto.ECDSA) {\n\t\t    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);\n\t\t} else if (this.prvKey instanceof KJUR.crypto.DSA) {\n\t\t    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);\n\t\t} else {\n\t\t    throw \"Signature: unsupported public key alg: \" + this.pubkeyAlgName;\n\t\t}\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n\t        this.sHashHex = this.md.digest();\n\t\tif (typeof this.ecpubhex != \"undefined\" &&\n\t\t    typeof this.eccurvename != \"undefined\") {\n\t\t    var ec = new KJUR.crypto.ECDSA({curve: this.eccurvename});\n\t\t    return ec.verifyHex(this.sHashHex, hSigVal, this.ecpubhex);\n\t\t} else if (this.pubKey instanceof RSAKey &&\n\t\t\t   this.pubkeyAlgName == \"rsaandmgf1\") {\n\t\t    return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, hSigVal, \n\t\t\t\t\t\t\t\tthis.mdAlgName,\n\t\t\t\t\t\t\t\tthis.pssSaltLen);\n\t\t} else if (this.pubKey instanceof RSAKey &&\n\t\t\t   this.pubkeyAlgName == \"rsa\") {\n\t\t    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);\n\t\t} else if (this.pubKey instanceof KJUR.crypto.ECDSA) {\n\t\t    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);\n\t\t} else if (this.pubKey instanceof KJUR.crypto.DSA) {\n\t\t    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);\n\t\t} else {\n\t\t    throw \"Signature: unsupported public key alg: \" + this.pubkeyAlgName;\n\t\t}\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for signing or verifying depends on key\n     * @name init\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {Object} key specifying public or private key as plain/encrypted PKCS#5/8 PEM file, certificate PEM or {@link RSAKey}, {@link KJUR.crypto.DSA} or {@link KJUR.crypto.ECDSA} object\n     * @param {String} pass (OPTION) passcode for encrypted private key\n     * @since crypto 1.1.3\n     * @description\n     * This method is very useful initialize method for Signature class since\n     * you just specify key then this method will automatically initialize it\n     * using {@link KEYUTIL.getKey} method.\n     * As for 'key',  following argument type are supported:\n     * <h5>signing</h5>\n     * <ul>\n     * <li>PEM formatted PKCS#8 encrypted RSA/ECDSA private key concluding \"BEGIN ENCRYPTED PRIVATE KEY\"</li>\n     * <li>PEM formatted PKCS#5 encrypted RSA/DSA private key concluding \"BEGIN RSA/DSA PRIVATE KEY\" and \",ENCRYPTED\"</li>\n     * <li>PEM formatted PKCS#8 plain RSA/ECDSA private key concluding \"BEGIN PRIVATE KEY\"</li>\n     * <li>PEM formatted PKCS#5 plain RSA/DSA private key concluding \"BEGIN RSA/DSA PRIVATE KEY\" without \",ENCRYPTED\"</li>\n     * <li>RSAKey object of private key</li>\n     * <li>KJUR.crypto.ECDSA object of private key</li>\n     * <li>KJUR.crypto.DSA object of private key</li>\n     * </ul>\n     * <h5>verification</h5>\n     * <ul>\n     * <li>PEM formatted PKCS#8 RSA/EC/DSA public key concluding \"BEGIN PUBLIC KEY\"</li>\n     * <li>PEM formatted X.509 certificate with RSA/EC/DSA public key concluding\n     *     \"BEGIN CERTIFICATE\", \"BEGIN X509 CERTIFICATE\" or \"BEGIN TRUSTED CERTIFICATE\".</li>\n     * <li>RSAKey object of public key</li>\n     * <li>KJUR.crypto.ECDSA object of public key</li>\n     * <li>KJUR.crypto.DSA object of public key</li>\n     * </ul>\n     * @example\n     * sig.init(sCertPEM)\n     */\n    this.init = function(key, pass) {\n\tthrow \"init(key, pass) not supported for this alg:prov=\" +\n\t      this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {Object} param RSAKey object of public key or associative array for ECDSA\n     * @since 1.0.2\n     * @deprecated from crypto 1.1.5. please use init() method instead.\n     * @description\n     * Public key information will be provided as 'param' parameter and the value will be\n     * following:\n     * <ul>\n     * <li>{@link RSAKey} object for RSA verification</li>\n     * <li>associative array for ECDSA verification\n     *     (ex. <code>{'ecpubhex': '041f..', 'eccurvename': 'secp256r1'}</code>)\n     * </li>\n     * </ul>\n     * @example\n     * sig.initVerifyByPublicKey(rsaPrvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow \"initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=\" +\n\t      this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @deprecated from crypto 1.1.5. please use init() method instead.\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow \"initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=\" +\n\t    this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {Object} param RSAKey object of public key or associative array for ECDSA\n     * @deprecated from crypto 1.1.5. please use init() method instead.\n     * @description\n     * Private key information will be provided as 'param' parameter and the value will be\n     * following:\n     * <ul>\n     * <li>{@link RSAKey} object for RSA signing</li>\n     * <li>associative array for ECDSA signing\n     *     (ex. <code>{'ecprvhex': '1d3f..', 'eccurvename': 'secp256r1'}</code>)</li>\n     * </ul>\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow \"initSign(prvKey) not supported for this alg:prov=\" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString('aaa')\n     */\n    this.updateString = function(str) {\n\tthrow \"updateString(str) not supported for this alg:prov=\" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex('1f2f3f')\n     */\n    this.updateHex = function(hex) {\n\tthrow \"updateHex(hex) not supported for this alg:prov=\" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow \"sign() not supported for this alg:prov=\" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString('aaa')\n     */\n    this.signString = function(str) {\n\tthrow \"digestString(str) not supported for this alg:prov=\" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex('1fdc33')\n     */\n    this.signHex = function(hex) {\n\tthrow \"digestHex(hex) not supported for this alg:prov=\" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature#\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify('1fbcefdca4823a7(snip)')\n     */\n    this.verify = function(hSigVal) {\n\tthrow \"verify(hSigVal) not supported for this alg:prov=\" + this.algProvName;\n    };\n\n    this.initParams = params;\n\n    if (params !== undefined) {\n\tif (params['alg'] !== undefined) {\n\t    this.algName = params['alg'];\n\t    if (params['prov'] === undefined) {\n\t\tthis.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];\n\t    } else {\n\t\tthis.provName = params['prov'];\n\t    }\n\t    this.algProvName = this.algName + \":\" + this.provName;\n\t    this.setAlgAndProvider(this.algName, this.provName);\n\t    this._setAlgNames();\n\t}\n\n\tif (params['psssaltlen'] !== undefined) this.pssSaltLen = params['psssaltlen'];\n\n\tif (params['prvkeypem'] !== undefined) {\n\t    if (params['prvkeypas'] !== undefined) {\n\t\tthrow \"both prvkeypem and prvkeypas parameters not supported\";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params['prvkeypem']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw \"fatal error to load pem private key: \" + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\n\n// ====== Cipher class ============================================================\n/**\n * Cipher class to encrypt and decrypt data<br/>\n * @name KJUR.crypto.Cipher\n * @class Cipher class to encrypt and decrypt data<br/>\n * @param {Array} params parameters for constructor\n * @since jsrsasign 6.2.0 crypto 1.1.10\n * @description\n * Here is supported canonicalized cipher algorithm names and its standard names:\n * <ul>\n * <li>RSA - RSA/ECB/PKCS1Padding (default for RSAKey)</li>\n * <li>RSAOAEP - RSA/ECB/OAEPWithSHA-1AndMGF1Padding</li>\n * <li>RSAOAEP224 - RSA/ECB/OAEPWithSHA-224AndMGF1Padding(*)</li>\n * <li>RSAOAEP256 - RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li>\n * <li>RSAOAEP384 - RSA/ECB/OAEPWithSHA-384AndMGF1Padding(*)</li>\n * <li>RSAOAEP512 - RSA/ECB/OAEPWithSHA-512AndMGF1Padding(*)</li>\n * </ul>\n * NOTE: (*) is not supported in Java JCE.<br/>\n * Currently this class supports only RSA encryption and decryption. \n * However it is planning to implement also symmetric ciphers near in the future.\n * @example\n */\nKJUR.crypto.Cipher = function(params) {\n};\n\n/**\n * encrypt raw string by specified key and algorithm<br/>\n * @name encrypt\n * @memberOf KJUR.crypto.Cipher\n * @function\n * @param {String} s input string to encrypt\n * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key\n * @param {String} algName short/long algorithm name for encryption/decryption\n * @return {String} hexadecimal encrypted string\n * @since jsrsasign 6.2.0 crypto 1.1.10\n * @description\n * This static method encrypts raw string with specified key and algorithm.\n * @example \n * KJUR.crypto.Cipher.encrypt(\"aaa\", pubRSAKeyObj) &rarr; \"1abc2d...\"\n * KJUR.crypto.Cipher.encrypt(\"aaa\", pubRSAKeyObj, \"RSAOAEP) &rarr; \"23ab02...\"\n */\nKJUR.crypto.Cipher.encrypt = function(s, keyObj, algName) {\n    if (keyObj instanceof RSAKey && keyObj.isPublic) {\n\tvar algName2 = KJUR.crypto.Cipher.getAlgByKeyAndName(keyObj, algName);\n\tif (algName2 === \"RSA\") return keyObj.encrypt(s);\n\tif (algName2 === \"RSAOAEP\") return keyObj.encryptOAEP(s, \"sha1\");\n\n\tvar a = algName2.match(/^RSAOAEP(\\d+)$/);\n\tif (a !== null) return keyObj.encryptOAEP(s, \"sha\" + a[1]);\n\n\tthrow \"Cipher.encrypt: unsupported algorithm for RSAKey: \" + algName;\n    } else {\n\tthrow \"Cipher.encrypt: unsupported key or algorithm\";\n    }\n};\n\n/**\n * decrypt encrypted hexadecimal string with specified key and algorithm<br/>\n * @name decrypt\n * @memberOf KJUR.crypto.Cipher\n * @function\n * @param {String} hex hexadecial string of encrypted message\n * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key\n * @param {String} algName short/long algorithm name for encryption/decryption\n * @return {String} hexadecimal encrypted string\n * @since jsrsasign 6.2.0 crypto 1.1.10\n * @description\n * This static method decrypts encrypted hexadecimal string with specified key and algorithm.\n * @example \n * KJUR.crypto.Cipher.decrypt(\"aaa\", prvRSAKeyObj) &rarr; \"1abc2d...\"\n * KJUR.crypto.Cipher.decrypt(\"aaa\", prvRSAKeyObj, \"RSAOAEP) &rarr; \"23ab02...\"\n */\nKJUR.crypto.Cipher.decrypt = function(hex, keyObj, algName) {\n    if (keyObj instanceof RSAKey && keyObj.isPrivate) {\n\tvar algName2 = KJUR.crypto.Cipher.getAlgByKeyAndName(keyObj, algName);\n\tif (algName2 === \"RSA\") return keyObj.decrypt(hex);\n\tif (algName2 === \"RSAOAEP\") return keyObj.decryptOAEP(hex, \"sha1\");\n\n\tvar a = algName2.match(/^RSAOAEP(\\d+)$/);\n\tif (a !== null) return keyObj.decryptOAEP(hex, \"sha\" + a[1]);\n\n\tthrow \"Cipher.decrypt: unsupported algorithm for RSAKey: \" + algName;\n    } else {\n\tthrow \"Cipher.decrypt: unsupported key or algorithm\";\n    }\n};\n\n/**\n * get canonicalized encrypt/decrypt algorithm name by key and short/long algorithm name<br/>\n * @name getAlgByKeyAndName\n * @memberOf KJUR.crypto.Cipher\n * @function\n * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key\n * @param {String} algName short/long algorithm name for encryption/decryption\n * @return {String} canonicalized algorithm name for encryption/decryption\n * @since jsrsasign 6.2.0 crypto 1.1.10\n * @description\n * Here is supported canonicalized cipher algorithm names and its standard names:\n * <ul>\n * <li>RSA - RSA/ECB/PKCS1Padding (default for RSAKey)</li>\n * <li>RSAOAEP - RSA/ECB/OAEPWithSHA-1AndMGF1Padding</li>\n * <li>RSAOAEP224 - RSA/ECB/OAEPWithSHA-224AndMGF1Padding(*)</li>\n * <li>RSAOAEP256 - RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li>\n * <li>RSAOAEP384 - RSA/ECB/OAEPWithSHA-384AndMGF1Padding(*)</li>\n * <li>RSAOAEP512 - RSA/ECB/OAEPWithSHA-512AndMGF1Padding(*)</li>\n * </ul>\n * NOTE: (*) is not supported in Java JCE.\n * @example \n * KJUR.crypto.Cipher.getAlgByKeyAndName(objRSAKey) &rarr; \"RSA\"\n * KJUR.crypto.Cipher.getAlgByKeyAndName(objRSAKey, \"RSAOAEP\") &rarr; \"RSAOAEP\"\n */\nKJUR.crypto.Cipher.getAlgByKeyAndName = function(keyObj, algName) {\n    if (keyObj instanceof RSAKey) {\n\tif (\":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:\".indexOf(algName) != -1)\n\t    return algName;\n\tif (algName === null || algName === undefined) return \"RSA\";\n\tthrow \"getAlgByKeyAndName: not supported algorithm name for RSAKey: \" + algName;\n    }\n    throw \"getAlgByKeyAndName: not supported algorithm name: \" + algName;\n}\n\n// ====== Other Utility class =====================================================\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.OID\n * @class static object for cryptography related OIDs\n * @property {Array} oidhex2name key value of hexadecimal OID and its name\n *           (ex. '2a8648ce3d030107' and 'secp256r1')\n * @since crypto 1.1.3\n * @description\n */\nKJUR.crypto.OID = new function() {\n    this.oidhex2name = {\n\t'2a864886f70d010101': 'rsaEncryption',\n\t'2a8648ce3d0201': 'ecPublicKey',\n\t'2a8648ce380401': 'dsa',\n\t'2a8648ce3d030107': 'secp256r1',\n\t'2b8104001f': 'secp192k1',\n\t'2b81040021': 'secp224r1',\n\t'2b8104000a': 'secp256k1',\n\t'2b81040023': 'secp521r1',\n\t'2b81040022': 'secp384r1',\n\t'2a8648ce380403': 'SHA1withDSA', // 1.2.840.10040.4.3\n\t'608648016503040301': 'SHA224withDSA', // 2.16.840.1.101.3.4.3.1\n\t'608648016503040302': 'SHA256withDSA', // 2.16.840.1.101.3.4.3.2\n    };\n};\n\n/*! rsasign-1.2.7.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * rsa-sign.js - adding signing functions to RSAKey class.\n *\n * version: 1.2.7 (2013 Aug 25)\n *\n * Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license/\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version rsasign 1.2.7\n * @license <a href=\"http://kjur.github.io/jsrsasign/license/\">MIT License</a>\n */\n\nvar _RE_HEXDECONLY = new RegExp(\"\");\n_RE_HEXDECONLY.compile(\"[^0-9a-f]\", \"gi\");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var hashFunc = function(s) { return KJUR.crypto.Util.hashString(s, hashAlg); };\n    var sHashHex = hashFunc(s);\n\n    return KJUR.crypto.Util.getPaddedDigestInfoHex(sHashHex, hashAlg, keySize);\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = \"\";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + \"0\";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    var hashFunc = function(s) { return KJUR.crypto.Util.hashString(s, hashAlg); };\n    var sHashHex = hashFunc(s);\n\n    return this.signWithMessageHash(sHashHex, hashAlg);\n}\n\n/**\n * sign hash value of message to be signed with RSA private key.<br/>\n * @name signWithMessageHash\n * @memberOf RSAKey\n * @function\n * @param {String} sHashHex hexadecimal string of hash value of message to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n * @since rsasign 1.2.6\n */\nfunction _rsasign_signWithMessageHash(sHashHex, hashAlg) {\n    var hPM = KJUR.crypto.Util.getPaddedDigestInfoHex(sHashHex, hashAlg, this.n.bitLength());\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, 'sha1');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, 'sha256');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = '', i = 0;\n\n    while (mask.length < len) {\n        mask += hextorstr(hash(rstrtohex(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]))));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.\n * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n *        There are two special values:\n *        <ul>\n *        <li>-1: sets the salt length to the digest length</li>\n *        <li>-2: sets the salt length to maximum permissible value\n *           (i.e. keybytelen - hashbytelen - 2)</li>\n *        </ul>\n *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); } \n    var hHash = hashFunc(rstrtohex(s));\n\n    if (sLen === undefined) sLen = -1;\n    return this.signWithMessageHashPSS(hHash, hashAlg, sLen);\n}\n\n/**\n * sign hash value of message with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signWithMessageHashPSS\n * @memberOf RSAKey\n * @function\n * @param {String} hHash hexadecimal hash value of message to be signed.\n * @param {String} hashAlg hash algorithm name for signing.\n * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n *        There are two special values:\n *        <ul>\n *        <li>-1: sets the salt length to the digest length</li>\n *        <li>-2: sets the salt length to maximum permissible value\n *           (i.e. keybytelen - hashbytelen - 2)</li>\n *        </ul>\n *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)\n * @return returns hexadecimal string of signature value.\n * @since rsasign 1.2.6\n */\nfunction _rsasign_signWithMessageHashPSS(hHash, hashAlg, sLen) {\n    var mHash = hextorstr(hHash);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); } \n\n    if (sLen === -1 || sLen === undefined) {\n        sLen = hLen; // same as hash length\n    } else if (sLen === -2) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw \"invalid salt length\";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw \"data too long\";\n    }\n\n    var salt = '';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hextorstr(hashFunc(rstrtohex('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' + mHash + salt)));\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + '\\x01' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(maskedDB)).toString(16),\n\t\t\t\t   this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in KJUR.crypto.Util.DIGESTINFOHEAD) {\n\tvar head = KJUR.crypto.Util.DIGESTINFOHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = function(s) { return KJUR.crypto.Util.hashString(s, algName); };\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, '');\n    hSig = hSig.replace(/[ \\n]+/g, \"\");\n    var biSig = parseBigInt(hSig, 16);\n    if (biSig.bitLength() > this.n.bitLength()) return 0;\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n  \n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = function(s) { return KJUR.crypto.Util.hashString(s, algName); };\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyWithMessageHash\n * @memberOf RSAKey\n * @function\n * @param {String} sHashHex hexadecimal hash value of message to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n * @since rsasign 1.2.6\n */\nfunction _rsasign_verifyWithMessageHash(sHashHex, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, '');\n    hSig = hSig.replace(/[ \\n]+/g, \"\");\n    var biSig = parseBigInt(hSig, 16);\n    if (biSig.bitLength() > this.n.bitLength()) return 0;\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n  \n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    return (diHashValue == sHashHex);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of signature value\n * @param {String} hashAlg hash algorithm name\n * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n *        There are two special values:\n *        <ul>\n *        <li>-1: sets the salt length to the digest length</li>\n *        <li>-2: sets the salt length to maximum permissible value\n *           (i.e. keybytelen - hashbytelen - 2)</li>\n *        </ul>\n *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)\n * @return returns true if valid, otherwise false\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); };\n    var hHash = hashFunc(rstrtohex(sMsg));\n\n    if (sLen === undefined) sLen = -1;\n    return this.verifyWithMessageHashPSS(hHash, hSig, hashAlg, sLen);\n}\n\n/**\n * verifies a sigature for a hash value of message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyWithMessageHashPSS\n * @memberOf RSAKey\n * @function\n * @param {String} hHash hexadecimal hash value of message string to be verified.\n * @param {String} hSig hexadecimal string of signature value\n * @param {String} hashAlg hash algorithm name\n * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).\n *        There are two special values:\n *        <ul>\n *        <li>-1: sets the salt length to the digest length</li>\n *        <li>-2: sets the salt length to maximum permissible value\n *           (i.e. keybytelen - hashbytelen - 2)</li>\n *        </ul>\n *        DEFAULT is -1 (NOTE: OpenSSL's default is -2.)\n * @return returns true if valid, otherwise false\n * @since rsasign 1.2.6\n */\nfunction _rsasign_verifyWithMessageHashPSS(hHash, hSig, hashAlg, sLen) {\n    var biSig = new BigInteger(hSig, 16);\n\n    if (biSig.bitLength() > this.n.bitLength()) {\n        return false;\n    }\n\n    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); };\n    var mHash = hextorstr(hHash);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1 || sLen === undefined) {\n        sLen = hLen; // same as hash length\n    } else if (sLen === -2) {\n        sLen = emLen - hLen - 2; // recover\n    } else if (sLen < -2) {\n        throw \"invalid salt length\";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw \"data too long\";\n    }\n\n    var em = this.doPublic(biSig).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw \"encoded message does not end in 0xbc\";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw \"bits beyond keysize not zero\";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw \"leftmost octets not zero\";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw \"0x01 marker not found\";\n    }\n\n    return H === hextorstr(hashFunc(rstrtohex('\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' + mHash +\n\t\t\t\t     String.fromCharCode.apply(String, DB.slice(-sLen)))));\n}\n\nRSAKey.prototype.signWithMessageHash = _rsasign_signWithMessageHash;\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\n\nRSAKey.prototype.signWithMessageHashPSS = _rsasign_signWithMessageHashPSS;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyWithMessageHash = _rsasign_verifyWithMessageHash;\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\n\nRSAKey.prototype.verifyWithMessageHashPSS = _rsasign_verifyWithMessageHashPSS;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu's RSA Key class and extension\n */\n\nmodule.exports = KJUR;\nmodule.exports.KEYUTIL = KEYUTIL;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../.tmp/lib/jsrsasign.js\n// module id = 0\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/buffer/index.js\n// module id = 1\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/base64-js/index.js\n// module id = 2\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/ieee754/index.js\n// module id = 3\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/isarray/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}