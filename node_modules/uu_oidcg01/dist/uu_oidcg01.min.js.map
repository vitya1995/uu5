{"version":3,"sources":["webpack:///uu_oidcg01@3.2.3/srcwebpack/universalModuleDefinition","webpack:///uu_oidcg01@3.2.3/srcuu_oidcg01.min.js","webpack:///uu_oidcg01@3.2.3/srcwebpack/bootstrap c740a437a4bd8980249f","webpack:///uu_oidcg01@3.2.3/src../.tmp/index.js","webpack:///uu_oidcg01@3.2.3/srcexternal {\"amd\":\"uu_appg01_core\",\"commonjs\":\"uu_appg01_core\",\"commonjs2\":\"uu_appg01_core\",\"root\":\"UuApp\"}","webpack:///uu_oidcg01@3.2.3/src./discovery/Discovery.js","webpack:///uu_oidcg01@3.2.3/src./Session.js","webpack:///uu_oidcg01@3.2.3/src./flow/ImplicitFlow.js","webpack:///uu_oidcg01@3.2.3/src./jwt/InvalidTokenError.js","webpack:///uu_oidcg01@3.2.3/src./ui/IframeComponent.js","webpack:///uu_oidcg01@3.2.3/src./util/PromiseUtil.js","webpack:///uu_oidcg01@3.2.3/src./ui/CallbackHandler.js","webpack:///uu_oidcg01@3.2.3/src./util/Base64Url.js","webpack:///uu_oidcg01@3.2.3/src./util/Dom.js","webpack:///uu_oidcg01@3.2.3/src./util/HttpClient.js","webpack:///uu_oidcg01@3.2.3/src./util/StringUtil.js","webpack:///uu_oidcg01@3.2.3/srcexternal {\"amd\":\"module\",\"commonjs\":\"module\",\"commonjs2\":\"module\",\"root\":\"undefined\"}","webpack:///uu_oidcg01@3.2.3/src./Defaults.js","webpack:///uu_oidcg01@3.2.3/src./SessionContext.js","webpack:///uu_oidcg01@3.2.3/src./SessionHandler.js","webpack:///uu_oidcg01@3.2.3/src./SessionStateChangeNotifier.js","webpack:///uu_oidcg01@3.2.3/src./bootstrap-session.js","webpack:///uu_oidcg01@3.2.3/src./index.js","webpack:///uu_oidcg01@3.2.3/src./jwks/Jwks.js","webpack:///uu_oidcg01@3.2.3/src./jwt/Jwt.js","webpack:///uu_oidcg01@3.2.3/src./jwt/JwtVerifierJsrsasign.js","webpack:///uu_oidcg01@3.2.3/src./jwt/JwtVerifierWebCrypto.js","webpack:///uu_oidcg01@3.2.3/src./ui/PopupComponent.js","webpack:///uu_oidcg01@3.2.3/src./util/Uuid.js","webpack:///uu_oidcg01@3.2.3/src./uuos8/Os8Auth.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_13__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","mod","uri","document","currentScript","Array","prototype","slice","getElementsByTagName","src","toString","split","join","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_HttpClient","_HttpClient2","_PromiseUtil","_PromiseUtil2","oidcMetadataCache","Discovery","getMetadata","aIssuerUri","issuerUri","replace","metadata","discoveryEndpoint","getMetadataUri","wrapForImmediateThen","get","catch","e","_classCallCheck","instance","Constructor","TypeError","toFullUrl","path","a","createElement","href","toTimeString","date","getHours","substr","getMinutes","getSeconds","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","_uu_appg01_core","_Defaults","_Defaults2","_ImplicitFlow","_ImplicitFlow2","_SessionContext","_SessionContext2","_Uuid","_Uuid2","_Os8Auth","_Os8Auth2","_StringUtil","_StringUtil2","_IframeComponent","_IframeComponent2","_SessionStateChangeNotifier","_SessionStateChangeNotifier2","_Discovery","_Discovery2","UuAppError","Error","logger","Logging","LoggerFactory","Session","options","_this","_optionsMergedPromise","Promise","resolve","initPromise","then","env","keys","forEach","k","v","clientId","implicitFlowRedirectUri","match","baseUrl","baseURI","location","pathname","charAt","sessionExpiringNotificationTime","sessionCheckInterval","tokenRefreshLeeway","tokenRefreshFailureRetryInterval","Math","max","_sessionChecker","onStateChange","debug","isAuthenticated","_silentTokenRefresh","_loginInProgress","_silentTokenRefreshInProgress","nonce","random","listeners","addListener","eventName","listener","list","push","removeListener","bind","idx","indexOf","splice","_runListeners","data","type","it","_loginCtx","addIdentityChangeListener","removeIdentityChangeListener","authResponse","session_expires_in","session_expires_at","floor","Date","now","Number","_autoLogoutTimeout","clearTimeout","expiresAt","getClaims","getTime","delay","setTimeout","_localLogout","lastTokenRefreshTime","tokenRefreshEnabled","_sessionRefreshTimeout","claims","LEEWAY_MILLIS","wasExtended","_activeSessionExpiresAtMillis","_sessionExpiringBlocked","prevIdentity","undefined","_sessionExpiringTimeout","newIdentity","getIdentity","opts","reduce","r","toSnakeCase","_login","canUpdateSessionWithLoginResultFn","os8Token","_this2","assign","token_type_hint","access_token","accessToken","doLogin","useCurrent","acr_values","identity","every","loginLevelOfAssurance","isAuthResponseExpired","id_token","state","authResponsePromise","immediateThen","os8Auth","serverUri","redirectUri","grantExchangeToken","subject_token","navigator","standalone","search","hash","login","loginParams","reject","validateAuthResponse","_ref","currentSession","aSkipIfPlanned","_this3","_silentTokenRefreshTimeout","invocationCount","doSilentRenew","prompt","_ref2","sub","err","error","isLoggedOutError","console","warn","_this4","logoutCallbackUri","logoutUrl","end_session_endpoint","encodeURIComponent","url","onResult","result","message","render","callUri","tokenType","token_type","token","allowAutoInitSession","Util","Config","initComplete","set","finalizeInit","isOk","log","_finalizeInit","_typeof","Symbol","iterator","constructor","_PopupComponent","_PopupComponent2","_Jwt","_Jwt2","_InvalidTokenError","_InvalidTokenError2","_Jwks","_Jwks2","GRACE_PERIOD","ImplicitFlow","oidcMetadata","scope","response_type","client_id","redirect_uri","loginParamsParts","loginUrl","authorization_endpoint","LoginVisualComponent","loginVisualComponent","aLoginResult","getAuthResponseFromCallback","ERROR_POPUP_BLOCKED","JSON","stringify","validateIdToken","leeway","expired","issued_at","expires_at","expires_in","verifyOptions","alg","iss","issuer","gracePeriod","decode","jwtHeader","keyType","supportedAlgs","id_token_signing_alg_values_supported","jwks","getKey","kid","aLoginCallbackResult","eqlIdx","decodeURIComponent","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","InvalidTokenError","_Errors$Error","getPrototypeOf","apply","arguments","_CallbackHandler","_CallbackHandler2","IframeComponent","initAttrs","attrs","iframe","contentWindow","registerForCallback","finalize","destroy","style","cssText","onload","onerror","body","appendChild","timeout","_timeout","TimeoutError","parentNode","removeChild","unregisterForCallback","promise","_immediateValue","_immediateError","thenFn","catchFn","VC_CALLBACK_FN_NAME","window","aSourceWindow","loginWindows","loginWindow","component","Base64Url","encodeAscii","txtAscii","btoa","encode","txtUtf8","unescape","decodeToAscii","base64Url","base64","atob","ascii","escape","isBrowser","Function","domReadyPromise","readyState","addEventListener","domReady","xhrJson","method","extraSettingFn","xhr","XMLHttpRequest","open","withCredentials","setRequestHeader","onreadystatechange","status","json","parse","responseText","send","post","aText","toLowerCase","SessionContext","loginOptions","name","email","uuIdentity","levelOfAssurance","_interopRequireWildcard","newObj","hasOwnProperty","SessionHandler","request","nextInterceptorFn","runWith","extraLoginParams","count","UuApp","AbortError","usedLoginParams","session","getCallToken","callToken","authToken","headers","response","wwwAuthenticate","valueMap","map","trim","decodeUriWithPlus","relevantValues","filter","hasCustomAuthn","_Session2","txt","_Session","getOrigin","absUrl","_Dom","_Dom2","SessionStateChangeNotifier","_listeners","_checkState","_onMessage","_init","listenerFn","_destroyed","_stateCheckInterval","clearInterval","removeEventListener","iframeUrl","check_session_iframe","_iframeTrustedOrigin","_iframe","tabIndex","_stateCheckAllowed","setInterval","origin","source","info","fn","session_state","query","postMessage","tryAutoLogin","g","_SessionHandler","_SessionHandler2","UuOidc","jwkSetCache","cacheBustCounter","_class","keyId","_getKey","forceKeySetReload","jwkSetMeta","jwks_uri","jwkSet","kty","_Base64Url","_Base64Url2","_JwtVerifierWebCrypto","_JwtVerifierWebCrypto2","_JwtVerifierJsrsasign","_JwtVerifierJsrsasign2","hasWebCrypto","crypto","subtle","importKey","useWebCrypto","protocol","verifier","DEFAULT_ALG","verifyOpts","getKeyFn","tokenParts","header","headerB64U","headerStr","typ","verify","valid","bodyStr","_module","_module2","scriptUri","jsrsasign","Verifier","loadPromise","continueFn","isMin","System","import","script","head","keyInst","KEYUTIL","jws","JWS","verifyJWT","asciiToUint8Array","Uint8Array","charCodeAt","asArray","isArray","seconds","toISOString","webCryptoAlgorithm","usedKey","use","webCryptoKey","signatureB64U","signatureBytes","dataBytes","algorithm","importError","cause","signatureValid","throwError","failedClaim","aud","bodyV","some","bv","verifyAt","exp","nbf","iat","jti","PopupComponent","closeCheckInterval","closeCheck","closed","rect","width","height","left","screen","availWidth","availLeft","top","availHeight","availTop","close","generateUuid","uuid","Os8Auth","parameters","params","urlParams","urlParamsParts"],"mappings":"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","file":"uu_oidcg01.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UuOidc\", [\"uu_appg01_core\", \"module\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UuOidc\"] = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse\n\t\troot[\"UuOidc\"] = factory(root[\"UuApp\"], root[\"undefined\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_13__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UuOidc\", [\"uu_appg01_core\", \"module\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UuOidc\"] = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse\n\t\troot[\"UuOidc\"] = factory(root[\"UuApp\"], root[\"undefined\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_13__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar mod=__webpack_require__(13);\n\t  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\n\t  __webpack_require__.p=uri.split(/\\//).slice(0, -1).join(\"/\") + \"/\"; // runtime publicPath configuration required for proper linking of styles, background images, ...\n\t  module.exports = __webpack_require__(19);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _HttpClient = __webpack_require__(11);\n\t\n\tvar _HttpClient2 = _interopRequireDefault(_HttpClient);\n\t\n\tvar _PromiseUtil = __webpack_require__(7);\n\t\n\tvar _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar oidcMetadataCache = {}; // stores Promises\n\t\n\tvar Discovery = {\n\t  /**\n\t   * @return Promise resolving to OIDC discovery metadata for given issuerUri.\n\t   */\n\t  getMetadata: function getMetadata(aIssuerUri) {\n\t    var issuerUri = aIssuerUri.replace(/\\/+$/, \"\"); // strip trailing slash(es) (this also normalizes it as a key to cache)\n\t    var metadata = oidcMetadataCache[issuerUri];\n\t    if (metadata) return metadata;\n\t    var discoveryEndpoint = Discovery.getMetadataUri(issuerUri);\n\t    return oidcMetadataCache[issuerUri] = _PromiseUtil2.default.wrapForImmediateThen(_HttpClient2.default.get(discoveryEndpoint).catch(function (e) {\n\t      delete oidcMetadataCache[issuerUri]; // don't cache errors so that e.g. clicking a button 2nd time (after network is up again) has chance to work\n\t      throw e;\n\t    }));\n\t  },\n\t  getMetadataUri: function getMetadataUri(aIssuerUri) {\n\t    var issuerUri = aIssuerUri.replace(/\\/+$/, \"\"); // strip trailing slash(es) (this also normalizes it as a key to cache)\n\t    return issuerUri + \"/.well-known/openid-configuration\";\n\t  }\n\t};\n\t\n\texports.default = Discovery;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _uu_appg01_core = __webpack_require__(1);\n\t\n\tvar _Defaults = __webpack_require__(14);\n\t\n\tvar _Defaults2 = _interopRequireDefault(_Defaults);\n\t\n\tvar _ImplicitFlow = __webpack_require__(4);\n\t\n\tvar _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);\n\t\n\tvar _SessionContext = __webpack_require__(15);\n\t\n\tvar _SessionContext2 = _interopRequireDefault(_SessionContext);\n\t\n\tvar _Uuid = __webpack_require__(25);\n\t\n\tvar _Uuid2 = _interopRequireDefault(_Uuid);\n\t\n\tvar _Os8Auth = __webpack_require__(26);\n\t\n\tvar _Os8Auth2 = _interopRequireDefault(_Os8Auth);\n\t\n\tvar _PromiseUtil = __webpack_require__(7);\n\t\n\tvar _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);\n\t\n\tvar _StringUtil = __webpack_require__(12);\n\t\n\tvar _StringUtil2 = _interopRequireDefault(_StringUtil);\n\t\n\tvar _IframeComponent = __webpack_require__(6);\n\t\n\tvar _IframeComponent2 = _interopRequireDefault(_IframeComponent);\n\t\n\tvar _SessionStateChangeNotifier = __webpack_require__(17);\n\t\n\tvar _SessionStateChangeNotifier2 = _interopRequireDefault(_SessionStateChangeNotifier);\n\t\n\tvar _Discovery = __webpack_require__(2);\n\t\n\tvar _Discovery2 = _interopRequireDefault(_Discovery);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar UuAppError = _uu_appg01_core.Error.Error;\n\tvar logger = _uu_appg01_core.Logging.LoggerFactory.get(\"UuOidc.Session\");\n\t\n\tvar Session = function () {\n\t\n\t  /**\n\t   * Creates new Session with specified options.\n\t   * \n\t   * @class UuOidc.Session\n\t   * @classdesc\n\t   * \n\t   * Session handling via OpenID Connect server.\n\t   * \n\t   * **Configuration**\n\t   * \n\t   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback\n\t   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be\n\t   * configured as described below - configuration parameter \"uuoidc.redirectUri\".\n\t   * \n\t   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:\n\t   * \n\t   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n\t   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for\n\t   *   accessing most of user data.\n\t   * * **uuoidc.redirectUri** - redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n\t   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n\t   *   to document.baseURI (current URL). Default is \"callbacks/oidc-callback.html\".\n\t   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is \"https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be\".\n\t   * * **uuoidc.sessionExpiringNotificationTime** - a \"sessionExpiring\" notification event is triggered these many seconds prior to the session expiration.\n\t   *   Default is 5 minutes. Using 0 disables the notification.\n\t   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.\n\t   *   Default is 5. Using 0 disables the checking.\n\t   * \n\t   * **Supported events**\n\t   * \n\t   * It's possible to handle session state changes and other notifications by registering a listener function to any of these events\n\t   * (see also {@link UuOidc.Session#addListener}):\n\t   * \n\t   * * **identityChange** - triggerred whenever an identity changes (user logs in / out / changes its authorization status). Event's\n\t   * \"data\" field contains the new identity (see {@link UuOidc.Session#getIdentity}).\n\t   * * **sessionExpiring** - triggerred some time before the global session against OpenID Connect server expires. The application\n\t   * can show a warning at this moment and suggest to the user to re-login themselves. Re-login can be initiated by\n\t   * {@link UuOidc.Session#login Session#login}({ prompt: \"login\" }) which forces a popup window to be shown.\n\t   * The event's \"data\" field contains an object with following fields:\n\t   *     * expiresAt - time in milliseconds when the expiration of the global session will occur.\n\t   * * **sessionExtended** - trigerred after the global session against OpenID Connect server has been extended. The application should\n\t   * remove the warning about necessity of user re-login if it's showing one (i.e. if there happenned a sessionExpiring event, the user\n\t   * re-logged in, possibly in different browser tab, then the application should no longer display any warning about sessionExpiring).\n\t   * The event's \"data\" field contains an object with following fields:\n\t   *     * expiresAt - time in milliseconds when the expiration of the global session will occur\n\t   * \n\t   * @param options {Object|UuApp.Util.Config} Options.\n\t   * @param options.serverUri OpenID Connect server to perform login / logout against.\n\t   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n\t   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n\t   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n\t   *   to document.baseURI (current URL).\n\t   * @param options.sessionExpiringNotificationTime A \"sessionExpiring\" notification event is triggered these many seconds prior to the session expiration.\n\t   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.\n\t   */\n\t  function Session(options) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Session);\n\t\n\t    if (!options) throw new UuAppError(\"Session must be initialized with proper options or UuApp.Util.Config.\");\n\t    this._optionsMergedPromise = _PromiseUtil2.default.wrapForImmediateThen(Promise.resolve(options && typeof options.get == \"function\" ? options.initPromise || options : options).then(function (env) {\n\t      Object.keys(_Defaults2.default).forEach(function (k) {\n\t        var v = void 0;\n\t        if (env && typeof env.get == \"function\") v = env.get(\"uuoidc.\" + k, false);else if (env) v = env[k];\n\t        if (v == null) v = _Defaults2.default[k];\n\t        _this[k === \"redirectUri\" ? \"implicitFlowRedirectUri\" : k] = v;\n\t      });\n\t      if (!_this.clientId) _this.clientId = \"uu-oidc:unregistered-client:\" + (0, _Uuid2.default)();\n\t      // if redirect URI is relative then absolutize it (relative to current document.baseURI)\n\t      if (!_this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) {\n\t        // no protocol present\n\t        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\\/).*/, \"$1\");\n\t        if (_this.implicitFlowRedirectUri.charAt(0) != \"/\") _this.implicitFlowRedirectUri = toFullUrl(baseUrl + _this.implicitFlowRedirectUri);else _this.implicitFlowRedirectUri = toFullUrl(_this.implicitFlowRedirectUri);\n\t      }\n\t      // sanitize times & interval settings\n\t      if (typeof _this.sessionExpiringNotificationTime !== \"number\" || _this.sessionExpiringNotificationTime < 0) _this.sessionExpiringNotificationTime = _Defaults2.default.sessionExpiringNotificationTime;\n\t      if (typeof _this.sessionCheckInterval !== \"number\" || _this.sessionCheckInterval < 0) _this.sessionCheckInterval = _Defaults2.default.sessionCheckInterval;\n\t      if (_this.sessionCheckInterval > 0 && _this.sessionCheckInterval < 2) _this.sessionCheckInterval = 2; // minimal interval is 2, but allow \"0\" for disabling the check\n\t      if (typeof _this.tokenRefreshLeeway !== \"number\" || _this.tokenRefreshLeeway < 0) _this.tokenRefreshLeeway = _Defaults2.default.tokenRefreshLeeway;\n\t      if (typeof _this.tokenRefreshFailureRetryInterval !== \"number\" || _this.tokenRefreshFailureRetryInterval < 0) _this.tokenRefreshFailureRetryInterval = _Defaults2.default.tokenRefreshFailureRetryInterval;\n\t      if (_this.tokenRefreshFailureRetryInterval > 0) _this.tokenRefreshFailureRetryInterval = Math.max(5, _this.tokenRefreshFailureRetryInterval);\n\t\n\t      // add session state checking which, in case that we were logged in and a logout\n\t      // against OIDC is detected (e.g. in another browser tab), will log us out\n\t      if (_this.sessionCheckInterval) {\n\t        _this._sessionChecker = new _SessionStateChangeNotifier2.default(_this);\n\t        _this._sessionChecker.onStateChange(function () {\n\t          logger.debug(\"Session state change detected.\");\n\t          if (!_this.isAuthenticated()) return; // don't check new state if we're currently logged out (don't auto-login)\n\t\n\t          // check login state against OpenID server (basically renew the token,\n\t          // possibly logging out if the current user on OpenID server differs from ours)\n\t          _this._silentTokenRefresh(true);\n\t        });\n\t      }\n\t    }));\n\t    this._loginInProgress = 0;\n\t    this._silentTokenRefreshInProgress = 0;\n\t    this.nonce = Math.random().toString(32).substr(2);\n\t\n\t    var listeners = {};\n\t    /**\n\t     * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:\n\t     * \n\t     * * **type** The type of the event, e.g. \"identityChange\".\n\t     * * **data** The data passed to the event.\n\t     * \n\t     * See {@link UuOidc.Session Session} for the list of supported events.\n\t     * \n\t     * @param {string} eventName The event to register listener for.\n\t     * @param {function(Event)} listener The function to be called whenever the event is trigerred.\n\t     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeListener}).\n\t     * @see UuOidc.Session#removeListener\n\t     * @method UuOidc.Session#addListener\n\t     */\n\t    this.addListener = function (eventName, listener) {\n\t      var list = listeners[eventName];\n\t      if (!list) list = listeners[eventName] = [];\n\t      list.push(listener);\n\t      return _this.removeListener.bind(_this, eventName, listener);\n\t    };\n\t    /**\n\t     * Removes listener for specified event.\n\t     * \n\t     * @param {string} eventName The event to remove listener for.\n\t     * @param {function(Event)} listener The listener (function) to unregister.\n\t     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).\n\t     * @see UuOidc.Session#addListener\n\t     * @method UuOidc.Session#removeListener\n\t     */\n\t    this.removeListener = function (eventName, listener) {\n\t      var list = listeners[eventName];\n\t      if (!list) return false;\n\t      var idx = list.indexOf(listener);\n\t      if (idx != -1) list.splice(idx, 1);\n\t      return idx != -1;\n\t    };\n\t\n\t    this._runListeners = function (eventName, data) {\n\t      logger.debug(\"Launching event \\\"\" + eventName + \".\\\"\");\n\t      var list = listeners[eventName];\n\t      if (list) {\n\t        var e = {\n\t          type: eventName,\n\t          data: data\n\t        };\n\t        list.forEach(function (it) {\n\t          return it.call(_this, e);\n\t        });\n\t      }\n\t      // run also deprecated identityChangeListener-s (they don't get \"event\" object but directly the data)\n\t      // if this is \"identityChange\" event\n\t      // TODO 3.0 Remove.\n\t      if (eventName === \"identityChange\" && listeners[\"__identityChange\"]) listeners[\"__identityChange\"].forEach(function (it) {\n\t        return it.call(_this, data);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @return {boolean} True iff the user is authenticated (logged in).\n\t     * @method UuOidc.Session#isAuthenticated\n\t     */\n\t    this.isAuthenticated = function () {\n\t      return !!_this._loginCtx;\n\t    };\n\t\n\t    /**\n\t     * Adds listener for changes of user identity (logins / logouts).\n\t     * \n\t     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.\n\t     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).\n\t     * @see UuOidc.Session#addListener\n\t     * @see UuOidc.Session#getIdentity\n\t     * @method UuOidc.Session#addIdentityChangeListener\n\t     * @deprecated Use Session#addListener(\"identityChange\", listener) instead. Note that the listener accepts Event object.\n\t     */\n\t    this.addIdentityChangeListener = this.addListener.bind(this, \"__identityChange\");\n\t\n\t    /**\n\t     * Removes listener for changes of user identity (logins / logouts).\n\t     * \n\t     * @param {Function(Object)} listener The listener to remove.\n\t     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).\n\t     * @see UuOidc.Session#removeListener\n\t     * @method UuOidc.Session#removeIdentityChangeListener\n\t     * @deprecated Use Session#removeListener(\"identityChange\", listener) instead.\n\t     */\n\t    this.removeIdentityChangeListener = this.removeListener.bind(this, \"__identityChange\");\n\t\n\t    // add session_expires_at field\n\t    // NOTE This is required for \"auto-logout\", \"session expiring\" and \"session extended\" functionality.\n\t    // NOTE This assumes that whenever a token changes, identity-change listeners are run\n\t    // And that they are run pretty much immediately (so that authResponse.session_expires_in\n\t    // is relative to the moment when we received the response).\n\t    this.addListener(\"identityChange\", function (e) {\n\t      var authResponse = (_this._loginCtx || {}).authResponse;\n\t      if (!authResponse || !authResponse.session_expires_in) return;\n\t      if (authResponse.session_expires_at) return;\n\t      authResponse.session_expires_at = Math.floor(Date.now() / 1000) + Number(authResponse.session_expires_in);\n\t    });\n\t\n\t    // auto-logout when server-side session reaches its expiration time (or when token\n\t    // reaches its expiration time in case that server-side session info is not available)\n\t    // NOTE This assumes that whenever a token changes, identity-change listeners are run\n\t    // (so that info from new token gets checked again).\n\t    this.addListener(\"identityChange\", function (e) {\n\t      if (_this._autoLogoutTimeout) {\n\t        clearTimeout(_this._autoLogoutTimeout);\n\t        delete _this._autoLogoutTimeout;\n\t      }\n\t      var authResponse = (_this._loginCtx || {}).authResponse;\n\t      if (!authResponse) return;\n\t\n\t      // plan local logout\n\t      var expiresAt = authResponse.session_expires_at || (_this.getClaims() || {})[\"exp\"];\n\t      if (!expiresAt) return;\n\t      var now = new Date().getTime();\n\t      var delay = Math.max(0, expiresAt * 1000 - now);\n\t      logger.debug(\"Planning local auto-logout at \" + toTimeString(new Date(now + delay)) + \".\");\n\t      _this._autoLogoutTimeout = setTimeout(function () {\n\t        delete _this._autoLogoutTimeout;\n\t        _this._localLogout();\n\t      }, delay);\n\t    });\n\t\n\t    // support for token auto-refresh when its nearing expiration\n\t    // NOTE This assumes that whenever a token changes, identity-change listeners are run\n\t    // (so that token refreshing gets re-planned / cleaned).\n\t    var lastTokenRefreshTime = 0;\n\t    this.addListener(\"identityChange\", function (e) {\n\t      if (!_this.tokenRefreshEnabled) return;\n\t\n\t      if (_this._sessionRefreshTimeout) {\n\t        clearTimeout(_this._sessionRefreshTimeout);\n\t        delete _this._sessionRefreshTimeout;\n\t      }\n\t      var claims = _this.getClaims();\n\t      var expiresAt = (claims || {})[\"exp\"];\n\t      if (!expiresAt) return; // not logged in (or there's something with the claims but that shouldn't happen)\n\t\n\t      // plan token refresh\n\t      var now = new Date().getTime();\n\t      var delay = Math.max(expiresAt * 1000 - now - _this.tokenRefreshLeeway * 1000, Math.max(0, 1000 - (now - lastTokenRefreshTime))); // wait at least 1s between 2 token refreshes\n\t      logger.debug(\"Planning token auto-refresh at \" + toTimeString(new Date(now + delay)) + \".\");\n\t      _this._sessionRefreshTimeout = setTimeout(function () {\n\t        delete _this._sessionRefreshTimeout;\n\t        lastTokenRefreshTime = new Date().getTime();\n\t        _this._silentTokenRefresh();\n\t      }, delay);\n\t    });\n\t\n\t    // support for \"session extended\" notification\n\t    // NOTE This assumes that whenever a token changes, identity-change listeners are run.\n\t    this.addListener(\"identityChange\", function (e) {\n\t      var LEEWAY_MILLIS = 10 * 1000; // use leeway because server sends \"session_expires_in\" which is relative so if network becomes slower, we might then compute the \"...expires_at\" value as if it was greater than before\n\t      var authResponse = (_this._loginCtx || {}).authResponse;\n\t      var wasExtended = _this._activeSessionExpiresAtMillis && authResponse && authResponse.session_expires_at * 1000 > _this._activeSessionExpiresAtMillis + LEEWAY_MILLIS;\n\t      _this._activeSessionExpiresAtMillis = authResponse ? authResponse.session_expires_at * 1000 : null;\n\t      if (wasExtended) {\n\t        _this._sessionExpiringBlocked = false;\n\t        var expiresAt = _this._activeSessionExpiresAtMillis;\n\t        setTimeout(function () {\n\t          // we're currently processing \"identityChange\" listeners so let them finish and run \"sessionExtended\" afterwards\n\t          _this._runListeners(\"sessionExtended\", { expiresAt: expiresAt });\n\t        }, 0);\n\t      }\n\t    });\n\t\n\t    // support for \"session expiring\" notification\n\t    // NOTE Must be after \"session extended\" functionality (so that unblocking done there\n\t    // gets performed sooner than the code below).\n\t    // NOTE This assumes that whenever a token changes, identity-change listeners are run.\n\t    var prevIdentity = undefined;\n\t    this.addListener(\"identityChange\", function (e) {\n\t      if (_this.sessionExpiringNotificationTime <= 0) return; // disabled\n\t\n\t      if (_this._sessionExpiringTimeout) {\n\t        clearTimeout(_this._sessionExpiringTimeout);\n\t        delete _this._sessionExpiringTimeout;\n\t      }\n\t      var authResponse = (_this._loginCtx || {}).authResponse;\n\t      var newIdentity = (_this.getClaims() || {})[\"sub\"];\n\t      if (newIdentity != prevIdentity) _this._sessionExpiringBlocked = false;\n\t      prevIdentity = newIdentity;\n\t\n\t      if (!authResponse) return; // not logged in\n\t      if (!authResponse.session_expires_at) return; // \"session expiring\" notification not supported on server\n\t      if (_this._sessionExpiringBlocked) return; // don't trigger \"session expiring\" multiple times for the same session\n\t\n\t      var expiresAt = authResponse.session_expires_at * 1000;\n\t      var now = Date.now();\n\t      var delay = Math.max(0, expiresAt - now - _this.sessionExpiringNotificationTime * 1000);\n\t      logger.debug(\"Planning sessionExpiring notification at \" + toTimeString(new Date(now + delay)) + \".\");\n\t      _this._sessionExpiringTimeout = setTimeout(function () {\n\t        delete _this._sessionExpiringTimeout;\n\t        _this._sessionExpiringBlocked = true;\n\t        _this._runListeners(\"sessionExpiring\", { expiresAt: expiresAt });\n\t      }, delay);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:\n\t   * \n\t   * * id\n\t   * * name\n\t   * * uuIdentity\n\t   * * email\n\t   * * levelOfAssurance\n\t   * * loginLevelOfAssurance\n\t   * \n\t   * @return {Object} Identity of currently logged in user or null if not logged in.\n\t   * @method UuOidc.Session#getIdentity\n\t   */\n\t\n\t\n\t  _createClass(Session, [{\n\t    key: \"getIdentity\",\n\t    value: function getIdentity() {\n\t      return this._loginCtx ? this._loginCtx.getIdentity() : null;\n\t    }\n\t\n\t    /**\n\t     * Returns all claims present in the token (or null if not logged in).\n\t     * \n\t     * @method UuOidc.Session#getClaims\n\t     */\n\t\n\t  }, {\n\t    key: \"getClaims\",\n\t    value: function getClaims() {\n\t      return this._loginCtx ? this._loginCtx.getClaims() : null;\n\t    }\n\t\n\t    /**\n\t     * Login against OpenID Connect server. If no or empty options are used, user will be required to\n\t     * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in\n\t     * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can\n\t     * be forced by using option \"prompt\" set to \"login\".\n\t     * \n\t     * @param options {Object} Options.\n\t     * @param options.prompt {string} (optional) One of \"\" (default), \"none\" (check login state without user interaction), \"login\" (re-request authentication).\n\t     * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).\n\t     * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.\n\t     * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it\n\t     *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:\n\t     * \n\t     * * \"urn:ietf:params:oauth:token-type:jwt-uuos8\" - indicates that the token being passed to the login was originally issued by uuOS8\n\t     * \n\t     * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained\n\t     *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:\n\t     * \n\t     *   * false - user refused to log in\n\t     *   * Error - any other error such as network problems, ...\n\t     * \n\t     * @method UuOidc.Session#login\n\t     */\n\t\n\t  }, {\n\t    key: \"login\",\n\t    value: function login(options) {\n\t      // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).\n\t\n\t      // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)\n\t      var opts;\n\t      if (options) opts = Object.keys(options).reduce(function (r, k) {\n\t        return r[_StringUtil2.default.toSnakeCase(k)] = options[k], r;\n\t      }, {});\n\t\n\t      return this._login(opts);\n\t    }\n\t\n\t    // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.\n\t\n\t  }, {\n\t    key: \"_login\",\n\t    value: function _login(options, canUpdateSessionWithLoginResultFn) {\n\t      var _this2 = this;\n\t\n\t      var opts = Object.assign({}, options);\n\t\n\t      // there's a special case in which we support providing uuOS8 token\n\t      var os8Token;\n\t      if (opts.token_type_hint === \"urn:ietf:params:oauth:token-type:jwt-uuos8\") {\n\t        os8Token = opts.access_token;\n\t        delete opts.access_token;\n\t        delete opts.token_type_hint;\n\t      }\n\t\n\t      // use accessToken directly if it's provided\n\t      var accessToken = opts.access_token;\n\t      delete opts.access_token;\n\t\n\t      var doLogin = function doLogin() {\n\t        ++_this2._loginInProgress;\n\t\n\t        // if calling Session.login() with no parameters, log in as non-anonymous user\n\t        if (Object.keys(opts).length == 0) opts[\"acr_values\"] = 1;\n\t\n\t        // if we have user then login only if options indicate that we have to\n\t        if (!accessToken && _this2._loginCtx) {\n\t          var useCurrent = true;\n\t          if (opts[\"prompt\"] || opts[\"max_age\"] || opts[\"access_token\"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.\n\t\n\t          // check required login level of assurance\n\t          var acr_values = (opts[\"acr_values\"] != null ? opts[\"acr_values\"] + \"\" : \"\").split(/\\s+/);\n\t          var identity = _this2.getIdentity();\n\t          if (acr_values.every(function (v) {\n\t            return Number(v) > identity.loginLevelOfAssurance;\n\t          })) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login\n\t\n\t          // check current token expiration\n\t          if (_ImplicitFlow2.default.isAuthResponseExpired(_this2._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login\n\t\n\t          // use current token if everything seems fine\n\t          if (useCurrent) {\n\t            --_this2._loginInProgress;\n\t            return Promise.resolve(_this2);\n\t          }\n\t        }\n\t\n\t        // login using implicit flow\n\t        var authResponse = accessToken ? { id_token: accessToken } : null;\n\t        var nonce = accessToken || os8Token || \"nonce\" in opts ? opts[\"nonce\"] : _this2.nonce;\n\t        opts.nonce = nonce;\n\t        delete opts.state; // we'll generate our own, if needed\n\t\n\t        // NOTE Clicking a button, which launches this login method, can result in\n\t        // at most 1 Promise resolution. If 2 or more Promises are chained, mobile\n\t        // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise\n\t        // is wrapped via PromiseUtil which then allows us here to call our \"then\" function immediately\n\t        // if the this._optionsMergedPromise has already been resolved.\n\t        // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)\n\t        // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is\n\t        // not trivial.\n\t        var authResponsePromise = Promise.resolve(authResponse || _PromiseUtil2.default.immediateThen(_this2._optionsMergedPromise, function () {\n\t          // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll\n\t          // do this by exchanging tokens via non-standard endpoint for uuOS8\n\t          if (os8Token) {\n\t            var os8Auth = new _Os8Auth2.default({\n\t              serverUri: _this2.serverUri,\n\t              clientId: _this2.clientId,\n\t              redirectUri: _this2.implicitFlowRedirectUri\n\t            });\n\t            return os8Auth.grantExchangeToken({\n\t              subject_token: os8Token\n\t            });\n\t          }\n\t\n\t          // authenticate using implicit flow\n\t          opts.state = Math.random().toString(32).substr(2);\n\t          if (navigator.standalone) opts.state += \",\" + location.pathname + location.search + (location.hash.length > 1 ? location.hash : \"\"); // iOS in standalone mode - callback HTML will redirect back with full page reload\n\t          return _ImplicitFlow2.default.login({\n\t            serverUri: _this2.serverUri,\n\t            clientId: _this2.clientId,\n\t            redirectUri: _this2.implicitFlowRedirectUri,\n\t            loginParams: opts\n\t          });\n\t        }, function (e) {\n\t          return Promise.reject(e);\n\t        }));\n\t        return authResponsePromise.then(function (authResponse) {\n\t          // validate response\n\t          return _this2._optionsMergedPromise.then(function () {\n\t            return _ImplicitFlow2.default.validateAuthResponse(authResponse, {\n\t              serverUri: _this2.serverUri,\n\t              clientId: _this2.clientId,\n\t              loginParams: opts\n\t            });\n\t          });\n\t        }).then(function (_ref) {\n\t          var authResponse = _ref.authResponse,\n\t              claims = _ref.claims;\n\t\n\t          // login successful => update the session\n\t          if (!canUpdateSessionWithLoginResultFn || canUpdateSessionWithLoginResultFn({ authResponse: authResponse, claims: claims }) !== false) {\n\t            _this2._loginCtx = new _SessionContext2.default(opts, authResponse, claims);\n\t            _this2._runListeners(\"identityChange\", _this2.getIdentity());\n\t          }\n\t          return _this2;\n\t        }).then(function (r) {\n\t          --_this2._loginInProgress;\n\t          return r;\n\t        }, function (e) {\n\t          --_this2._loginInProgress;\n\t          return Promise.reject(e);\n\t        });\n\t      };\n\t\n\t      // wait for session restoring in case that this instance of the session is the \"main\" session\n\t      return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? _PromiseUtil2.default.immediateThen(Session.initPromise, doLogin) : doLogin();\n\t    }\n\t\n\t    /**\n\t     * Tries to re-authenticate the user silently:\n\t     * - if we are locally logged out => do nothing\n\t     * - if a user is logged in (on remote) and it's the same user as ours => use the new token\n\t     * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout\n\t     * - if a user is not logged in (on remote) => perform local logout\n\t     */\n\t\n\t  }, {\n\t    key: \"_silentTokenRefresh\",\n\t    value: function _silentTokenRefresh(aSkipIfPlanned) {\n\t      var _this3 = this;\n\t\n\t      if (aSkipIfPlanned && (this._silentTokenRefreshTimeout || this._silentTokenRefreshInProgress > 0)) return;\n\t\n\t      if (this._silentTokenRefreshTimeout) {\n\t        clearTimeout(this._silentTokenRefreshTimeout);\n\t        delete this._silentTokenRefreshTimeout;\n\t      }\n\t      var invocationCount = 0;\n\t      var doSilentRenew = function doSilentRenew() {\n\t        if (!_this3.isAuthenticated()) return;\n\t\n\t        logger.debug(\"Silent token refresh - starting.\");\n\t        ++_this3._silentTokenRefreshInProgress;\n\t        ++invocationCount;\n\t        return _this3._login({\n\t          acr_values: \"1\",\n\t          prompt: \"none\"\n\t        }, function (_ref2) {\n\t          var claims = _ref2.claims;\n\t\n\t          --_this3._silentTokenRefreshInProgress;\n\t          if (!_this3.isAuthenticated()) {\n\t            // no-op (we're logged out and don't want to silently auto-login)\n\t            logger.debug(\"Silent token refresh - ending with no-op (local session is already logged out).\");\n\t            return false; // don't use the new authResponse\n\t          }\n\t          // if the user is different than the current one then perform logout\n\t          if (claims.sub !== _this3.getClaims().sub) {\n\t            logger.debug(\"Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).\");\n\t            _this3._localLogout();\n\t            return false; // don't use the new authResponse\n\t          }\n\t          logger.debug(\"Silent token refresh - ending with token renewed.\");\n\t          return true; // use the new authResponse\n\t        }).catch(function (e) {\n\t          var err = e && e.error ? e.error : e; // e could be AuthenticationResponse, Error or anything else\n\t          if (_ImplicitFlow2.default.isLoggedOutError(e)) {\n\t            logger.debug(\"Silent token refresh - ending with local logout (user is not logged in on remote).\");\n\t            _this3._localLogout();\n\t            return;\n\t          }\n\t          if (!_this3._silentTokenRefreshTimeout && _this3.tokenRefreshFailureRetryInterval) {\n\t            logger.debug(\"Silent token refresh - will retry in \" + _this3.tokenRefreshFailureRetryInterval + \"s (operation ended with unexpected error).\", { error: err });\n\t            _this3._silentTokenRefreshTimeout = setTimeout(function () {\n\t              delete _this3._silentTokenRefreshTimeout;\n\t              doSilentRenew();\n\t            }, _this3.tokenRefreshFailureRetryInterval * 1000);\n\t          } else {\n\t            if (_this3._silentTokenRefreshTimeout) logger.debug(\"Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).\", { error: err });else logger.debug(\"Silent token refresh - ending with no-op (operation ended with unexpected error).\", { error: err });\n\t          }\n\t          if (invocationCount === 1) console.warn(\"Token refresh failed with error:\", err);else if (invocationCount === 2) console.warn(\"Suppressing further notifications of token refresh problem to prevent log cluttering (until success or logout).\");\n\t        });\n\t      };\n\t\n\t      doSilentRenew();\n\t    }\n\t  }, {\n\t    key: \"_localLogout\",\n\t    value: function _localLogout() {\n\t      logger.debug(\"Performing local-logout.\");\n\t      if (!this._loginCtx) return;\n\t      delete this._loginCtx;\n\t      this._runListeners(\"identityChange\", this.getIdentity());\n\t    }\n\t\n\t    /**\n\t     * Log out the user.\n\t     * \n\t     * @return Promise resolved after the user gets logged out (or immediately, if the user is not logged in).\n\t     * @method UuOidc.Session#logout\n\t     */\n\t\n\t  }, {\n\t    key: \"logout\",\n\t    value: function logout() {\n\t      var _this4 = this;\n\t\n\t      if (!this._loginCtx) return Promise.resolve();\n\t\n\t      // logout global session using end_session_endpoint (in an iframe)\n\t      return this._optionsMergedPromise.then(function () {\n\t        return _Discovery2.default.getMetadata(_this4.serverUri).then(function (metadata) {\n\t          return new Promise(function (resolve, reject) {\n\t            if (!_this4._loginCtx) return resolve();\n\t            var logoutCallbackUri = _this4.implicitFlowRedirectUri;\n\t            var logoutUrl = metadata.end_session_endpoint + \"?post_logout_redirect_uri=\" + encodeURIComponent(logoutCallbackUri) + \"&id_token_hint=\" + encodeURIComponent(_this4._loginCtx.authResponse.id_token);\n\t            new _IframeComponent2.default({\n\t              url: logoutUrl,\n\t              onResult: function onResult(result) {\n\t                if (result instanceof Error) {\n\t                  result.message = \"Logout failed.\" + (result.message ? \" \" + result.message : \"\");\n\t                  reject(result);\n\t                } else {\n\t                  _this4._localLogout();\n\t                  resolve();\n\t                }\n\t              }\n\t            }).render();\n\t          });\n\t        });\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns token and its type for calling commands. Returned object contains following fields:\n\t     * \n\t     * * tokenType - the type of the token, such as \"Bearer\",\n\t     * * token - the token itself.\n\t     * \n\t     * If the user is not logged in, null is returned.\n\t     * \n\t     * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.\n\t     * @return Object containing token and its type, or null if user is not logged in.\n\t     * @method UuOidc.Session#getCallToken\n\t     */\n\t\n\t  }, {\n\t    key: \"getCallToken\",\n\t    value: function getCallToken(callUri) {\n\t      var authResponse = (this._loginCtx || {}).authResponse;\n\t      if (!authResponse) return null;\n\t      var result = {\n\t        tokenType: authResponse.token_type || null,\n\t        token: authResponse.id_token || null\n\t      };\n\t      return result;\n\t    }\n\t  }]);\n\t\n\t  return Session;\n\t}();\n\t\n\texports.default = Session;\n\t\n\t\n\tfunction toFullUrl(path) {\n\t  var a = document.createElement(\"a\");\n\t  a.href = path;\n\t  return a.href.toString(); // browser-normalized URL (removed \"../\" sequences, ...)\n\t}\n\t\n\tfunction toTimeString(date) {\n\t  return (\n\t    // date.getFullYear() + \"-\" + (\"0\" + (date.getMonth() + 1)).substr(-2) + \"-\" + (\"0\" + date.getDate()).substr(-2) + \" \" +\n\t    (\"0\" + date.getHours()).substr(-2) + \":\" + (\"0\" + date.getMinutes()).substr(-2) + \":\" + (\"0\" + date.getSeconds()).substr(-2)\n\t  );\n\t}\n\t\n\t/**\n\t * Current session.\n\t * \n\t * @name UuOidc.Session.currentSession\n\t * @type UuOidc.Session\n\t */\n\tvar currentSession;\n\tvar allowAutoInitSession = true;\n\tObject.defineProperty(Session, \"currentSession\", {\n\t  get: function get() {\n\t    if (allowAutoInitSession && !currentSession) {\n\t      currentSession = new Session(_uu_appg01_core.Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).\n\t      currentSession.initComplete = false;\n\t      currentSession.initPromise = Session.initPromise;\n\t    }\n\t    return currentSession;\n\t  },\n\t  set: function set(value) {\n\t    allowAutoInitSession = false;\n\t    currentSession = value;\n\t  }\n\t});\n\t\n\tvar finalizeInit;\n\t/**\n\t * Promise resolved after session initialization (restoring state) finishes.\n\t * \n\t * @type {Promise<UuOidc.Session>}\n\t * @name UuOidc.Session.initPromise \n\t */\n\t/**\n\t * Promise resolved after session initialization (restoring state) finishes.\n\t * Note that this field is available only on a session instance that is\n\t * created automatically during page load.\n\t * \n\t * @type {Promise<UuOidc.Session>}\n\t * @name UuOidc.Session#initPromise \n\t */\n\tSession.initPromise = _PromiseUtil2.default.wrapForImmediateThen(new Promise(function (resolve, reject) {\n\t  finalizeInit = function finalizeInit(isOk, result) {\n\t    Session.initComplete = true;\n\t    Session.currentSession.initComplete = true;\n\t    if (!isOk) console.log(\"Session initialization failed:\", result);\n\t    resolve(Session.currentSession); // always resolve as success even if checking session state failed\n\t    return Session.initPromise;\n\t  };\n\t}));\n\tSession.initPromise._finalizeInit = finalizeInit;\n\t\n\t/**\n\t * Whether the session initialization performed during page load has already completed.\n\t * \n\t * @type {boolean}\n\t * @name UuOidc.Session.initComplete\n\t */\n\t/**\n\t * Whether the session initialization performed during page load has already completed.\n\t * Note that this field is available only on a session instance that is\n\t * created automatically during page load.\n\t * \n\t * @type {boolean}\n\t * @name UuOidc.Session#initComplete\n\t */\n\tSession.initComplete = false;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _Discovery = __webpack_require__(2);\n\t\n\tvar _Discovery2 = _interopRequireDefault(_Discovery);\n\t\n\tvar _PromiseUtil = __webpack_require__(7);\n\t\n\tvar _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);\n\t\n\tvar _PopupComponent = __webpack_require__(24);\n\t\n\tvar _PopupComponent2 = _interopRequireDefault(_PopupComponent);\n\t\n\tvar _IframeComponent = __webpack_require__(6);\n\t\n\tvar _IframeComponent2 = _interopRequireDefault(_IframeComponent);\n\t\n\tvar _Jwt = __webpack_require__(21);\n\t\n\tvar _Jwt2 = _interopRequireDefault(_Jwt);\n\t\n\tvar _InvalidTokenError = __webpack_require__(5);\n\t\n\tvar _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);\n\t\n\tvar _Jwks = __webpack_require__(20);\n\t\n\tvar _Jwks2 = _interopRequireDefault(_Jwks);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar GRACE_PERIOD = 300;\n\t\n\tvar ImplicitFlow = {\n\t  /**\n\t   * @param options.serverUri\n\t   * @param options.clientId\n\t   * @param options.redirectUri\n\t   * @param options.loginVisualComponent\n\t   * @param options.loginParams Additional URL parameters to be passed in the HTTP request.\n\t   */\n\t  login: function login(options) {\n\t    var opts = options || {};\n\t\n\t    // check that required data is available\n\t    var serverUri = opts.serverUri;\n\t    if (!serverUri) throw new Error(\"ImplicitFlow.login requires option 'serverUri'.\");\n\t    var clientId = opts.clientId;\n\t    if (!clientId) throw new Error(\"ImplicitFlow.login requires option 'clientId'.\");\n\t    var redirectUri = opts.redirectUri;\n\t    if (!redirectUri) throw new Error(\"ImplicitFlow.login requires option 'redirectUri'.\");\n\t\n\t    // NOTE Using PromiseUtil.immediateThen which will run our \"then\" callback immediately if\n\t    // the Discovery.getMetadata is already resolved. The idea is that this login could have\n\t    // been triggered from \"click\" event and we need to open popup window within this event's\n\t    // lifetime or within single Promise (but not Promise chain because that doesn't work on\n\t    // iPhones).\n\t    return _PromiseUtil2.default.immediateThen(_Discovery2.default.getMetadata(serverUri), function (oidcMetadata) {\n\t      // prepare login URL\n\t      var loginParams = Object.assign({ scope: \"openid\" }, opts.loginParams, {\n\t        response_type: \"id_token token\",\n\t        client_id: clientId,\n\t        redirect_uri: redirectUri\n\t      });\n\t      var loginParamsParts = [];\n\t      for (var k in loginParams) {\n\t        var v = loginParams[k];\n\t        if (v == null) continue;\n\t        loginParamsParts.push(encodeURIComponent(k) + \"=\" + encodeURIComponent(v + \"\"));\n\t      }\n\t      var loginUrl = oidcMetadata.authorization_endpoint + \"?\" + loginParamsParts.join(\"&\");\n\t\n\t      // display visual component for logging in (popup window)\n\t      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != \"none\" ? _PopupComponent2.default : _IframeComponent2.default);\n\t      return new Promise(function (resolve, reject) {\n\t        new LoginVisualComponent({\n\t          url: loginUrl,\n\t          onResult: function onResult(aLoginResult) {\n\t            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);\n\t            if (authResponse === false) return reject(new Error(\"User refused to log in.\"));\n\t            if (authResponse === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return reject(new Error(\"Login failed due to popup blocking.\"));\n\t\n\t            // resolve the promise successfully with the token (iff there's no \"error\" field)\n\t            if (authResponse.error) reject(authResponse);else resolve(authResponse);\n\t          }\n\t        }).render();\n\t      });\n\t    }, function (e) {\n\t      return Promise.reject(e);\n\t    });\n\t  },\n\t\n\t  validateAuthResponse: function validateAuthResponse(authResponse, opts) {\n\t    // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation\n\t    // 1. process only recognized fields in response (id_token, expires_in, ...)\n\t    // 2. validate implicit flow callback response (\"state\")\n\t    // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n\t    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n\t    //     ii. validate signature\n\t    //    iii. validate nonce\n\t    // 4. validate access_token\n\t\n\t    // 2.i. validate state\n\t    if (opts.loginParams.state && authResponse.state !== opts.loginParams.state) throw new Error(\"Invalid 'state' in received authorization response. Expected \" + opts.loginParams.state + \" but got \" + authResponse.state + \". Response: \" + JSON.stringify(authResponse));\n\t\n\t    // 2.ii. validate expiration\n\t    if (ImplicitFlow.isAuthResponseExpired(authResponse)) throw new Error(\"Token expired \" + JSON.stringify(authResponse));\n\t\n\t    // 3. validate id_token with nonce\n\t    return ImplicitFlow.validateIdToken(authResponse.id_token, opts).then(function (claims) {\n\t      return { authResponse: authResponse, claims: claims };\n\t    });\n\t\n\t    // 4. validate access_token\n\t    // NOTE Ignore - we're not using access_token field.\n\t  },\n\t  isAuthResponseExpired: function isAuthResponseExpired(authResponse) {\n\t    var now = new Date().getTime() / 1000;\n\t    var leeway = 60;\n\t    var expired = false;\n\t    if (!authResponse.issued_at) authResponse.issued_at = now;\n\t    if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;\n\t    if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;\n\t    return expired;\n\t  },\n\t\n\t\n\t  /**\n\t   * @param {*} e The error during authorization.\n\t   * @return Whether the error means that the user is not logged in on the remote server.\n\t   */\n\t  isLoggedOutError: function isLoggedOutError(e) {\n\t    return e && (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) == \"object\" && typeof e[\"error_description\"] == \"string\" && e[\"error_description\"].match(/interaction/i) && e[\"error_description\"].match(/required/i);\n\t  },\n\t\n\t\n\t  /**\n\t   * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.\n\t   */\n\t  validateIdToken: function validateIdToken(token, _ref) {\n\t    var serverUri = _ref.serverUri,\n\t        nonce = _ref.loginParams.nonce;\n\t\n\t    // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n\t    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n\t    //         1. -Decrypt JWE - not supported.\n\t    //         2. +REQUIRED validate 'iss'\n\t    //         3. +REQUIRED validate 'aud'\n\t    //         4. -SHOULD validate multiple 'aud' vs. 'azp'\n\t    //         5. -SHOULD validate 'azp'\n\t    //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>\n\t    //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration\n\t    //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)\n\t    //         9. +REQUIRED current time < 'exp'\n\t    //        10. +CAN check 'iat'\n\t    //        11. +REQUIRED (for implicit flow) validate nonce\n\t    //        12. -SHOULD check if 'acr' is appropriate\n\t    //        13. -SHOULD check if 'auth_time' was requested.\n\t    //     ii. validate signature\n\t    //    iii. validate nonce\n\t    return _Discovery2.default.getMetadata(serverUri).then(function (metadata) {\n\t      var verifyOptions = {\n\t        // NOTE IE11 doesn't have RS512 (but it has \"RS256\" and \"RS384\").\n\t        alg: [\"RS256\"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)\n\t        iss: [metadata.issuer], // 3.i.2.\n\t        // aud: clientId, // 3.i.3. TODO We don't have the proper value.\n\t        // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') \n\t        gracePeriod: GRACE_PERIOD\n\t      };\n\t      return _Jwt2.default.decode(token, verifyOptions, function (jwtHeader) {\n\t        // 3.ii.\n\t        if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\\d+$/)) throw new Error(\"Invalid token. Only RSA signature is supported, but token uses algorithm '\" + jwtHeader.alg + \"'. Token: \" + token);\n\t        var keyType = \"RSA\";\n\t\n\t        // check algorithm in token (whether it's really supported by the server)\n\t        var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];\n\t        if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error(\"Invalid token. Token was signed using algorithm '\" + jwtHeader.alg + \"' but the OIDC server '\" + serverUri + \"' supports only \" + JSON.stringify(supportedAlgs) + \". Token: \" + token);\n\t\n\t        // pick the key from JWK Set\n\t        var jwks = new _Jwks2.default({ serverUri: serverUri });\n\t        return jwks.getKey(jwtHeader.kid, keyType).catch(function (e) {\n\t          throw new Error(\"Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server \" + serverUri + \". Token: \" + token, e);\n\t        });\n\t      }).then(function (claims) {\n\t        // 3.i.11., 3.iii. validate nonce\n\t        if (nonce && claims.nonce !== nonce) throw new _InvalidTokenError2.default(\"Invalid nonce in ID token claims. Expected \" + nonce + \" but got \" + claims.nonce);\n\t        return claims;\n\t      });\n\t    });\n\t  },\n\t\n\t\n\t  /**\n\t   * \n\t   * @param {*} aLoginCallbackResult \n\t   * @return One of: \n\t   * * false - user refused to log in (or popups are blocked)\n\t   * * object with \"error\" field set - an error\n\t   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...\n\t   */\n\t  getAuthResponseFromCallback: function getAuthResponseFromCallback(aLoginCallbackResult) {\n\t    if (aLoginCallbackResult === false || aLoginCallbackResult === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return aLoginCallbackResult;\n\t    if (aLoginCallbackResult instanceof Error) return { error: aLoginCallbackResult };\n\t\n\t    // extract login token\n\t    // example of successful aLoginCallbackResult: \"...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid\" \n\t    // example of error aLoginCallbackResult:      \"...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR\"\n\t    var authResponse = {};\n\t    aLoginCallbackResult.replace(/^[^#]*#?/, \"\").split(/&/).forEach(function (it) {\n\t      var eqlIdx = it.indexOf(\"=\");\n\t      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\\+/g, \" \"));\n\t      var value = decodeURIComponent((eqlIdx == -1 ? \"\" : it.substr(eqlIdx + 1)).replace(/\\+/g, \" \"));\n\t      authResponse[key] = value;\n\t    });\n\t    return authResponse;\n\t  }\n\t};\n\t\n\texports.default = ImplicitFlow;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _uu_appg01_core = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar InvalidTokenError = function (_Errors$Error) {\n\t  _inherits(InvalidTokenError, _Errors$Error);\n\t\n\t  function InvalidTokenError() {\n\t    _classCallCheck(this, InvalidTokenError);\n\t\n\t    return _possibleConstructorReturn(this, (InvalidTokenError.__proto__ || Object.getPrototypeOf(InvalidTokenError)).apply(this, arguments));\n\t  }\n\t\n\t  return InvalidTokenError;\n\t}(_uu_appg01_core.Error.Error);\n\t\n\texports.default = InvalidTokenError;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _CallbackHandler = __webpack_require__(8);\n\t\n\tvar _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);\n\t\n\tvar _uu_appg01_core = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt=\"none\" cases.\n\t * After login/logout initAttrs.onResult(authResultUrl) is called as callback. In case of an error, an error instance\n\t * is passed to the callback.\n\t * \n\t * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n\t * @param initAttrs.onResult The callback to call after login/logout finishes.\n\t * @param initAttrs.timeout Seconds to wait after which consider the attempt unsuccessful, resulting in UuApp.Error.TimeoutError result.\n\t */\n\tvar IframeComponent = function IframeComponent(initAttrs) {\n\t  var attrs = Object.assign({}, initAttrs);\n\t  var state = {\n\t    iframe: null\n\t  };\n\t  Object.defineProperty(state, \"loginWindow\", {\n\t    get: function get() {\n\t      try {\n\t        // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)\n\t        return state.iframe != null ? state.iframe.contentWindow : null;\n\t      } catch (e) {\n\t        // ignore\n\t      }\n\t      return null;\n\t    }\n\t  });\n\t\n\t  // add self to the list of openend loginWindows\n\t  _CallbackHandler2.default.registerForCallback(this, state);\n\t\n\t  // finalization callback (for this component instance) called after login from redirect_uri page\n\t  this.finalize = function (aLoginResult) {\n\t    // cleanup & do the callback\n\t    this.finalize = function () {};\n\t    this.destroy();\n\t    if (attrs.onResult) attrs.onResult(aLoginResult);\n\t  }.bind(this);\n\t\n\t  this.render = function () {\n\t    var _this = this;\n\t\n\t    if (!state.iframe) {\n\t      state.iframe = document.createElement(\"iframe\");\n\t      state.iframe.style.cssText = \"position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;\";\n\t      state.iframe.src = attrs.url;\n\t      state.iframe.onload = function () {\n\t        return _this.finalize(new Error(\"OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running.\" + \" Alternatively, an error might have happened on OIDC server while processing URL \" + attrs.url + \" or the application sent wrong redirect_uri.\"));\n\t      }; // proper callback page will perform callback prior to onload event\n\t      state.iframe.onerror = function () {\n\t        return _this.finalize(new Error(\"OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running.\" + \" Alternatively, an error might have happened on OIDC server while processing URL \" + attrs.url + \" or the application sent wrong redirect_uri.\"));\n\t      };\n\t      document.body.appendChild(state.iframe);\n\t      if (attrs.timeout) this._timeout = setTimeout(function () {\n\t        _this.finalize(new _uu_appg01_core.Error.TimeoutError(\"OIDC iframe didn't receive callback within \" + attrs.timeout + \"s.\"));\n\t      }, attrs.timeout * 1000);\n\t    }\n\t  };\n\t\n\t  this.destroy = function () {\n\t    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);\n\t    this.destroy = function () {};\n\t    if (this._timeout) clearTimeout(this._timeout);\n\t    _CallbackHandler2.default.unregisterForCallback(this);\n\t  };\n\t};\n\t\n\texports.default = IframeComponent;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  /**\n\t   * Wraps Promise so that it can then be used in immediateThen function.\n\t   */\n\t  wrapForImmediateThen: function wrapForImmediateThen(promise) {\n\t    promise.then(function (v) {\n\t      return promise._immediateValue = v;\n\t    }, function (e) {\n\t      return promise._immediateError = e;\n\t    });\n\t    return promise;\n\t  },\n\t\n\t  /**\n\t   * If promise has already been resolved, thenFn is called immediately (or catchFn in\n\t   * case that the promise has been rejected). Otherwise thenFn and catchFn callbacks\n\t   * are simply registered via promise.then(thenFn, catchFn).\n\t   * \n\t   * Note that this works only on promises that were wrapped via #wrapForImmediateThen\n\t   * function.\n\t   * \n\t   * @return Return value of thenFn/catchFn (if invoked immediately) or promise.then(thenFn, catchFn).\n\t   */\n\t  immediateThen: function immediateThen(promise, thenFn, catchFn) {\n\t    if (\"_immediateValue\" in promise) return typeof thenFn == \"function\" ? thenFn(promise._immediateValue) : promise._immediateValue;\n\t    if (\"_immediateError\" in promise) {\n\t      if (typeof catchFn == \"function\") return catchFn(promise._immediateError);\n\t      throw promise._immediateError;\n\t    }\n\t    return promise.then(thenFn, catchFn);\n\t  }\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// login callback handling\n\tvar VC_CALLBACK_FN_NAME = \"uuOidcCallbackFn\"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.\n\t\n\t// make sure that callback works correctly even if multiple invocations using visual component below were\n\t// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup\n\t// and are now displayed both)\n\tif (typeof window != \"undefined\" && !window[VC_CALLBACK_FN_NAME]) {\n\t  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow) {\n\t    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n\t    // received callback from a popup => find out which component is using the source window and notify it\n\t    for (var i = 0; i < loginWindows.length; ++i) {\n\t      var p = loginWindows[i];\n\t      if (p.state.loginWindow == aSourceWindow) {\n\t        p.component.finalize(aLoginResult);\n\t        return;\n\t      }\n\t    }\n\t    console.warn(\"Received unexpected callback from window\", aSourceWindow, \"Passed result was:\", aLoginResult, \"Ignoring the callback.\");\n\t  };\n\t  window[VC_CALLBACK_FN_NAME].loginWindows = [];\n\t}\n\t\n\texports.default = {\n\t  registerForCallback: function registerForCallback(component, state) {\n\t    window[VC_CALLBACK_FN_NAME].loginWindows.push({ component: component, state: state });\n\t  },\n\t  unregisterForCallback: function unregisterForCallback(component) {\n\t    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n\t    for (var i = 0; i < loginWindows.length; ++i) {\n\t      // remove self from opened loginWindows\n\t      if (loginWindows[i].component === component) {\n\t        loginWindows.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar Base64Url = {\n\t  /**\n\t   * @param txtAscii Ascii string to encode (each character is in range 0-255).\n\t   * @return {string} Provided string encoded to Base64Url encoding.\n\t   */\n\t  encodeAscii: function encodeAscii(txtAscii) {\n\t    if (!txtAscii) return txtAscii;\n\t    return btoa(txtAscii).replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n\t  },\n\t  /**\n\t   * @param txtUtf8 UTF-8 string to encode.\n\t   * @return {string} Provided string encoded to Base64Url encoding.\n\t   */\n\t  encode: function encode(txtUtf8) {\n\t    if (!txtUtf8) return txtUtf8;\n\t    return Base64Url.encodeAscii(unescape(encodeURIComponent(txtUtf8)));\n\t  },\n\t  /**\n\t   * @return {string} Base64Url decoded to an Ascii string (each character is in range 0-255).\n\t   */\n\t  decodeToAscii: function decodeToAscii(base64Url) {\n\t    if (!base64Url) return null;\n\t    var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\t    return atob(base64);\n\t  },\n\t  /**\n\t   * @return {string} Base64Url decoded to a UTF-8 string.\n\t   */\n\t  decode: function decode(base64Url) {\n\t    var ascii = Base64Url.decodeToAscii(base64Url);\n\t    return ascii != null ? decodeURIComponent(escape(ascii)) : null;\n\t  }\n\t};\n\texports.default = Base64Url;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\n\tvar domReadyPromise = isBrowser ? document.readyState === \"interactive\" || document.readyState === \"complete\" ? Promise.resolve() : new Promise(function (resolve) {\n\t  document.addEventListener(\"DOMContentLoaded\", resolve, false);\n\t}) : Promise.resolve();\n\t\n\texports.default = {\n\t  domReady: domReadyPromise\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// helper for invoking Ajax requests and returning Promise\n\tfunction xhrJson(method, url, body, extraSettingFn) {\n\t  return new Promise(function (resolve, reject) {\n\t    var xhr = new XMLHttpRequest();\n\t    xhr.open(method, url, true);\n\t    xhr.withCredentials = true;\n\t    xhr.setRequestHeader(\"Accept\", \"application/json\");\n\t    xhr.onreadystatechange = function (e) {\n\t      if (xhr.readyState == 4) {\n\t        if (xhr.status >= 200 && xhr.status < 300) {\n\t          try {\n\t            var json = JSON.parse(xhr.responseText);\n\t            resolve(json);\n\t          } catch (err) {\n\t            reject(err);\n\t          }\n\t        } else {\n\t          reject(new Error(\"Server responded with status \" + xhr.status)); // TODO Better error.\n\t        }\n\t      }\n\t    };\n\t    xhr.withCredentials = true;\n\t    if (extraSettingFn) extraSettingFn(xhr);\n\t    xhr.send(body);\n\t  });\n\t}\n\t\n\texports.default = {\n\t  get: function get() {\n\t    return xhrJson.bind(this, \"GET\").apply(this, Array.prototype.slice.call(arguments));\n\t  },\n\t  post: function post() {\n\t    return xhrJson.bind(this, \"POST\").apply(this, Array.prototype.slice.call(arguments));\n\t  }\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  toSnakeCase: function toSnakeCase(aText) {\n\t    return (aText || \"\").replace(/[A-Z]/g, function (m) {\n\t      return \"_\" + m.toLowerCase();\n\t    });\n\t  }\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// NOTE If changed, update also JSDoc in Session.js.\n\texports.default = {\n\t  serverUri: \"https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be\",\n\t  clientId: null,\n\t  redirectUri: \"callbacks/oidc-callback.html\",\n\t  sessionCheckInterval: 5, // seconds between postMessage queries posted to check_session_iframe\n\t  sessionExpiringNotificationTime: 5 * 60, // seconds; event \"sessionExpiring\" will be launched these seconds prior to real expiration\n\t  tokenRefreshEnabled: true,\n\t  tokenRefreshLeeway: 5 * 60, // seconds prior to token expiration, at which to attempt refreshing of the token\n\t  tokenRefreshFailureRetryInterval: 30 // when refreshing token fails (e.g. due to network problem) wait these seconds and then try again\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar SessionContext = function SessionContext(loginOptions, authResponse, claims) {\n\t  _classCallCheck(this, SessionContext);\n\t\n\t  this.loginOptions = loginOptions;\n\t  this.authResponse = authResponse;\n\t  this.claims = claims;\n\t\n\t  this.getClaims = function () {\n\t    return claims;\n\t  };\n\t\n\t  var identity;\n\t  this.getIdentity = function () {\n\t    if (identity) return identity;\n\t    return identity = {\n\t      id: claims[\"sub\"],\n\t      name: claims[\"name\"],\n\t      email: claims[\"email\"],\n\t      uuIdentity: claims[\"uu_identity\"],\n\t      levelOfAssurance: Number(claims[\"loa\"]),\n\t      loginLevelOfAssurance: Number(claims[\"acr\"])\n\t    };\n\t  };\n\t};\n\t\n\texports.default = SessionContext;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = SessionHandler;\n\t\n\tvar _uu_appg01_core = __webpack_require__(1);\n\t\n\tvar UuApp = _interopRequireWildcard(_uu_appg01_core);\n\t\n\tvar _Session = __webpack_require__(3);\n\t\n\tvar _Session2 = _interopRequireDefault(_Session);\n\t\n\tvar _StringUtil = __webpack_require__(12);\n\t\n\tvar _StringUtil2 = _interopRequireDefault(_StringUtil);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\t// NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.\n\t\n\t/**\n\t * @class UuOidc.SessionHandler\n\t * @classdesc\n\t * Interceptor for Client which authenticates command calls by using user from\n\t * current / specified session. Additionally, if server responds with authentication challenge\n\t * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor\n\t * performs session login and calls the command again.\n\t * \n\t * Interceptor is skipped if there's request header \"authorization\" set for the command call, even\n\t * if the header value is null.\n\t * \n\t * **Configuration**\n\t * \n\t * Interceptor recognizes following options for command call:\n\t * \n\t * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.\n\t * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.\n\t * \n\t * **Error handling**\n\t * \n\t * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):\n\t * \n\t * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.\n\t */\n\tfunction SessionHandler(request, options, nextInterceptorFn) {\n\t  var hasCustomAuthn = \"authorization\" in request.headers;\n\t  if (hasCustomAuthn) return nextInterceptorFn(request, options);\n\t\n\t  var session = options.session || _Session2.default.currentSession;\n\t  var loginParams = options[\"uuoidc.loginParameters\"];\n\t  if (loginParams) loginParams = Object.keys(loginParams).reduce(function (r, k) {\n\t    return r[_StringUtil2.default.toSnakeCase(k)] = loginParams[k], r;\n\t  }, {});\n\t  var count = 0;\n\t\n\t  function runWith(extraLoginParams) {\n\t    if (++count > 5) throw new UuApp.Error.AbortError(\"Command invocation stopped because user was not able to fulfill login requirements for the command within \" + count + \" attempts.\");\n\t\n\t    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)\n\t    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);\n\t    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams) : Promise.resolve(session)).catch(function (e) {\n\t      // if user login failed then abort or throw\n\t      if (e === false) throw new UuApp.Error.AbortError(\"Command invocation stopped because user refused to log in.\");\n\t      throw new UuApp.Error.Error(\"Command invocation stopped because of a login error.\", e);\n\t    }).then(function (session) {\n\t      var isAuthenticated = session.isAuthenticated();\n\t      if (isAuthenticated) {\n\t        return Promise.resolve(session.getCallToken()).then(function (callToken) {\n\t          return { isAuthenticated: isAuthenticated, callToken: callToken };\n\t        });\n\t      }\n\t      return { isAuthenticated: isAuthenticated, callToken: null };\n\t    }).then(function (data) {\n\t      var isAuthenticated = data.isAuthenticated;\n\t      var callToken = data.callToken;\n\t      var authToken = callToken ? callToken.token : null;\n\t      if (authToken) request.headers[\"authorization\"] = [callToken.tokenType || \"Bearer\", authToken].join(\" \");\n\t      return nextInterceptorFn(request, options).catch(function (response) {\n\t        // check for special response values in WWW-Authenticate response header which indicates\n\t        // that we shall run login procedure with additional parameters and then try again the same command\n\t        try {\n\t          // NOTE Using try-catch in case that target server is cross-domain and CORS doesn't allow\n\t          // access to response headers.\n\t          var wwwAuthenticate = response.headers(\"www-authenticate\");\n\t        } catch (e) {\n\t          console.error(e);\n\t        }\n\t        if (wwwAuthenticate) {\n\t          var valueMap = {};\n\t          wwwAuthenticate.replace(/^\\S+\\s+/, \"\").split(/,/).map(function (it) {\n\t            return it.trim();\n\t          }).forEach(function (it) {\n\t            // remove \"Bearer \"\n\t            var idx = it.indexOf(\"=\");\n\t            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));\n\t            var value = decodeUriWithPlus(idx == -1 ? \"\" : it.substr(idx + 1));\n\t            valueMap[key] = decodeUriWithPlus(value);\n\t          });\n\t\n\t          var relevantValues = Object.keys(valueMap).filter(function (key) {\n\t            return key.match(/^(max_age|acr_values|prompt|scope)$/);\n\t          }).reduce(function (r, k) {\n\t            return r[k] = valueMap[k], r;\n\t          }, {});\n\t          // if there's any of relevant keys in the WWW-Authenticate response header then\n\t          // re-run the whole OIDC Handler with those values sent to login\n\t          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);\n\t\n\t          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also\n\t          if (!isAuthenticated) return runWith({ acr_values: \"1\" }); // require non-anonymous\n\t        }\n\t        return Promise.reject(response);\n\t      });\n\t    });\n\t  }\n\t  return runWith(null);\n\t}\n\t\n\tfunction decodeUriWithPlus(txt) {\n\t  return decodeURIComponent(txt.replace(/\\+/g, \" \"));\n\t}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Dom = __webpack_require__(10);\n\t\n\tvar _Dom2 = _interopRequireDefault(_Dom);\n\t\n\tvar _Discovery = __webpack_require__(2);\n\t\n\tvar _Discovery2 = _interopRequireDefault(_Discovery);\n\t\n\tvar _uu_appg01_core = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = _uu_appg01_core.Logging.LoggerFactory.get(\"UuOidc.SessionStateChangeNotifier\");\n\t\n\tvar SessionStateChangeNotifier = function () {\n\t  function SessionStateChangeNotifier(session) {\n\t    _classCallCheck(this, SessionStateChangeNotifier);\n\t\n\t    this.session = session;\n\t    this._listeners = [];\n\t\n\t    this._checkState = this._checkState.bind(this);\n\t    this._onMessage = this._onMessage.bind(this);\n\t    this._init();\n\t  }\n\t\n\t  _createClass(SessionStateChangeNotifier, [{\n\t    key: \"onStateChange\",\n\t    value: function onStateChange(listenerFn) {\n\t      var _this = this;\n\t\n\t      this._listeners.push(listenerFn);\n\t      return function () {\n\t        // return function for unregistering\n\t        var idx = _this._listeners.indexOf(listenerFn);\n\t        if (idx != -1) _this._listeners.splice(idx, 1);\n\t        return idx != -1;\n\t      };\n\t    }\n\t  }, {\n\t    key: \"destroy\",\n\t    value: function destroy() {\n\t      if (this._destroyed) return;\n\t      this._destroyed = true;\n\t      if (this._stateCheckInterval) clearInterval(this._stateCheckInterval);\n\t      delete this._stateCheckInterval;\n\t      window.removeEventListener(\"message\", this._onMessage);\n\t      this._listeners = [];\n\t    }\n\t  }, {\n\t    key: \"_init\",\n\t    value: function _init() {\n\t      var _this2 = this;\n\t\n\t      // add iframe with check_session_iframe URL\n\t      _Dom2.default.domReady.then(function () {\n\t        if (_this2._destroyed) return;\n\t        return _Discovery2.default.getMetadata(_this2.session.serverUri).then(function (metadata) {\n\t          var iframeUrl = metadata.check_session_iframe;\n\t          if (!iframeUrl) {\n\t            console.error(\"The OpenID Connect server\", _this2.session.serverUri, \"doesn't support check_session_iframe (see\", _Discovery2.default.getMetadataUri(_this2.session.serverUri), \").\");\n\t            return;\n\t          }\n\t          logger.debug(\"Creating iframe with check_session_iframe endpoint URL - \" + iframeUrl);\n\t          _this2._iframeTrustedOrigin = getOrigin(iframeUrl);\n\t          var iframe = _this2._iframe = document.createElement(\"iframe\");\n\t          iframe.style.cssText = \"position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;\";\n\t          iframe.tabIndex = \"-1\";\n\t          iframe.onload = function () {\n\t            return _this2._stateCheckAllowed = true;\n\t          };\n\t          iframe.src = iframeUrl;\n\t          document.body.appendChild(iframe);\n\t\n\t          // add message handler for processing messages from the iframe\n\t          window.addEventListener(\"message\", _this2._onMessage);\n\t\n\t          // start checking\n\t          _this2._stateCheckInterval = setInterval(_this2._checkState, _this2.session.sessionCheckInterval * 1000);\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: \"_onMessage\",\n\t    value: function _onMessage(e) {\n\t      logger.debug(\"Received message from \" + e.origin + \": \" + e.data);\n\t      if (!this._iframe || e.source !== this._iframe.contentWindow || e.origin !== this._iframeTrustedOrigin) return;\n\t      if (e.data === \"changed\") {\n\t        logger.info(\"Received session state change notification from OIDC iframe (message: '\" + e.data + \"').\");\n\t        this._listeners.forEach(function (fn) {\n\t          return fn();\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: \"_checkState\",\n\t    value: function _checkState() {\n\t      if (!this._stateCheckAllowed || !this._iframe) return;\n\t      var authResponse = (this.session._loginCtx || {}).authResponse;\n\t      if (!authResponse) return; // we have no session state (and we don't really need to get info that the user became logged in due to login in different tab)\n\t      if (!authResponse.session_state) return; // unknown session state (e.g. current token was provided directly, instead of via login in browser tab)\n\t\n\t      var query = this.session.clientId + \" \" + authResponse.session_state;\n\t      logger.debug(\"Querying session state change from OIDC iframe. Query: \" + query);\n\t      this._iframe.contentWindow.postMessage(query, this._iframeTrustedOrigin);\n\t    }\n\t  }]);\n\t\n\t  return SessionStateChangeNotifier;\n\t}();\n\t\n\texports.default = SessionStateChangeNotifier;\n\t\n\t\n\tfunction getOrigin(absUrl) {\n\t  return (absUrl || \"\").match(/^(https?:\\/\\/[^\\/]+).*$/)[1] || null;\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Session = __webpack_require__(3);\n\t\n\tvar _Session2 = _interopRequireDefault(_Session);\n\t\n\tvar _Dom = __webpack_require__(10);\n\t\n\tvar _Dom2 = _interopRequireDefault(_Dom);\n\t\n\tvar _ImplicitFlow = __webpack_require__(4);\n\t\n\tvar _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction tryAutoLogin() {\n\t  if (_Session2.default.currentSession.isAuthenticated() || _Session2.default.currentSession._loginInProgress > 0) return;\n\t\n\t  // if there's access_token parameter in current URL, consider it as the id_token of the user\n\t  var id_token;\n\t  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {\n\t    id_token = decodeURIComponent(g.replace(/\\+/g, \" \"));\n\t  });\n\t  if (id_token) {\n\t    return _Session2.default.currentSession._login({\n\t      access_token: id_token,\n\t      nonce: null\n\t    });\n\t  }\n\t\n\t  // try to login with no user interaction\n\t  return _Session2.default.currentSession._login({\n\t    prompt: \"none\", // no user interaction\n\t    acr_values: \"1\" // non-anonymous user\n\t  }).catch(function (e) {\n\t    if (_ImplicitFlow2.default.isLoggedOutError(e)) return; // everything is fine, we just aren't logged in\n\t    throw e; // some other error happenned\n\t  });\n\t}\n\t\n\t// try to login without prompting user (only for browser environment)\n\tvar isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\n\tif (isBrowser) {\n\t  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works\n\t  _Dom2.default.domReady.then(function () {\n\t    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter\n\t  }).then(_Session2.default.initPromise._finalizeInit.bind(null, true), _Session2.default.initPromise._finalizeInit.bind(null, false));\n\t} else {\n\t  _Session2.default.initPromise._finalizeInit(true);\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.SessionHandler = exports.Session = undefined;\n\t\n\tvar _Session = __webpack_require__(3);\n\t\n\tvar _Session2 = _interopRequireDefault(_Session);\n\t\n\tvar _SessionHandler = __webpack_require__(16);\n\t\n\tvar _SessionHandler2 = _interopRequireDefault(_SessionHandler);\n\t\n\t__webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// make UuOidc always present in global variable so that there're no issues\n\t// with detecting it (even during load via SystemJS)\n\tif (typeof window !== \"undefined\") window.UuOidc = { Session: _Session2.default, SessionHandler: _SessionHandler2.default };\n\t\n\texports.Session = _Session2.default;\n\texports.SessionHandler = _SessionHandler2.default;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Discovery = __webpack_require__(2);\n\t\n\tvar _Discovery2 = _interopRequireDefault(_Discovery);\n\t\n\tvar _HttpClient = __webpack_require__(11);\n\t\n\tvar _HttpClient2 = _interopRequireDefault(_HttpClient);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar jwkSetCache = {};\n\tvar cacheBustCounter = 0;\n\t\n\t// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517\n\t\n\tvar _class = function () {\n\t  function _class(options) {\n\t    _classCallCheck(this, _class);\n\t\n\t    if (!options || !options.serverUri) throw new Error(\"Jwks must be initialized with options containing serverUri.\");\n\t    this.options = options;\n\t  }\n\t\n\t  _createClass(_class, [{\n\t    key: \"getKey\",\n\t    value: function getKey(keyId, keyType) {\n\t      return this._getKey(keyId, keyType, false);\n\t    }\n\t  }, {\n\t    key: \"_getKey\",\n\t    value: function _getKey(keyId, keyType, forceKeySetReload) {\n\t      var _this = this;\n\t\n\t      // load set of OIDC server JSON Web Key-s\n\t      return _Discovery2.default.getMetadata(this.options.serverUri).then(function (metadata) {\n\t        // TODO Use also localStorage cache as optimization.\n\t        var jwkSetMeta = jwkSetCache[metadata.jwks_uri];\n\t        if (!jwkSetMeta || forceKeySetReload) {\n\t          var url = metadata.jwks_uri;\n\t          if (forceKeySetReload) url = url.replace(/(\\?.*)?$/, function (m) {\n\t            return \"?cachebust=\" + Date.now().toString(36) + \"_\" + (cacheBustCounter++).toString(36) + (m ? \"&\" + m.substr(1) : \"\");\n\t          });\n\t          jwkSetMeta = jwkSetCache[metadata.jwks_uri] = _HttpClient2.default.get(url).then(function (value) {\n\t            return { jwkSet: value, url: url };\n\t          });\n\t        }\n\t        return jwkSetMeta;\n\t      }).then(function (jwkSetMeta) {\n\t        var jwkSet = jwkSetMeta.jwkSet;\n\t        // choose key by id & type\n\t        var keys = jwkSet.keys;\n\t        if (keyId) keys = keys.filter(function (it) {\n\t          return it.kid === keyId;\n\t        }); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)\n\t        if (keyType) keys = keys.filter(function (it) {\n\t          return it.kty === keyType;\n\t        });\n\t        // keys = keys.filter(it => it.use === \"sig\" || (it.key_ops||[]).indexOf(\"verify\") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)\n\t        if (keys.length != 1) {\n\t          // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser\n\t          // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)\n\t          if (!forceKeySetReload) return _this._getKey(keyId, keyType, true);\n\t          throw new Error(\"There's \" + keys.length + \" JSON Web Key(s) in JWK Set with kid='\" + keyId + \"' kty='\" + keyType + \"'. There must be exactly 1. JWK Set has been downloaded from: \" + jwkSetMeta.url);\n\t        }\n\t        return keys[0];\n\t      });\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Base64Url = __webpack_require__(9);\n\t\n\tvar _Base64Url2 = _interopRequireDefault(_Base64Url);\n\t\n\tvar _InvalidTokenError = __webpack_require__(5);\n\t\n\tvar _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);\n\t\n\tvar _JwtVerifierWebCrypto = __webpack_require__(23);\n\t\n\tvar _JwtVerifierWebCrypto2 = _interopRequireDefault(_JwtVerifierWebCrypto);\n\t\n\tvar _JwtVerifierJsrsasign = __webpack_require__(22);\n\t\n\tvar _JwtVerifierJsrsasign2 = _interopRequireDefault(_JwtVerifierJsrsasign);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519\n\t//     - JSON (containing claims) encoded in a JWS / JWE structure\n\t// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515\n\t// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516\n\t\n\t// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net\n\t// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,\n\t// but not on production; it's ~90kB of minified code).\n\tvar hasWebCrypto = typeof crypto != \"undefined\" && crypto.subtle && crypto.subtle.importKey;\n\tvar useWebCrypto = hasWebCrypto && (typeof location == \"undefined\" || location.protocol == \"https:\");\n\tvar verifier = useWebCrypto ? _JwtVerifierWebCrypto2.default : _JwtVerifierJsrsasign2.default;\n\t\n\tvar DEFAULT_ALG = \"RS256\";\n\texports.default = {\n\t  /**\n\t   * \n\t   */\n\t  decode: function decode(token, verifyOpts, getKeyFn) {\n\t    var tokenParts;\n\t    var header;\n\t    return Promise.resolve().then(function () {\n\t      if (typeof token != \"string\") throw new Error(\"Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).\");\n\t      tokenParts = token.split(\".\");\n\t      if (tokenParts.length != 3) throw new Error(\"Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: \" + token);\n\t\n\t      // parse header\n\t      var headerB64U = tokenParts[0];\n\t      var headerStr = _Base64Url2.default.decode(headerB64U);\n\t      header = JSON.parse(headerStr);\n\t      if (header.typ != \"JWT\") throw new Error(\"Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: \" + token);\n\t\n\t      // get key\n\t      return getKeyFn(header);\n\t    }).then(function (key) {\n\t      // NOTE Check the whole importKey call if adding support for other key types.\n\t      if (!key || key.kty != \"RSA\") throw new Error(\"Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: \" + JSON.stringify(key));\n\t      // always verify algorithm against the one is JOSE header\n\t      var alg = key.alg || DEFAULT_ALG;\n\t      if (alg !== header.alg) throw new _InvalidTokenError2.default(\"Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '\" + header.alg + \"', verification key uses '\" + key.alg + \"' (with default of '\" + DEFAULT_ALG + \"'). Token: \" + token + \" Key: \" + JSON.stringify(key));\n\t\n\t      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);\n\t    }).then(function (valid) {\n\t      if (!valid) throw new _InvalidTokenError2.default(\"Invalid JSON Web Token: \" + token);\n\t      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);\n\t      var body = JSON.parse(bodyStr);\n\t      return body;\n\t    });\n\t  }\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _module = __webpack_require__(13);\n\t\n\tvar _module2 = _interopRequireDefault(_module);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar scriptUri = ((_module2.default ? _module2.default.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\n\tvar jsrsasign = undefined;\n\tvar Verifier = {\n\t  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {\n\t    var _this = this;\n\t\n\t    return Promise.resolve().then(function () {\n\t      // load jsrsasign library on 1st verification\n\t      if (jsrsasign === undefined) {\n\t        var continueFn = Verifier.verify.bind(_this, key, alg, verifyOpts, header, tokenParts, token);\n\t        var isMin = scriptUri.indexOf(\".min.\") != -1;\n\t        var baseUrl = scriptUri.replace(/^(.*\\/).*/, \"$1\");\n\t        var url = baseUrl + \"jsrsasign\" + (isMin ? \".min\" : \"\") + \".js\";\n\t        var loadPromise;\n\t        if (typeof System != \"undefined\") loadPromise = System.import(url);else loadPromise = new Promise(function (resolve, reject) {\n\t          var script = document.createElement(\"script\");\n\t          script.onload = function () {\n\t            resolve(window[\"Jsrsasign\"]);\n\t          };\n\t          script.onerror = function (e) {\n\t            reject(e);\n\t          };\n\t          script.src = url;\n\t          document.head.appendChild(script);\n\t        });\n\t        return loadPromise.then(function (obj) {\n\t          jsrsasign = obj || null;\n\t          return continueFn();\n\t        }, function (e) {\n\t          // NOTE Don't set jsrsasign to null (if network was down, next attempt of the user might work)\n\t          console.error(e);\n\t          return continueFn();\n\t        });\n\t      }\n\t      if (!jsrsasign) throw new Error(\"Unable to verify token because jsrsasign library failed to load.\");\n\t\n\t      // var exampleKey = {\"kty\":\"RSA\",\"e\":\"AQAB\",\"n\":\"yXxJt2xevNsgGGGFfX5e22Jvy0_Eopgkumz7mJ7ScWlPfsMsAi8BZsF7nbDjA3T3v2vy2_-DaLDg-z-BjRwQIPL1LRzQGeDDSVmPcZtbexqkpjouxZ6-abpefSAFX5cA8NJ5h4JknFJWAsxxKEw4Ogy6XFd_BEaDmyXlLcV65Bs\",\"alg\":\"RS256\",\"kid\":\"rJZx5vzX1FOt_Nt8sB8jUA\",\"use\":\"sig\"};\n\t      // var pem = KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(exampleKey));\n\t      //   =>\n\t      // -----BEGIN PUBLIC KEY-----\n\t      // MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJfEm3bF682yAYYYV9fl7bYm/L\n\t      // T8SimCS6bPuYntJxaU9+wywCLwFmwXudsOMDdPe/a/Lb/4NosOD7P4GNHBAg8vUt\n\t      // HNAZ4MNJWY9xm1t7GqSmOi7Fnr5pul59IAVflwDw0nmHgmScUlYCzHEoTDg6DLpc\n\t      // V38ERoObJeUtxXrkGwIDAQAB\n\t      // -----END PUBLIC KEY-----\n\t\n\t      // do the verification\n\t      var keyInst = jsrsasign.KEYUTIL.getKey(key);\n\t      var result = jsrsasign.jws.JWS.verifyJWT(token, keyInst, verifyOpts); // see lib/jsrsasign-.../jws-3.3.js\n\t      return result || Promise.reject(new Error(\"Token is not valid. Token: \" + token));\n\t    });\n\t  }\n\t};\n\t\n\tmodule.exports = Verifier;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Base64Url = __webpack_require__(9);\n\t\n\tvar _Base64Url2 = _interopRequireDefault(_Base64Url);\n\t\n\tvar _InvalidTokenError = __webpack_require__(5);\n\t\n\tvar _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tmodule.exports = {\n\t  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {\n\t    var webCryptoAlgorithm = {\n\t      name: \"RSASSA-PKCS1-v1_5\",\n\t      hash: { name: \"SHA-\" + alg.substr(2) }\n\t    };\n\t    // MS Edge throws error if the key contains field \"use\" => remove it\n\t    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails\n\t    var usedKey = JSON.parse(JSON.stringify(key));\n\t    delete usedKey.use;\n\t\n\t    return crypto.subtle.importKey(\"jwk\", usedKey, webCryptoAlgorithm, false, [\"verify\"]).then(function (webCryptoKey) {\n\t      // validate signature\n\t      var signatureB64U = tokenParts[2];\n\t      var data = tokenParts[0] + \".\" + tokenParts[1];\n\t      var signatureBytes = asciiToUint8Array(_Base64Url2.default.decodeToAscii(signatureB64U));\n\t      var dataBytes = asciiToUint8Array(data);\n\t      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);\n\t    }, function (importError) {\n\t      var e = new Error(\"Unable to verify JSON Web Token - importing key via WebCrypto API failed.\\nKey: \" + JSON.stringify(usedKey) + \"\\nToken: \" + token + \"\\nError: \" + importError);\n\t      e.cause = importError;\n\t      return Promise.reject(e);\n\t    }).then(function (signatureValid) {\n\t      if (!signatureValid) throw new _InvalidTokenError2.default(\"Invalid JSON Web Token - signature is not valid. Token: \" + token);\n\t      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);\n\t      var body = JSON.parse(bodyStr);\n\t      var throwError = function throwError(txt, failedClaim) {\n\t        throw new _InvalidTokenError2.default(\"Invalid token: \" + txt + \"\\nFailed claim: \" + JSON.stringify(failedClaim) + \"\\nIssued by: \" + JSON.stringify(body.iss) + \"\\nVerification options: \" + JSON.stringify(verifyOpts) + \"\\nToken: \" + token);\n\t      };\n\t\n\t      // verify claims\n\t\n\t      // 'alg' is always checked\n\t      if (!verifyOpts.alg) throw new Error(\"Unable to verify JWT claim - 'alg' field must be always given for verification.\");\n\t      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError(\"Algorithm \" + JSON.stringify(header.alg) + \" used by token is not valid - expected one of \" + JSON.stringify(verifyOpts.alg) + \".\", \"alg\");\n\t\n\t      // 'iss'\n\t      var v;\n\t      v = asArray(verifyOpts.iss);\n\t      if (v && v.indexOf(body.iss) === -1) throwError(\"Issuer URI \" + JSON.stringify(body.iss) + \" in token is not valid - expected one of \" + JSON.stringify(v) + \". Token was issued by different OpenID Connect server or it was forged.\", \"iss\");\n\t\n\t      // 'sub'\n\t      v = asArray(verifyOpts.sub);\n\t      if (v && v.indexOf(body.sub) === -1) throwError(\"Subject \" + JSON.stringify(body.sub) + \" in token is not valid - expected one of \" + JSON.stringify(v) + \".\", \"sub\");\n\t\n\t      // 'aud' - all values from verifyOpts.aud must be present in body.aud \n\t      v = asArray(verifyOpts.aud);\n\t      var bodyV = asArray(body.aud) || [];\n\t      if (v && bodyV.some(function (bv) {\n\t        return v.indexOf(bv) == -1;\n\t      })) throwError(\"Audience list \" + JSON.stringify(bodyV) + \" in token is not valid - some of following values are missing: \" + JSON.stringify(v) + \".\", \"aud\");\n\t\n\t      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)\n\t      var now = Date.now() / 1000;\n\t      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;\n\t      var gracePeriod = verifyOpts.gracePeriod || 0;\n\t\n\t      // 'exp' - expires\n\t      if (typeof body.exp === \"number\" && body.exp + gracePeriod < now) throwError(\"Token already expired at \" + toTimeString(body.exp) + \", current time is \" + toTimeString(now) + \".\", \"exp\");\n\t\n\t      // 'nbf' - not before\n\t      if (typeof body.nbf === \"number\" && now < body.nbf - gracePeriod) throwError(\"Token is not yet valid - it will become valid at \" + toTimeString(body.nbf) + \", current time is \" + toTimeString(now) + \". Check that your system time is correctly set.\", \"nbf\");\n\t\n\t      // 'iat' - issued at time\n\t      if (typeof body.iat === \"number\" && now < body.iat - gracePeriod) throwError(\"Token seems to have been issued in the future - \" + toTimeString(body.iat) + \", current time is \" + toTimeString(now) + \". Check that your system time is correctly set.\", \"iat\");\n\t\n\t      // 'jti' - JWT id\n\t      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError(\"Token ID \" + JSON.stringify(body.jti) + \" not valid - expected \" + JSON.stringify(verifyOpts.jti) + \".\", \"jti\");\n\t\n\t      return true;\n\t    });\n\t  }\n\t};\n\t\n\tfunction asciiToUint8Array(ascii) {\n\t  return new Uint8Array(ascii.split(\"\").map(function (c) {\n\t    return c.charCodeAt(0);\n\t  }));\n\t}\n\tfunction asArray(value) {\n\t  if (value == null) return null;\n\t  if (Array.isArray(value)) return value;\n\t  return [value];\n\t}\n\tfunction toTimeString(seconds) {\n\t  return new Date(seconds * 1000).toISOString().replace(/T/, \" \");\n\t}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _CallbackHandler = __webpack_require__(8);\n\t\n\tvar _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Default visual component for presenting login/logout prompt to the user. It displays the\n\t * URL in a popup window and waits until the user logs in / closes the window. After that\n\t * initAttrs.onResult(authResultUrl) is called as callback.\n\t * \n\t * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n\t * @param initAttrs.onResult The callback to call after login finishes. If the login finished\n\t *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.\n\t *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which\n\t *   contains the authentication response in fragment). \n\t */\n\tvar PopupComponent = function PopupComponent(initAttrs) {\n\t  var attrs = Object.assign({}, initAttrs);\n\t  var state = {\n\t    loginWindow: null,\n\t    closeCheckInterval: null\n\t  };\n\t\n\t  // add self to the list of opened loginWindows\n\t  _CallbackHandler2.default.registerForCallback(this, state);\n\t\n\t  this.finalize = function (result) {\n\t    // cleanup & do the callback\n\t    this.finalize = function () {};\n\t    this.destroy();\n\t    if (attrs.onResult) attrs.onResult(result);\n\t  }.bind(this);\n\t\n\t  var closeCheck = function () {\n\t    if (!state.loginWindow || !state.loginWindow.closed) return;\n\t    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value \"false\"\n\t  }.bind(this);\n\t\n\t  this.render = function () {\n\t    var _this = this;\n\t\n\t    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)\n\t    if (!state.loginWindow) {\n\t      var rect = { width: 599, height: 600 };\n\t      rect.left = (screen.availWidth - rect.width) / 2 + (screen.availLeft || 0);\n\t      rect.top = (screen.availHeight - rect.height) / 2 + (screen.availTop || 0);\n\t      state.loginWindow = window.open(attrs.url, \"_blank\", \"toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=\" + rect.width + \",height=\" + rect.height + \",top=\" + rect.top + \",left=\" + rect.left);\n\t      if (!state.loginWindow) {\n\t        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in\n\t        Promise.resolve().then(function () {\n\t          return _this.finalize(PopupComponent.ERROR_POPUP_BLOCKED);\n\t        }); // finalize in async way\n\t      } else {\n\t        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);\n\t      }\n\t    }\n\t  };\n\t\n\t  this.destroy = function () {\n\t    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();\n\t    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);\n\t    this.destroy = function () {};\n\t    _CallbackHandler2.default.unregisterForCallback(this);\n\t  };\n\t};\n\t\n\tPopupComponent.ERROR_POPUP_BLOCKED = \"POPUP_BLOCKED\";\n\t\n\texports.default = PopupComponent;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = generateUuid;\n\tfunction generateUuid() {\n\t  // generate UUID (RFC4122 version 4 compliant) for the event ID\n\t  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n\t  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0,\n\t        v = c == 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t  return uuid;\n\t}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _IframeComponent = __webpack_require__(6);\n\t\n\tvar _IframeComponent2 = _interopRequireDefault(_IframeComponent);\n\t\n\tvar _ImplicitFlow = __webpack_require__(4);\n\t\n\tvar _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Os8Auth = function () {\n\t\n\t  /**\n\t   * @param options.serverUri\n\t   * @param options.clientId\n\t   * @param options.redirectUri\n\t   */\n\t  function Os8Auth(options) {\n\t    _classCallCheck(this, Os8Auth);\n\t\n\t    if (!options || !options.serverUri || !options.clientId || !options.redirectUri) throw new Error(\"Os8Auth must be initialized with options containing serverUri, clientId and redirectUri.\");\n\t    this.options = options;\n\t  }\n\t\n\t  /**\n\t   * @param parameters\n\t   * @param parameters.subject_token\n\t   */\n\t\n\t\n\t  _createClass(Os8Auth, [{\n\t    key: \"grantExchangeToken\",\n\t    value: function grantExchangeToken(parameters) {\n\t      var params = parameters || {};\n\t      if (!params.subject_token) throw new Error(\"Os8Auth.grantExchangeToken must be called with parameter subject_token.\");\n\t      var urlParams = Object.assign({}, params, {\n\t        response_type: \"id_token token\",\n\t        client_id: this.options.clientId,\n\t        redirect_uri: this.options.redirectUri\n\t      });\n\t      var urlParamsParts = Object.keys(urlParams).filter(function (k) {\n\t        return urlParams[k] != null;\n\t      }).map(function (k) {\n\t        return encodeURIComponent(k) + \"=\" + encodeURIComponent(urlParams[k] + \"\");\n\t      });\n\t      var url = this.options.serverUri.replace(/\\/*$/, \"/\") + \"exchangeOs8Token\" + \"?\" + urlParamsParts.join(\"&\");\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        new _IframeComponent2.default({\n\t          url: url,\n\t          onResult: function onResult(aLoginResult) {\n\t            var authResponse = _ImplicitFlow2.default.getAuthResponseFromCallback(aLoginResult);\n\t            if (!authResponse || authResponse.error) reject(authResponse);else resolve(authResponse);\n\t          }\n\t        }).render();\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Os8Auth;\n\t}();\n\t\n\texports.default = Os8Auth;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// uu_oidcg01.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c740a437a4bd8980249f","var mod=require(\"module\");\n  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\n  __webpack_public_path__=uri.split(/\\//).slice(0, -1).join(\"/\") + \"/\"; // runtime publicPath configuration required for proper linking of styles, background images, ...\n  module.exports = require(\"__project__/index.js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../.tmp/index.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"amd\":\"uu_appg01_core\",\"commonjs\":\"uu_appg01_core\",\"commonjs2\":\"uu_appg01_core\",\"root\":\"UuApp\"}\n// module id = 1\n// module chunks = 0","import HttpClient from \"../util/HttpClient.js\";\nimport PromiseUtil from \"../util/PromiseUtil.js\";\n\nvar oidcMetadataCache = {}; // stores Promises\n\nconst Discovery = {\n  /**\n   * @return Promise resolving to OIDC discovery metadata for given issuerUri.\n   */\n  getMetadata: function (aIssuerUri) {\n    var issuerUri = aIssuerUri.replace(/\\/+$/, \"\"); // strip trailing slash(es) (this also normalizes it as a key to cache)\n    var metadata = oidcMetadataCache[issuerUri];\n    if (metadata) return metadata;\n    var discoveryEndpoint = Discovery.getMetadataUri(issuerUri);\n    return oidcMetadataCache[issuerUri] = PromiseUtil.wrapForImmediateThen(HttpClient.get(discoveryEndpoint).catch(e => {\n      delete oidcMetadataCache[issuerUri]; // don't cache errors so that e.g. clicking a button 2nd time (after network is up again) has chance to work\n      throw e;\n    }));\n  },\n  getMetadataUri: function (aIssuerUri) {\n    var issuerUri = aIssuerUri.replace(/\\/+$/, \"\"); // strip trailing slash(es) (this also normalizes it as a key to cache)\n    return issuerUri + \"/.well-known/openid-configuration\";\n  }\n};\n\nexport default Discovery;\n\n\n// WEBPACK FOOTER //\n// ./discovery/Discovery.js","import {Util, Error as Errors, Logging} from \"uu_appg01_core\";\nimport Defaults from \"./Defaults.js\";\nimport ImplicitFlow from \"./flow/ImplicitFlow.js\";\nimport SessionContext from \"./SessionContext.js\";\nimport generateUuid from \"./util/Uuid.js\";\nimport Os8Auth from \"./uuos8/Os8Auth.js\";\nimport PromiseUtil from \"./util/PromiseUtil.js\";\nimport StringUtil from \"./util/StringUtil.js\";\nimport IframeComponent from \"./ui/IframeComponent.js\";\nimport SessionStateChangeNotifier from \"./SessionStateChangeNotifier.js\";\nimport Discovery from \"./discovery/Discovery.js\";\n\nconst UuAppError = Errors.Error;\nconst logger = Logging.LoggerFactory.get(\"UuOidc.Session\");\n\nexport default class Session {\n\n  /**\n   * Creates new Session with specified options.\n   * \n   * @class UuOidc.Session\n   * @classdesc\n   * \n   * Session handling via OpenID Connect server.\n   * \n   * **Configuration**\n   * \n   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback\n   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be\n   * configured as described below - configuration parameter \"uuoidc.redirectUri\".\n   * \n   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:\n   * \n   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for\n   *   accessing most of user data.\n   * * **uuoidc.redirectUri** - redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n   *   to document.baseURI (current URL). Default is \"callbacks/oidc-callback.html\".\n   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is \"https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be\".\n   * * **uuoidc.sessionExpiringNotificationTime** - a \"sessionExpiring\" notification event is triggered these many seconds prior to the session expiration.\n   *   Default is 5 minutes. Using 0 disables the notification.\n   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.\n   *   Default is 5. Using 0 disables the checking.\n   * \n   * **Supported events**\n   * \n   * It's possible to handle session state changes and other notifications by registering a listener function to any of these events\n   * (see also {@link UuOidc.Session#addListener}):\n   * \n   * * **identityChange** - triggerred whenever an identity changes (user logs in / out / changes its authorization status). Event's\n   * \"data\" field contains the new identity (see {@link UuOidc.Session#getIdentity}).\n   * * **sessionExpiring** - triggerred some time before the global session against OpenID Connect server expires. The application\n   * can show a warning at this moment and suggest to the user to re-login themselves. Re-login can be initiated by\n   * {@link UuOidc.Session#login Session#login}({ prompt: \"login\" }) which forces a popup window to be shown.\n   * The event's \"data\" field contains an object with following fields:\n   *     * expiresAt - time in milliseconds when the expiration of the global session will occur.\n   * * **sessionExtended** - trigerred after the global session against OpenID Connect server has been extended. The application should\n   * remove the warning about necessity of user re-login if it's showing one (i.e. if there happenned a sessionExpiring event, the user\n   * re-logged in, possibly in different browser tab, then the application should no longer display any warning about sessionExpiring).\n   * The event's \"data\" field contains an object with following fields:\n   *     * expiresAt - time in milliseconds when the expiration of the global session will occur\n   * \n   * @param options {Object|UuApp.Util.Config} Options.\n   * @param options.serverUri OpenID Connect server to perform login / logout against.\n   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n   *   to document.baseURI (current URL).\n   * @param options.sessionExpiringNotificationTime A \"sessionExpiring\" notification event is triggered these many seconds prior to the session expiration.\n   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.\n   */\n  constructor(options) {\n    if (!options) throw new UuAppError(\"Session must be initialized with proper options or UuApp.Util.Config.\");\n    this._optionsMergedPromise = PromiseUtil.wrapForImmediateThen(Promise.resolve(options && typeof options.get == \"function\" ? (options.initPromise || options) : options).then(env => {\n      Object.keys(Defaults).forEach(k => {\n        let v;\n        if (env && typeof env.get == \"function\") v = env.get(\"uuoidc.\" + k, false);\n        else if (env) v = env[k];\n        if (v == null) v = Defaults[k];\n        this[k === \"redirectUri\" ? \"implicitFlowRedirectUri\" : k] = v;\n      });\n      if (!this.clientId) this.clientId = \"uu-oidc:unregistered-client:\" + generateUuid();\n      // if redirect URI is relative then absolutize it (relative to current document.baseURI)\n      if (!this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) { // no protocol present\n        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\\/).*/, \"$1\");\n        if (this.implicitFlowRedirectUri.charAt(0) != \"/\") this.implicitFlowRedirectUri = toFullUrl(baseUrl + this.implicitFlowRedirectUri);\n        else this.implicitFlowRedirectUri = toFullUrl(this.implicitFlowRedirectUri);\n      }\n      // sanitize times & interval settings\n      if (typeof this.sessionExpiringNotificationTime !== \"number\" || this.sessionExpiringNotificationTime < 0) this.sessionExpiringNotificationTime = Defaults.sessionExpiringNotificationTime;\n      if (typeof this.sessionCheckInterval !== \"number\" || this.sessionCheckInterval < 0) this.sessionCheckInterval = Defaults.sessionCheckInterval;\n      if (this.sessionCheckInterval > 0 && this.sessionCheckInterval < 2) this.sessionCheckInterval = 2; // minimal interval is 2, but allow \"0\" for disabling the check\n      if (typeof this.tokenRefreshLeeway !== \"number\" || this.tokenRefreshLeeway < 0) this.tokenRefreshLeeway = Defaults.tokenRefreshLeeway;\n      if (typeof this.tokenRefreshFailureRetryInterval !== \"number\" || this.tokenRefreshFailureRetryInterval < 0) this.tokenRefreshFailureRetryInterval = Defaults.tokenRefreshFailureRetryInterval;\n      if (this.tokenRefreshFailureRetryInterval > 0) this.tokenRefreshFailureRetryInterval = Math.max(5, this.tokenRefreshFailureRetryInterval);\n\n      // add session state checking which, in case that we were logged in and a logout\n      // against OIDC is detected (e.g. in another browser tab), will log us out\n      if (this.sessionCheckInterval) {\n        this._sessionChecker = new SessionStateChangeNotifier(this);\n        this._sessionChecker.onStateChange(() => {\n          logger.debug(\"Session state change detected.\");\n          if (!this.isAuthenticated()) return; // don't check new state if we're currently logged out (don't auto-login)\n  \n          // check login state against OpenID server (basically renew the token,\n          // possibly logging out if the current user on OpenID server differs from ours)\n          this._silentTokenRefresh(true);\n        });\n      }\n    }));\n    this._loginInProgress = 0;\n    this._silentTokenRefreshInProgress = 0;\n    this.nonce = Math.random().toString(32).substr(2);\n\n    let listeners = {};\n    /**\n     * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:\n     * \n     * * **type** The type of the event, e.g. \"identityChange\".\n     * * **data** The data passed to the event.\n     * \n     * See {@link UuOidc.Session Session} for the list of supported events.\n     * \n     * @param {string} eventName The event to register listener for.\n     * @param {function(Event)} listener The function to be called whenever the event is trigerred.\n     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeListener}).\n     * @see UuOidc.Session#removeListener\n     * @method UuOidc.Session#addListener\n     */\n    this.addListener = (eventName, listener) => {\n      let list = listeners[eventName];\n      if (!list) list = listeners[eventName] = [];\n      list.push(listener);\n      return this.removeListener.bind(this, eventName, listener);\n    };\n    /**\n     * Removes listener for specified event.\n     * \n     * @param {string} eventName The event to remove listener for.\n     * @param {function(Event)} listener The listener (function) to unregister.\n     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).\n     * @see UuOidc.Session#addListener\n     * @method UuOidc.Session#removeListener\n     */\n    this.removeListener = (eventName, listener) => {\n      let list = listeners[eventName];\n      if (!list) return false;\n      let idx = list.indexOf(listener);\n      if (idx != -1) list.splice(idx, 1);\n      return idx != -1;\n    };\n\n    this._runListeners = (eventName, data) => {\n      logger.debug(`Launching event \"${eventName}.\"`);\n      let list = listeners[eventName];\n      if (list) {\n        let e = {\n          type: eventName,\n          data: data\n        };\n        list.forEach((it) => it.call(this, e));\n      }\n      // run also deprecated identityChangeListener-s (they don't get \"event\" object but directly the data)\n      // if this is \"identityChange\" event\n      // TODO 3.0 Remove.\n      if (eventName === \"identityChange\" && listeners[\"__identityChange\"]) listeners[\"__identityChange\"].forEach(it => it.call(this, data));\n    };\n\n    /**\n     * @return {boolean} True iff the user is authenticated (logged in).\n     * @method UuOidc.Session#isAuthenticated\n     */\n    this.isAuthenticated = () => !!this._loginCtx;\n\n    /**\n     * Adds listener for changes of user identity (logins / logouts).\n     * \n     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.\n     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).\n     * @see UuOidc.Session#addListener\n     * @see UuOidc.Session#getIdentity\n     * @method UuOidc.Session#addIdentityChangeListener\n     * @deprecated Use Session#addListener(\"identityChange\", listener) instead. Note that the listener accepts Event object.\n     */\n    this.addIdentityChangeListener = this.addListener.bind(this, \"__identityChange\");\n    \n    /**\n     * Removes listener for changes of user identity (logins / logouts).\n     * \n     * @param {Function(Object)} listener The listener to remove.\n     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).\n     * @see UuOidc.Session#removeListener\n     * @method UuOidc.Session#removeIdentityChangeListener\n     * @deprecated Use Session#removeListener(\"identityChange\", listener) instead.\n     */\n    this.removeIdentityChangeListener = this.removeListener.bind(this, \"__identityChange\");\n    \n    // add session_expires_at field\n    // NOTE This is required for \"auto-logout\", \"session expiring\" and \"session extended\" functionality.\n    // NOTE This assumes that whenever a token changes, identity-change listeners are run\n    // And that they are run pretty much immediately (so that authResponse.session_expires_in\n    // is relative to the moment when we received the response).\n    this.addListener(\"identityChange\", (e) => {\n      let authResponse = (this._loginCtx || {}).authResponse;\n      if (!authResponse || !authResponse.session_expires_in) return;\n      if (authResponse.session_expires_at) return;\n      authResponse.session_expires_at = Math.floor(Date.now() / 1000) + Number(authResponse.session_expires_in);\n    });\n\n    // auto-logout when server-side session reaches its expiration time (or when token\n    // reaches its expiration time in case that server-side session info is not available)\n    // NOTE This assumes that whenever a token changes, identity-change listeners are run\n    // (so that info from new token gets checked again).\n    this.addListener(\"identityChange\", (e) => {\n      if (this._autoLogoutTimeout) {\n        clearTimeout(this._autoLogoutTimeout);\n        delete this._autoLogoutTimeout;\n      }\n      let authResponse = (this._loginCtx || {}).authResponse;\n      if (!authResponse) return;\n      \n      // plan local logout\n      let expiresAt = authResponse.session_expires_at || (this.getClaims() || {})[\"exp\"];\n      if (!expiresAt) return;\n      let now = new Date().getTime();\n      let delay = Math.max(0, expiresAt * 1000 - now);\n      logger.debug(`Planning local auto-logout at ${toTimeString(new Date(now + delay))}.`);\n      this._autoLogoutTimeout = setTimeout(() => {\n        delete this._autoLogoutTimeout;\n        this._localLogout();\n      }, delay);\n    });\n\n    // support for token auto-refresh when its nearing expiration\n    // NOTE This assumes that whenever a token changes, identity-change listeners are run\n    // (so that token refreshing gets re-planned / cleaned).\n    let lastTokenRefreshTime = 0;\n    this.addListener(\"identityChange\", (e) => {\n      if (!this.tokenRefreshEnabled) return;\n\n      if (this._sessionRefreshTimeout) {\n        clearTimeout(this._sessionRefreshTimeout);\n        delete this._sessionRefreshTimeout;\n      }\n      let claims = this.getClaims();\n      let expiresAt = (claims||{})[\"exp\"];\n      if (!expiresAt) return; // not logged in (or there's something with the claims but that shouldn't happen)\n\n      // plan token refresh\n      let now = new Date().getTime();\n      let delay = Math.max(expiresAt * 1000 - now - this.tokenRefreshLeeway * 1000, Math.max(0, 1000 - (now - lastTokenRefreshTime))); // wait at least 1s between 2 token refreshes\n      logger.debug(`Planning token auto-refresh at ${toTimeString(new Date(now + delay))}.`);\n      this._sessionRefreshTimeout = setTimeout(() => {\n        delete this._sessionRefreshTimeout;\n        lastTokenRefreshTime = new Date().getTime();\n        this._silentTokenRefresh();\n      }, delay);\n    });\n\n    // support for \"session extended\" notification\n    // NOTE This assumes that whenever a token changes, identity-change listeners are run.\n    this.addListener(\"identityChange\", e => {\n      const LEEWAY_MILLIS = 10 * 1000; // use leeway because server sends \"session_expires_in\" which is relative so if network becomes slower, we might then compute the \"...expires_at\" value as if it was greater than before\n      let authResponse = (this._loginCtx || {}).authResponse;\n      let wasExtended = (this._activeSessionExpiresAtMillis && authResponse && authResponse.session_expires_at * 1000 > this._activeSessionExpiresAtMillis + LEEWAY_MILLIS);\n      this._activeSessionExpiresAtMillis = authResponse ? authResponse.session_expires_at * 1000 : null;\n      if (wasExtended) {\n        this._sessionExpiringBlocked = false;\n        let expiresAt = this._activeSessionExpiresAtMillis;\n        setTimeout(() => { // we're currently processing \"identityChange\" listeners so let them finish and run \"sessionExtended\" afterwards\n          this._runListeners(\"sessionExtended\", { expiresAt: expiresAt });\n        }, 0);\n      }\n    });\n    \n    // support for \"session expiring\" notification\n    // NOTE Must be after \"session extended\" functionality (so that unblocking done there\n    // gets performed sooner than the code below).\n    // NOTE This assumes that whenever a token changes, identity-change listeners are run.\n    var prevIdentity = undefined;\n    this.addListener(\"identityChange\", (e) => {\n      if (this.sessionExpiringNotificationTime <= 0) return; // disabled\n\n      if (this._sessionExpiringTimeout) {\n        clearTimeout(this._sessionExpiringTimeout);\n        delete this._sessionExpiringTimeout;\n      }\n      let authResponse = (this._loginCtx || {}).authResponse;\n      let newIdentity = (this.getClaims() || {})[\"sub\"];\n      if (newIdentity != prevIdentity) this._sessionExpiringBlocked = false;\n      prevIdentity = newIdentity;\n\n      if (!authResponse) return; // not logged in\n      if (!authResponse.session_expires_at) return; // \"session expiring\" notification not supported on server\n      if (this._sessionExpiringBlocked) return; // don't trigger \"session expiring\" multiple times for the same session\n\n      let expiresAt = authResponse.session_expires_at * 1000;\n      let now = Date.now();\n      let delay = Math.max(0, expiresAt - now - this.sessionExpiringNotificationTime * 1000);\n      logger.debug(`Planning sessionExpiring notification at ${toTimeString(new Date(now + delay))}.`);\n      this._sessionExpiringTimeout = setTimeout(() => {\n        delete this._sessionExpiringTimeout;\n        this._sessionExpiringBlocked = true;\n        this._runListeners(\"sessionExpiring\", { expiresAt: expiresAt });\n      }, delay);\n    });\n  }\n\n  /**\n   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:\n   * \n   * * id\n   * * name\n   * * uuIdentity\n   * * email\n   * * levelOfAssurance\n   * * loginLevelOfAssurance\n   * \n   * @return {Object} Identity of currently logged in user or null if not logged in.\n   * @method UuOidc.Session#getIdentity\n   */\n  getIdentity() {\n    return (this._loginCtx ? this._loginCtx.getIdentity() : null);\n  }\n\n  /**\n   * Returns all claims present in the token (or null if not logged in).\n   * \n   * @method UuOidc.Session#getClaims\n   */\n  getClaims() {\n    return (this._loginCtx ? this._loginCtx.getClaims() : null);\n  }\n\n  /**\n   * Login against OpenID Connect server. If no or empty options are used, user will be required to\n   * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in\n   * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can\n   * be forced by using option \"prompt\" set to \"login\".\n   * \n   * @param options {Object} Options.\n   * @param options.prompt {string} (optional) One of \"\" (default), \"none\" (check login state without user interaction), \"login\" (re-request authentication).\n   * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).\n   * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.\n   * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it\n   *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:\n   * \n   * * \"urn:ietf:params:oauth:token-type:jwt-uuos8\" - indicates that the token being passed to the login was originally issued by uuOS8\n   * \n   * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained\n   *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:\n   * \n   *   * false - user refused to log in\n   *   * Error - any other error such as network problems, ...\n   * \n   * @method UuOidc.Session#login\n   */\n  login(options) {\n    // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).\n\n    // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)\n    var opts;\n    if (options) opts = Object.keys(options).reduce((r, k) => (r[StringUtil.toSnakeCase(k)] = options[k], r), {});\n\n    return this._login(opts);\n  }\n\n  // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.\n  _login(options, canUpdateSessionWithLoginResultFn) {\n    var opts = Object.assign({}, options);\n\n    // there's a special case in which we support providing uuOS8 token\n    var os8Token;\n    if (opts.token_type_hint === \"urn:ietf:params:oauth:token-type:jwt-uuos8\") {\n      os8Token = opts.access_token;\n      delete opts.access_token;\n      delete opts.token_type_hint;\n    }\n\n    // use accessToken directly if it's provided\n    var accessToken = opts.access_token;\n    delete opts.access_token;\n\n    var doLogin = () => {\n      ++this._loginInProgress;\n      \n      // if calling Session.login() with no parameters, log in as non-anonymous user\n      if (Object.keys(opts).length == 0) opts[\"acr_values\"] = 1;\n\n      // if we have user then login only if options indicate that we have to\n      if (!accessToken && this._loginCtx) {\n        var useCurrent = true;\n        if (opts[\"prompt\"] || opts[\"max_age\"] || opts[\"access_token\"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.\n\n        // check required login level of assurance\n        var acr_values = (opts[\"acr_values\"] != null ? opts[\"acr_values\"]+\"\" : \"\").split(/\\s+/);\n        var identity = this.getIdentity();\n        if (acr_values.every(v => Number(v) > identity.loginLevelOfAssurance)) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login\n\n        // check current token expiration\n        if (ImplicitFlow.isAuthResponseExpired(this._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login\n\n        // use current token if everything seems fine\n        if (useCurrent) {\n          --this._loginInProgress;\n          return Promise.resolve(this);\n        }\n      }\n\n      // login using implicit flow\n      var authResponse = accessToken ? { id_token: accessToken } : null;\n      var nonce = (accessToken || os8Token || \"nonce\" in opts ? opts[\"nonce\"] : this.nonce);\n      opts.nonce = nonce;\n      delete opts.state; // we'll generate our own, if needed\n\n      // NOTE Clicking a button, which launches this login method, can result in\n      // at most 1 Promise resolution. If 2 or more Promises are chained, mobile\n      // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise\n      // is wrapped via PromiseUtil which then allows us here to call our \"then\" function immediately\n      // if the this._optionsMergedPromise has already been resolved.\n      // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)\n      // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is\n      // not trivial.\n      var authResponsePromise = Promise.resolve(authResponse || PromiseUtil.immediateThen(this._optionsMergedPromise, () => {\n        // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll\n        // do this by exchanging tokens via non-standard endpoint for uuOS8\n        if (os8Token) {\n          var os8Auth = new Os8Auth({\n            serverUri: this.serverUri,\n            clientId: this.clientId,\n            redirectUri: this.implicitFlowRedirectUri\n          });\n          return os8Auth.grantExchangeToken({\n            subject_token: os8Token\n          });\n        }\n\n        // authenticate using implicit flow\n        opts.state = Math.random().toString(32).substr(2);\n        if (navigator.standalone) opts.state += \",\" + location.pathname + location.search + (location.hash.length > 1 ? location.hash : \"\"); // iOS in standalone mode - callback HTML will redirect back with full page reload\n        return ImplicitFlow.login({\n          serverUri: this.serverUri,\n          clientId: this.clientId,\n          redirectUri: this.implicitFlowRedirectUri,\n          loginParams: opts\n        });\n      }, (e) => Promise.reject(e)));\n      return authResponsePromise.then((authResponse) => {\n        // validate response\n        return this._optionsMergedPromise.then(() => ImplicitFlow.validateAuthResponse(authResponse, {\n          serverUri: this.serverUri,\n          clientId: this.clientId,\n          loginParams: opts\n        }));\n      }).then(({authResponse, claims}) => {\n        // login successful => update the session\n        if (!canUpdateSessionWithLoginResultFn || canUpdateSessionWithLoginResultFn({ authResponse, claims }) !== false) {\n          this._loginCtx = new SessionContext(opts, authResponse, claims);\n          this._runListeners(\"identityChange\", this.getIdentity());\n        }\n        return this;\n      }).then(r => {\n        --this._loginInProgress;\n        return r;\n      }, e => {\n        --this._loginInProgress;\n        return Promise.reject(e);\n      });\n    };\n\n    // wait for session restoring in case that this instance of the session is the \"main\" session\n    return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? PromiseUtil.immediateThen(Session.initPromise, doLogin) : doLogin();\n  }\n\n  /**\n   * Tries to re-authenticate the user silently:\n   * - if we are locally logged out => do nothing\n   * - if a user is logged in (on remote) and it's the same user as ours => use the new token\n   * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout\n   * - if a user is not logged in (on remote) => perform local logout\n   */\n  _silentTokenRefresh(aSkipIfPlanned) {\n    if (aSkipIfPlanned && (this._silentTokenRefreshTimeout || this._silentTokenRefreshInProgress > 0)) return;\n    \n    if (this._silentTokenRefreshTimeout) {\n      clearTimeout(this._silentTokenRefreshTimeout);\n      delete this._silentTokenRefreshTimeout;\n    }\n    let invocationCount = 0;\n    let doSilentRenew = () => {\n      if (!this.isAuthenticated()) return;\n\n      logger.debug(\"Silent token refresh - starting.\");\n      ++this._silentTokenRefreshInProgress;\n      ++invocationCount;\n      return this._login({\n        acr_values: \"1\",\n        prompt: \"none\"\n      }, ({ /*authResponse,*/ claims }) => {\n        --this._silentTokenRefreshInProgress;\n        if (!this.isAuthenticated()) { // no-op (we're logged out and don't want to silently auto-login)\n          logger.debug(\"Silent token refresh - ending with no-op (local session is already logged out).\");\n          return false; // don't use the new authResponse\n        }\n        // if the user is different than the current one then perform logout\n        if (claims.sub !== this.getClaims().sub) {\n          logger.debug(\"Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).\");\n          this._localLogout();\n          return false; // don't use the new authResponse\n        }\n        logger.debug(\"Silent token refresh - ending with token renewed.\");\n        return true; // use the new authResponse\n      }).catch((e) => {\n        let err = (e && e.error ? e.error : e); // e could be AuthenticationResponse, Error or anything else\n        if (ImplicitFlow.isLoggedOutError(e)) {\n          logger.debug(\"Silent token refresh - ending with local logout (user is not logged in on remote).\");\n          this._localLogout();\n          return;\n        }\n        if (!this._silentTokenRefreshTimeout && this.tokenRefreshFailureRetryInterval) {\n          logger.debug(`Silent token refresh - will retry in ${this.tokenRefreshFailureRetryInterval}s (operation ended with unexpected error).`, { error: err });\n          this._silentTokenRefreshTimeout = setTimeout(() => {\n            delete this._silentTokenRefreshTimeout;\n            doSilentRenew();\n          }, this.tokenRefreshFailureRetryInterval * 1000);\n        } else {\n          if (this._silentTokenRefreshTimeout) logger.debug(\"Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).\", { error: err });\n          else logger.debug(\"Silent token refresh - ending with no-op (operation ended with unexpected error).\", { error: err });\n        }\n        if (invocationCount === 1) console.warn(\"Token refresh failed with error:\", err);\n        else if (invocationCount === 2) console.warn(\"Suppressing further notifications of token refresh problem to prevent log cluttering (until success or logout).\")\n      });\n    };\n\n    doSilentRenew();\n  }\n\n  _localLogout() {\n    logger.debug(\"Performing local-logout.\");\n    if (!this._loginCtx) return;\n    delete this._loginCtx;\n    this._runListeners(\"identityChange\", this.getIdentity());\n  }\n\n  /**\n   * Log out the user.\n   * \n   * @return Promise resolved after the user gets logged out (or immediately, if the user is not logged in).\n   * @method UuOidc.Session#logout\n   */\n  logout() {\n    if (!this._loginCtx) return Promise.resolve();\n\n    // logout global session using end_session_endpoint (in an iframe)\n    return this._optionsMergedPromise.then(() => {\n      return Discovery.getMetadata(this.serverUri).then(metadata => {\n        return new Promise((resolve, reject) => {\n          if (!this._loginCtx) return resolve();\n          var logoutCallbackUri = this.implicitFlowRedirectUri;\n          var logoutUrl = metadata.end_session_endpoint + \"?post_logout_redirect_uri=\" + encodeURIComponent(logoutCallbackUri) + \"&id_token_hint=\" + encodeURIComponent(this._loginCtx.authResponse.id_token);\n          new IframeComponent({\n            url: logoutUrl,\n            onResult: (result) => {\n              if (result instanceof Error) {\n                result.message = \"Logout failed.\" + (result.message ? \" \" + result.message : \"\");\n                reject(result);\n              } else {\n                this._localLogout();\n                resolve();\n              }\n            }\n          }).render();\n        });\n      });\n    });\n  }\n\n  /**\n   * Returns token and its type for calling commands. Returned object contains following fields:\n   * \n   * * tokenType - the type of the token, such as \"Bearer\",\n   * * token - the token itself.\n   * \n   * If the user is not logged in, null is returned.\n   * \n   * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.\n   * @return Object containing token and its type, or null if user is not logged in.\n   * @method UuOidc.Session#getCallToken\n   */\n  getCallToken(callUri) {\n    var authResponse = (this._loginCtx || {}).authResponse;\n    if (!authResponse) return null;\n    var result = {\n      tokenType: authResponse.token_type || null,\n      token: authResponse.id_token || null\n    };\n    return result;\n  }\n\n}\n\nfunction toFullUrl(path) {\n  var a = document.createElement(\"a\");\n  a.href = path;\n  return a.href.toString(); // browser-normalized URL (removed \"../\" sequences, ...)\n}\n\nfunction toTimeString(date) {\n  return (\n    // date.getFullYear() + \"-\" + (\"0\" + (date.getMonth() + 1)).substr(-2) + \"-\" + (\"0\" + date.getDate()).substr(-2) + \" \" +\n    (\"0\" + date.getHours()).substr(-2) + \":\" + (\"0\" + date.getMinutes()).substr(-2) + \":\" + (\"0\" + date.getSeconds()).substr(-2)\n  );\n}\n\n/**\n * Current session.\n * \n * @name UuOidc.Session.currentSession\n * @type UuOidc.Session\n */\nvar currentSession;\nvar allowAutoInitSession = true;\nObject.defineProperty(Session, \"currentSession\", {\n  get: function () {\n    if (allowAutoInitSession && !currentSession) {\n      currentSession = new Session(Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).\n      currentSession.initComplete = false;\n      currentSession.initPromise = Session.initPromise;\n    }\n    return currentSession;\n  },\n  set: function (value) {\n    allowAutoInitSession = false;\n    currentSession = value;\n  }\n});\n\nvar finalizeInit;\n/**\n * Promise resolved after session initialization (restoring state) finishes.\n * \n * @type {Promise<UuOidc.Session>}\n * @name UuOidc.Session.initPromise \n */\n/**\n * Promise resolved after session initialization (restoring state) finishes.\n * Note that this field is available only on a session instance that is\n * created automatically during page load.\n * \n * @type {Promise<UuOidc.Session>}\n * @name UuOidc.Session#initPromise \n */\nSession.initPromise = PromiseUtil.wrapForImmediateThen(new Promise((resolve, reject) => {\n  finalizeInit = (isOk, result) => {\n    Session.initComplete = true;\n    Session.currentSession.initComplete = true;\n    if (!isOk) console.log(\"Session initialization failed:\", result);\n    resolve(Session.currentSession); // always resolve as success even if checking session state failed\n    return Session.initPromise;\n  };\n}));\nSession.initPromise._finalizeInit = finalizeInit;\n\n/**\n * Whether the session initialization performed during page load has already completed.\n * \n * @type {boolean}\n * @name UuOidc.Session.initComplete\n */\n/**\n * Whether the session initialization performed during page load has already completed.\n * Note that this field is available only on a session instance that is\n * created automatically during page load.\n * \n * @type {boolean}\n * @name UuOidc.Session#initComplete\n */\nSession.initComplete = false;\n\n\n\n// WEBPACK FOOTER //\n// ./Session.js","import Discovery from \"../discovery/Discovery.js\";\nimport PromiseUtil from \"../util/PromiseUtil.js\";\nimport PopupComponent from \"../ui/PopupComponent.js\";\nimport IframeComponent from \"../ui/IframeComponent.js\";\nimport Jwt from \"../jwt/Jwt.js\";\nimport InvalidTokenError from \"../jwt/InvalidTokenError.js\";\nimport Jwks from \"../jwks/Jwks.js\";\n\nconst GRACE_PERIOD = 300;\n\nvar ImplicitFlow = {\n  /**\n   * @param options.serverUri\n   * @param options.clientId\n   * @param options.redirectUri\n   * @param options.loginVisualComponent\n   * @param options.loginParams Additional URL parameters to be passed in the HTTP request.\n   */\n  login: function (options) {\n    var opts = options || {};\n\n    // check that required data is available\n    var serverUri = opts.serverUri;\n    if (!serverUri) throw new Error(\"ImplicitFlow.login requires option 'serverUri'.\");\n    var clientId = opts.clientId;\n    if (!clientId) throw new Error(\"ImplicitFlow.login requires option 'clientId'.\");\n    var redirectUri = opts.redirectUri;\n    if (!redirectUri) throw new Error(\"ImplicitFlow.login requires option 'redirectUri'.\");\n\n    // NOTE Using PromiseUtil.immediateThen which will run our \"then\" callback immediately if\n    // the Discovery.getMetadata is already resolved. The idea is that this login could have\n    // been triggered from \"click\" event and we need to open popup window within this event's\n    // lifetime or within single Promise (but not Promise chain because that doesn't work on\n    // iPhones).\n    return PromiseUtil.immediateThen(Discovery.getMetadata(serverUri), (oidcMetadata) => {\n      // prepare login URL\n      var loginParams = Object.assign({ scope: \"openid\" }, opts.loginParams, {\n        response_type: \"id_token token\",\n        client_id: clientId,\n        redirect_uri: redirectUri\n      });\n      var loginParamsParts = [];\n      for (var k in loginParams) {\n        var v = loginParams[k];\n        if (v == null) continue;\n        loginParamsParts.push(encodeURIComponent(k) + \"=\" + encodeURIComponent(v + \"\"));\n      }\n      var loginUrl = oidcMetadata.authorization_endpoint + \"?\" + loginParamsParts.join(\"&\");\n\n      // display visual component for logging in (popup window)\n      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != \"none\" ? PopupComponent : IframeComponent);\n      return new Promise(function (resolve, reject) {\n        new LoginVisualComponent({\n          url: loginUrl,\n          onResult: function (aLoginResult) {\n            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);\n            if (authResponse === false) return reject(new Error(\"User refused to log in.\"));\n            if (authResponse === PopupComponent.ERROR_POPUP_BLOCKED) return reject(new Error(\"Login failed due to popup blocking.\"));\n\n            // resolve the promise successfully with the token (iff there's no \"error\" field)\n            if (authResponse.error) reject(authResponse);\n            else resolve(authResponse);\n          }\n        }).render();\n      });\n    }, (e) => {\n      return Promise.reject(e);\n    });\n  },\n\n  validateAuthResponse(authResponse, opts) {\n    // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation\n    // 1. process only recognized fields in response (id_token, expires_in, ...)\n    // 2. validate implicit flow callback response (\"state\")\n    // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n    //     ii. validate signature\n    //    iii. validate nonce\n    // 4. validate access_token\n\n    // 2.i. validate state\n    if (opts.loginParams.state && authResponse.state !== opts.loginParams.state) throw new Error(\"Invalid 'state' in received authorization response. Expected \" + opts.loginParams.state + \" but got \" + authResponse.state + \". Response: \" + JSON.stringify(authResponse));\n    \n    // 2.ii. validate expiration\n    if (ImplicitFlow.isAuthResponseExpired(authResponse)) throw new Error(\"Token expired \" + JSON.stringify(authResponse));\n\n    // 3. validate id_token with nonce\n    return ImplicitFlow.validateIdToken(authResponse.id_token, opts).then(claims => {\n      return { authResponse, claims };\n    });\n\n    // 4. validate access_token\n    // NOTE Ignore - we're not using access_token field.\n  },\n\n  isAuthResponseExpired(authResponse) {\n    var now = new Date().getTime() / 1000;\n    var leeway = 60;\n    var expired = false;\n    if (!authResponse.issued_at) authResponse.issued_at = now;\n    if (authResponse.expires_at) expired = expired || (authResponse.expires_at < now - leeway);\n    if (authResponse.expires_in && authResponse.issued_at) expired = expired || (Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway);\n    return expired;\n  },\n\n  /**\n   * @param {*} e The error during authorization.\n   * @return Whether the error means that the user is not logged in on the remote server.\n   */\n  isLoggedOutError(e) {\n    return (e && typeof e == \"object\" && typeof e[\"error_description\"] == \"string\" && e[\"error_description\"].match(/interaction/i) && e[\"error_description\"].match(/required/i));\n  },\n\n  /**\n   * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.\n   */\n  validateIdToken(token, {serverUri/*, clientId*/, loginParams: {nonce} }) {\n    // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n    //         1. -Decrypt JWE - not supported.\n    //         2. +REQUIRED validate 'iss'\n    //         3. +REQUIRED validate 'aud'\n    //         4. -SHOULD validate multiple 'aud' vs. 'azp'\n    //         5. -SHOULD validate 'azp'\n    //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>\n    //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration\n    //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)\n    //         9. +REQUIRED current time < 'exp'\n    //        10. +CAN check 'iat'\n    //        11. +REQUIRED (for implicit flow) validate nonce\n    //        12. -SHOULD check if 'acr' is appropriate\n    //        13. -SHOULD check if 'auth_time' was requested.\n    //     ii. validate signature\n    //    iii. validate nonce\n    return Discovery.getMetadata(serverUri).then(metadata => {\n      var verifyOptions = {\n        // NOTE IE11 doesn't have RS512 (but it has \"RS256\" and \"RS384\").\n        alg: [\"RS256\"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)\n        iss: [metadata.issuer], // 3.i.2.\n        // aud: clientId, // 3.i.3. TODO We don't have the proper value.\n        // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') \n        gracePeriod: GRACE_PERIOD\n      };\n      return Jwt.decode(token, verifyOptions, (jwtHeader) => { // 3.ii.\n        if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\\d+$/)) throw new Error(\"Invalid token. Only RSA signature is supported, but token uses algorithm '\" + jwtHeader.alg + \"'. Token: \" + token);\n        var keyType = \"RSA\";\n\n        // check algorithm in token (whether it's really supported by the server)\n        var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];\n        if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error(\"Invalid token. Token was signed using algorithm '\" + jwtHeader.alg + \"' but the OIDC server '\" + serverUri + \"' supports only \" + JSON.stringify(supportedAlgs) + \". Token: \" + token);\n\n        // pick the key from JWK Set\n        var jwks = new Jwks({ serverUri: serverUri });\n        return jwks.getKey(jwtHeader.kid, keyType).catch(e => {\n          throw new Error(\"Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server \" + serverUri + \". Token: \" + token, e);\n        });\n      }).then(claims => {\n        // 3.i.11., 3.iii. validate nonce\n        if (nonce && claims.nonce !== nonce) throw new InvalidTokenError(\"Invalid nonce in ID token claims. Expected \" + nonce + \" but got \" + claims.nonce);\n        return claims;\n      });\n    });\n  },\n\n  /**\n   * \n   * @param {*} aLoginCallbackResult \n   * @return One of: \n   * * false - user refused to log in (or popups are blocked)\n   * * object with \"error\" field set - an error\n   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...\n   */\n  getAuthResponseFromCallback(aLoginCallbackResult) {\n    if (aLoginCallbackResult === false || aLoginCallbackResult === PopupComponent.ERROR_POPUP_BLOCKED) return aLoginCallbackResult;\n    if (aLoginCallbackResult instanceof Error) return { error: aLoginCallbackResult };\n\n    // extract login token\n    // example of successful aLoginCallbackResult: \"...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid\" \n    // example of error aLoginCallbackResult:      \"...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR\"\n    var authResponse = {};\n    aLoginCallbackResult.replace(/^[^#]*#?/, \"\").split(/&/).forEach(it => { \n      var eqlIdx = it.indexOf(\"=\");\n      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\\+/g, \" \"));\n      var value = decodeURIComponent((eqlIdx == -1 ? \"\" : it.substr(eqlIdx+1)).replace(/\\+/g, \" \"));\n      authResponse[key] = value;\n    });\n    return authResponse;\n  }\n};\n\n\nexport default ImplicitFlow;\n\n\n// WEBPACK FOOTER //\n// ./flow/ImplicitFlow.js","import {Error as Errors} from \"uu_appg01_core\";\n\nexport default class InvalidTokenError extends Errors.Error {}\n\n\n// WEBPACK FOOTER //\n// ./jwt/InvalidTokenError.js","import CallbackHandler from \"./CallbackHandler.js\";\nimport {Error as Errors} from \"uu_appg01_core\";\n\n/**\n * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt=\"none\" cases.\n * After login/logout initAttrs.onResult(authResultUrl) is called as callback. In case of an error, an error instance\n * is passed to the callback.\n * \n * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n * @param initAttrs.onResult The callback to call after login/logout finishes.\n * @param initAttrs.timeout Seconds to wait after which consider the attempt unsuccessful, resulting in UuApp.Error.TimeoutError result.\n */\nvar IframeComponent = function (initAttrs) {\n  var attrs = Object.assign({}, initAttrs);\n  var state = {\n    iframe: null\n  };\n  Object.defineProperty(state, \"loginWindow\", {\n    get: function () {\n      try { // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)\n        return (state.iframe != null ? state.iframe.contentWindow : null);\n      } catch (e) {\n        // ignore\n      }\n      return null;\n    }\n  });\n\n  // add self to the list of openend loginWindows\n  CallbackHandler.registerForCallback(this, state);\n\n  // finalization callback (for this component instance) called after login from redirect_uri page\n  this.finalize = function (aLoginResult) {\n    // cleanup & do the callback\n    this.finalize = function () {};\n    this.destroy();\n    if (attrs.onResult) attrs.onResult(aLoginResult);\n  }.bind(this);\n\n  this.render = function () {\n    if (!state.iframe) {\n      state.iframe = document.createElement(\"iframe\");\n      state.iframe.style.cssText = \"position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;\";\n      state.iframe.src = attrs.url;\n      state.iframe.onload = () => this.finalize(new Error(\"OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running.\" +\n        \" Alternatively, an error might have happened on OIDC server while processing URL \" + attrs.url + \" or the application sent wrong redirect_uri.\")); // proper callback page will perform callback prior to onload event\n      state.iframe.onerror = () => this.finalize(new Error(\"OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running.\" +\n        \" Alternatively, an error might have happened on OIDC server while processing URL \" + attrs.url + \" or the application sent wrong redirect_uri.\"));\n      document.body.appendChild(state.iframe);\n      if (attrs.timeout) this._timeout = setTimeout(() => {\n        this.finalize(new Errors.TimeoutError(\"OIDC iframe didn't receive callback within \" + attrs.timeout + \"s.\"));\n      }, attrs.timeout * 1000);\n    }\n  };\n\n  this.destroy = function () {\n    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);\n    this.destroy = function () {};\n    if (this._timeout) clearTimeout(this._timeout);\n    CallbackHandler.unregisterForCallback(this);\n  };\n};\n\nexport default IframeComponent;\n\n\n// WEBPACK FOOTER //\n// ./ui/IframeComponent.js","export default {\n  /**\n   * Wraps Promise so that it can then be used in immediateThen function.\n   */\n  wrapForImmediateThen: function (promise) {\n    promise.then(v => promise._immediateValue = v, e => promise._immediateError = e);\n    return promise;\n  },\n\n  /**\n   * If promise has already been resolved, thenFn is called immediately (or catchFn in\n   * case that the promise has been rejected). Otherwise thenFn and catchFn callbacks\n   * are simply registered via promise.then(thenFn, catchFn).\n   * \n   * Note that this works only on promises that were wrapped via #wrapForImmediateThen\n   * function.\n   * \n   * @return Return value of thenFn/catchFn (if invoked immediately) or promise.then(thenFn, catchFn).\n   */\n  immediateThen: function (promise, thenFn, catchFn) {\n    if (\"_immediateValue\" in promise) return (typeof thenFn == \"function\" ? thenFn(promise._immediateValue) : promise._immediateValue);\n    if (\"_immediateError\" in promise) {\n      if (typeof catchFn == \"function\") return catchFn(promise._immediateError);\n      throw promise._immediateError;\n    }\n    return promise.then(thenFn, catchFn);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./util/PromiseUtil.js","// login callback handling\nvar VC_CALLBACK_FN_NAME = \"uuOidcCallbackFn\"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.\n\n// make sure that callback works correctly even if multiple invocations using visual component below were\n// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup\n// and are now displayed both)\nif (typeof window != \"undefined\" && !window[VC_CALLBACK_FN_NAME]) {\n  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow) {\n    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n    // received callback from a popup => find out which component is using the source window and notify it\n    for (var i = 0; i < loginWindows.length; ++i) {\n      var p = loginWindows[i];\n      if (p.state.loginWindow == aSourceWindow) {\n        p.component.finalize(aLoginResult);\n        return;\n      } \n    }\n    console.warn(\"Received unexpected callback from window\", aSourceWindow, \"Passed result was:\", aLoginResult, \"Ignoring the callback.\");\n  };\n  window[VC_CALLBACK_FN_NAME].loginWindows = [];\n}\n\nexport default {\n  registerForCallback(component, state) {\n    window[VC_CALLBACK_FN_NAME].loginWindows.push({component: component, state: state});\n  },\n\n  unregisterForCallback(component) {\n    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n    for (var i=0; i<loginWindows.length; ++i) { // remove self from opened loginWindows\n      if (loginWindows[i].component === component) {\n        loginWindows.splice(i, 1);\n        break;\n      }\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./ui/CallbackHandler.js","var Base64Url = {\n  /**\n   * @param txtAscii Ascii string to encode (each character is in range 0-255).\n   * @return {string} Provided string encoded to Base64Url encoding.\n   */\n  encodeAscii: (txtAscii) => {\n    if (!txtAscii) return txtAscii;\n    return btoa(txtAscii).replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  },\n  /**\n   * @param txtUtf8 UTF-8 string to encode.\n   * @return {string} Provided string encoded to Base64Url encoding.\n   */\n  encode: (txtUtf8) => {\n    if (!txtUtf8) return txtUtf8;\n    return Base64Url.encodeAscii(unescape(encodeURIComponent(txtUtf8)));\n  },\n  /**\n   * @return {string} Base64Url decoded to an Ascii string (each character is in range 0-255).\n   */\n  decodeToAscii: (base64Url) => {\n    if (!base64Url) return null;\n    var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return atob(base64);\n  },\n  /**\n   * @return {string} Base64Url decoded to a UTF-8 string.\n   */\n  decode: (base64Url) => {\n    var ascii = Base64Url.decodeToAscii(base64Url);\n    return (ascii != null ? decodeURIComponent(escape(ascii)) : null);\n  }\n};\nexport default Base64Url;\n\n\n// WEBPACK FOOTER //\n// ./util/Base64Url.js","var isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\nvar domReadyPromise = isBrowser ? (document.readyState === \"interactive\" || document.readyState === \"complete\" ? Promise.resolve() : new Promise((resolve) => {\n  document.addEventListener(\"DOMContentLoaded\", resolve, false);\n})) : Promise.resolve();\n\nexport default {\n  domReady: domReadyPromise\n};\n\n\n// WEBPACK FOOTER //\n// ./util/Dom.js","// helper for invoking Ajax requests and returning Promise\nfunction xhrJson(method, url, body, extraSettingFn) {\n  return new Promise(function (resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    xhr.withCredentials = true;\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n    xhr.onreadystatechange = function (e) {\n      if (xhr.readyState == 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            var json = JSON.parse(xhr.responseText);\n            resolve(json);\n          } catch (err) {\n            reject(err);\n          }\n        } else {\n          reject(new Error(\"Server responded with status \" + xhr.status)); // TODO Better error.\n        }\n      }\n    };\n    xhr.withCredentials = true;\n    if (extraSettingFn) extraSettingFn(xhr);\n    xhr.send(body);\n  });\n}\n\nexport default {\n  get: function () {\n    return xhrJson.bind(this, \"GET\").apply(this, Array.prototype.slice.call(arguments));\n  },\n  post: function () {\n    return xhrJson.bind(this, \"POST\").apply(this, Array.prototype.slice.call(arguments));\n  }\n};\n\n\n// WEBPACK FOOTER //\n// ./util/HttpClient.js","export default {\n  toSnakeCase(aText) {\n    return (aText || \"\").replace(/[A-Z]/g, m => \"_\" + m.toLowerCase());\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./util/StringUtil.js","module.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"amd\":\"module\",\"commonjs\":\"module\",\"commonjs2\":\"module\",\"root\":\"undefined\"}\n// module id = 13\n// module chunks = 0","// NOTE If changed, update also JSDoc in Session.js.\nexport default {\n  serverUri: \"https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be\",\n  clientId: null,\n  redirectUri: \"callbacks/oidc-callback.html\",\n  sessionCheckInterval: 5, // seconds between postMessage queries posted to check_session_iframe\n  sessionExpiringNotificationTime: 5 * 60, // seconds; event \"sessionExpiring\" will be launched these seconds prior to real expiration\n  tokenRefreshEnabled: true,\n  tokenRefreshLeeway: 5 * 60, // seconds prior to token expiration, at which to attempt refreshing of the token\n  tokenRefreshFailureRetryInterval: 30 // when refreshing token fails (e.g. due to network problem) wait these seconds and then try again\n};\n\n\n// WEBPACK FOOTER //\n// ./Defaults.js","export default class SessionContext {\n  constructor(loginOptions, authResponse, claims) {\n    this.loginOptions = loginOptions;\n    this.authResponse = authResponse;\n    this.claims = claims;\n\n    this.getClaims = () => claims;\n\n    var identity;\n    this.getIdentity = () => {\n      if (identity) return identity;\n      return (identity = {\n        id: claims[\"sub\"],\n        name: claims[\"name\"],\n        email: claims[\"email\"],\n        uuIdentity: claims[\"uu_identity\"],\n        levelOfAssurance: Number(claims[\"loa\"]),\n        loginLevelOfAssurance: Number(claims[\"acr\"])\n      });\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./SessionContext.js","import * as UuApp from \"uu_appg01_core\";\nimport Session from \"./Session.js\";\nimport StringUtil from \"./util/StringUtil.js\";\n\n // NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.\n\n/**\n * @class UuOidc.SessionHandler\n * @classdesc\n * Interceptor for Client which authenticates command calls by using user from\n * current / specified session. Additionally, if server responds with authentication challenge\n * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor\n * performs session login and calls the command again.\n * \n * Interceptor is skipped if there's request header \"authorization\" set for the command call, even\n * if the header value is null.\n * \n * **Configuration**\n * \n * Interceptor recognizes following options for command call:\n * \n * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.\n * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.\n * \n * **Error handling**\n * \n * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):\n * \n * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.\n */\nexport default function SessionHandler(request, options, nextInterceptorFn) {\n  var hasCustomAuthn = \"authorization\" in request.headers;\n  if (hasCustomAuthn) return nextInterceptorFn(request, options);\n\n  var session = options.session || Session.currentSession;\n  var loginParams = options[\"uuoidc.loginParameters\"];\n  if (loginParams) loginParams = Object.keys(loginParams).reduce((r, k) => (r[StringUtil.toSnakeCase(k)] = loginParams[k], r), {});\n  var count = 0;\n\n  function runWith(extraLoginParams) {\n    if (++count > 5) throw new UuApp.Error.AbortError(\"Command invocation stopped because user was not able to fulfill login requirements for the command within \" + count + \" attempts.\");\n\n    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)\n    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);\n    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams) : Promise.resolve(session)).catch(e => {\n      // if user login failed then abort or throw\n      if (e === false) throw new UuApp.Error.AbortError(\"Command invocation stopped because user refused to log in.\");\n      throw new UuApp.Error.Error(\"Command invocation stopped because of a login error.\", e);\n    }).then(function (session) {\n      var isAuthenticated = session.isAuthenticated();\n      if (isAuthenticated) {\n        return Promise.resolve(session.getCallToken()).then(callToken => ({ isAuthenticated: isAuthenticated, callToken: callToken }));\n      }\n      return { isAuthenticated: isAuthenticated, callToken: null };\n    }).then(data => {\n      var isAuthenticated = data.isAuthenticated;\n      var callToken = data.callToken;\n      var authToken = (callToken ? callToken.token : null);\n      if (authToken) request.headers[\"authorization\"] = [callToken.tokenType || \"Bearer\", authToken].join(\" \");\n      return nextInterceptorFn(request, options).catch(response => {\n        // check for special response values in WWW-Authenticate response header which indicates\n        // that we shall run login procedure with additional parameters and then try again the same command\n        try {\n          // NOTE Using try-catch in case that target server is cross-domain and CORS doesn't allow\n          // access to response headers.\n          var wwwAuthenticate = response.headers(\"www-authenticate\");\n        } catch (e) {\n          console.error(e);\n        }\n        if (wwwAuthenticate) {\n          var valueMap = {};\n          wwwAuthenticate.replace(/^\\S+\\s+/, \"\").split(/,/).map(it => it.trim()).forEach(it => { // remove \"Bearer \"\n            var idx = it.indexOf(\"=\");\n            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));\n            var value = decodeUriWithPlus(idx == -1 ? \"\" : it.substr(idx + 1));\n            valueMap[key] = decodeUriWithPlus(value);\n          });\n\n          var relevantValues = Object.keys(valueMap).filter(key => key.match(/^(max_age|acr_values|prompt|scope)$/)).reduce((r,k) => (r[k]=valueMap[k],r), {});\n          // if there's any of relevant keys in the WWW-Authenticate response header then\n          // re-run the whole OIDC Handler with those values sent to login\n          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);\n\n          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also\n          if (!isAuthenticated) return runWith({ acr_values: \"1\" }); // require non-anonymous\n        }\n        return Promise.reject(response);\n      });\n    });\n  }\n  return runWith(null);\n}\n\nfunction decodeUriWithPlus(txt) {\n  return decodeURIComponent(txt.replace(/\\+/g, \" \"));\n}\n\n\n// WEBPACK FOOTER //\n// ./SessionHandler.js","import Dom from \"./util/Dom.js\";\nimport Discovery from \"./discovery/Discovery.js\";\nimport {Logging} from \"uu_appg01_core\";\n\nconst logger = Logging.LoggerFactory.get(\"UuOidc.SessionStateChangeNotifier\");\n\nexport default class SessionStateChangeNotifier {\n  constructor(session) {\n    this.session = session;\n    this._listeners = [];\n\n    this._checkState = this._checkState.bind(this);\n    this._onMessage = this._onMessage.bind(this);\n    this._init();\n  }\n  onStateChange(listenerFn) {\n    this._listeners.push(listenerFn);\n    return () => { // return function for unregistering\n      var idx = this._listeners.indexOf(listenerFn);\n      if (idx != -1) this._listeners.splice(idx, 1);\n      return idx != -1;\n    };\n  }\n  destroy() {\n    if (this._destroyed) return;\n    this._destroyed = true;\n    if (this._stateCheckInterval) clearInterval(this._stateCheckInterval);\n    delete this._stateCheckInterval;\n    window.removeEventListener(\"message\", this._onMessage);\n    this._listeners = [];\n  }\n\n  _init() {\n    // add iframe with check_session_iframe URL\n    Dom.domReady.then(() => {\n      if (this._destroyed) return;\n      return Discovery.getMetadata(this.session.serverUri).then(metadata => {\n        var iframeUrl = metadata.check_session_iframe;\n        if (!iframeUrl) {\n          console.error(\"The OpenID Connect server\", this.session.serverUri, \"doesn't support check_session_iframe (see\", Discovery.getMetadataUri(this.session.serverUri), \").\");\n          return;\n        }\n        logger.debug(\"Creating iframe with check_session_iframe endpoint URL - \" + iframeUrl);\n        this._iframeTrustedOrigin = getOrigin(iframeUrl);\n        var iframe = this._iframe = document.createElement(\"iframe\");\n        iframe.style.cssText = \"position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;\";\n        iframe.tabIndex = \"-1\";\n        iframe.onload = () => this._stateCheckAllowed = true;\n        iframe.src = iframeUrl;\n        document.body.appendChild(iframe);\n\n        // add message handler for processing messages from the iframe\n        window.addEventListener(\"message\", this._onMessage);\n\n        // start checking\n        this._stateCheckInterval = setInterval(this._checkState, this.session.sessionCheckInterval * 1000);\n      });\n    });\n  }\n  _onMessage(e) {\n    logger.debug(\"Received message from \" + e.origin + \": \" + e.data);\n    if (!this._iframe || e.source !== this._iframe.contentWindow || e.origin !== this._iframeTrustedOrigin) return;\n    if (e.data === \"changed\") {\n      logger.info(\"Received session state change notification from OIDC iframe (message: '\" + e.data + \"').\");\n      this._listeners.forEach(fn => fn());\n    }\n  }\n  _checkState() {\n    if (!this._stateCheckAllowed || !this._iframe) return;\n    let authResponse = (this.session._loginCtx || {}).authResponse;\n    if (!authResponse) return; // we have no session state (and we don't really need to get info that the user became logged in due to login in different tab)\n    if (!authResponse.session_state) return; // unknown session state (e.g. current token was provided directly, instead of via login in browser tab)\n\n    let query = this.session.clientId + \" \" + authResponse.session_state;\n    logger.debug(\"Querying session state change from OIDC iframe. Query: \" + query);\n    this._iframe.contentWindow.postMessage(query, this._iframeTrustedOrigin);\n  }\n}\n\nfunction getOrigin(absUrl) {\n  return (absUrl || \"\").match(/^(https?:\\/\\/[^\\/]+).*$/)[1] || null;\n}\n\n\n// WEBPACK FOOTER //\n// ./SessionStateChangeNotifier.js","import Session from \"./Session.js\";\nimport Dom from \"./util/Dom.js\";\nimport ImplicitFlow from \"./flow/ImplicitFlow.js\";\n\nfunction tryAutoLogin() {\n  if (Session.currentSession.isAuthenticated() || Session.currentSession._loginInProgress > 0) return;\n\n  // if there's access_token parameter in current URL, consider it as the id_token of the user\n  var id_token;\n  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {\n    id_token = decodeURIComponent(g.replace(/\\+/g, \" \"));\n  });\n  if (id_token) {\n    return Session.currentSession._login({\n      access_token: id_token,\n      nonce: null\n    });\n  }\n\n  // try to login with no user interaction\n  return Session.currentSession._login({\n    prompt: \"none\", // no user interaction\n    acr_values: \"1\" // non-anonymous user\n  }).catch(e => {\n    if (ImplicitFlow.isLoggedOutError(e)) return; // everything is fine, we just aren't logged in\n    throw e; // some other error happenned\n  });\n}\n\n// try to login without prompting user (only for browser environment)\nvar isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\nif (isBrowser) {\n  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works\n  Dom.domReady.then(() => {\n    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter\n  }).then(Session.initPromise._finalizeInit.bind(null, true), Session.initPromise._finalizeInit.bind(null, false));\n} else {\n  Session.initPromise._finalizeInit(true);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./bootstrap-session.js","import Session from \"./Session.js\";\nimport SessionHandler from \"./SessionHandler.js\";\nimport \"./bootstrap-session.js\";\n\n// make UuOidc always present in global variable so that there're no issues\n// with detecting it (even during load via SystemJS)\nif (typeof window !== \"undefined\") window.UuOidc = { Session, SessionHandler };\n\nexport { Session, SessionHandler };\n\n\n// WEBPACK FOOTER //\n// ./index.js","import Discovery from \"../discovery/Discovery.js\";\nimport HttpClient from \"../util/HttpClient.js\";\n\nvar jwkSetCache = {};\nvar cacheBustCounter = 0;\n\n// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517\n\nexport default class {\n  constructor (options) {\n    if (!options || !options.serverUri) throw new Error(\"Jwks must be initialized with options containing serverUri.\");\n    this.options = options;\n  }\n\n  getKey(keyId, keyType) {\n    return this._getKey(keyId, keyType, false);\n  }\n\n  _getKey(keyId, keyType, forceKeySetReload) {\n    // load set of OIDC server JSON Web Key-s\n    return Discovery.getMetadata(this.options.serverUri).then(metadata => {\n      // TODO Use also localStorage cache as optimization.\n      var jwkSetMeta = jwkSetCache[metadata.jwks_uri];\n      if (!jwkSetMeta || forceKeySetReload) {\n        var url = metadata.jwks_uri;\n        if (forceKeySetReload) url = url.replace(/(\\?.*)?$/, m => \"?cachebust=\" + Date.now().toString(36) + \"_\" + (cacheBustCounter++).toString(36) + (m ? \"&\" + m.substr(1) : \"\"));\n        jwkSetMeta = jwkSetCache[metadata.jwks_uri] = HttpClient.get(url).then(value => ({ jwkSet: value, url: url }));\n      }\n      return jwkSetMeta;\n    }).then(jwkSetMeta => {\n      var jwkSet = jwkSetMeta.jwkSet;\n      // choose key by id & type\n      var keys = jwkSet.keys;\n      if (keyId) keys = keys.filter(it => it.kid === keyId); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)\n      if (keyType) keys = keys.filter(it => it.kty === keyType);\n      // keys = keys.filter(it => it.use === \"sig\" || (it.key_ops||[]).indexOf(\"verify\") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)\n      if (keys.length != 1) {\n        // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser\n        // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)\n        if (!forceKeySetReload) return this._getKey(keyId, keyType, true);\n        throw new Error(\"There's \" + keys.length + \" JSON Web Key(s) in JWK Set with kid='\" + keyId + \"' kty='\" + keyType + \"'. There must be exactly 1. JWK Set has been downloaded from: \" + jwkSetMeta.url);\n      }\n      return keys[0];\n    });\n  } \n}\n\n\n// WEBPACK FOOTER //\n// ./jwks/Jwks.js","import Base64Url from \"../util/Base64Url.js\";\nimport InvalidTokenError from \"./InvalidTokenError.js\";\nimport JwtVerifierWebCrypto from \"./JwtVerifierWebCrypto.js\";\nimport JwtVerifierJsrsasign from \"./JwtVerifierJsrsasign.js\";\n\n// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519\n//     - JSON (containing claims) encoded in a JWS / JWE structure\n// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515\n// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516\n\n// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net\n// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,\n// but not on production; it's ~90kB of minified code).\nvar hasWebCrypto = (typeof crypto != \"undefined\" && crypto.subtle && crypto.subtle.importKey);\nvar useWebCrypto = hasWebCrypto && (typeof location == \"undefined\" || location.protocol == \"https:\");\nvar verifier = (useWebCrypto ? JwtVerifierWebCrypto : JwtVerifierJsrsasign);\n\nvar DEFAULT_ALG = \"RS256\";\nexport default {\n  /**\n   * \n   */\n  decode: (token, verifyOpts, getKeyFn) => {\n    var tokenParts;\n    var header;\n    return Promise.resolve().then(() => {\n      if (typeof token != \"string\") throw new Error(\"Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).\");\n      tokenParts = token.split(\".\");\n      if (tokenParts.length != 3) throw new Error(\"Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: \" + token);\n\n      // parse header\n      var headerB64U = tokenParts[0];\n      var headerStr = Base64Url.decode(headerB64U);\n      header = JSON.parse(headerStr);\n      if (header.typ != \"JWT\") throw new Error(\"Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: \" + token);\n\n      // get key\n      return getKeyFn(header);\n    }).then(key => {\n      // NOTE Check the whole importKey call if adding support for other key types.\n      if (!key || key.kty != \"RSA\") throw new Error(\"Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: \" + JSON.stringify(key));\n      // always verify algorithm against the one is JOSE header\n      var alg = key.alg || DEFAULT_ALG;\n      if (alg !== header.alg) throw new InvalidTokenError(\"Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '\" + header.alg + \"', verification key uses '\" + key.alg + \"' (with default of '\" + DEFAULT_ALG + \"'). Token: \" + token + \" Key: \" + JSON.stringify(key));\n\n      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);\n    }).then(valid => {\n      if (!valid) throw new InvalidTokenError(\"Invalid JSON Web Token: \" + token);\n      var bodyStr = Base64Url.decode(tokenParts[1]);\n      var body = JSON.parse(bodyStr);\n      return body;\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./jwt/Jwt.js","import mod from \"module\";\n\nvar scriptUri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\nvar jsrsasign = undefined;\nvar Verifier = {\n  verify: function (key, alg, verifyOpts, header, tokenParts, token) {\n    return Promise.resolve().then(() => {\n      // load jsrsasign library on 1st verification\n      if (jsrsasign === undefined) {\n        var continueFn = Verifier.verify.bind(this, key, alg, verifyOpts, header, tokenParts, token);\n        var isMin = scriptUri.indexOf(\".min.\") != -1;\n        var baseUrl = scriptUri.replace(/^(.*\\/).*/, \"$1\");\n        var url = baseUrl + \"jsrsasign\" + (isMin ? \".min\" : \"\") + \".js\";\n        var loadPromise;\n        if (typeof System != \"undefined\") loadPromise = System.import(url);\n        else loadPromise = new Promise((resolve, reject) => {\n          var script = document.createElement(\"script\");\n          script.onload = () => { resolve(window[\"Jsrsasign\"]); };\n          script.onerror = (e) => { reject(e); };\n          script.src = url;\n          document.head.appendChild(script);\n        });\n        return loadPromise.then((obj) => {\n          jsrsasign = obj || null;\n          return continueFn();\n        }, (e) => {\n          // NOTE Don't set jsrsasign to null (if network was down, next attempt of the user might work)\n          console.error(e);\n          return continueFn();\n        });\n      }\n      if (!jsrsasign) throw new Error(\"Unable to verify token because jsrsasign library failed to load.\");\n\n      // var exampleKey = {\"kty\":\"RSA\",\"e\":\"AQAB\",\"n\":\"yXxJt2xevNsgGGGFfX5e22Jvy0_Eopgkumz7mJ7ScWlPfsMsAi8BZsF7nbDjA3T3v2vy2_-DaLDg-z-BjRwQIPL1LRzQGeDDSVmPcZtbexqkpjouxZ6-abpefSAFX5cA8NJ5h4JknFJWAsxxKEw4Ogy6XFd_BEaDmyXlLcV65Bs\",\"alg\":\"RS256\",\"kid\":\"rJZx5vzX1FOt_Nt8sB8jUA\",\"use\":\"sig\"};\n      // var pem = KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(exampleKey));\n      //   =>\n      // -----BEGIN PUBLIC KEY-----\n      // MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJfEm3bF682yAYYYV9fl7bYm/L\n      // T8SimCS6bPuYntJxaU9+wywCLwFmwXudsOMDdPe/a/Lb/4NosOD7P4GNHBAg8vUt\n      // HNAZ4MNJWY9xm1t7GqSmOi7Fnr5pul59IAVflwDw0nmHgmScUlYCzHEoTDg6DLpc\n      // V38ERoObJeUtxXrkGwIDAQAB\n      // -----END PUBLIC KEY-----\n\n      // do the verification\n      var keyInst = jsrsasign.KEYUTIL.getKey(key);\n      var result = jsrsasign.jws.JWS.verifyJWT(token, keyInst, verifyOpts); // see lib/jsrsasign-.../jws-3.3.js\n      return result || Promise.reject(new Error(\"Token is not valid. Token: \" + token));\n    });\n  }\n}\n\nmodule.exports = Verifier;\n\n\n// WEBPACK FOOTER //\n// ./jwt/JwtVerifierJsrsasign.js","import Base64Url from \"../util/Base64Url.js\";\nimport InvalidTokenError from \"./InvalidTokenError.js\";\n\n\nmodule.exports = {\n  verify: function (key, alg, verifyOpts, header, tokenParts, token) {\n    var webCryptoAlgorithm = {\n      name: \"RSASSA-PKCS1-v1_5\",\n      hash: { name: \"SHA-\" + alg.substr(2) }\n    };\n    // MS Edge throws error if the key contains field \"use\" => remove it\n    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails\n    var usedKey = JSON.parse(JSON.stringify(key));\n    delete usedKey.use;\n    \n    return crypto.subtle.importKey(\"jwk\", usedKey, webCryptoAlgorithm, false, [\"verify\"]).then(webCryptoKey => {\n      // validate signature\n      var signatureB64U  = tokenParts[2];\n      var data = tokenParts[0] + \".\" + tokenParts[1];\n      var signatureBytes = asciiToUint8Array(Base64Url.decodeToAscii(signatureB64U));\n      var dataBytes = asciiToUint8Array(data);\n      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);\n    }, (importError) => {\n      var e = new Error(`Unable to verify JSON Web Token - importing key via WebCrypto API failed.\\nKey: ${JSON.stringify(usedKey)}\\nToken: ${token}\\nError: ` + importError);\n      e.cause = importError;\n      return Promise.reject(e);\n    }).then(signatureValid => {\n      if (!signatureValid) throw new InvalidTokenError(\"Invalid JSON Web Token - signature is not valid. Token: \" + token);\n      var bodyStr = Base64Url.decode(tokenParts[1]);\n      var body = JSON.parse(bodyStr);\n      var throwError = (txt, failedClaim) => {\n        throw new InvalidTokenError(\"Invalid token: \" + txt + \"\\nFailed claim: \" + JSON.stringify(failedClaim) + \"\\nIssued by: \" + JSON.stringify(body.iss) + \"\\nVerification options: \" + JSON.stringify(verifyOpts) + \"\\nToken: \" + token);\n      }\n\n      // verify claims\n\n      // 'alg' is always checked\n      if (!verifyOpts.alg) throw new Error(\"Unable to verify JWT claim - 'alg' field must be always given for verification.\");\n      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError(`Algorithm ${JSON.stringify(header.alg)} used by token is not valid - expected one of ${JSON.stringify(verifyOpts.alg)}.`, \"alg\");\n\n      // 'iss'\n      var v;\n      v = asArray(verifyOpts.iss);\n      if (v && v.indexOf(body.iss) === -1) throwError(`Issuer URI ${JSON.stringify(body.iss)} in token is not valid - expected one of ${JSON.stringify(v)}. Token was issued by different OpenID Connect server or it was forged.`, \"iss\");\n\n      // 'sub'\n      v = asArray(verifyOpts.sub);\n      if (v && v.indexOf(body.sub) === -1) throwError(`Subject ${JSON.stringify(body.sub)} in token is not valid - expected one of ${JSON.stringify(v)}.`, \"sub\");\n\n      // 'aud' - all values from verifyOpts.aud must be present in body.aud \n      v = asArray(verifyOpts.aud);\n      var bodyV = asArray(body.aud) || [];\n      if (v && bodyV.some(bv => v.indexOf(bv) == -1)) throwError(`Audience list ${JSON.stringify(bodyV)} in token is not valid - some of following values are missing: ${JSON.stringify(v)}.`, \"aud\");\n\n      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)\n      var now = Date.now() / 1000;\n      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;\n      var gracePeriod = verifyOpts.gracePeriod || 0;\n\n      // 'exp' - expires\n      if (typeof body.exp === \"number\" && body.exp + gracePeriod < now) throwError(`Token already expired at ${toTimeString(body.exp)}, current time is ${toTimeString(now)}.`, \"exp\");\n\n      // 'nbf' - not before\n      if (typeof body.nbf === \"number\" && now < body.nbf - gracePeriod) throwError(`Token is not yet valid - it will become valid at ${toTimeString(body.nbf)}, current time is ${toTimeString(now)}. Check that your system time is correctly set.`, \"nbf\");\n\n      // 'iat' - issued at time\n      if (typeof body.iat === \"number\" && now < body.iat - gracePeriod) throwError(`Token seems to have been issued in the future - ${toTimeString(body.iat)}, current time is ${toTimeString(now)}. Check that your system time is correctly set.`, \"iat\");\n\n      // 'jti' - JWT id\n      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError(`Token ID ${JSON.stringify(body.jti)} not valid - expected ${JSON.stringify(verifyOpts.jti)}.`, \"jti\");\n\n      return true;\n    });\n  }\n}\n\n\nfunction asciiToUint8Array(ascii) {\n  return new Uint8Array(ascii.split(\"\").map(function (c) { return c.charCodeAt(0); }));\n}\nfunction asArray(value) {\n  if (value == null) return null;\n  if (Array.isArray(value)) return value;\n  return [value];\n}\nfunction toTimeString(seconds) {\n  return new Date(seconds*1000).toISOString().replace(/T/, \" \");\n}\n\n\n\n// WEBPACK FOOTER //\n// ./jwt/JwtVerifierWebCrypto.js","import CallbackHandler from \"./CallbackHandler.js\";\n\n/**\n * Default visual component for presenting login/logout prompt to the user. It displays the\n * URL in a popup window and waits until the user logs in / closes the window. After that\n * initAttrs.onResult(authResultUrl) is called as callback.\n * \n * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n * @param initAttrs.onResult The callback to call after login finishes. If the login finished\n *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.\n *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which\n *   contains the authentication response in fragment). \n */\nconst PopupComponent = function (initAttrs) {\n  var attrs = Object.assign({}, initAttrs);\n  var state = {\n    loginWindow: null,\n    closeCheckInterval: null\n  };\n\n  // add self to the list of opened loginWindows\n  CallbackHandler.registerForCallback(this, state);\n\n  this.finalize = function (result) {\n    // cleanup & do the callback\n    this.finalize = function () {};\n    this.destroy();\n    if (attrs.onResult) attrs.onResult(result);\n  }.bind(this);\n\n  var closeCheck = function () {\n    if (!state.loginWindow || !state.loginWindow.closed) return;\n    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value \"false\"\n  }.bind(this);\n\n  this.render = function () {\n    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)\n    if (!state.loginWindow) {\n      var rect = { width: 599, height: 600 };\n      rect.left = (screen.availWidth - rect.width) / 2 + (screen.availLeft || 0);\n      rect.top = (screen.availHeight - rect.height) / 2 + (screen.availTop || 0);\n      state.loginWindow = window.open(attrs.url, \"_blank\", `toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=${rect.width},height=${rect.height},top=${rect.top},left=${rect.left}`);\n      if (!state.loginWindow) { // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in\n        Promise.resolve().then(() => this.finalize(PopupComponent.ERROR_POPUP_BLOCKED)); // finalize in async way\n      } else {\n        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);\n      }\n    }\n  };\n\n  this.destroy = function () {\n    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();\n    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);\n    this.destroy = function () {};\n    CallbackHandler.unregisterForCallback(this);\n  };\n};\n\nPopupComponent.ERROR_POPUP_BLOCKED = \"POPUP_BLOCKED\";\n\nexport default PopupComponent;\n\n\n// WEBPACK FOOTER //\n// ./ui/PopupComponent.js","export default function generateUuid() {\n  // generate UUID (RFC4122 version 4 compliant) for the event ID\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n  var uuid= 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  });\n  return uuid;\n}\n\n\n// WEBPACK FOOTER //\n// ./util/Uuid.js","import IframeComponent from \"../ui/IframeComponent.js\";\nimport ImplicitFlow from \"../flow/ImplicitFlow.js\";\n\nexport default class Os8Auth {\n\n  /**\n   * @param options.serverUri\n   * @param options.clientId\n   * @param options.redirectUri\n   */\n  constructor(options) {\n    if (!options || !options.serverUri || !options.clientId || !options.redirectUri) throw new Error(\"Os8Auth must be initialized with options containing serverUri, clientId and redirectUri.\");\n    this.options = options;\n  }\n\n  /**\n   * @param parameters\n   * @param parameters.subject_token\n   */\n  grantExchangeToken(parameters) {\n    var params = parameters || {};\n    if (!params.subject_token) throw new Error(\"Os8Auth.grantExchangeToken must be called with parameter subject_token.\");\n    var urlParams = Object.assign({}, params, {\n      response_type: \"id_token token\",\n      client_id: this.options.clientId,\n      redirect_uri: this.options.redirectUri\n    });\n    var urlParamsParts = Object.keys(urlParams)\n      .filter(k => urlParams[k] != null)\n      .map(k => encodeURIComponent(k) + \"=\" + encodeURIComponent(urlParams[k] + \"\"));\n    var url = this.options.serverUri.replace(/\\/*$/, \"/\") + \"exchangeOs8Token\" + \"?\" + urlParamsParts.join(\"&\");\n\n    return new Promise(function (resolve, reject) {\n      new IframeComponent({\n        url: url,\n        onResult: function (aLoginResult) {\n          var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);\n          if (!authResponse || authResponse.error) reject(authResponse);\n          else resolve(authResponse);\n        }\n      }).render();\n    });\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./uuos8/Os8Auth.js"],"sourceRoot":""}