/*! uu_oidcg01, 3.2.1, 2017-11-23 13:57:04Z */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core"));
	else if(typeof define === 'function' && define.amd)
		define("UuOidc", ["module", "uu_appg01_core"], factory);
	else if(typeof exports === 'object')
		exports["UuOidc"] = factory(require("module"), require("uu_appg01_core"));
	else
		root["UuOidc"] = factory(root["undefined"], root["UuApp"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_4__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!************************!*\
  !*** ../.tmp/index.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var mod=__webpack_require__(/*! module */ 1);
	  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
	  __webpack_require__.p=uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
	  module.exports = __webpack_require__(/*! __project__/index.js */ 2);

/***/ },
/* 1 */
/*!*********************************************************************************************!*\
  !*** external {"amd":"module","commonjs":"module","commonjs2":"module","root":"undefined"} ***!
  \*********************************************************************************************/
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SessionHandler = exports.Session = undefined;

	var _Session = __webpack_require__(/*! ./Session.js */ 3);

	var _Session2 = _interopRequireDefault(_Session);

	var _SessionHandler = __webpack_require__(/*! ./SessionHandler.js */ 25);

	var _SessionHandler2 = _interopRequireDefault(_SessionHandler);

	__webpack_require__(/*! ./bootstrap-session.js */ 26);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// make UuOidc always present in global variable so that there're no issues
	// with detecting it (even during load via SystemJS)
	if (typeof window !== "undefined") window.UuOidc = { Session: _Session2.default, SessionHandler: _SessionHandler2.default };

	exports.Session = _Session2.default;
	exports.SessionHandler = _SessionHandler2.default;

/***/ },
/* 3 */
/*!********************!*\
  !*** ./Session.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var _Defaults = __webpack_require__(/*! ./Defaults.js */ 5);

	var _Defaults2 = _interopRequireDefault(_Defaults);

	var _ImplicitFlow = __webpack_require__(/*! ./flow/ImplicitFlow.js */ 6);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	var _SessionContext = __webpack_require__(/*! ./SessionContext.js */ 19);

	var _SessionContext2 = _interopRequireDefault(_SessionContext);

	var _Uuid = __webpack_require__(/*! ./util/Uuid.js */ 20);

	var _Uuid2 = _interopRequireDefault(_Uuid);

	var _Os8Auth = __webpack_require__(/*! ./uuos8/Os8Auth.js */ 21);

	var _Os8Auth2 = _interopRequireDefault(_Os8Auth);

	var _PromiseUtil = __webpack_require__(/*! ./util/PromiseUtil.js */ 9);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	var _StringUtil = __webpack_require__(/*! ./util/StringUtil.js */ 22);

	var _StringUtil2 = _interopRequireDefault(_StringUtil);

	var _IframeComponent = __webpack_require__(/*! ./ui/IframeComponent.js */ 12);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	var _SessionStateChangeNotifier = __webpack_require__(/*! ./SessionStateChangeNotifier.js */ 23);

	var _SessionStateChangeNotifier2 = _interopRequireDefault(_SessionStateChangeNotifier);

	var _Discovery = __webpack_require__(/*! ./discovery/Discovery.js */ 7);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var UuAppError = _uu_appg01_core.Error.Error;
	var logger = _uu_appg01_core.Logging.LoggerFactory.get("UuOidc.Session");

	var Session = function () {

	  /**
	   * Creates new Session with specified options.
	   * 
	   * @class UuOidc.Session
	   * @classdesc
	   * 
	   * Session handling via OpenID Connect server.
	   * 
	   * **Configuration**
	   * 
	   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback
	   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be
	   * configured as described below - configuration parameter "uuoidc.redirectUri".
	   * 
	   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:
	   * 
	   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
	   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for
	   *   accessing most of user data.
	   * * **uuoidc.redirectUri** - redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
	   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
	   *   to document.baseURI (current URL). Default is "callbacks/oidc-callback.html".
	   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is "https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be".
	   * * **uuoidc.sessionExpiringNotificationTime** - a "sessionExpiring" notification event is triggered these many seconds prior to the session expiration.
	   *   Default is 5 minutes. Using 0 disables the notification.
	   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
	   *   Default is 5. Using 0 disables the checking.
	   * 
	   * **Supported events**
	   * 
	   * It's possible to handle session state changes and other notifications by registering a listener function to any of these events
	   * (see also {@link UuOidc.Session#addListener}):
	   * 
	   * * **identityChange** - triggerred whenever an identity changes (user logs in / out / changes its authorization status). Event's
	   * "data" field contains the new identity (see {@link UuOidc.Session#getIdentity}).
	   * * **sessionExpiring** - triggerred some time before the global session against OpenID Connect server expires. The application
	   * can show a warning at this moment and suggest to the user to re-login themselves. Re-login can be initiated by
	   * {@link UuOidc.Session#login Session#login}({ prompt: "login" }) which forces a popup window to be shown.
	   * The event's "data" field contains an object with following fields:
	   *     * expiresAt - time in milliseconds when the expiration of the global session will occur.
	   * * **sessionExtended** - trigerred after the global session against OpenID Connect server has been extended. The application should
	   * remove the warning about necessity of user re-login if it's showing one (i.e. if there happenned a sessionExpiring event, the user
	   * re-logged in, possibly in different browser tab, then the application should no longer display any warning about sessionExpiring).
	   * The event's "data" field contains an object with following fields:
	   *     * expiresAt - time in milliseconds when the expiration of the global session will occur
	   * 
	   * @param options {Object|UuApp.Util.Config} Options.
	   * @param options.serverUri OpenID Connect server to perform login / logout against.
	   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
	   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
	   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
	   *   to document.baseURI (current URL).
	   * @param options.sessionExpiringNotificationTime A "sessionExpiring" notification event is triggered these many seconds prior to the session expiration.
	   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
	   */
	  function Session(options) {
	    var _this = this;

	    _classCallCheck(this, Session);

	    if (!options) throw new UuAppError("Session must be initialized with proper options or UuApp.Util.Config.");
	    this._optionsMergedPromise = _PromiseUtil2.default.wrapForImmediateThen(Promise.resolve(options && typeof options.get == "function" ? options.initPromise || options : options).then(function (env) {
	      Object.keys(_Defaults2.default).forEach(function (k) {
	        var v = void 0;
	        if (env && typeof env.get == "function") v = env.get("uuoidc." + k, false);else if (env) v = env[k];
	        if (v == null) v = _Defaults2.default[k];
	        _this[k === "redirectUri" ? "implicitFlowRedirectUri" : k] = v;
	      });
	      if (!_this.clientId) _this.clientId = "uu-oidc:unregistered-client:" + (0, _Uuid2.default)();
	      // if redirect URI is relative then absolutize it (relative to current document.baseURI)
	      if (!_this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) {
	        // no protocol present
	        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\/).*/, "$1");
	        if (_this.implicitFlowRedirectUri.charAt(0) != "/") _this.implicitFlowRedirectUri = toFullUrl(baseUrl + _this.implicitFlowRedirectUri);else _this.implicitFlowRedirectUri = toFullUrl(_this.implicitFlowRedirectUri);
	      }
	      // sanitize times & interval settings
	      if (typeof _this.sessionExpiringNotificationTime !== "number" || _this.sessionExpiringNotificationTime < 0) _this.sessionExpiringNotificationTime = _Defaults2.default.sessionExpiringNotificationTime;
	      if (typeof _this.sessionCheckInterval !== "number" || _this.sessionCheckInterval < 0) _this.sessionCheckInterval = _Defaults2.default.sessionCheckInterval;
	      if (_this.sessionCheckInterval > 0 && _this.sessionCheckInterval < 2) _this.sessionCheckInterval = 2; // minimal interval is 2, but allow "0" for disabling the check
	      if (typeof _this.tokenRefreshLeeway !== "number" || _this.tokenRefreshLeeway < 0) _this.tokenRefreshLeeway = _Defaults2.default.tokenRefreshLeeway;
	      if (typeof _this.tokenRefreshFailureRetryInterval !== "number" || _this.tokenRefreshFailureRetryInterval < 0) _this.tokenRefreshFailureRetryInterval = _Defaults2.default.tokenRefreshFailureRetryInterval;
	      if (_this.tokenRefreshFailureRetryInterval > 0) _this.tokenRefreshFailureRetryInterval = Math.max(5, _this.tokenRefreshFailureRetryInterval);

	      // add session state checking which, in case that we were logged in and a logout
	      // against OIDC is detected (e.g. in another browser tab), will log us out
	      if (_this.sessionCheckInterval) {
	        _this._sessionChecker = new _SessionStateChangeNotifier2.default(_this);
	        _this._sessionChecker.onStateChange(function () {
	          logger.debug("Session state change detected.");
	          if (!_this.isAuthenticated()) return; // don't check new state if we're currently logged out (don't auto-login)

	          // check login state against OpenID server (basically renew the token,
	          // possibly logging out if the current user on OpenID server differs from ours)
	          _this._silentTokenRefresh(true);
	        });
	      }
	    }));
	    this._loginInProgress = 0;
	    this._silentTokenRefreshInProgress = 0;
	    this.nonce = Math.random().toString(32).substr(2);

	    var listeners = {};
	    /**
	     * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:
	     * 
	     * * **type** The type of the event, e.g. "identityChange".
	     * * **data** The data passed to the event.
	     * 
	     * See {@link UuOidc.Session Session} for the list of supported events.
	     * 
	     * @param {string} eventName The event to register listener for.
	     * @param {function(Event)} listener The function to be called whenever the event is trigerred.
	     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeListener}).
	     * @see UuOidc.Session#removeListener
	     * @method UuOidc.Session#addListener
	     */
	    this.addListener = function (eventName, listener) {
	      var list = listeners[eventName];
	      if (!list) list = listeners[eventName] = [];
	      list.push(listener);
	      return _this.removeListener.bind(_this, eventName, listener);
	    };
	    /**
	     * Removes listener for specified event.
	     * 
	     * @param {string} eventName The event to remove listener for.
	     * @param {function(Event)} listener The listener (function) to unregister.
	     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
	     * @see UuOidc.Session#addListener
	     * @method UuOidc.Session#removeListener
	     */
	    this.removeListener = function (eventName, listener) {
	      var list = listeners[eventName];
	      if (!list) return false;
	      var idx = list.indexOf(listener);
	      if (idx != -1) list.splice(idx, 1);
	      return idx != -1;
	    };

	    this._runListeners = function (eventName, data) {
	      logger.debug("Launching event \"" + eventName + ".\"");
	      var list = listeners[eventName];
	      if (list) {
	        var e = {
	          type: eventName,
	          data: data
	        };
	        list.forEach(function (it) {
	          return it.call(_this, e);
	        });
	      }
	      // run also deprecated identityChangeListener-s (they don't get "event" object but directly the data)
	      // if this is "identityChange" event
	      // TODO 3.0 Remove.
	      if (eventName === "identityChange" && listeners["__identityChange"]) listeners["__identityChange"].forEach(function (it) {
	        return it.call(_this, data);
	      });
	    };

	    /**
	     * @return {boolean} True iff the user is authenticated (logged in).
	     * @method UuOidc.Session#isAuthenticated
	     */
	    this.isAuthenticated = function () {
	      return !!_this._loginCtx;
	    };

	    /**
	     * Adds listener for changes of user identity (logins / logouts).
	     * 
	     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.
	     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).
	     * @see UuOidc.Session#addListener
	     * @see UuOidc.Session#getIdentity
	     * @method UuOidc.Session#addIdentityChangeListener
	     * @deprecated Use Session#addListener("identityChange", listener) instead. Note that the listener accepts Event object.
	     */
	    this.addIdentityChangeListener = this.addListener.bind(this, "__identityChange");

	    /**
	     * Removes listener for changes of user identity (logins / logouts).
	     * 
	     * @param {Function(Object)} listener The listener to remove.
	     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
	     * @see UuOidc.Session#removeListener
	     * @method UuOidc.Session#removeIdentityChangeListener
	     * @deprecated Use Session#removeListener("identityChange", listener) instead.
	     */
	    this.removeIdentityChangeListener = this.removeListener.bind(this, "__identityChange");

	    // add session_expires_at field
	    // NOTE This is required for "auto-logout", "session expiring" and "session extended" functionality.
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run
	    // And that they are run pretty much immediately (so that authResponse.session_expires_in
	    // is relative to the moment when we received the response).
	    this.addListener("identityChange", function (e) {
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      if (!authResponse || !authResponse.session_expires_in) return;
	      if (authResponse.session_expires_at) return;
	      authResponse.session_expires_at = Math.floor(Date.now() / 1000) + Number(authResponse.session_expires_in);
	    });

	    // auto-logout when server-side session reaches its expiration time (or when token
	    // reaches its expiration time in case that server-side session info is not available)
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run
	    // (so that info from new token gets checked again).
	    this.addListener("identityChange", function (e) {
	      if (_this._autoLogoutTimeout) {
	        clearTimeout(_this._autoLogoutTimeout);
	        delete _this._autoLogoutTimeout;
	      }
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      if (!authResponse) return;

	      // plan local logout
	      var expiresAt = authResponse.session_expires_at || (_this.getClaims() || {})["exp"];
	      if (!expiresAt) return;
	      var now = new Date().getTime();
	      var delay = Math.max(0, expiresAt * 1000 - now);
	      logger.debug("Planning local auto-logout at " + toTimeString(new Date(now + delay)) + ".");
	      _this._autoLogoutTimeout = setTimeout(function () {
	        delete _this._autoLogoutTimeout;
	        _this._localLogout();
	      }, delay);
	    });

	    // support for token auto-refresh when its nearing expiration
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run
	    // (so that token refreshing gets re-planned / cleaned).
	    var lastTokenRefreshTime = 0;
	    this.addListener("identityChange", function (e) {
	      if (!_this.tokenRefreshEnabled) return;

	      if (_this._sessionRefreshTimeout) {
	        clearTimeout(_this._sessionRefreshTimeout);
	        delete _this._sessionRefreshTimeout;
	      }
	      var claims = _this.getClaims();
	      var expiresAt = (claims || {})["exp"];
	      if (!expiresAt) return; // not logged in (or there's something with the claims but that shouldn't happen)

	      // plan token refresh
	      var now = new Date().getTime();
	      var delay = Math.max(expiresAt * 1000 - now - _this.tokenRefreshLeeway * 1000, Math.max(0, 1000 - (now - lastTokenRefreshTime))); // wait at least 1s between 2 token refreshes
	      logger.debug("Planning token auto-refresh at " + toTimeString(new Date(now + delay)) + ".");
	      _this._sessionRefreshTimeout = setTimeout(function () {
	        delete _this._sessionRefreshTimeout;
	        lastTokenRefreshTime = new Date().getTime();
	        _this._silentTokenRefresh();
	      }, delay);
	    });

	    // support for "session extended" notification
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run.
	    this.addListener("identityChange", function (e) {
	      var LEEWAY_MILLIS = 10 * 1000; // use leeway because server sends "session_expires_in" which is relative so if network becomes slower, we might then compute the "...expires_at" value as if it was greater than before
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      var wasExtended = _this._activeSessionExpiresAtMillis && authResponse && authResponse.session_expires_at * 1000 > _this._activeSessionExpiresAtMillis + LEEWAY_MILLIS;
	      _this._activeSessionExpiresAtMillis = authResponse ? authResponse.session_expires_at * 1000 : null;
	      if (wasExtended) {
	        _this._sessionExpiringBlocked = false;
	        var expiresAt = _this._activeSessionExpiresAtMillis;
	        setTimeout(function () {
	          // we're currently processing "identityChange" listeners so let them finish and run "sessionExtended" afterwards
	          _this._runListeners("sessionExtended", { expiresAt: expiresAt });
	        }, 0);
	      }
	    });

	    // support for "session expiring" notification
	    // NOTE Must be after "session extended" functionality (so that unblocking done there
	    // gets performed sooner than the code below).
	    // NOTE This assumes that whenever a token changes, identity-change listeners are run.
	    var prevIdentity = undefined;
	    this.addListener("identityChange", function (e) {
	      if (_this.sessionExpiringNotificationTime <= 0) return; // disabled

	      if (_this._sessionExpiringTimeout) {
	        clearTimeout(_this._sessionExpiringTimeout);
	        delete _this._sessionExpiringTimeout;
	      }
	      var authResponse = (_this._loginCtx || {}).authResponse;
	      var newIdentity = (_this.getClaims() || {})["sub"];
	      if (newIdentity != prevIdentity) _this._sessionExpiringBlocked = false;
	      prevIdentity = newIdentity;

	      if (!authResponse) return; // not logged in
	      if (!authResponse.session_expires_at) return; // "session expiring" notification not supported on server
	      if (_this._sessionExpiringBlocked) return; // don't trigger "session expiring" multiple times for the same session

	      var expiresAt = authResponse.session_expires_at * 1000;
	      var now = Date.now();
	      var delay = Math.max(0, expiresAt - now - _this.sessionExpiringNotificationTime * 1000);
	      logger.debug("Planning sessionExpiring notification at " + toTimeString(new Date(now + delay)) + ".");
	      _this._sessionExpiringTimeout = setTimeout(function () {
	        delete _this._sessionExpiringTimeout;
	        _this._sessionExpiringBlocked = true;
	        _this._runListeners("sessionExpiring", { expiresAt: expiresAt });
	      }, delay);
	    });
	  }

	  /**
	   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:
	   * 
	   * * id
	   * * name
	   * * uuIdentity
	   * * email
	   * * levelOfAssurance
	   * * loginLevelOfAssurance
	   * 
	   * @return {Object} Identity of currently logged in user or null if not logged in.
	   * @method UuOidc.Session#getIdentity
	   */


	  _createClass(Session, [{
	    key: "getIdentity",
	    value: function getIdentity() {
	      return this._loginCtx ? this._loginCtx.getIdentity() : null;
	    }

	    /**
	     * Returns all claims present in the token (or null if not logged in).
	     * 
	     * @method UuOidc.Session#getClaims
	     */

	  }, {
	    key: "getClaims",
	    value: function getClaims() {
	      return this._loginCtx ? this._loginCtx.getClaims() : null;
	    }

	    /**
	     * Login against OpenID Connect server. If no or empty options are used, user will be required to
	     * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in
	     * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can
	     * be forced by using option "prompt" set to "login".
	     * 
	     * @param options {Object} Options.
	     * @param options.prompt {string} (optional) One of "" (default), "none" (check login state without user interaction), "login" (re-request authentication).
	     * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).
	     * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.
	     * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it
	     *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:
	     * 
	     * * "urn:ietf:params:oauth:token-type:jwt-uuos8" - indicates that the token being passed to the login was originally issued by uuOS8
	     * 
	     * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained
	     *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:
	     * 
	     *   * false - user refused to log in
	     *   * Error - any other error such as network problems, ...
	     * 
	     * @method UuOidc.Session#login
	     */

	  }, {
	    key: "login",
	    value: function login(options) {
	      // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).

	      // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)
	      var opts;
	      if (options) opts = Object.keys(options).reduce(function (r, k) {
	        return r[_StringUtil2.default.toSnakeCase(k)] = options[k], r;
	      }, {});

	      return this._login(opts);
	    }

	    // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.

	  }, {
	    key: "_login",
	    value: function _login(options, canUpdateSessionWithLoginResultFn) {
	      var _this2 = this;

	      var opts = Object.assign({}, options);

	      // there's a special case in which we support providing uuOS8 token
	      var os8Token;
	      if (opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
	        os8Token = opts.access_token;
	        delete opts.access_token;
	        delete opts.token_type_hint;
	      }

	      // use accessToken directly if it's provided
	      var accessToken = opts.access_token;
	      delete opts.access_token;

	      var doLogin = function doLogin() {
	        ++_this2._loginInProgress;

	        // if calling Session.login() with no parameters, log in as non-anonymous user
	        if (Object.keys(opts).length == 0) opts["acr_values"] = 1;

	        // if we have user then login only if options indicate that we have to
	        if (!accessToken && _this2._loginCtx) {
	          var useCurrent = true;
	          if (opts["prompt"] || opts["max_age"] || opts["access_token"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.

	          // check required login level of assurance
	          var acr_values = (opts["acr_values"] != null ? opts["acr_values"] + "" : "").split(/\s+/);
	          var identity = _this2.getIdentity();
	          if (acr_values.every(function (v) {
	            return Number(v) > identity.loginLevelOfAssurance;
	          })) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login

	          // check current token expiration
	          if (_ImplicitFlow2.default.isAuthResponseExpired(_this2._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login

	          // use current token if everything seems fine
	          if (useCurrent) {
	            --_this2._loginInProgress;
	            return Promise.resolve(_this2);
	          }
	        }

	        // login using implicit flow
	        var authResponse = accessToken ? { id_token: accessToken } : null;
	        var nonce = accessToken || os8Token || "nonce" in opts ? opts["nonce"] : _this2.nonce;
	        opts.nonce = nonce;
	        delete opts.state; // we'll generate our own, if needed

	        // NOTE Clicking a button, which launches this login method, can result in
	        // at most 1 Promise resolution. If 2 or more Promises are chained, mobile
	        // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise
	        // is wrapped via PromiseUtil which then allows us here to call our "then" function immediately
	        // if the this._optionsMergedPromise has already been resolved.
	        // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)
	        // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is
	        // not trivial.
	        var authResponsePromise = Promise.resolve(authResponse || _PromiseUtil2.default.immediateThen(_this2._optionsMergedPromise, function () {
	          // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll
	          // do this by exchanging tokens via non-standard endpoint for uuOS8
	          if (os8Token) {
	            var os8Auth = new _Os8Auth2.default({
	              serverUri: _this2.serverUri,
	              clientId: _this2.clientId,
	              redirectUri: _this2.implicitFlowRedirectUri
	            });
	            return os8Auth.grantExchangeToken({
	              subject_token: os8Token
	            });
	          }

	          // authenticate using implicit flow
	          opts.state = Math.random().toString(32).substr(2);
	          if (navigator.standalone) opts.state += "," + location.pathname + location.search + (location.hash.length > 1 ? location.hash : ""); // iOS in standalone mode - callback HTML will redirect back with full page reload
	          return _ImplicitFlow2.default.login({
	            serverUri: _this2.serverUri,
	            clientId: _this2.clientId,
	            redirectUri: _this2.implicitFlowRedirectUri,
	            loginParams: opts
	          });
	        }, function (e) {
	          return Promise.reject(e);
	        }));
	        return authResponsePromise.then(function (authResponse) {
	          // validate response
	          return _this2._optionsMergedPromise.then(function () {
	            return _ImplicitFlow2.default.validateAuthResponse(authResponse, {
	              serverUri: _this2.serverUri,
	              clientId: _this2.clientId,
	              loginParams: opts
	            });
	          });
	        }).then(function (_ref) {
	          var authResponse = _ref.authResponse,
	              claims = _ref.claims;

	          // login successful => update the session
	          if (!canUpdateSessionWithLoginResultFn || canUpdateSessionWithLoginResultFn({ authResponse: authResponse, claims: claims }) !== false) {
	            _this2._loginCtx = new _SessionContext2.default(opts, authResponse, claims);
	            _this2._runListeners("identityChange", _this2.getIdentity());
	          }
	          return _this2;
	        }).then(function (r) {
	          --_this2._loginInProgress;
	          return r;
	        }, function (e) {
	          --_this2._loginInProgress;
	          return Promise.reject(e);
	        });
	      };

	      // wait for session restoring in case that this instance of the session is the "main" session
	      return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? _PromiseUtil2.default.immediateThen(Session.initPromise, doLogin) : doLogin();
	    }

	    /**
	     * Tries to re-authenticate the user silently:
	     * - if we are locally logged out => do nothing
	     * - if a user is logged in (on remote) and it's the same user as ours => use the new token
	     * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout
	     * - if a user is not logged in (on remote) => perform local logout
	     */

	  }, {
	    key: "_silentTokenRefresh",
	    value: function _silentTokenRefresh(aSkipIfPlanned) {
	      var _this3 = this;

	      if (aSkipIfPlanned && (this._silentTokenRefreshTimeout || this._silentTokenRefreshInProgress > 0)) return;

	      if (this._silentTokenRefreshTimeout) {
	        clearTimeout(this._silentTokenRefreshTimeout);
	        delete this._silentTokenRefreshTimeout;
	      }
	      var invocationCount = 0;
	      var doSilentRenew = function doSilentRenew() {
	        if (!_this3.isAuthenticated()) return;

	        logger.debug("Silent token refresh - starting.");
	        ++_this3._silentTokenRefreshInProgress;
	        ++invocationCount;
	        return _this3._login({
	          acr_values: "1",
	          prompt: "none"
	        }, function (_ref2) {
	          var claims = _ref2.claims;

	          --_this3._silentTokenRefreshInProgress;
	          if (!_this3.isAuthenticated()) {
	            // no-op (we're logged out and don't want to silently auto-login)
	            logger.debug("Silent token refresh - ending with no-op (local session is already logged out).");
	            return false; // don't use the new authResponse
	          }
	          // if the user is different than the current one then perform logout
	          if (claims.sub !== _this3.getClaims().sub) {
	            logger.debug("Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).");
	            _this3._localLogout();
	            return false; // don't use the new authResponse
	          }
	          logger.debug("Silent token refresh - ending with token renewed.");
	          return true; // use the new authResponse
	        }).catch(function (e) {
	          var err = e && e.error ? e.error : e; // e could be AuthenticationResponse, Error or anything else
	          if (_ImplicitFlow2.default.isLoggedOutError(e)) {
	            logger.debug("Silent token refresh - ending with local logout (user is not logged in on remote).");
	            _this3._localLogout();
	            return;
	          }
	          if (!_this3._silentTokenRefreshTimeout && _this3.tokenRefreshFailureRetryInterval) {
	            logger.debug("Silent token refresh - will retry in " + _this3.tokenRefreshFailureRetryInterval + "s (operation ended with unexpected error).", { error: err });
	            _this3._silentTokenRefreshTimeout = setTimeout(function () {
	              delete _this3._silentTokenRefreshTimeout;
	              doSilentRenew();
	            }, _this3.tokenRefreshFailureRetryInterval * 1000);
	          } else {
	            if (_this3._silentTokenRefreshTimeout) logger.debug("Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).", { error: err });else logger.debug("Silent token refresh - ending with no-op (operation ended with unexpected error).", { error: err });
	          }
	          if (invocationCount === 1) console.warn("Token refresh failed with error:", err);else if (invocationCount === 2) console.warn("Suppressing further notifications of token refresh problem to prevent log cluttering (until success or logout).");
	        });
	      };

	      doSilentRenew();
	    }
	  }, {
	    key: "_localLogout",
	    value: function _localLogout() {
	      logger.debug("Performing local-logout.");
	      if (!this._loginCtx) return;
	      delete this._loginCtx;
	      this._runListeners("identityChange", this.getIdentity());
	    }

	    /**
	     * Log out the user.
	     * 
	     * @return Promise resolved after the user gets logged out (or immediately, if the user is not logged in).
	     * @method UuOidc.Session#logout
	     */

	  }, {
	    key: "logout",
	    value: function logout() {
	      var _this4 = this;

	      if (!this._loginCtx) return Promise.resolve();

	      // logout global session using end_session_endpoint (in an iframe)
	      return this._optionsMergedPromise.then(function () {
	        return _Discovery2.default.getMetadata(_this4.serverUri).then(function (metadata) {
	          return new Promise(function (resolve, reject) {
	            if (!_this4._loginCtx) return resolve();
	            var logoutCallbackUri = _this4.implicitFlowRedirectUri;
	            var logoutUrl = metadata.end_session_endpoint + "?post_logout_redirect_uri=" + encodeURIComponent(logoutCallbackUri) + "&id_token_hint=" + encodeURIComponent(_this4._loginCtx.authResponse.id_token);
	            new _IframeComponent2.default({
	              url: logoutUrl,
	              onResult: function onResult(result) {
	                if (result instanceof Error) {
	                  result.message = "Logout failed." + (result.message ? " " + result.message : "");
	                  reject(result);
	                } else {
	                  _this4._localLogout();
	                  resolve();
	                }
	              }
	            }).render();
	          });
	        });
	      });
	    }

	    /**
	     * Returns token and its type for calling commands. Returned object contains following fields:
	     * 
	     * * tokenType - the type of the token, such as "Bearer",
	     * * token - the token itself.
	     * 
	     * If the user is not logged in, null is returned.
	     * 
	     * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.
	     * @return Object containing token and its type, or null if user is not logged in.
	     * @method UuOidc.Session#getCallToken
	     */

	  }, {
	    key: "getCallToken",
	    value: function getCallToken(callUri) {
	      var authResponse = (this._loginCtx || {}).authResponse;
	      if (!authResponse) return null;
	      var result = {
	        tokenType: authResponse.token_type || null,
	        token: authResponse.id_token || null
	      };
	      return result;
	    }
	  }]);

	  return Session;
	}();

	exports.default = Session;


	function toFullUrl(path) {
	  var a = document.createElement("a");
	  a.href = path;
	  return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
	}

	function toTimeString(date) {
	  return (
	    // date.getFullYear() + "-" + ("0" + (date.getMonth() + 1)).substr(-2) + "-" + ("0" + date.getDate()).substr(-2) + " " +
	    ("0" + date.getHours()).substr(-2) + ":" + ("0" + date.getMinutes()).substr(-2) + ":" + ("0" + date.getSeconds()).substr(-2)
	  );
	}

	/**
	 * Current session.
	 * 
	 * @name UuOidc.Session.currentSession
	 * @type UuOidc.Session
	 */
	var currentSession;
	var allowAutoInitSession = true;
	Object.defineProperty(Session, "currentSession", {
	  get: function get() {
	    if (allowAutoInitSession && !currentSession) {
	      currentSession = new Session(_uu_appg01_core.Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).
	      currentSession.initComplete = false;
	      currentSession.initPromise = Session.initPromise;
	    }
	    return currentSession;
	  },
	  set: function set(value) {
	    allowAutoInitSession = false;
	    currentSession = value;
	  }
	});

	var finalizeInit;
	/**
	 * Promise resolved after session initialization (restoring state) finishes.
	 * 
	 * @type {Promise<UuOidc.Session>}
	 * @name UuOidc.Session.initPromise 
	 */
	/**
	 * Promise resolved after session initialization (restoring state) finishes.
	 * Note that this field is available only on a session instance that is
	 * created automatically during page load.
	 * 
	 * @type {Promise<UuOidc.Session>}
	 * @name UuOidc.Session#initPromise 
	 */
	Session.initPromise = _PromiseUtil2.default.wrapForImmediateThen(new Promise(function (resolve, reject) {
	  finalizeInit = function finalizeInit(isOk, result) {
	    Session.initComplete = true;
	    Session.currentSession.initComplete = true;
	    if (!isOk) console.log("Session initialization failed:", result);
	    resolve(Session.currentSession); // always resolve as success even if checking session state failed
	    return Session.initPromise;
	  };
	}));
	Session.initPromise._finalizeInit = finalizeInit;

	/**
	 * Whether the session initialization performed during page load has already completed.
	 * 
	 * @type {boolean}
	 * @name UuOidc.Session.initComplete
	 */
	/**
	 * Whether the session initialization performed during page load has already completed.
	 * Note that this field is available only on a session instance that is
	 * created automatically during page load.
	 * 
	 * @type {boolean}
	 * @name UuOidc.Session#initComplete
	 */
	Session.initComplete = false;

/***/ },
/* 4 */
/*!*****************************************************************************************************************!*\
  !*** external {"amd":"uu_appg01_core","commonjs":"uu_appg01_core","commonjs2":"uu_appg01_core","root":"UuApp"} ***!
  \*****************************************************************************************************************/
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ },
/* 5 */
/*!*********************!*\
  !*** ./Defaults.js ***!
  \*********************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// NOTE If changed, update also JSDoc in Session.js.
	exports.default = {
	  serverUri: "https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be",
	  clientId: null,
	  redirectUri: "callbacks/oidc-callback.html",
	  sessionCheckInterval: 5, // seconds between postMessage queries posted to check_session_iframe
	  sessionExpiringNotificationTime: 5 * 60, // seconds; event "sessionExpiring" will be launched these seconds prior to real expiration
	  tokenRefreshEnabled: true,
	  tokenRefreshLeeway: 5 * 60, // seconds prior to token expiration, at which to attempt refreshing of the token
	  tokenRefreshFailureRetryInterval: 30 // when refreshing token fails (e.g. due to network problem) wait these seconds and then try again
	};

/***/ },
/* 6 */
/*!******************************!*\
  !*** ./flow/ImplicitFlow.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _Discovery = __webpack_require__(/*! ../discovery/Discovery.js */ 7);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _PromiseUtil = __webpack_require__(/*! ../util/PromiseUtil.js */ 9);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	var _PopupComponent = __webpack_require__(/*! ../ui/PopupComponent.js */ 10);

	var _PopupComponent2 = _interopRequireDefault(_PopupComponent);

	var _IframeComponent = __webpack_require__(/*! ../ui/IframeComponent.js */ 12);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	var _Jwt = __webpack_require__(/*! ../jwt/Jwt.js */ 13);

	var _Jwt2 = _interopRequireDefault(_Jwt);

	var _InvalidTokenError = __webpack_require__(/*! ../jwt/InvalidTokenError.js */ 15);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	var _Jwks = __webpack_require__(/*! ../jwks/Jwks.js */ 18);

	var _Jwks2 = _interopRequireDefault(_Jwks);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var GRACE_PERIOD = 300;

	var ImplicitFlow = {
	  /**
	   * @param options.serverUri
	   * @param options.clientId
	   * @param options.redirectUri
	   * @param options.loginVisualComponent
	   * @param options.loginParams Additional URL parameters to be passed in the HTTP request.
	   */
	  login: function login(options) {
	    var opts = options || {};

	    // check that required data is available
	    var serverUri = opts.serverUri;
	    if (!serverUri) throw new Error("ImplicitFlow.login requires option 'serverUri'.");
	    var clientId = opts.clientId;
	    if (!clientId) throw new Error("ImplicitFlow.login requires option 'clientId'.");
	    var redirectUri = opts.redirectUri;
	    if (!redirectUri) throw new Error("ImplicitFlow.login requires option 'redirectUri'.");

	    // NOTE Using PromiseUtil.immediateThen which will run our "then" callback immediately if
	    // the Discovery.getMetadata is already resolved. The idea is that this login could have
	    // been triggered from "click" event and we need to open popup window within this event's
	    // lifetime or within single Promise (but not Promise chain because that doesn't work on
	    // iPhones).
	    return _PromiseUtil2.default.immediateThen(_Discovery2.default.getMetadata(serverUri), function (oidcMetadata) {
	      // prepare login URL
	      var loginParams = Object.assign({ scope: "openid" }, opts.loginParams, {
	        response_type: "id_token token",
	        client_id: clientId,
	        redirect_uri: redirectUri
	      });
	      var loginParamsParts = [];
	      for (var k in loginParams) {
	        var v = loginParams[k];
	        if (v == null) continue;
	        loginParamsParts.push(encodeURIComponent(k) + "=" + encodeURIComponent(v + ""));
	      }
	      var loginUrl = oidcMetadata.authorization_endpoint + "?" + loginParamsParts.join("&");

	      // display visual component for logging in (popup window)
	      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != "none" ? _PopupComponent2.default : _IframeComponent2.default);
	      return new Promise(function (resolve, reject) {
	        new LoginVisualComponent({
	          url: loginUrl,
	          onResult: function onResult(aLoginResult) {
	            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);
	            if (authResponse === false) return reject(new Error("User refused to log in."));
	            if (authResponse === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return reject(new Error("Login failed due to popup blocking."));

	            // resolve the promise successfully with the token (iff there's no "error" field)
	            if (authResponse.error) reject(authResponse);else resolve(authResponse);
	          }
	        }).render();
	      });
	    }, function (e) {
	      return Promise.reject(e);
	    });
	  },

	  validateAuthResponse: function validateAuthResponse(authResponse, opts) {
	    // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation
	    // 1. process only recognized fields in response (id_token, expires_in, ...)
	    // 2. validate implicit flow callback response ("state")
	    // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
	    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
	    //     ii. validate signature
	    //    iii. validate nonce
	    // 4. validate access_token

	    // 2.i. validate state
	    if (opts.loginParams.state && authResponse.state !== opts.loginParams.state) throw new Error("Invalid 'state' in received authorization response. Expected " + opts.loginParams.state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));

	    // 2.ii. validate expiration
	    if (ImplicitFlow.isAuthResponseExpired(authResponse)) throw new Error("Token expired " + JSON.stringify(authResponse));

	    // 3. validate id_token with nonce
	    return ImplicitFlow.validateIdToken(authResponse.id_token, opts).then(function (claims) {
	      return { authResponse: authResponse, claims: claims };
	    });

	    // 4. validate access_token
	    // NOTE Ignore - we're not using access_token field.
	  },
	  isAuthResponseExpired: function isAuthResponseExpired(authResponse) {
	    var now = new Date().getTime() / 1000;
	    var leeway = 60;
	    var expired = false;
	    if (!authResponse.issued_at) authResponse.issued_at = now;
	    if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;
	    if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;
	    return expired;
	  },


	  /**
	   * @param {*} e The error during authorization.
	   * @return Whether the error means that the user is not logged in on the remote server.
	   */
	  isLoggedOutError: function isLoggedOutError(e) {
	    return e && (typeof e === "undefined" ? "undefined" : _typeof(e)) == "object" && typeof e["error_description"] == "string" && e["error_description"].match(/interaction/i) && e["error_description"].match(/required/i);
	  },


	  /**
	   * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.
	   */
	  validateIdToken: function validateIdToken(token, _ref) {
	    var serverUri = _ref.serverUri,
	        nonce = _ref.loginParams.nonce;

	    // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
	    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
	    //         1. -Decrypt JWE - not supported.
	    //         2. +REQUIRED validate 'iss'
	    //         3. +REQUIRED validate 'aud'
	    //         4. -SHOULD validate multiple 'aud' vs. 'azp'
	    //         5. -SHOULD validate 'azp'
	    //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>
	    //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration
	    //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)
	    //         9. +REQUIRED current time < 'exp'
	    //        10. +CAN check 'iat'
	    //        11. +REQUIRED (for implicit flow) validate nonce
	    //        12. -SHOULD check if 'acr' is appropriate
	    //        13. -SHOULD check if 'auth_time' was requested.
	    //     ii. validate signature
	    //    iii. validate nonce
	    return _Discovery2.default.getMetadata(serverUri).then(function (metadata) {
	      var verifyOptions = {
	        // NOTE IE11 doesn't have RS512 (but it has "RS256" and "RS384").
	        alg: ["RS256"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)
	        iss: [metadata.issuer], // 3.i.2.
	        // aud: clientId, // 3.i.3. TODO We don't have the proper value.
	        // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') 
	        gracePeriod: GRACE_PERIOD
	      };
	      return _Jwt2.default.decode(token, verifyOptions, function (jwtHeader) {
	        // 3.ii.
	        if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\d+$/)) throw new Error("Invalid token. Only RSA signature is supported, but token uses algorithm '" + jwtHeader.alg + "'. Token: " + token);
	        var keyType = "RSA";

	        // check algorithm in token (whether it's really supported by the server)
	        var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];
	        if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error("Invalid token. Token was signed using algorithm '" + jwtHeader.alg + "' but the OIDC server '" + serverUri + "' supports only " + JSON.stringify(supportedAlgs) + ". Token: " + token);

	        // pick the key from JWK Set
	        var jwks = new _Jwks2.default({ serverUri: serverUri });
	        return jwks.getKey(jwtHeader.kid, keyType).catch(function (e) {
	          throw new Error("Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server " + serverUri + ". Token: " + token, e);
	        });
	      }).then(function (claims) {
	        // 3.i.11., 3.iii. validate nonce
	        if (nonce && claims.nonce !== nonce) throw new _InvalidTokenError2.default("Invalid nonce in ID token claims. Expected " + nonce + " but got " + claims.nonce);
	        return claims;
	      });
	    });
	  },


	  /**
	   * 
	   * @param {*} aLoginCallbackResult 
	   * @return One of: 
	   * * false - user refused to log in (or popups are blocked)
	   * * object with "error" field set - an error
	   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
	   */
	  getAuthResponseFromCallback: function getAuthResponseFromCallback(aLoginCallbackResult) {
	    if (aLoginCallbackResult === false || aLoginCallbackResult === _PopupComponent2.default.ERROR_POPUP_BLOCKED) return aLoginCallbackResult;
	    if (aLoginCallbackResult instanceof Error) return { error: aLoginCallbackResult };

	    // extract login token
	    // example of successful aLoginCallbackResult: "...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid" 
	    // example of error aLoginCallbackResult:      "...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
	    var authResponse = {};
	    aLoginCallbackResult.replace(/^[^#]*#?/, "").split(/&/).forEach(function (it) {
	      var eqlIdx = it.indexOf("=");
	      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
	      var value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
	      authResponse[key] = value;
	    });
	    return authResponse;
	  }
	};

	exports.default = ImplicitFlow;

/***/ },
/* 7 */
/*!********************************!*\
  !*** ./discovery/Discovery.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _HttpClient = __webpack_require__(/*! ../util/HttpClient.js */ 8);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	var _PromiseUtil = __webpack_require__(/*! ../util/PromiseUtil.js */ 9);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var oidcMetadataCache = {}; // stores Promises

	var Discovery = {
	  /**
	   * @return Promise resolving to OIDC discovery metadata for given issuerUri.
	   */
	  getMetadata: function getMetadata(aIssuerUri) {
	    var issuerUri = aIssuerUri.replace(/\/+$/, ""); // strip trailing slash(es) (this also normalizes it as a key to cache)
	    var metadata = oidcMetadataCache[issuerUri];
	    if (metadata) return metadata;
	    var discoveryEndpoint = Discovery.getMetadataUri(issuerUri);
	    return oidcMetadataCache[issuerUri] = _PromiseUtil2.default.wrapForImmediateThen(_HttpClient2.default.get(discoveryEndpoint).catch(function (e) {
	      delete oidcMetadataCache[issuerUri]; // don't cache errors so that e.g. clicking a button 2nd time (after network is up again) has chance to work
	      throw e;
	    }));
	  },
	  getMetadataUri: function getMetadataUri(aIssuerUri) {
	    var issuerUri = aIssuerUri.replace(/\/+$/, ""); // strip trailing slash(es) (this also normalizes it as a key to cache)
	    return issuerUri + "/.well-known/openid-configuration";
	  }
	};

	exports.default = Discovery;

/***/ },
/* 8 */
/*!****************************!*\
  !*** ./util/HttpClient.js ***!
  \****************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// helper for invoking Ajax requests and returning Promise
	function xhrJson(method, url, body, extraSettingFn) {
	  return new Promise(function (resolve, reject) {
	    var xhr = new XMLHttpRequest();
	    xhr.open(method, url, true);
	    xhr.withCredentials = true;
	    xhr.setRequestHeader("Accept", "application/json");
	    xhr.onreadystatechange = function (e) {
	      if (xhr.readyState == 4) {
	        if (xhr.status >= 200 && xhr.status < 300) {
	          try {
	            var json = JSON.parse(xhr.responseText);
	            resolve(json);
	          } catch (err) {
	            reject(err);
	          }
	        } else {
	          reject(new Error("Server responded with status " + xhr.status)); // TODO Better error.
	        }
	      }
	    };
	    xhr.withCredentials = true;
	    if (extraSettingFn) extraSettingFn(xhr);
	    xhr.send(body);
	  });
	}

	exports.default = {
	  get: function get() {
	    return xhrJson.bind(this, "GET").apply(this, Array.prototype.slice.call(arguments));
	  },
	  post: function post() {
	    return xhrJson.bind(this, "POST").apply(this, Array.prototype.slice.call(arguments));
	  }
	};

/***/ },
/* 9 */
/*!*****************************!*\
  !*** ./util/PromiseUtil.js ***!
  \*****************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  /**
	   * Wraps Promise so that it can then be used in immediateThen function.
	   */
	  wrapForImmediateThen: function wrapForImmediateThen(promise) {
	    promise.then(function (v) {
	      return promise._immediateValue = v;
	    }, function (e) {
	      return promise._immediateError = e;
	    });
	    return promise;
	  },

	  /**
	   * If promise has already been resolved, thenFn is called immediately (or catchFn in
	   * case that the promise has been rejected). Otherwise thenFn and catchFn callbacks
	   * are simply registered via promise.then(thenFn, catchFn).
	   * 
	   * Note that this works only on promises that were wrapped via #wrapForImmediateThen
	   * function.
	   * 
	   * @return Return value of thenFn/catchFn (if invoked immediately) or promise.then(thenFn, catchFn).
	   */
	  immediateThen: function immediateThen(promise, thenFn, catchFn) {
	    if ("_immediateValue" in promise) return typeof thenFn == "function" ? thenFn(promise._immediateValue) : promise._immediateValue;
	    if ("_immediateError" in promise) {
	      if (typeof catchFn == "function") return catchFn(promise._immediateError);
	      throw promise._immediateError;
	    }
	    return promise.then(thenFn, catchFn);
	  }
	};

/***/ },
/* 10 */
/*!******************************!*\
  !*** ./ui/PopupComponent.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CallbackHandler = __webpack_require__(/*! ./CallbackHandler.js */ 11);

	var _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Default visual component for presenting login/logout prompt to the user. It displays the
	 * URL in a popup window and waits until the user logs in / closes the window. After that
	 * initAttrs.onResult(authResultUrl) is called as callback.
	 * 
	 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
	 * @param initAttrs.onResult The callback to call after login finishes. If the login finished
	 *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.
	 *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which
	 *   contains the authentication response in fragment). 
	 */
	var PopupComponent = function PopupComponent(initAttrs) {
	  var attrs = Object.assign({}, initAttrs);
	  var state = {
	    loginWindow: null,
	    closeCheckInterval: null
	  };

	  // add self to the list of opened loginWindows
	  _CallbackHandler2.default.registerForCallback(this, state);

	  this.finalize = function (result) {
	    // cleanup & do the callback
	    this.finalize = function () {};
	    this.destroy();
	    if (attrs.onResult) attrs.onResult(result);
	  }.bind(this);

	  var closeCheck = function () {
	    if (!state.loginWindow || !state.loginWindow.closed) return;
	    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value "false"
	  }.bind(this);

	  this.render = function () {
	    var _this = this;

	    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)
	    if (!state.loginWindow) {
	      var rect = { width: 599, height: 600 };
	      rect.left = (screen.availWidth - rect.width) / 2 + (screen.availLeft || 0);
	      rect.top = (screen.availHeight - rect.height) / 2 + (screen.availTop || 0);
	      state.loginWindow = window.open(attrs.url, "_blank", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=" + rect.width + ",height=" + rect.height + ",top=" + rect.top + ",left=" + rect.left);
	      if (!state.loginWindow) {
	        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in
	        Promise.resolve().then(function () {
	          return _this.finalize(PopupComponent.ERROR_POPUP_BLOCKED);
	        }); // finalize in async way
	      } else {
	        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);
	      }
	    }
	  };

	  this.destroy = function () {
	    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();
	    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);
	    this.destroy = function () {};
	    _CallbackHandler2.default.unregisterForCallback(this);
	  };
	};

	PopupComponent.ERROR_POPUP_BLOCKED = "POPUP_BLOCKED";

	exports.default = PopupComponent;

/***/ },
/* 11 */
/*!*******************************!*\
  !*** ./ui/CallbackHandler.js ***!
  \*******************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// login callback handling
	var VC_CALLBACK_FN_NAME = "uuOidcCallbackFn"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.

	// make sure that callback works correctly even if multiple invocations using visual component below were
	// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup
	// and are now displayed both)
	if (typeof window != "undefined" && !window[VC_CALLBACK_FN_NAME]) {
	  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow) {
	    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
	    // received callback from a popup => find out which component is using the source window and notify it
	    for (var i = 0; i < loginWindows.length; ++i) {
	      var p = loginWindows[i];
	      if (p.state.loginWindow == aSourceWindow) {
	        p.component.finalize(aLoginResult);
	        return;
	      }
	    }
	    console.warn("Received unexpected callback from window", aSourceWindow, "Passed result was:", aLoginResult, "Ignoring the callback.");
	  };
	  window[VC_CALLBACK_FN_NAME].loginWindows = [];
	}

	exports.default = {
	  registerForCallback: function registerForCallback(component, state) {
	    window[VC_CALLBACK_FN_NAME].loginWindows.push({ component: component, state: state });
	  },
	  unregisterForCallback: function unregisterForCallback(component) {
	    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
	    for (var i = 0; i < loginWindows.length; ++i) {
	      // remove self from opened loginWindows
	      if (loginWindows[i].component === component) {
	        loginWindows.splice(i, 1);
	        break;
	      }
	    }
	  }
	};

/***/ },
/* 12 */
/*!*******************************!*\
  !*** ./ui/IframeComponent.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CallbackHandler = __webpack_require__(/*! ./CallbackHandler.js */ 11);

	var _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt="none" cases.
	 * After login/logout initAttrs.onResult(authResultUrl) is called as callback. In case of an error, an error instance
	 * is passed to the callback.
	 * 
	 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
	 * @param initAttrs.onResult The callback to call after login/logout finishes.
	 * @param initAttrs.timeout Seconds to wait after which consider the attempt unsuccessful, resulting in UuApp.Error.TimeoutError result.
	 */
	var IframeComponent = function IframeComponent(initAttrs) {
	  var attrs = Object.assign({}, initAttrs);
	  var state = {
	    iframe: null
	  };
	  Object.defineProperty(state, "loginWindow", {
	    get: function get() {
	      try {
	        // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)
	        return state.iframe != null ? state.iframe.contentWindow : null;
	      } catch (e) {
	        // ignore
	      }
	      return null;
	    }
	  });

	  // add self to the list of openend loginWindows
	  _CallbackHandler2.default.registerForCallback(this, state);

	  // finalization callback (for this component instance) called after login from redirect_uri page
	  this.finalize = function (aLoginResult) {
	    // cleanup & do the callback
	    this.finalize = function () {};
	    this.destroy();
	    if (attrs.onResult) attrs.onResult(aLoginResult);
	  }.bind(this);

	  this.render = function () {
	    var _this = this;

	    if (!state.iframe) {
	      state.iframe = document.createElement("iframe");
	      state.iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
	      state.iframe.src = attrs.url;
	      state.iframe.onload = function () {
	        return _this.finalize(new Error("OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running." + " Alternatively, an error might have happened on OIDC server while processing URL " + attrs.url + " or the application sent wrong redirect_uri."));
	      }; // proper callback page will perform callback prior to onload event
	      state.iframe.onerror = function () {
	        return _this.finalize(new Error("OIDC iframe doesn't contain proper callback HTML page - check that your network is up & running." + " Alternatively, an error might have happened on OIDC server while processing URL " + attrs.url + " or the application sent wrong redirect_uri."));
	      };
	      document.body.appendChild(state.iframe);
	      if (attrs.timeout) this._timeout = setTimeout(function () {
	        _this.finalize(new _uu_appg01_core.Error.TimeoutError("OIDC iframe didn't receive callback within " + attrs.timeout + "s."));
	      }, attrs.timeout * 1000);
	    }
	  };

	  this.destroy = function () {
	    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);
	    this.destroy = function () {};
	    if (this._timeout) clearTimeout(this._timeout);
	    _CallbackHandler2.default.unregisterForCallback(this);
	  };
	};

	exports.default = IframeComponent;

/***/ },
/* 13 */
/*!********************!*\
  !*** ./jwt/Jwt.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Base64Url = __webpack_require__(/*! ../util/Base64Url.js */ 14);

	var _Base64Url2 = _interopRequireDefault(_Base64Url);

	var _InvalidTokenError = __webpack_require__(/*! ./InvalidTokenError.js */ 15);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	var _JwtVerifierWebCrypto = __webpack_require__(/*! ./JwtVerifierWebCrypto.js */ 16);

	var _JwtVerifierWebCrypto2 = _interopRequireDefault(_JwtVerifierWebCrypto);

	var _JwtVerifierJsrsasign = __webpack_require__(/*! ./JwtVerifierJsrsasign.js */ 17);

	var _JwtVerifierJsrsasign2 = _interopRequireDefault(_JwtVerifierJsrsasign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519
	//     - JSON (containing claims) encoded in a JWS / JWE structure
	// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515
	// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516

	// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net
	// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,
	// but not on production; it's ~90kB of minified code).
	var hasWebCrypto = typeof crypto != "undefined" && crypto.subtle && crypto.subtle.importKey;
	var useWebCrypto = hasWebCrypto && (typeof location == "undefined" || location.protocol == "https:");
	var verifier = useWebCrypto ? _JwtVerifierWebCrypto2.default : _JwtVerifierJsrsasign2.default;

	var DEFAULT_ALG = "RS256";
	exports.default = {
	  /**
	   * 
	   */
	  decode: function decode(token, verifyOpts, getKeyFn) {
	    var tokenParts;
	    var header;
	    return Promise.resolve().then(function () {
	      if (typeof token != "string") throw new Error("Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).");
	      tokenParts = token.split(".");
	      if (tokenParts.length != 3) throw new Error("Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: " + token);

	      // parse header
	      var headerB64U = tokenParts[0];
	      var headerStr = _Base64Url2.default.decode(headerB64U);
	      header = JSON.parse(headerStr);
	      if (header.typ != "JWT") throw new Error("Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: " + token);

	      // get key
	      return getKeyFn(header);
	    }).then(function (key) {
	      // NOTE Check the whole importKey call if adding support for other key types.
	      if (!key || key.kty != "RSA") throw new Error("Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: " + JSON.stringify(key));
	      // always verify algorithm against the one is JOSE header
	      var alg = key.alg || DEFAULT_ALG;
	      if (alg !== header.alg) throw new _InvalidTokenError2.default("Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '" + header.alg + "', verification key uses '" + key.alg + "' (with default of '" + DEFAULT_ALG + "'). Token: " + token + " Key: " + JSON.stringify(key));

	      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);
	    }).then(function (valid) {
	      if (!valid) throw new _InvalidTokenError2.default("Invalid JSON Web Token: " + token);
	      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
	      var body = JSON.parse(bodyStr);
	      return body;
	    });
	  }
	};

/***/ },
/* 14 */
/*!***************************!*\
  !*** ./util/Base64Url.js ***!
  \***************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Base64Url = {
	  /**
	   * @param txtAscii Ascii string to encode (each character is in range 0-255).
	   * @return {string} Provided string encoded to Base64Url encoding.
	   */
	  encodeAscii: function encodeAscii(txtAscii) {
	    if (!txtAscii) return txtAscii;
	    return btoa(txtAscii).replace(/\+/g, "-").replace(/\//g, "_");
	  },
	  /**
	   * @param txtUtf8 UTF-8 string to encode.
	   * @return {string} Provided string encoded to Base64Url encoding.
	   */
	  encode: function encode(txtUtf8) {
	    if (!txtUtf8) return txtUtf8;
	    return Base64Url.encodeAscii(unescape(encodeURIComponent(txtUtf8)));
	  },
	  /**
	   * @return {string} Base64Url decoded to an Ascii string (each character is in range 0-255).
	   */
	  decodeToAscii: function decodeToAscii(base64Url) {
	    if (!base64Url) return null;
	    var base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
	    return atob(base64);
	  },
	  /**
	   * @return {string} Base64Url decoded to a UTF-8 string.
	   */
	  decode: function decode(base64Url) {
	    var ascii = Base64Url.decodeToAscii(base64Url);
	    return ascii != null ? decodeURIComponent(escape(ascii)) : null;
	  }
	};
	exports.default = Base64Url;

/***/ },
/* 15 */
/*!**********************************!*\
  !*** ./jwt/InvalidTokenError.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var InvalidTokenError = function (_Errors$Error) {
	  _inherits(InvalidTokenError, _Errors$Error);

	  function InvalidTokenError() {
	    _classCallCheck(this, InvalidTokenError);

	    return _possibleConstructorReturn(this, (InvalidTokenError.__proto__ || Object.getPrototypeOf(InvalidTokenError)).apply(this, arguments));
	  }

	  return InvalidTokenError;
	}(_uu_appg01_core.Error.Error);

	exports.default = InvalidTokenError;

/***/ },
/* 16 */
/*!*************************************!*\
  !*** ./jwt/JwtVerifierWebCrypto.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Base64Url = __webpack_require__(/*! ../util/Base64Url.js */ 14);

	var _Base64Url2 = _interopRequireDefault(_Base64Url);

	var _InvalidTokenError = __webpack_require__(/*! ./InvalidTokenError.js */ 15);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports = {
	  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {
	    var webCryptoAlgorithm = {
	      name: "RSASSA-PKCS1-v1_5",
	      hash: { name: "SHA-" + alg.substr(2) }
	    };
	    // MS Edge throws error if the key contains field "use" => remove it
	    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails
	    var usedKey = JSON.parse(JSON.stringify(key));
	    delete usedKey.use;

	    return crypto.subtle.importKey("jwk", usedKey, webCryptoAlgorithm, false, ["verify"]).then(function (webCryptoKey) {
	      // validate signature
	      var signatureB64U = tokenParts[2];
	      var data = tokenParts[0] + "." + tokenParts[1];
	      var signatureBytes = asciiToUint8Array(_Base64Url2.default.decodeToAscii(signatureB64U));
	      var dataBytes = asciiToUint8Array(data);
	      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);
	    }, function (importError) {
	      var e = new Error("Unable to verify JSON Web Token - importing key via WebCrypto API failed.\nKey: " + JSON.stringify(usedKey) + "\nToken: " + token + "\nError: " + importError);
	      e.cause = importError;
	      return Promise.reject(e);
	    }).then(function (signatureValid) {
	      if (!signatureValid) throw new _InvalidTokenError2.default("Invalid JSON Web Token - signature is not valid. Token: " + token);
	      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
	      var body = JSON.parse(bodyStr);
	      var throwError = function throwError(txt, failedClaim) {
	        throw new _InvalidTokenError2.default("Invalid token: " + txt + "\nFailed claim: " + JSON.stringify(failedClaim) + "\nIssued by: " + JSON.stringify(body.iss) + "\nVerification options: " + JSON.stringify(verifyOpts) + "\nToken: " + token);
	      };

	      // verify claims

	      // 'alg' is always checked
	      if (!verifyOpts.alg) throw new Error("Unable to verify JWT claim - 'alg' field must be always given for verification.");
	      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError("Algorithm " + JSON.stringify(header.alg) + " used by token is not valid - expected one of " + JSON.stringify(verifyOpts.alg) + ".", "alg");

	      // 'iss'
	      var v;
	      v = asArray(verifyOpts.iss);
	      if (v && v.indexOf(body.iss) === -1) throwError("Issuer URI " + JSON.stringify(body.iss) + " in token is not valid - expected one of " + JSON.stringify(v) + ". Token was issued by different OpenID Connect server or it was forged.", "iss");

	      // 'sub'
	      v = asArray(verifyOpts.sub);
	      if (v && v.indexOf(body.sub) === -1) throwError("Subject " + JSON.stringify(body.sub) + " in token is not valid - expected one of " + JSON.stringify(v) + ".", "sub");

	      // 'aud' - all values from verifyOpts.aud must be present in body.aud 
	      v = asArray(verifyOpts.aud);
	      var bodyV = asArray(body.aud) || [];
	      if (v && bodyV.some(function (bv) {
	        return v.indexOf(bv) == -1;
	      })) throwError("Audience list " + JSON.stringify(bodyV) + " in token is not valid - some of following values are missing: " + JSON.stringify(v) + ".", "aud");

	      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)
	      var now = Date.now() / 1000;
	      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;
	      var gracePeriod = verifyOpts.gracePeriod || 0;

	      // 'exp' - expires
	      if (typeof body.exp === "number" && body.exp + gracePeriod < now) throwError("Token already expired at " + toTimeString(body.exp) + ", current time is " + toTimeString(now) + ".", "exp");

	      // 'nbf' - not before
	      if (typeof body.nbf === "number" && now < body.nbf - gracePeriod) throwError("Token is not yet valid - it will become valid at " + toTimeString(body.nbf) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "nbf");

	      // 'iat' - issued at time
	      if (typeof body.iat === "number" && now < body.iat - gracePeriod) throwError("Token seems to have been issued in the future - " + toTimeString(body.iat) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "iat");

	      // 'jti' - JWT id
	      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError("Token ID " + JSON.stringify(body.jti) + " not valid - expected " + JSON.stringify(verifyOpts.jti) + ".", "jti");

	      return true;
	    });
	  }
	};

	function asciiToUint8Array(ascii) {
	  return new Uint8Array(ascii.split("").map(function (c) {
	    return c.charCodeAt(0);
	  }));
	}
	function asArray(value) {
	  if (value == null) return null;
	  if (Array.isArray(value)) return value;
	  return [value];
	}
	function toTimeString(seconds) {
	  return new Date(seconds * 1000).toISOString().replace(/T/, " ");
	}

/***/ },
/* 17 */
/*!*************************************!*\
  !*** ./jwt/JwtVerifierJsrsasign.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _module = __webpack_require__(/*! module */ 1);

	var _module2 = _interopRequireDefault(_module);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var scriptUri = ((_module2.default ? _module2.default.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
	var jsrsasign = undefined;
	var Verifier = {
	  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {
	    var _this = this;

	    return Promise.resolve().then(function () {
	      // load jsrsasign library on 1st verification
	      if (jsrsasign === undefined) {
	        var continueFn = Verifier.verify.bind(_this, key, alg, verifyOpts, header, tokenParts, token);
	        var isMin = scriptUri.indexOf(".min.") != -1;
	        var baseUrl = scriptUri.replace(/^(.*\/).*/, "$1");
	        var url = baseUrl + "jsrsasign" + (isMin ? ".min" : "") + ".js";
	        var loadPromise;
	        if (typeof System != "undefined") loadPromise = System.import(url);else loadPromise = new Promise(function (resolve, reject) {
	          var script = document.createElement("script");
	          script.onload = function () {
	            resolve(window["Jsrsasign"]);
	          };
	          script.onerror = function (e) {
	            reject(e);
	          };
	          script.src = url;
	          document.head.appendChild(script);
	        });
	        return loadPromise.then(function (obj) {
	          jsrsasign = obj || null;
	          return continueFn();
	        }, function (e) {
	          // NOTE Don't set jsrsasign to null (if network was down, next attempt of the user might work)
	          console.error(e);
	          return continueFn();
	        });
	      }
	      if (!jsrsasign) throw new Error("Unable to verify token because jsrsasign library failed to load.");

	      // var exampleKey = {"kty":"RSA","e":"AQAB","n":"yXxJt2xevNsgGGGFfX5e22Jvy0_Eopgkumz7mJ7ScWlPfsMsAi8BZsF7nbDjA3T3v2vy2_-DaLDg-z-BjRwQIPL1LRzQGeDDSVmPcZtbexqkpjouxZ6-abpefSAFX5cA8NJ5h4JknFJWAsxxKEw4Ogy6XFd_BEaDmyXlLcV65Bs","alg":"RS256","kid":"rJZx5vzX1FOt_Nt8sB8jUA","use":"sig"};
	      // var pem = KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(exampleKey));
	      //   =>
	      // -----BEGIN PUBLIC KEY-----
	      // MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJfEm3bF682yAYYYV9fl7bYm/L
	      // T8SimCS6bPuYntJxaU9+wywCLwFmwXudsOMDdPe/a/Lb/4NosOD7P4GNHBAg8vUt
	      // HNAZ4MNJWY9xm1t7GqSmOi7Fnr5pul59IAVflwDw0nmHgmScUlYCzHEoTDg6DLpc
	      // V38ERoObJeUtxXrkGwIDAQAB
	      // -----END PUBLIC KEY-----

	      // do the verification
	      var keyInst = jsrsasign.KEYUTIL.getKey(key);
	      var result = jsrsasign.jws.JWS.verifyJWT(token, keyInst, verifyOpts); // see lib/jsrsasign-.../jws-3.3.js
	      return result || Promise.reject(new Error("Token is not valid. Token: " + token));
	    });
	  }
	};

	module.exports = Verifier;

/***/ },
/* 18 */
/*!**********************!*\
  !*** ./jwks/Jwks.js ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Discovery = __webpack_require__(/*! ../discovery/Discovery.js */ 7);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _HttpClient = __webpack_require__(/*! ../util/HttpClient.js */ 8);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var jwkSetCache = {};
	var cacheBustCounter = 0;

	// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517

	var _class = function () {
	  function _class(options) {
	    _classCallCheck(this, _class);

	    if (!options || !options.serverUri) throw new Error("Jwks must be initialized with options containing serverUri.");
	    this.options = options;
	  }

	  _createClass(_class, [{
	    key: "getKey",
	    value: function getKey(keyId, keyType) {
	      return this._getKey(keyId, keyType, false);
	    }
	  }, {
	    key: "_getKey",
	    value: function _getKey(keyId, keyType, forceKeySetReload) {
	      var _this = this;

	      // load set of OIDC server JSON Web Key-s
	      return _Discovery2.default.getMetadata(this.options.serverUri).then(function (metadata) {
	        // TODO Use also localStorage cache as optimization.
	        var jwkSetMeta = jwkSetCache[metadata.jwks_uri];
	        if (!jwkSetMeta || forceKeySetReload) {
	          var url = metadata.jwks_uri;
	          if (forceKeySetReload) url = url.replace(/(\?.*)?$/, function (m) {
	            return "?cachebust=" + Date.now().toString(36) + "_" + (cacheBustCounter++).toString(36) + (m ? "&" + m.substr(1) : "");
	          });
	          jwkSetMeta = jwkSetCache[metadata.jwks_uri] = _HttpClient2.default.get(url).then(function (value) {
	            return { jwkSet: value, url: url };
	          });
	        }
	        return jwkSetMeta;
	      }).then(function (jwkSetMeta) {
	        var jwkSet = jwkSetMeta.jwkSet;
	        // choose key by id & type
	        var keys = jwkSet.keys;
	        if (keyId) keys = keys.filter(function (it) {
	          return it.kid === keyId;
	        }); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)
	        if (keyType) keys = keys.filter(function (it) {
	          return it.kty === keyType;
	        });
	        // keys = keys.filter(it => it.use === "sig" || (it.key_ops||[]).indexOf("verify") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)
	        if (keys.length != 1) {
	          // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser
	          // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)
	          if (!forceKeySetReload) return _this._getKey(keyId, keyType, true);
	          throw new Error("There's " + keys.length + " JSON Web Key(s) in JWK Set with kid='" + keyId + "' kty='" + keyType + "'. There must be exactly 1. JWK Set has been downloaded from: " + jwkSetMeta.url);
	        }
	        return keys[0];
	      });
	    }
	  }]);

	  return _class;
	}();

	exports.default = _class;

/***/ },
/* 19 */
/*!***************************!*\
  !*** ./SessionContext.js ***!
  \***************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SessionContext = function SessionContext(loginOptions, authResponse, claims) {
	  _classCallCheck(this, SessionContext);

	  this.loginOptions = loginOptions;
	  this.authResponse = authResponse;
	  this.claims = claims;

	  this.getClaims = function () {
	    return claims;
	  };

	  var identity;
	  this.getIdentity = function () {
	    if (identity) return identity;
	    return identity = {
	      id: claims["sub"],
	      name: claims["name"],
	      email: claims["email"],
	      uuIdentity: claims["uu_identity"],
	      levelOfAssurance: Number(claims["loa"]),
	      loginLevelOfAssurance: Number(claims["acr"])
	    };
	  };
	};

	exports.default = SessionContext;

/***/ },
/* 20 */
/*!**********************!*\
  !*** ./util/Uuid.js ***!
  \**********************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = generateUuid;
	function generateUuid() {
	  // generate UUID (RFC4122 version 4 compliant) for the event ID
	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0,
	        v = c == 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	  return uuid;
	}

/***/ },
/* 21 */
/*!**************************!*\
  !*** ./uuos8/Os8Auth.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _IframeComponent = __webpack_require__(/*! ../ui/IframeComponent.js */ 12);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	var _ImplicitFlow = __webpack_require__(/*! ../flow/ImplicitFlow.js */ 6);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Os8Auth = function () {

	  /**
	   * @param options.serverUri
	   * @param options.clientId
	   * @param options.redirectUri
	   */
	  function Os8Auth(options) {
	    _classCallCheck(this, Os8Auth);

	    if (!options || !options.serverUri || !options.clientId || !options.redirectUri) throw new Error("Os8Auth must be initialized with options containing serverUri, clientId and redirectUri.");
	    this.options = options;
	  }

	  /**
	   * @param parameters
	   * @param parameters.subject_token
	   */


	  _createClass(Os8Auth, [{
	    key: "grantExchangeToken",
	    value: function grantExchangeToken(parameters) {
	      var params = parameters || {};
	      if (!params.subject_token) throw new Error("Os8Auth.grantExchangeToken must be called with parameter subject_token.");
	      var urlParams = Object.assign({}, params, {
	        response_type: "id_token token",
	        client_id: this.options.clientId,
	        redirect_uri: this.options.redirectUri
	      });
	      var urlParamsParts = Object.keys(urlParams).filter(function (k) {
	        return urlParams[k] != null;
	      }).map(function (k) {
	        return encodeURIComponent(k) + "=" + encodeURIComponent(urlParams[k] + "");
	      });
	      var url = this.options.serverUri.replace(/\/*$/, "/") + "exchangeOs8Token" + "?" + urlParamsParts.join("&");

	      return new Promise(function (resolve, reject) {
	        new _IframeComponent2.default({
	          url: url,
	          onResult: function onResult(aLoginResult) {
	            var authResponse = _ImplicitFlow2.default.getAuthResponseFromCallback(aLoginResult);
	            if (!authResponse || authResponse.error) reject(authResponse);else resolve(authResponse);
	          }
	        }).render();
	      });
	    }
	  }]);

	  return Os8Auth;
	}();

	exports.default = Os8Auth;

/***/ },
/* 22 */
/*!****************************!*\
  !*** ./util/StringUtil.js ***!
  \****************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  toSnakeCase: function toSnakeCase(aText) {
	    return (aText || "").replace(/[A-Z]/g, function (m) {
	      return "_" + m.toLowerCase();
	    });
	  }
	};

/***/ },
/* 23 */
/*!***************************************!*\
  !*** ./SessionStateChangeNotifier.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Dom = __webpack_require__(/*! ./util/Dom.js */ 24);

	var _Dom2 = _interopRequireDefault(_Dom);

	var _Discovery = __webpack_require__(/*! ./discovery/Discovery.js */ 7);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var logger = _uu_appg01_core.Logging.LoggerFactory.get("UuOidc.SessionStateChangeNotifier");

	var SessionStateChangeNotifier = function () {
	  function SessionStateChangeNotifier(session) {
	    _classCallCheck(this, SessionStateChangeNotifier);

	    this.session = session;
	    this._listeners = [];

	    this._checkState = this._checkState.bind(this);
	    this._onMessage = this._onMessage.bind(this);
	    this._init();
	  }

	  _createClass(SessionStateChangeNotifier, [{
	    key: "onStateChange",
	    value: function onStateChange(listenerFn) {
	      var _this = this;

	      this._listeners.push(listenerFn);
	      return function () {
	        // return function for unregistering
	        var idx = _this._listeners.indexOf(listenerFn);
	        if (idx != -1) _this._listeners.splice(idx, 1);
	        return idx != -1;
	      };
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      if (this._destroyed) return;
	      this._destroyed = true;
	      if (this._stateCheckInterval) clearInterval(this._stateCheckInterval);
	      delete this._stateCheckInterval;
	      window.removeEventListener("message", this._onMessage);
	      this._listeners = [];
	    }
	  }, {
	    key: "_init",
	    value: function _init() {
	      var _this2 = this;

	      // add iframe with check_session_iframe URL
	      _Dom2.default.domReady.then(function () {
	        if (_this2._destroyed) return;
	        return _Discovery2.default.getMetadata(_this2.session.serverUri).then(function (metadata) {
	          var iframeUrl = metadata.check_session_iframe;
	          if (!iframeUrl) {
	            console.error("The OpenID Connect server", _this2.session.serverUri, "doesn't support check_session_iframe (see", _Discovery2.default.getMetadataUri(_this2.session.serverUri), ").");
	            return;
	          }
	          logger.debug("Creating iframe with check_session_iframe endpoint URL - " + iframeUrl);
	          _this2._iframeTrustedOrigin = getOrigin(iframeUrl);
	          var iframe = _this2._iframe = document.createElement("iframe");
	          iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
	          iframe.tabIndex = "-1";
	          iframe.onload = function () {
	            return _this2._stateCheckAllowed = true;
	          };
	          iframe.src = iframeUrl;
	          document.body.appendChild(iframe);

	          // add message handler for processing messages from the iframe
	          window.addEventListener("message", _this2._onMessage);

	          // start checking
	          _this2._stateCheckInterval = setInterval(_this2._checkState, _this2.session.sessionCheckInterval * 1000);
	        });
	      });
	    }
	  }, {
	    key: "_onMessage",
	    value: function _onMessage(e) {
	      logger.debug("Received message from " + e.origin + ": " + e.data);
	      if (!this._iframe || e.source !== this._iframe.contentWindow || e.origin !== this._iframeTrustedOrigin) return;
	      if (e.data === "changed") {
	        logger.info("Received session state change notification from OIDC iframe (message: '" + e.data + "').");
	        this._listeners.forEach(function (fn) {
	          return fn();
	        });
	      }
	    }
	  }, {
	    key: "_checkState",
	    value: function _checkState() {
	      if (!this._stateCheckAllowed || !this._iframe) return;
	      var authResponse = (this.session._loginCtx || {}).authResponse;
	      if (!authResponse) return; // we have no session state (and we don't really need to get info that the user became logged in due to login in different tab)
	      if (!authResponse.session_state) return; // unknown session state (e.g. current token was provided directly, instead of via login in browser tab)

	      var query = this.session.clientId + " " + authResponse.session_state;
	      logger.debug("Querying session state change from OIDC iframe. Query: " + query);
	      this._iframe.contentWindow.postMessage(query, this._iframeTrustedOrigin);
	    }
	  }]);

	  return SessionStateChangeNotifier;
	}();

	exports.default = SessionStateChangeNotifier;


	function getOrigin(absUrl) {
	  return (absUrl || "").match(/^(https?:\/\/[^\/]+).*$/)[1] || null;
	}

/***/ },
/* 24 */
/*!*********************!*\
  !*** ./util/Dom.js ***!
  \*********************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
	var domReadyPromise = isBrowser ? document.readyState === "interactive" || document.readyState === "complete" ? Promise.resolve() : new Promise(function (resolve) {
	  document.addEventListener("DOMContentLoaded", resolve, false);
	}) : Promise.resolve();

	exports.default = {
	  domReady: domReadyPromise
	};

/***/ },
/* 25 */
/*!***************************!*\
  !*** ./SessionHandler.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = SessionHandler;

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var UuApp = _interopRequireWildcard(_uu_appg01_core);

	var _Session = __webpack_require__(/*! ./Session.js */ 3);

	var _Session2 = _interopRequireDefault(_Session);

	var _StringUtil = __webpack_require__(/*! ./util/StringUtil.js */ 22);

	var _StringUtil2 = _interopRequireDefault(_StringUtil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.

	/**
	 * @class UuOidc.SessionHandler
	 * @classdesc
	 * Interceptor for Client which authenticates command calls by using user from
	 * current / specified session. Additionally, if server responds with authentication challenge
	 * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor
	 * performs session login and calls the command again.
	 * 
	 * Interceptor is skipped if there's request header "authorization" set for the command call, even
	 * if the header value is null.
	 * 
	 * **Configuration**
	 * 
	 * Interceptor recognizes following options for command call:
	 * 
	 * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.
	 * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.
	 * 
	 * **Error handling**
	 * 
	 * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):
	 * 
	 * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.
	 */
	function SessionHandler(request, options, nextInterceptorFn) {
	  var hasCustomAuthn = "authorization" in request.headers;
	  if (hasCustomAuthn) return nextInterceptorFn(request, options);

	  var session = options.session || _Session2.default.currentSession;
	  var loginParams = options["uuoidc.loginParameters"];
	  if (loginParams) loginParams = Object.keys(loginParams).reduce(function (r, k) {
	    return r[_StringUtil2.default.toSnakeCase(k)] = loginParams[k], r;
	  }, {});
	  var count = 0;

	  function runWith(extraLoginParams) {
	    if (++count > 5) throw new UuApp.Error.AbortError("Command invocation stopped because user was not able to fulfill login requirements for the command within " + count + " attempts.");

	    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)
	    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);
	    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams) : Promise.resolve(session)).catch(function (e) {
	      // if user login failed then abort or throw
	      if (e === false) throw new UuApp.Error.AbortError("Command invocation stopped because user refused to log in.");
	      throw new UuApp.Error.Error("Command invocation stopped because of a login error.", e);
	    }).then(function (session) {
	      var isAuthenticated = session.isAuthenticated();
	      if (isAuthenticated) {
	        return Promise.resolve(session.getCallToken()).then(function (callToken) {
	          return { isAuthenticated: isAuthenticated, callToken: callToken };
	        });
	      }
	      return { isAuthenticated: isAuthenticated, callToken: null };
	    }).then(function (data) {
	      var isAuthenticated = data.isAuthenticated;
	      var callToken = data.callToken;
	      var authToken = callToken ? callToken.token : null;
	      if (authToken) request.headers["authorization"] = [callToken.tokenType || "Bearer", authToken].join(" ");
	      return nextInterceptorFn(request, options).catch(function (response) {
	        // check for special response values in WWW-Authenticate response header which indicates
	        // that we shall run login procedure with additional parameters and then try again the same command
	        try {
	          // NOTE Using try-catch in case that target server is cross-domain and CORS doesn't allow
	          // access to response headers.
	          var wwwAuthenticate = response.headers("www-authenticate");
	        } catch (e) {
	          console.error(e);
	        }
	        if (wwwAuthenticate) {
	          var valueMap = {};
	          wwwAuthenticate.replace(/^\S+\s+/, "").split(/,/).map(function (it) {
	            return it.trim();
	          }).forEach(function (it) {
	            // remove "Bearer "
	            var idx = it.indexOf("=");
	            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));
	            var value = decodeUriWithPlus(idx == -1 ? "" : it.substr(idx + 1));
	            valueMap[key] = decodeUriWithPlus(value);
	          });

	          var relevantValues = Object.keys(valueMap).filter(function (key) {
	            return key.match(/^(max_age|acr_values|prompt|scope)$/);
	          }).reduce(function (r, k) {
	            return r[k] = valueMap[k], r;
	          }, {});
	          // if there's any of relevant keys in the WWW-Authenticate response header then
	          // re-run the whole OIDC Handler with those values sent to login
	          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);

	          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also
	          if (!isAuthenticated) return runWith({ acr_values: "1" }); // require non-anonymous
	        }
	        return Promise.reject(response);
	      });
	    });
	  }
	  return runWith(null);
	}

	function decodeUriWithPlus(txt) {
	  return decodeURIComponent(txt.replace(/\+/g, " "));
	}

/***/ },
/* 26 */
/*!******************************!*\
  !*** ./bootstrap-session.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Session = __webpack_require__(/*! ./Session.js */ 3);

	var _Session2 = _interopRequireDefault(_Session);

	var _Dom = __webpack_require__(/*! ./util/Dom.js */ 24);

	var _Dom2 = _interopRequireDefault(_Dom);

	var _ImplicitFlow = __webpack_require__(/*! ./flow/ImplicitFlow.js */ 6);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function tryAutoLogin() {
	  if (_Session2.default.currentSession.isAuthenticated() || _Session2.default.currentSession._loginInProgress > 0) return;

	  // if there's access_token parameter in current URL, consider it as the id_token of the user
	  var id_token;
	  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {
	    id_token = decodeURIComponent(g.replace(/\+/g, " "));
	  });
	  if (id_token) {
	    return _Session2.default.currentSession._login({
	      access_token: id_token,
	      nonce: null
	    });
	  }

	  // try to login with no user interaction
	  return _Session2.default.currentSession._login({
	    prompt: "none", // no user interaction
	    acr_values: "1" // non-anonymous user
	  }).catch(function (e) {
	    if (_ImplicitFlow2.default.isLoggedOutError(e)) return; // everything is fine, we just aren't logged in
	    throw e; // some other error happenned
	  });
	}

	// try to login without prompting user (only for browser environment)
	var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
	if (isBrowser) {
	  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works
	  _Dom2.default.domReady.then(function () {
	    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter
	  }).then(_Session2.default.initPromise._finalizeInit.bind(null, true), _Session2.default.initPromise._finalizeInit.bind(null, false));
	} else {
	  _Session2.default.initPromise._finalizeInit(true);
	}

/***/ }
/******/ ])
});
;