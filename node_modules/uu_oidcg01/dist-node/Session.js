"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _uu_appg01_core = require("uu_appg01_core");

var _Defaults = require("./Defaults.js");

var _Defaults2 = _interopRequireDefault(_Defaults);

var _ImplicitFlow = require("./flow/ImplicitFlow.js");

var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

var _SessionContext = require("./SessionContext.js");

var _SessionContext2 = _interopRequireDefault(_SessionContext);

var _Uuid = require("./util/Uuid.js");

var _Uuid2 = _interopRequireDefault(_Uuid);

var _Os8Auth = require("./uuos8/Os8Auth.js");

var _Os8Auth2 = _interopRequireDefault(_Os8Auth);

var _PromiseUtil = require("./util/PromiseUtil.js");

var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

var _StringUtil = require("./util/StringUtil.js");

var _StringUtil2 = _interopRequireDefault(_StringUtil);

var _IframeComponent = require("./ui/IframeComponent.js");

var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

var _SessionStateChangeNotifier = require("./SessionStateChangeNotifier.js");

var _SessionStateChangeNotifier2 = _interopRequireDefault(_SessionStateChangeNotifier);

var _Discovery = require("./discovery/Discovery.js");

var _Discovery2 = _interopRequireDefault(_Discovery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UuAppError = _uu_appg01_core.Error.Error;
var logger = _uu_appg01_core.Logging.LoggerFactory.get("UuOidc.Session");

var Session = function () {

  /**
   * Creates new Session with specified options.
   * 
   * @class UuOidc.Session
   * @classdesc
   * 
   * Session handling via OpenID Connect server.
   * 
   * **Configuration**
   * 
   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback
   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be
   * configured as described below - configuration parameter "uuoidc.redirectUri".
   * 
   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:
   * 
   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for
   *   accessing most of user data.
   * * **uuoidc.redirectUri** - redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
   *   to document.baseURI (current URL). Default is "callbacks/oidc-callback.html".
   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is "https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be".
   * * **uuoidc.sessionExpiringNotificationTime** - a "sessionExpiring" notification event is triggered these many seconds prior to the session expiration.
   *   Default is 5 minutes. Using 0 disables the notification.
   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
   *   Default is 5. Using 0 disables the checking.
   * 
   * **Supported events**
   * 
   * It's possible to handle session state changes and other notifications by registering a listener function to any of these events
   * (see also {@link UuOidc.Session#addListener}):
   * 
   * * **identityChange** - triggerred whenever an identity changes (user logs in / out / changes its authorization status). Event's
   * "data" field contains the new identity (see {@link UuOidc.Session#getIdentity}).
   * * **sessionExpiring** - triggerred some time before the global session against OpenID Connect server expires. The application
   * can show a warning at this moment and suggest to the user to re-login themselves. Re-login can be initiated by
   * {@link UuOidc.Session#login Session#login}({ prompt: "login" }) which forces a popup window to be shown.
   * The event's "data" field contains an object with following fields:
   *     * expiresAt - time in milliseconds when the expiration of the global session will occur.
   * * **sessionExtended** - trigerred after the global session against OpenID Connect server has been extended. The application should
   * remove the warning about necessity of user re-login if it's showing one (i.e. if there happenned a sessionExpiring event, the user
   * re-logged in, possibly in different browser tab, then the application should no longer display any warning about sessionExpiring).
   * The event's "data" field contains an object with following fields:
   *     * expiresAt - time in milliseconds when the expiration of the global session will occur
   * 
   * @param options {Object|UuApp.Util.Config} Options.
   * @param options.serverUri OpenID Connect server to perform login / logout against.
   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
   *   to document.baseURI (current URL).
   * @param options.sessionExpiringNotificationTime A "sessionExpiring" notification event is triggered these many seconds prior to the session expiration.
   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
   */
  function Session(options) {
    var _this = this;

    _classCallCheck(this, Session);

    if (!options) throw new UuAppError("Session must be initialized with proper options or UuApp.Util.Config.");
    this._optionsMergedPromise = _PromiseUtil2.default.wrapForImmediateThen(Promise.resolve(options && typeof options.get == "function" ? options.initPromise || options : options).then(function (env) {
      Object.keys(_Defaults2.default).forEach(function (k) {
        var v = void 0;
        if (env && typeof env.get == "function") v = env.get("uuoidc." + k, false);else if (env) v = env[k];
        if (v == null) v = _Defaults2.default[k];
        _this[k === "redirectUri" ? "implicitFlowRedirectUri" : k] = v;
      });
      if (!_this.clientId) _this.clientId = "uu-oidc:unregistered-client:" + (0, _Uuid2.default)();
      // if redirect URI is relative then absolutize it (relative to current document.baseURI)
      if (!_this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) {
        // no protocol present
        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\/).*/, "$1");
        if (_this.implicitFlowRedirectUri.charAt(0) != "/") _this.implicitFlowRedirectUri = toFullUrl(baseUrl + _this.implicitFlowRedirectUri);else _this.implicitFlowRedirectUri = toFullUrl(_this.implicitFlowRedirectUri);
      }
      // sanitize times & interval settings
      if (typeof _this.sessionExpiringNotificationTime !== "number" || _this.sessionExpiringNotificationTime < 0) _this.sessionExpiringNotificationTime = _Defaults2.default.sessionExpiringNotificationTime;
      if (typeof _this.sessionCheckInterval !== "number" || _this.sessionCheckInterval < 0) _this.sessionCheckInterval = _Defaults2.default.sessionCheckInterval;
      if (_this.sessionCheckInterval > 0 && _this.sessionCheckInterval < 2) _this.sessionCheckInterval = 2; // minimal interval is 2, but allow "0" for disabling the check
      if (typeof _this.tokenRefreshLeeway !== "number" || _this.tokenRefreshLeeway < 0) _this.tokenRefreshLeeway = _Defaults2.default.tokenRefreshLeeway;
      if (typeof _this.tokenRefreshFailureRetryInterval !== "number" || _this.tokenRefreshFailureRetryInterval < 0) _this.tokenRefreshFailureRetryInterval = _Defaults2.default.tokenRefreshFailureRetryInterval;
      if (_this.tokenRefreshFailureRetryInterval > 0) _this.tokenRefreshFailureRetryInterval = Math.max(5, _this.tokenRefreshFailureRetryInterval);

      // add session state checking which, in case that we were logged in and a logout
      // against OIDC is detected (e.g. in another browser tab), will log us out
      if (_this.sessionCheckInterval) {
        _this._sessionChecker = new _SessionStateChangeNotifier2.default(_this);
        _this._sessionChecker.onStateChange(function () {
          logger.debug("Session state change detected.");
          if (!_this.isAuthenticated()) return; // don't check new state if we're currently logged out (don't auto-login)

          // check login state against OpenID server (basically renew the token,
          // possibly logging out if the current user on OpenID server differs from ours)
          _this._silentTokenRefresh(true);
        });
      }
    }));
    this._loginInProgress = 0;
    this._silentTokenRefreshInProgress = 0;
    this.nonce = Math.random().toString(32).substr(2);

    var listeners = {};
    /**
     * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:
     * 
     * * **type** The type of the event, e.g. "identityChange".
     * * **data** The data passed to the event.
     * 
     * See {@link UuOidc.Session Session} for the list of supported events.
     * 
     * @param {string} eventName The event to register listener for.
     * @param {function(Event)} listener The function to be called whenever the event is trigerred.
     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeListener}).
     * @see UuOidc.Session#removeListener
     * @method UuOidc.Session#addListener
     */
    this.addListener = function (eventName, listener) {
      var list = listeners[eventName];
      if (!list) list = listeners[eventName] = [];
      list.push(listener);
      return _this.removeListener.bind(_this, eventName, listener);
    };
    /**
     * Removes listener for specified event.
     * 
     * @param {string} eventName The event to remove listener for.
     * @param {function(Event)} listener The listener (function) to unregister.
     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
     * @see UuOidc.Session#addListener
     * @method UuOidc.Session#removeListener
     */
    this.removeListener = function (eventName, listener) {
      var list = listeners[eventName];
      if (!list) return false;
      var idx = list.indexOf(listener);
      if (idx != -1) list.splice(idx, 1);
      return idx != -1;
    };

    this._runListeners = function (eventName, data) {
      logger.debug("Launching event \"" + eventName + ".\"");
      var list = listeners[eventName];
      if (list) {
        var e = {
          type: eventName,
          data: data
        };
        list.forEach(function (it) {
          return it.call(_this, e);
        });
      }
      // run also deprecated identityChangeListener-s (they don't get "event" object but directly the data)
      // if this is "identityChange" event
      // TODO 3.0 Remove.
      if (eventName === "identityChange" && listeners["__identityChange"]) listeners["__identityChange"].forEach(function (it) {
        return it.call(_this, data);
      });
    };

    /**
     * @return {boolean} True iff the user is authenticated (logged in).
     * @method UuOidc.Session#isAuthenticated
     */
    this.isAuthenticated = function () {
      return !!_this._loginCtx;
    };

    /**
     * Adds listener for changes of user identity (logins / logouts).
     * 
     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.
     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).
     * @see UuOidc.Session#addListener
     * @see UuOidc.Session#getIdentity
     * @method UuOidc.Session#addIdentityChangeListener
     * @deprecated Use Session#addListener("identityChange", listener) instead. Note that the listener accepts Event object.
     */
    this.addIdentityChangeListener = this.addListener.bind(this, "__identityChange");

    /**
     * Removes listener for changes of user identity (logins / logouts).
     * 
     * @param {Function(Object)} listener The listener to remove.
     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
     * @see UuOidc.Session#removeListener
     * @method UuOidc.Session#removeIdentityChangeListener
     * @deprecated Use Session#removeListener("identityChange", listener) instead.
     */
    this.removeIdentityChangeListener = this.removeListener.bind(this, "__identityChange");

    // add session_expires_at field
    // NOTE This is required for "auto-logout", "session expiring" and "session extended" functionality.
    // NOTE This assumes that whenever a token changes, identity-change listeners are run
    // And that they are run pretty much immediately (so that authResponse.session_expires_in
    // is relative to the moment when we received the response).
    this.addListener("identityChange", function (e) {
      var authResponse = (_this._loginCtx || {}).authResponse;
      if (!authResponse || !authResponse.session_expires_in) return;
      if (authResponse.session_expires_at) return;
      authResponse.session_expires_at = Math.floor(Date.now() / 1000) + Number(authResponse.session_expires_in);
    });

    // auto-logout when server-side session reaches its expiration time (or when token
    // reaches its expiration time in case that server-side session info is not available)
    // NOTE This assumes that whenever a token changes, identity-change listeners are run
    // (so that info from new token gets checked again).
    this.addListener("identityChange", function (e) {
      if (_this._autoLogoutTimeout) {
        clearTimeout(_this._autoLogoutTimeout);
        delete _this._autoLogoutTimeout;
      }
      var authResponse = (_this._loginCtx || {}).authResponse;
      if (!authResponse) return;

      // plan local logout
      var expiresAt = authResponse.session_expires_at || (_this.getClaims() || {})["exp"];
      if (!expiresAt) return;
      var now = new Date().getTime();
      var delay = Math.max(0, expiresAt * 1000 - now);
      logger.debug("Planning local auto-logout at " + toTimeString(new Date(now + delay)) + ".");
      _this._autoLogoutTimeout = setTimeout(function () {
        delete _this._autoLogoutTimeout;
        _this._localLogout();
      }, delay);
    });

    // support for token auto-refresh when its nearing expiration
    // NOTE This assumes that whenever a token changes, identity-change listeners are run
    // (so that token refreshing gets re-planned / cleaned).
    var lastTokenRefreshTime = 0;
    this.addListener("identityChange", function (e) {
      if (!_this.tokenRefreshEnabled) return;

      if (_this._sessionRefreshTimeout) {
        clearTimeout(_this._sessionRefreshTimeout);
        delete _this._sessionRefreshTimeout;
      }
      var claims = _this.getClaims();
      var expiresAt = (claims || {})["exp"];
      if (!expiresAt) return; // not logged in (or there's something with the claims but that shouldn't happen)

      // plan token refresh
      var now = new Date().getTime();
      var delay = Math.max(expiresAt * 1000 - now - _this.tokenRefreshLeeway * 1000, Math.max(0, 1000 - (now - lastTokenRefreshTime))); // wait at least 1s between 2 token refreshes
      logger.debug("Planning token auto-refresh at " + toTimeString(new Date(now + delay)) + ".");
      _this._sessionRefreshTimeout = setTimeout(function () {
        delete _this._sessionRefreshTimeout;
        lastTokenRefreshTime = new Date().getTime();
        _this._silentTokenRefresh();
      }, delay);
    });

    // support for "session extended" notification
    // NOTE This assumes that whenever a token changes, identity-change listeners are run.
    this.addListener("identityChange", function (e) {
      var LEEWAY_MILLIS = 10 * 1000; // use leeway because server sends "session_expires_in" which is relative so if network becomes slower, we might then compute the "...expires_at" value as if it was greater than before
      var authResponse = (_this._loginCtx || {}).authResponse;
      var wasExtended = _this._activeSessionExpiresAtMillis && authResponse && authResponse.session_expires_at * 1000 > _this._activeSessionExpiresAtMillis + LEEWAY_MILLIS;
      _this._activeSessionExpiresAtMillis = authResponse ? authResponse.session_expires_at * 1000 : null;
      if (wasExtended) {
        _this._sessionExpiringBlocked = false;
        var expiresAt = _this._activeSessionExpiresAtMillis;
        setTimeout(function () {
          // we're currently processing "identityChange" listeners so let them finish and run "sessionExtended" afterwards
          _this._runListeners("sessionExtended", { expiresAt: expiresAt });
        }, 0);
      }
    });

    // support for "session expiring" notification
    // NOTE Must be after "session extended" functionality (so that unblocking done there
    // gets performed sooner than the code below).
    // NOTE This assumes that whenever a token changes, identity-change listeners are run.
    var prevIdentity = undefined;
    this.addListener("identityChange", function (e) {
      if (_this.sessionExpiringNotificationTime <= 0) return; // disabled

      if (_this._sessionExpiringTimeout) {
        clearTimeout(_this._sessionExpiringTimeout);
        delete _this._sessionExpiringTimeout;
      }
      var authResponse = (_this._loginCtx || {}).authResponse;
      var newIdentity = (_this.getClaims() || {})["sub"];
      if (newIdentity != prevIdentity) _this._sessionExpiringBlocked = false;
      prevIdentity = newIdentity;

      if (!authResponse) return; // not logged in
      if (!authResponse.session_expires_at) return; // "session expiring" notification not supported on server
      if (_this._sessionExpiringBlocked) return; // don't trigger "session expiring" multiple times for the same session

      var expiresAt = authResponse.session_expires_at * 1000;
      var now = Date.now();
      var delay = Math.max(0, expiresAt - now - _this.sessionExpiringNotificationTime * 1000);
      logger.debug("Planning sessionExpiring notification at " + toTimeString(new Date(now + delay)) + ".");
      _this._sessionExpiringTimeout = setTimeout(function () {
        delete _this._sessionExpiringTimeout;
        _this._sessionExpiringBlocked = true;
        _this._runListeners("sessionExpiring", { expiresAt: expiresAt });
      }, delay);
    });
  }

  /**
   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:
   * 
   * * id
   * * name
   * * uuIdentity
   * * email
   * * levelOfAssurance
   * * loginLevelOfAssurance
   * 
   * @return {Object} Identity of currently logged in user or null if not logged in.
   * @method UuOidc.Session#getIdentity
   */


  _createClass(Session, [{
    key: "getIdentity",
    value: function getIdentity() {
      return this._loginCtx ? this._loginCtx.getIdentity() : null;
    }

    /**
     * Returns all claims present in the token (or null if not logged in).
     * 
     * @method UuOidc.Session#getClaims
     */

  }, {
    key: "getClaims",
    value: function getClaims() {
      return this._loginCtx ? this._loginCtx.getClaims() : null;
    }

    /**
     * Login against OpenID Connect server. If no or empty options are used, user will be required to
     * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in
     * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can
     * be forced by using option "prompt" set to "login".
     * 
     * @param options {Object} Options.
     * @param options.prompt {string} (optional) One of "" (default), "none" (check login state without user interaction), "login" (re-request authentication).
     * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).
     * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.
     * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it
     *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:
     * 
     * * "urn:ietf:params:oauth:token-type:jwt-uuos8" - indicates that the token being passed to the login was originally issued by uuOS8
     * 
     * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained
     *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:
     * 
     *   * false - user refused to log in
     *   * Error - any other error such as network problems, ...
     * 
     * @method UuOidc.Session#login
     */

  }, {
    key: "login",
    value: function login(options) {
      // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).

      // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)
      var opts;
      if (options) opts = Object.keys(options).reduce(function (r, k) {
        return r[_StringUtil2.default.toSnakeCase(k)] = options[k], r;
      }, {});

      return this._login(opts);
    }

    // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.

  }, {
    key: "_login",
    value: function _login(options, canUpdateSessionWithLoginResultFn) {
      var _this2 = this;

      var opts = Object.assign({}, options);

      // there's a special case in which we support providing uuOS8 token
      var os8Token;
      if (opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
        os8Token = opts.access_token;
        delete opts.access_token;
        delete opts.token_type_hint;
      }

      // use accessToken directly if it's provided
      var accessToken = opts.access_token;
      delete opts.access_token;

      var doLogin = function doLogin() {
        ++_this2._loginInProgress;

        // if calling Session.login() with no parameters, log in as non-anonymous user
        if (Object.keys(opts).length == 0) opts["acr_values"] = 1;

        // if we have user then login only if options indicate that we have to
        if (!accessToken && _this2._loginCtx) {
          var useCurrent = true;
          if (opts["prompt"] || opts["max_age"] || opts["access_token"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.

          // check required login level of assurance
          var acr_values = (opts["acr_values"] != null ? opts["acr_values"] + "" : "").split(/\s+/);
          var identity = _this2.getIdentity();
          if (acr_values.every(function (v) {
            return Number(v) > identity.loginLevelOfAssurance;
          })) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login

          // check current token expiration
          if (_ImplicitFlow2.default.isAuthResponseExpired(_this2._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login

          // use current token if everything seems fine
          if (useCurrent) {
            --_this2._loginInProgress;
            return Promise.resolve(_this2);
          }
        }

        // login using implicit flow
        var authResponse = accessToken ? { id_token: accessToken } : null;
        var nonce = accessToken || os8Token || "nonce" in opts ? opts["nonce"] : _this2.nonce;
        opts.nonce = nonce;
        delete opts.state; // we'll generate our own, if needed

        // NOTE Clicking a button, which launches this login method, can result in
        // at most 1 Promise resolution. If 2 or more Promises are chained, mobile
        // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise
        // is wrapped via PromiseUtil which then allows us here to call our "then" function immediately
        // if the this._optionsMergedPromise has already been resolved.
        // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)
        // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is
        // not trivial.
        var authResponsePromise = Promise.resolve(authResponse || _PromiseUtil2.default.immediateThen(_this2._optionsMergedPromise, function () {
          // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll
          // do this by exchanging tokens via non-standard endpoint for uuOS8
          if (os8Token) {
            var os8Auth = new _Os8Auth2.default({
              serverUri: _this2.serverUri,
              clientId: _this2.clientId,
              redirectUri: _this2.implicitFlowRedirectUri
            });
            return os8Auth.grantExchangeToken({
              subject_token: os8Token
            });
          }

          // authenticate using implicit flow
          opts.state = Math.random().toString(32).substr(2);
          if (navigator.standalone) opts.state += "," + location.pathname + location.search + (location.hash.length > 1 ? location.hash : ""); // iOS in standalone mode - callback HTML will redirect back with full page reload
          return _ImplicitFlow2.default.login({
            serverUri: _this2.serverUri,
            clientId: _this2.clientId,
            redirectUri: _this2.implicitFlowRedirectUri,
            loginParams: opts
          });
        }, function (e) {
          return Promise.reject(e);
        }));
        return authResponsePromise.then(function (authResponse) {
          // validate response
          return _this2._optionsMergedPromise.then(function () {
            return _ImplicitFlow2.default.validateAuthResponse(authResponse, {
              serverUri: _this2.serverUri,
              clientId: _this2.clientId,
              loginParams: opts
            });
          });
        }).then(function (_ref) {
          var authResponse = _ref.authResponse,
              claims = _ref.claims;

          // login successful => update the session
          if (!canUpdateSessionWithLoginResultFn || canUpdateSessionWithLoginResultFn({ authResponse: authResponse, claims: claims }) !== false) {
            _this2._loginCtx = new _SessionContext2.default(opts, authResponse, claims);
            _this2._runListeners("identityChange", _this2.getIdentity());
          }
          return _this2;
        }).then(function (r) {
          --_this2._loginInProgress;
          return r;
        }, function (e) {
          --_this2._loginInProgress;
          return Promise.reject(e);
        });
      };

      // wait for session restoring in case that this instance of the session is the "main" session
      return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? _PromiseUtil2.default.immediateThen(Session.initPromise, doLogin) : doLogin();
    }

    /**
     * Tries to re-authenticate the user silently:
     * - if we are locally logged out => do nothing
     * - if a user is logged in (on remote) and it's the same user as ours => use the new token
     * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout
     * - if a user is not logged in (on remote) => perform local logout
     */

  }, {
    key: "_silentTokenRefresh",
    value: function _silentTokenRefresh(aSkipIfPlanned) {
      var _this3 = this;

      if (aSkipIfPlanned && (this._silentTokenRefreshTimeout || this._silentTokenRefreshInProgress > 0)) return;

      if (this._silentTokenRefreshTimeout) {
        clearTimeout(this._silentTokenRefreshTimeout);
        delete this._silentTokenRefreshTimeout;
      }
      var invocationCount = 0;
      var doSilentRenew = function doSilentRenew() {
        if (!_this3.isAuthenticated()) return;

        logger.debug("Silent token refresh - starting.");
        ++_this3._silentTokenRefreshInProgress;
        ++invocationCount;
        return _this3._login({
          acr_values: "1",
          prompt: "none"
        }, function (_ref2) {
          var claims = _ref2.claims;

          --_this3._silentTokenRefreshInProgress;
          if (!_this3.isAuthenticated()) {
            // no-op (we're logged out and don't want to silently auto-login)
            logger.debug("Silent token refresh - ending with no-op (local session is already logged out).");
            return false; // don't use the new authResponse
          }
          // if the user is different than the current one then perform logout
          if (claims.sub !== _this3.getClaims().sub) {
            logger.debug("Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).");
            _this3._localLogout();
            return false; // don't use the new authResponse
          }
          logger.debug("Silent token refresh - ending with token renewed.");
          return true; // use the new authResponse
        }).catch(function (e) {
          var err = e && e.error ? e.error : e; // e could be AuthenticationResponse, Error or anything else
          if (_ImplicitFlow2.default.isLoggedOutError(e)) {
            logger.debug("Silent token refresh - ending with local logout (user is not logged in on remote).");
            _this3._localLogout();
            return;
          }
          if (!_this3._silentTokenRefreshTimeout && _this3.tokenRefreshFailureRetryInterval) {
            logger.debug("Silent token refresh - will retry in " + _this3.tokenRefreshFailureRetryInterval + "s (operation ended with unexpected error).", { error: err });
            _this3._silentTokenRefreshTimeout = setTimeout(function () {
              delete _this3._silentTokenRefreshTimeout;
              doSilentRenew();
            }, _this3.tokenRefreshFailureRetryInterval * 1000);
          } else {
            if (_this3._silentTokenRefreshTimeout) logger.debug("Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).", { error: err });else logger.debug("Silent token refresh - ending with no-op (operation ended with unexpected error).", { error: err });
          }
          if (invocationCount === 1) console.warn("Token refresh failed with error:", err);else if (invocationCount === 2) console.warn("Suppressing further notifications of token refresh problem to prevent log cluttering (until success or logout).");
        });
      };

      doSilentRenew();
    }
  }, {
    key: "_localLogout",
    value: function _localLogout() {
      logger.debug("Performing local-logout.");
      if (!this._loginCtx) return;
      delete this._loginCtx;
      this._runListeners("identityChange", this.getIdentity());
    }

    /**
     * Log out the user.
     * 
     * @return Promise resolved after the user gets logged out (or immediately, if the user is not logged in).
     * @method UuOidc.Session#logout
     */

  }, {
    key: "logout",
    value: function logout() {
      var _this4 = this;

      if (!this._loginCtx) return Promise.resolve();

      // logout global session using end_session_endpoint (in an iframe)
      return this._optionsMergedPromise.then(function () {
        return _Discovery2.default.getMetadata(_this4.serverUri).then(function (metadata) {
          return new Promise(function (resolve, reject) {
            if (!_this4._loginCtx) return resolve();
            var logoutCallbackUri = _this4.implicitFlowRedirectUri;
            var logoutUrl = metadata.end_session_endpoint + "?post_logout_redirect_uri=" + encodeURIComponent(logoutCallbackUri) + "&id_token_hint=" + encodeURIComponent(_this4._loginCtx.authResponse.id_token);
            new _IframeComponent2.default({
              url: logoutUrl,
              onResult: function onResult(result) {
                if (result instanceof Error) {
                  result.message = "Logout failed." + (result.message ? " " + result.message : "");
                  reject(result);
                } else {
                  _this4._localLogout();
                  resolve();
                }
              }
            }).render();
          });
        });
      });
    }

    /**
     * Returns token and its type for calling commands. Returned object contains following fields:
     * 
     * * tokenType - the type of the token, such as "Bearer",
     * * token - the token itself.
     * 
     * If the user is not logged in, null is returned.
     * 
     * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.
     * @return Object containing token and its type, or null if user is not logged in.
     * @method UuOidc.Session#getCallToken
     */

  }, {
    key: "getCallToken",
    value: function getCallToken(callUri) {
      var authResponse = (this._loginCtx || {}).authResponse;
      if (!authResponse) return null;
      var result = {
        tokenType: authResponse.token_type || null,
        token: authResponse.id_token || null
      };
      return result;
    }
  }]);

  return Session;
}();

exports.default = Session;


function toFullUrl(path) {
  var a = document.createElement("a");
  a.href = path;
  return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
}

function toTimeString(date) {
  return (
    // date.getFullYear() + "-" + ("0" + (date.getMonth() + 1)).substr(-2) + "-" + ("0" + date.getDate()).substr(-2) + " " +
    ("0" + date.getHours()).substr(-2) + ":" + ("0" + date.getMinutes()).substr(-2) + ":" + ("0" + date.getSeconds()).substr(-2)
  );
}

/**
 * Current session.
 * 
 * @name UuOidc.Session.currentSession
 * @type UuOidc.Session
 */
var currentSession;
var allowAutoInitSession = true;
Object.defineProperty(Session, "currentSession", {
  get: function get() {
    if (allowAutoInitSession && !currentSession) {
      currentSession = new Session(_uu_appg01_core.Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).
      currentSession.initComplete = false;
      currentSession.initPromise = Session.initPromise;
    }
    return currentSession;
  },
  set: function set(value) {
    allowAutoInitSession = false;
    currentSession = value;
  }
});

var finalizeInit;
/**
 * Promise resolved after session initialization (restoring state) finishes.
 * 
 * @type {Promise<UuOidc.Session>}
 * @name UuOidc.Session.initPromise 
 */
/**
 * Promise resolved after session initialization (restoring state) finishes.
 * Note that this field is available only on a session instance that is
 * created automatically during page load.
 * 
 * @type {Promise<UuOidc.Session>}
 * @name UuOidc.Session#initPromise 
 */
Session.initPromise = _PromiseUtil2.default.wrapForImmediateThen(new Promise(function (resolve, reject) {
  finalizeInit = function finalizeInit(isOk, result) {
    Session.initComplete = true;
    Session.currentSession.initComplete = true;
    if (!isOk) console.log("Session initialization failed:", result);
    resolve(Session.currentSession); // always resolve as success even if checking session state failed
    return Session.initPromise;
  };
}));
Session.initPromise._finalizeInit = finalizeInit;

/**
 * Whether the session initialization performed during page load has already completed.
 * 
 * @type {boolean}
 * @name UuOidc.Session.initComplete
 */
/**
 * Whether the session initialization performed during page load has already completed.
 * Note that this field is available only on a session instance that is
 * created automatically during page load.
 * 
 * @type {boolean}
 * @name UuOidc.Session#initComplete
 */
Session.initComplete = false;