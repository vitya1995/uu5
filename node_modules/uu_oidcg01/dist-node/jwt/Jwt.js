"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Base64Url = require("../util/Base64Url.js");

var _Base64Url2 = _interopRequireDefault(_Base64Url);

var _InvalidTokenError = require("./InvalidTokenError.js");

var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

var _JwtVerifierWebCrypto = require("./JwtVerifierWebCrypto.js");

var _JwtVerifierWebCrypto2 = _interopRequireDefault(_JwtVerifierWebCrypto);

var _JwtVerifierJsrsasign = require("./JwtVerifierJsrsasign.js");

var _JwtVerifierJsrsasign2 = _interopRequireDefault(_JwtVerifierJsrsasign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519
//     - JSON (containing claims) encoded in a JWS / JWE structure
// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515
// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516

// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net
// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,
// but not on production; it's ~90kB of minified code).
var hasWebCrypto = typeof crypto != "undefined" && crypto.subtle && crypto.subtle.importKey;
var useWebCrypto = hasWebCrypto && (typeof location == "undefined" || location.protocol == "https:");
var verifier = useWebCrypto ? _JwtVerifierWebCrypto2.default : _JwtVerifierJsrsasign2.default;

var DEFAULT_ALG = "RS256";
exports.default = {
  /**
   * 
   */
  decode: function decode(token, verifyOpts, getKeyFn) {
    var tokenParts;
    var header;
    return Promise.resolve().then(function () {
      if (typeof token != "string") throw new Error("Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).");
      tokenParts = token.split(".");
      if (tokenParts.length != 3) throw new Error("Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: " + token);

      // parse header
      var headerB64U = tokenParts[0];
      var headerStr = _Base64Url2.default.decode(headerB64U);
      header = JSON.parse(headerStr);
      if (header.typ != "JWT") throw new Error("Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: " + token);

      // get key
      return getKeyFn(header);
    }).then(function (key) {
      // NOTE Check the whole importKey call if adding support for other key types.
      if (!key || key.kty != "RSA") throw new Error("Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: " + JSON.stringify(key));
      // always verify algorithm against the one is JOSE header
      var alg = key.alg || DEFAULT_ALG;
      if (alg !== header.alg) throw new _InvalidTokenError2.default("Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '" + header.alg + "', verification key uses '" + key.alg + "' (with default of '" + DEFAULT_ALG + "'). Token: " + token + " Key: " + JSON.stringify(key));

      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);
    }).then(function (valid) {
      if (!valid) throw new _InvalidTokenError2.default("Invalid JSON Web Token: " + token);
      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
      var body = JSON.parse(bodyStr);
      return body;
    });
  }
};