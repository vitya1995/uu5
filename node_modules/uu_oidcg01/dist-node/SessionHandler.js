"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SessionHandler;

var _uu_appg01_core = require("uu_appg01_core");

var UuApp = _interopRequireWildcard(_uu_appg01_core);

var _Session = require("./Session.js");

var _Session2 = _interopRequireDefault(_Session);

var _StringUtil = require("./util/StringUtil.js");

var _StringUtil2 = _interopRequireDefault(_StringUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.

/**
 * @class UuOidc.SessionHandler
 * @classdesc
 * Interceptor for Client which authenticates command calls by using user from
 * current / specified session. Additionally, if server responds with authentication challenge
 * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor
 * performs session login and calls the command again.
 * 
 * Interceptor is skipped if there's request header "authorization" set for the command call, even
 * if the header value is null.
 * 
 * **Configuration**
 * 
 * Interceptor recognizes following options for command call:
 * 
 * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.
 * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.
 * 
 * **Error handling**
 * 
 * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):
 * 
 * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.
 */
function SessionHandler(request, options, nextInterceptorFn) {
  var hasCustomAuthn = "authorization" in request.headers;
  if (hasCustomAuthn) return nextInterceptorFn(request, options);

  var session = options.session || _Session2.default.currentSession;
  var loginParams = options["uuoidc.loginParameters"];
  if (loginParams) loginParams = Object.keys(loginParams).reduce(function (r, k) {
    return r[_StringUtil2.default.toSnakeCase(k)] = loginParams[k], r;
  }, {});
  var count = 0;

  function runWith(extraLoginParams) {
    if (++count > 5) throw new UuApp.Error.AbortError("Command invocation stopped because user was not able to fulfill login requirements for the command within " + count + " attempts.");

    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)
    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);
    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams) : Promise.resolve(session)).catch(function (e) {
      // if user login failed then abort or throw
      if (e === false) throw new UuApp.Error.AbortError("Command invocation stopped because user refused to log in.");
      throw new UuApp.Error.Error("Command invocation stopped because of a login error.", e);
    }).then(function (session) {
      var isAuthenticated = session.isAuthenticated();
      if (isAuthenticated) {
        return Promise.resolve(session.getCallToken()).then(function (callToken) {
          return { isAuthenticated: isAuthenticated, callToken: callToken };
        });
      }
      return { isAuthenticated: isAuthenticated, callToken: null };
    }).then(function (data) {
      var isAuthenticated = data.isAuthenticated;
      var callToken = data.callToken;
      var authToken = callToken ? callToken.token : null;
      if (authToken) request.headers["authorization"] = [callToken.tokenType || "Bearer", authToken].join(" ");
      return nextInterceptorFn(request, options).catch(function (response) {
        // check for special response values in WWW-Authenticate response header which indicates
        // that we shall run login procedure with additional parameters and then try again the same command
        try {
          // NOTE Using try-catch in case that target server is cross-domain and CORS doesn't allow
          // access to response headers.
          var wwwAuthenticate = response.headers("www-authenticate");
        } catch (e) {
          console.error(e);
        }
        if (wwwAuthenticate) {
          var valueMap = {};
          wwwAuthenticate.replace(/^\S+\s+/, "").split(/,/).map(function (it) {
            return it.trim();
          }).forEach(function (it) {
            // remove "Bearer "
            var idx = it.indexOf("=");
            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));
            var value = decodeUriWithPlus(idx == -1 ? "" : it.substr(idx + 1));
            valueMap[key] = decodeUriWithPlus(value);
          });

          var relevantValues = Object.keys(valueMap).filter(function (key) {
            return key.match(/^(max_age|acr_values|prompt|scope)$/);
          }).reduce(function (r, k) {
            return r[k] = valueMap[k], r;
          }, {});
          // if there's any of relevant keys in the WWW-Authenticate response header then
          // re-run the whole OIDC Handler with those values sent to login
          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);

          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also
          if (!isAuthenticated) return runWith({ acr_values: "1" }); // require non-anonymous
        }
        return Promise.reject(response);
      });
    });
  }
  return runWith(null);
}

function decodeUriWithPlus(txt) {
  return decodeURIComponent(txt.replace(/\+/g, " "));
}