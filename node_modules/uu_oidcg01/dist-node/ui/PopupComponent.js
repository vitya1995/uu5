"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CallbackHandler = require("./CallbackHandler.js");

var _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Default visual component for presenting login/logout prompt to the user. It displays the
 * URL in a popup window and waits until the user logs in / closes the window. After that
 * initAttrs.onResult(authResultUrl) is called as callback.
 * 
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call after login finishes. If the login finished
 *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.
 *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which
 *   contains the authentication response in fragment). 
 */
var PopupComponent = function PopupComponent(initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  var state = {
    loginWindow: null,
    closeCheckInterval: null
  };

  // add self to the list of opened loginWindows
  _CallbackHandler2.default.registerForCallback(this, state);

  this.finalize = function (result) {
    // cleanup & do the callback
    this.finalize = function () {};
    this.destroy();
    if (attrs.onResult) attrs.onResult(result);
  }.bind(this);

  var closeCheck = function () {
    if (!state.loginWindow || !state.loginWindow.closed) return;
    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value "false"
  }.bind(this);

  this.render = function () {
    var _this = this;

    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)
    if (!state.loginWindow) {
      var rect = { width: 599, height: 600 };
      rect.left = (screen.availWidth - rect.width) / 2 + (screen.availLeft || 0);
      rect.top = (screen.availHeight - rect.height) / 2 + (screen.availTop || 0);
      state.loginWindow = window.open(attrs.url, "_blank", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=" + rect.width + ",height=" + rect.height + ",top=" + rect.top + ",left=" + rect.left);
      if (!state.loginWindow) {
        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in
        Promise.resolve().then(function () {
          return _this.finalize(PopupComponent.ERROR_POPUP_BLOCKED);
        }); // finalize in async way
      } else {
        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);
      }
    }
  };

  this.destroy = function () {
    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();
    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);
    this.destroy = function () {};
    _CallbackHandler2.default.unregisterForCallback(this);
  };
};

PopupComponent.ERROR_POPUP_BLOCKED = "POPUP_BLOCKED";

exports.default = PopupComponent;