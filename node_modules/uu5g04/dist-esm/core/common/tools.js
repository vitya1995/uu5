var _this = this;

import React from 'react';
import ReactDOM from 'react-dom';
import Environment from '../environment/environment.js';
import EnvTools from '../environment/tools.js';

export const REGEXP = {
  attrs: /([-\w]+)(?:\s*=\s*(?:(?:"\s*(<uu5json\s*\/>(?:\\.|[^"])*?)")|(?:'\s*(<uu5json\s*\/>(?:\\.|[^'])*?)')|(?:"\s*(<uu5string\s*\/>(?:\\.|[^"])*?)")|(?:'\s*(<uu5string\s*\/>(?:\\.|[^'])*?)')|(?:"\s*(<uu5data\s*\/>(?:\\.|[^"])*?)")|(?:'\s*(<uu5data\s*\/>(?:\\.|[^'])*?)')|(?:"((?:\\.|[^"])*?)")|(?:'((?:\\.|[^'])*?)')|([^\s]+)))?/g,
  uu5string: /^\s*<uu5string\s*\/>/,
  uu5json: /^\s*<uu5json\s*\/>/,
  uu5data: /^\s*<uu5data\s*\/>/,
  slashes: /^.*[\\\/]/,
  char: /(\-[a-z])/g,
  mobile1: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i,
  mobile2: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
  xy: /[xy]/g,
  whiteSpaces: /\s\s+/g,
  digitInBracket: /{(\d+)}/g,
  stringParams: /%((%)|s|d)/g,
  jsCode: /^(javascript:\s*)*/i,
  columnRegexp: /^((?:offset-)?[a-z]+)(?:-)?(\d+)$/
};

export const Tools = {};

Tools.events = {
  lsi: 'UU5_Common_LsiMixin_lsiEvent',
  highlight: 'UU5_Bricks_TextCorrector_highlightEvent',
  dateTime: 'UU5_Bricks_DateTime_event',
  number: 'UU5_Bricks_Number_event'
};

Tools.screenSize = {
  xs: 480,
  s: 768,
  m: 992,
  l: 1360,
  xl: Infinity
};

Tools.getPage = () => {
  return Environment.page;
};

Tools.checkTag = function (tag, hideError) {
  let result = null;
  switch (typeof tag) {
    case "string":
      result = tag;

      let tagArray = tag.split('.');
      let isSimpleString = tagArray.length === 1;

      if (!isSimpleString) {
        let calculatedTag = window;
        while (calculatedTag && ["object", "function"].indexOf(typeof calculatedTag) > -1 && tagArray.length > 0) {
          calculatedTag = calculatedTag[tagArray.shift()];
        }
        result = calculatedTag || null;

        if (typeof result !== 'function') {
          if (!hideError) {
            Tools.error('Unknown tag ' + tag + ' - element was not found.', {
              notFoundObject: result,
              notFoundObjectType: typeof result
            });
          }
          result = null;
        }
      }

      break;
    case "function":
      result = tag;
      break;
  }

  return result;
};

Tools.findComponent = (tag, props, content) => {
  let newTag = tag;
  if (typeof tag === 'object' && tag.tag) {
    newTag = tag.tag;
    props = tag.props;
  }
  props = props || {};

  let result;
  let UU5 = window.UU5;
  if (Environment.useComponentRegistry) {
    let fTag = Tools.checkTag(newTag, true);
    if (fTag) {
      result = React.createElement(fTag, props, content);
    } else {
      let module = newTag.split('.');
      module.splice(-1, 1);

      if (module.length === 2 && window[module[0]] && window[module[0]][module[1]] && Object.keys(window[module[0]][module[1]]).length) {
        result = <UU5.Common.NotFoundTag tagName={tag} id={props.id} ref_={props.ref_} />;
      } else {
        result = <UU5.Common.TagPlaceholder tagName={newTag} props={props} content={content} />;
      }

      // let fModule = Tools.checkTag(module.join('.'), true);
      // result = fModule ? <UU5.Common.NotFoundTag tagName={tag} id={props.id} ref_={props.ref_} /> :
      //   <UU5.Common.TagPlaceholder tagName={newTag} props={props} content={content} />;
    }
  } else {
    let component = Tools.checkTag(newTag, false);
    result = component ? React.createElement(component, props, content) : <UU5.Common.NotFoundTag tagName={tag} id={props.id} ref_={props.ref_} />;
  }

  return result;
};

Tools.loadLibrary = (libraryName, callback) => {
  let dtoIn = {
    code: libraryName
  };
  let library = Environment.getLibrary(libraryName);
  library && library.version && (dtoIn.version = library.version);
  let url = Environment.COMPONENT_REGISTRY_URL;
  let query = Tools.encodeQuery(dtoIn);
  url += query;
  let cache = Tools.loadLibraryCache;

  if (!cache[query]) {
    cache[query] = {
      result: null,
      error: null,
      pendingCallback: [callback]
    };
    let request = new XMLHttpRequest();
    request.onreadystatechange = () => {
      if (request.readyState === XMLHttpRequest.DONE) {
        let result, error;
        // TODO: componentRegistry must return error, not 200
        if (request.status === 200) {
          try {
            result = JSON.parse(request.response);
          } catch (e) {
            error = e;
          }
        } else {
          error = new Error("Loading library ended with status " + request.status + " on url:" + url);
        }
        cache[query].result = result;
        cache[query].error = error;
        cache[query].pendingCallback.forEach(fn => fn(result, error));
      }
    };
    request.open('GET', url, true);
    request.setRequestHeader("Content-Type", "application/json");
    request.send(JSON.stringify(dtoIn.code));
  } else if (cache[query].result || cache[query].error) {
    callback(cache[query].result, cache[query].error);
  } else {
    cache[query].pendingCallback.push(callback);
  }
};

Tools.loadLibraryCache = {};

Tools.buildAttributes = function (attrsString) {

  //group1 = name (Attribute name)
  //group2 = value (uu5JSON "...")
  //group3 = value (uu5JSON '...')
  //group4 = value (uu5String "...")
  //group5 = value (uu5String '...')
  //group6 = value (uu5Data "...")
  //group7 = value (uu5Data '...')
  //group8 = value (string "...")
  //group9 = value (string '...')
  //group10 = value (no string ... null, true, false, number)

  let attrs = {};
  // !!!!! Never put attrsReg to constants, otherwise it gets stuck - because of exec method on regexp
  let attrsReg = /([-\w]+)(?:\s*=\s*(?:(?:"\s*(<uu5json\s*\/>(?:\\.|[^"])*?)")|(?:'\s*(<uu5json\s*\/>(?:\\.|[^'])*?)')|(?:"\s*(<uu5string\s*\/>(?:\\.|[^"])*?)")|(?:'\s*(<uu5string\s*\/>(?:\\.|[^'])*?)')|(?:"\s*(<uu5data\s*\/>(?:\\.|[^"])*?)")|(?:'\s*(<uu5data\s*\/>(?:\\.|[^'])*?)')|(?:"((?:\\.|[^"])*?)")|(?:'((?:\\.|[^'])*?)')|([^\s]+)))?/g;
  let matchAttrs = attrsReg.exec(attrsString);

  while (matchAttrs) {
    let name = matchAttrs[1];
    let value = true;
    let matchValue = matchAttrs[2] || matchAttrs[3] || matchAttrs[4] || matchAttrs[5] || matchAttrs[6] || matchAttrs[7] || matchAttrs[8] || matchAttrs[9] || matchAttrs[10];

    if (matchValue) {
      if (matchAttrs[10]) {
        //no string value
        if (matchValue == "true") {
          //true
          value = true;
        } else if (matchValue == "false") {
          //false
          value = false;
        } else if (isFinite(matchValue)) {
          //number
          value = +matchValue;
        } else {
          //any other -> null
          value = null;
        }
      } else if (matchAttrs[2] || matchAttrs[3]) {
        //uu5JSON
        try {
          value = this.parseFromUu5JSON(matchValue);
        } catch (e) {
          e.context.prop = name;
          throw e;
        }
      } else if (matchAttrs[4] || matchAttrs[5]) {
        //uu5String
        value = this.getChildrenFromUu5String(matchValue);
      } else if (matchAttrs[6] || matchAttrs[7]) {
        //uu5Data
        value = this.parseFromUu5Data(matchValue);
      } else {
        if (name === "href") {
          matchValue = matchValue.replace(REGEXP.jsCode, "");
        }

        value = matchValue;
      }
    } else if (typeof matchAttrs[8] === 'string' || typeof matchAttrs[9] === 'string') {
      value = matchAttrs[8] || matchAttrs[9];
    }

    attrs[name] = value;

    matchAttrs = attrsReg.exec(attrsString);
  }

  return attrs;
};

Tools.isUU5String = uu5String => {
  return typeof uu5String === 'string' && !!uu5String.match(REGEXP.uu5string);
};

Tools.getChildrenFromUu5String = function (uu5String, opt) {
  // opt (Object) - tagsRegExp, checkSpaces, checkGrammar, language - defaults from UU5.Common.TextCorrector
  opt = opt || {};

  // replace \r\n because of spaces at the start of text in some paragraph
  uu5String = uu5String.trim().replace(/\r\n/g, " ");

  let body = opt && opt.body;

  let tagsRegExp = opt.tagsRegExp || Environment.uu5StringTagsRegExp || null;

  let childStack = [{
    tag: '_root',
    content: [],
    index: 0
  }];

  let pointer = childStack[0];

  let cIndex = -1;
  let pIndex = 0;
  let pre = false;

  // !!!!! Never put uu5stringRe to constants, otherwise it gets stuck - because of exec method on regexp
  let uu5stringRe = /(<\/?)([-\w.]+)((?:\s+\w+(?:\s*=\s*(?:(?:"(?:\\.|[^"])*")|(?:'(?:\\.|[^'])*')|[^>\s]+))?)*)\s*(\/?>)((?:[^<])*)/g;
  let matchS = uu5stringRe.exec(uu5String);
  if (matchS && matchS[2] === 'uu5string' && matchS[4] === '/>') {
    if (matchS[5]) pointer.content.push(Tools.replaceTextEntity(matchS[5]));
    pIndex = matchS[0].length; //skip <uu5string />
    matchS = uu5stringRe.exec(uu5String);
  } else {
    //not an uu5string, leave output intact
    pointer.content.push(uu5String);
    matchS = false;
  }

  while (matchS) {
    cIndex = matchS.index;
    if (cIndex > pIndex) {
      let head = uu5String.substring(pIndex, cIndex);
      pointer.content.push(pre ? Environment.textEntityMap.replaceHtmlEntity(head) : Tools.replaceTextEntity(head));
    }
    let childTag = matchS[2];
    let tagObj;

    if (pre && !(childTag === 'uu5string.pre' && matchS[1] === '</')) {
      pointer.content.push(Environment.textEntityMap.replaceHtmlEntity(matchS[0]));
    } else {

      if (matchS[1] === '</') {
        //closing tag

        tagObj = childStack.pop();

        if (tagObj.tag !== childTag) {
          //ERROR
          Tools.error("Invalid uu5string", { uu5String: uu5String, tag: tagObj.tag, position: tagObj.index });
          return React.createElement(window.UU5.Common.Error, // eslint-disable-line no-undef
          null, <div>Invalid uu5string: Tag {tagObj.tag} at position {tagObj.index} is not closed.<br />{uu5String}</div>);
        }

        pointer = childStack[childStack.length - 1];

        if (pre) {
          pre = false;
          pointer.content[pointer.content.length - 1] = Environment.textEntityMap.replaceHtmlEntity(tagObj.content.join(''));
        } else {
          if (tagObj.forbidden) {
            tagObj.content = [`Error: Tag <${tagObj.tag}/> is not allowed.`];
            tagObj.tag = "UU5.Common.Error";
          }
          let props;
          if (body) {
            props = tagObj.attrs || {};
            props.content = props.content || tagObj.content;
          }
          pointer.content[pointer.content.length - 1] = body ? {
            tag: tagObj.tag,
            props: props
          } : this.findComponent(tagObj.tag, tagObj.attrs, React.Children.toArray(tagObj.content));
        }
      } else {
        pre = childTag === 'uu5string.pre';
        tagObj = { tag: childTag, content: [], index: matchS.index };

        if (tagsRegExp && !tagsRegExp.test(childTag)) tagObj.forbidden = true;else if (matchS[3]) {
          try {
            tagObj.attrs = this.buildAttributes(matchS[3]);
          } catch (err) {
            if (err.code === "uu5jsonInvalid") {
              const tag = tagObj.tag;

              tagObj = {
                tag: window.UU5.Common.Error,
                content: [],
                index: matchS.index,
                attrs: {
                  content: <div>Invalid uu5json: Component {tag} has invalid
                    property {err.context.prop + `='<uu5json/>${err.context.json}'`}. {err.message}<br />{uu5String}
                  </div>
                }
              };
            } else {
              throw err;
            }
          }
        }

        if (matchS[4] === '/>') {
          //self-closing tag
          pre = false;

          if (childTag.indexOf('uu5string.') === 0) {
            //meta-tag uu5string.*
            let s = this.execMetaTag(childTag, tagObj.attrs);
            if (s) s.forEach(item => pointer.content.push(item));
          } else body ? pointer.content.push({
            tag: tagObj.tag,
            props: tagObj.attrs
          }) : pointer.content.push(this.findComponent(tagObj.tag, tagObj.attrs, null));
        } else {
          //common tag
          pointer.content.push(tagObj);
          childStack.push(tagObj);
          pointer = tagObj;
        }
      }

      //text after tag
      if (matchS[5]) pointer.content.push(pre ? Environment.textEntityMap.replaceHtmlEntity(matchS[5]) : Tools.replaceTextEntity(matchS[5]));
    }
    pIndex = cIndex + matchS[0].length;
    matchS = uu5stringRe.exec(uu5String);
  }

  if (childStack.length > 1) {
    let tagObj = childStack.pop();

    Tools.error("Invalid uu5string", { uu5String: uu5String, tag: tagObj.tag, position: tagObj.index });
    return React.createElement(window.UU5.Common.Error, // eslint-disable-line no-undef
    null, <div>Invalid uu5string: Tag {tagObj.tag} at position {tagObj.index} is not closed.<br />{uu5String}</div>);
  }

  return body ? pointer.content : React.Children.toArray(pointer.content);
};

Tools.execMetaTag = (tag, args) => {
  //TODO implement each metaTag as separate function, call functions dynamically (witch safety keyword guard)
  let metaTag = tag.slice(10);
  let r = [];
  switch (metaTag) {
    case 'now':
      r.push(Tools.toLocaleString(new Date(Date.now())));
      break;
    case 'codeHex32':
      r.push(Tools.generateUUID());
      break;
    case 'codeHex64':
      r.push(Tools.generateUUID() + Tools.generateUUID());
      break;
    default:
      r.push(null);
  }
  return r;
};

Tools.parseFromUu5JSON = function (uu5Json) {
  uu5Json = uu5Json.replace(REGEXP.uu5json, '');
  let value = null;
  try {
    value = JSON.parse(uu5Json);
  } catch (err) {
    Tools.error('Error uu5JSON parse.', {
      uu5Json: uu5Json,
      cause: err
    });

    err.code = "uu5jsonInvalid";
    err.context = {
      json: uu5Json
    };
    throw err;
  }
  return value;
};

Tools.parseFromUu5Data = function (uu5data) {
  uu5data = uu5data.replace(REGEXP.uu5data, '');
  let data = UU5.Environment.uu5DataMap && UU5.Environment.uu5DataMap[uu5data]; // eslint-disable-line no-undef
  typeof data === "undefined" && Tools.warning(`There is no component data in UU5.Environment.uu5DataMap for uu5Data: ${uu5data} !`, {
    string: uu5data
  });
  return data;
};

Tools.replaceTextEntity = text => {
  return Environment.textEntityReplace ? Environment.textEntityMap.replace(text) : text; // eslint-disable-line no-undef
};

Tools.pad = function (n, width, z) {
  //return width times leading z for n ... pad(99,5,'-') -> '---99'
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
};

Tools.getServerRequest = function (src, parameters, contentType, done, fail) {
  let request = new XMLHttpRequest();
  request.open('GET', src, true);

  contentType && request.setRequestHeader("Content-type", contentType);
  parameters && request.setRequestHeader("Content-length", parameters.length);

  request.onload = () => {
    if (request.status >= 200 && request.status < 300) {
      typeof done === 'function' && done(request.response);
    } else if (typeof fail === 'function') {
      fail(request);
    }
  };

  request.onerror = () => {
    if (typeof fail === 'function') {
      fail(request);
    }
  };

  request.send(parameters);
};

Tools._merge = function (args, deep) {
  //   var result;
  //   if(args.length){
  //     result = window.Immutable.fromJS(args[0]);
  //
  //     for(var i = 1; i < args.length; i++){
  //       result = deep ? result.mergeDeep(args[i]) : result.merge(args[i]);
  //     }
  //
  //     result = result.toJS();
  //   }
  //   return result;

  var result;
  if (args.length) {
    var data = deep ? [true, {}] : [{}];

    for (var i = 0; i < args.length; i++) {
      data.push(args[i]);
    }

    result = Tools.extend.apply(null, data);
  }
  return result;
};

Tools.mergeDeep = function () {
  return Tools._merge(arguments, true);
};

Tools.merge = function () {
  return Tools._merge(arguments);
};

Tools.mergeEnvironmentUu5DataMap = function (uu5DataMap) {
  Environment.uu5DataMap = UU5.Common.Tools.merge(Environment.uu5DataMap || {}, uu5DataMap); // eslint-disable-line no-undef
};

Tools.getUrlParam = function (name) {
  var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
  return results ? results[1] : null;
};

// used for error context which is sent to server
Tools.getBasicObject = function (object) {
  var result = {};

  if (object['$$typeof']) {
    result = typeof object.type === 'function' ? object.type.tagName : object.type;
  } else if (object['updater']) {
    result = object['getTagName'] ? object.getTagName() : '[React.element]';
  } else {
    for (var key in object) {
      if (key !== '__proto__') {
        var value = object[key];

        if (value && typeof value === 'object') {
          value = this.getBasicObject(value);
        } else if (typeof value === 'function') {
          value = '[function]';
        }

        result[key] = value;
      }
    }
  }
  return result;
};

Tools.getNavigator = function () {
  var navigator = window.navigator;
  return {
    vendor: navigator.vendor,
    maxTouchPoints: navigator.maxTouchPoints,
    hardwareConcurrency: navigator.hardwareConcurrency,
    appCodeName: navigator.appCodeName,
    appName: navigator.appName,
    appVersion: navigator.appVersion,
    platform: navigator.platform,
    product: navigator.product,
    userAgent: navigator.userAgent,
    language: navigator.language,
    languages: navigator.languages,
    onLine: navigator.onLine,
    cookieEnabled: navigator.cookieEnabled,
    doNotTrack: navigator.doNotTrack
  };
};

// Tools.logError = function (data) {
//   $.ajax(
//     {
//       url: Environment.logErrorUrl,
//       type: 'post',
//       cache: false,
//       contentType: 'application/json',
//       data: JSON.stringify(
//         {
//           uri: Environment.logErrorUrl,
//           data: data
//         }
//       )
//     }
//   ).fail(
//     function (failDtoIn) {
//       Tools.error('Cannot send error to server', {failDtoIn: failDtoIn});
//     }
//   );
// };

Tools.getFileName = function (path) {
  return path.replace(REGEXP.slashes, '');
};

Tools.getCamelCase = function (string) {
  var camelCase = '';
  if (string) {
    camelCase = string.charAt(0).toUpperCase() + string.slice(1);
    camelCase = camelCase.replace(REGEXP.char, function ($1) {
      return $1.toUpperCase().replace('-', '');
    });
  }
  return camelCase;
};

Tools.getDashCase = string => {
  let dashCase = '';
  if (string) {
    dashCase = string.replace(/\B[A-Z]/g, $1 => {
      return '-' + $1.toLowerCase();
    });
  }
  return dashCase;
};

Tools.getSnakeCase = string => {
  let snakeCase = '';
  if (string) {
    snakeCase = string.replace(/\B[A-Z]/g, $1 => {
      return '_' + $1.toLowerCase();
    });
  }
  return snakeCase;
};

// Element
Tools.getDocumentHeight = () => {
  let body = document.body;
  let html = document.documentElement;

  return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
};

Tools.getDocumentWidth = () => {
  let body = document.body;
  let html = document.documentElement;

  return Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
};

Tools.getWidth = function (element) {
  let paddingLeft = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('padding-left').replace('px', ''));
  let paddingRight = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('padding-right').replace('px', ''));
  return ReactDOM.findDOMNode(element).clientWidth - paddingLeft - paddingRight;
};

Tools.getInnerWidth = function (element) {
  return ReactDOM.findDOMNode(element).clientWidth;
};

Tools.getOuterWidth = function (element, withMargin) {
  let result = ReactDOM.findDOMNode(element).offsetWidth;
  if (withMargin) {
    let marginLeft = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('margin-left').replace('px', ''));
    let marginRight = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('margin-right').replace('px', ''));
    result += marginLeft + marginRight;
  }
  return result;
};

Tools.getHeight = function (element) {
  let paddingTop = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('padding-top').replace('px', ''));
  let paddingBottom = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('padding-bottom').replace('px', ''));
  return ReactDOM.findDOMNode(element).clientHeight - paddingTop - paddingBottom;
};

Tools.getInnerHeight = function (element) {
  return ReactDOM.findDOMNode(element).clientHeight;
};

Tools.getOuterHeight = function (element, withMargin) {
  let result = ReactDOM.findDOMNode(element).offsetHeight;
  if (withMargin) {
    let marginTop = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('margin-top').replace('px', ''));
    let marginBottom = parseInt(window.getComputedStyle(ReactDOM.findDOMNode(element), null).getPropertyValue('margin-bottom').replace('px', ''));
    result += marginTop + marginBottom;
  }
  return result;
};

Tools.getOffsetTop = function (element) {
  let offsetTop = 0;
  do {
    if (!isNaN(element.offsetTop)) {
      offsetTop += element.offsetTop;
    }
  } while (element = element.offsetParent);
  return offsetTop;
};

Tools.getOffsetLeft = function (element) {
  let offsetLeft = 0;
  do {
    if (!isNaN(element.offsetLeft)) {
      offsetLeft += element.offsetLeft;
    }
  } while (element = element.offsetParent);
  return offsetLeft;
};

Tools.getChildTag = function (child) {
  // react child type
  return child.type;
};

Tools.getChildDisplayName = function (child) {
  var tag = Tools.getChildTag(child);
  return typeof tag === 'function' ? tag.displayName : tag;
};

Tools.getChildTagName = function (child) {
  // UU5 tagNames or standard DOM tags ('div', 'span',...)
  var tag = Tools.getChildTag(child);
  return typeof tag === 'function' ? tag.tagName : tag;
};

// Environment
Tools.isMobileOrTablet = function () {
  var check = false;
  (function (a) {
    if (REGEXP.mobile1.test(a) || REGEXP.mobile2.test(a.substr(0, 4))) check = true;
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check;
}();

// Cookies
Tools.setCookie = function (cookieName, cookieValue, expireDays) {
  var d = new Date();
  d.setTime(d.getTime() + expireDays * 24 * 60 * 60 * 1000);
  var expires = 'expires=' + d.toUTCString();
  document.cookie = cookieName + '=' + cookieValue + '; ' + expires;
};

Tools.getCookie = function (cookieName) {
  var name = cookieName + '=';
  var ca = document.cookie.split(';');
  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return '';
};

// languagesString = 'cs-CZ,en;q=0.6,sk;q=0.8' => [{language: 'cs', location: 'cs-cz', q: 1.0}, {language: 'sk', q:
// 0.8}, {language: 'en', q: 0.6}] languagesString = 'cs' => [{language: 'cs', q: 1.0}] languagesString =
// 'en;q=0.6,sk;q=0.8' => [{language: 'sk', q: 0.8}, {language: 'en', q: 0.6}]
Tools.sortLanguages = function (languagesString) {
  // languagesString = 'cs-CZ,en;q=0.6,sk;q=0.8' => languagesSplitter = ['cs-CZ', 'en;q=0.6', 'sk;q=0.8']
  var languagesSplitter = languagesString.toLowerCase().split(',');

  var languages = {};
  languagesSplitter.forEach(function (lang) {
    var language = {};

    var langOpt = lang.split(';');
    var langStr = langOpt[0];
    var q = 1; // quality factor
    if (langOpt.length > 1) {
      langStr = langOpt[0];
      q = parseFloat(langOpt[1].split('=')[1]);
    }

    var langStrSplitter = langStr.split('-');
    language.language = langStrSplitter[0];
    langStrSplitter[1] && (language.location = langStr);

    if (languages[lang]) {
      languages[lang].q < q && (languages[lang].q = q);
    } else {
      language.q = q;
      languages[lang] = language;
    }
  });

  // languagesArray = [{language: 'cs', location: 'cs-CZ', q: 1.0}, {language: 'en', q: 0.6}, {language: 'sk', q:
  // 0.8}]
  var languagesArray = Object.keys(languages).map(lang => languages[lang]).sort((langA, langB) => {
    if (langA.q < langB.q) {
      return -1;
    }
    if (langA.q > langB.q) {
      return 1;
    }
    return 0;
  });

  // [{language: 'cs', location: 'cs-CZ', q: 1.0}, {language: 'sk', q: 0.8}, {language: 'en', q: 0.6}]
  return languagesArray.sort(function (lang1, lang2) {
    var result = 0;
    if (lang1.q < lang2.q) {
      result = 1;
    } else if (lang1.q > lang2.q) {
      result = -1;
    }
    return result;
  });
};

Tools.generateUUID = length => {
  return EnvTools.generateId(length);
};

Tools.joinClassNames = (className1, className2) => {
  return [className1, className2].join(' ').replace(REGEXP.whiteSpaces, ' ').trim();
};

Tools.buildClasses = function (classes, keys) {
  var className = '';
  classes && keys.forEach(function (v) {
    classes[v] && (className += ' ' + classes[v]);
  });
  return className.trim();
};

Tools.isInClasses = function (classes, regExp) {
  var classesArray = classes ? classes.split(' ') : [];
  var result = false;
  while (!result && classesArray.length) {
    classesArray[0].match(regExp) && (result = true);
    classesArray.shift();
  }
  return result;
};

Tools.buildCounterCallback = function (callback, count) {
  /*
   Method wrap (function) callback by newCallBack.
   If newCallBack is used, increase closureCounter
   but call callback just if closureCounter === count.
   You can use this 'tricky' method, when you want to call callback
   just once but you have to send it to several methods.
   See examples!!!
   */
  var newCallback = null;
  if (typeof callback === 'function') {
    var closureCounter = 0;
    newCallback = function () {
      closureCounter++;
      closureCounter === count && callback.apply(null, arguments);
    };
  }
  return newCallback;
};

Tools._replaceParamsInString = function (string, stringParams) {
  var i = 0;
  return string.replace(REGEXP.stringParams, function (match) {
    // match is the matched format, e.g. %s, %d
    var val = null;
    if (match[2]) {
      val = match[2];
    } else if (stringParams) {
      val = stringParams[i];
      // A switch statement so that the formatter can be extended. Default is %s
      switch (match) {
        case '%d':
          var parsedVal = parseFloat(val);
          if (isNaN(parsedVal)) {
            // cannot use showWarning because of this method is used in showWarning !!!
            Tools.warning('Value ' + val + ' is not number!', {
              string: string,
              stringParams: stringParams
            });
            val = '%d';
          }
          break;
      }
      i++;
    }
    return val;
  });
};

Tools._setParamsToString = function (string, stringParams) {
  return string.replace(REGEXP.digitInBracket, function (match, number) {
    return stringParams && typeof stringParams[number] != 'undefined' ? stringParams[number] : match;
  });
};

Tools.formatString = function (string, stringParams) {
  var result;
  stringParams = stringParams && !Array.isArray(stringParams) ? [stringParams] : stringParams;

  if (string.indexOf('%s') > -1 || string.indexOf('%d') > -1) {
    result = Tools._replaceParamsInString(string, stringParams);
  } else {
    result = Tools._setParamsToString(string, stringParams);
  }
  return result;
};

Tools.scrollToTarget = (id, smoothScroll, offset) => {

  //stop scroll on this events: scroll mousedown wheel DOMMouseScroll mousewheel keyup touchmove
  let html = document.documentElement;
  window.UU5.Environment.EventListener.addEvent(html, 'scroll', id, cancel);
  window.UU5.Environment.EventListener.addEvent(html, 'mousedown', id, cancel);
  window.UU5.Environment.EventListener.addEvent(html, 'wheel', id, cancel);
  window.UU5.Environment.EventListener.addEvent(html, 'DOMMouseScroll', id, cancel);
  window.UU5.Environment.EventListener.addEvent(html, 'mousewheel', id, cancel);
  window.UU5.Environment.EventListener.addEvent(html, 'keyup', id, cancel);
  window.UU5.Environment.EventListener.addEvent(html, 'touchmove', id, cancel);

  let element = id ? document.getElementById(id.replace('#', '')) : document.body;
  let y = (Tools.getOffsetTop(element) || 0) + (offset || 0);

  let _update;
  let _from = scroll();
  let _duration = smoothScroll || 1000;
  let _curr = _from; //Tools merge
  let _done = false;
  let _start = Date.now();

  // x, y coordinates
  let _to = { top: y, left: 0 };

  let _ease = n => {
    n *= 2;
    if (n < 1) return 0.5 * n * n;
    return -0.5 * (--n * (n - 2) - 1);
  };

  update(o => {
    window.scrollTo(o.left | 0, o.top | 0);
  });

  function cancel() {
    _done = true;
    window.UU5.Environment.EventListener.removeEvent(html, 'scroll', id);
    window.UU5.Environment.EventListener.removeEvent(html, 'mousedown', id);
    window.UU5.Environment.EventListener.removeEvent(html, 'wheel', id);
    window.UU5.Environment.EventListener.removeEvent(html, 'DOMMouseScroll', id);
    window.UU5.Environment.EventListener.removeEvent(html, 'mousewheel', id);
    window.UU5.Environment.EventListener.removeEvent(html, 'keyup', id);
    window.UU5.Environment.EventListener.removeEvent(html, 'touchmove', id);
    return this;
  }

  function step() {
    if (!_done) {

      // duration
      let duration = _duration;
      let now = Date.now();
      let delta = now - _start;
      let done = delta >= duration;

      // complete
      if (done) {
        _from = _to;
        _update(_to);
        _done = true;
        return this;
      }

      let from = _from;
      let to = _to;
      let curr = _curr;
      let fn = _ease;
      let p = (now - _start) / duration;
      let n = fn(p);

      for (let k in from) {
        curr[k] = from[k] + (to[k] - from[k]) * n;
      }

      _update(curr);
    }
    return this;
  }

  function update(fn) {
    if (0 == arguments.length) return step();
    _update = fn;
    return this;
  }

  function scroll() {
    let y = window.pageYOffset || document.documentElement.scrollTop;
    let x = window.pageXOffset || document.documentElement.scrollLeft;
    return { top: y, left: x };
  }

  function animate() {
    let raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || fallback;
    raf(animate);
    update();
  }

  function fallback(fn) {
    let prev = new Date().getTime();
    let curr = new Date().getTime();
    let ms = Math.max(0, 16 - (curr - prev));
    let req = setTimeout(fn, ms);
    prev = curr;
    return req;
  }

  animate();

  return _this;
};

Tools.error = function (msg, context) {
  // if (Environment.isProduction()) {
  //   console.error('For debugging use development mode.');
  // } else {
  console.error(msg, context);
  // }

  if (Environment.logErrorFunction) {
    let data = {
      message: msg,
      context: Tools.getBasicObject(context),
      navigator: Tools.getNavigator(),
      stackTrace: new Error().stack
    };

    if (typeof Environment.logErrorFunction === 'function') {
      Environment.logErrorFunction(data);
    } else {
      //Tools.logError(data);
      console.error(`Please add to "UU5.Environment.logErrorFunction" your own function as:
      function (data) {
        $.ajax(
          {
            url: '...',
            type: 'post',
            cache: false,
            contentType: 'application/json',
            data: JSON.stringify(
              {
                data: data
              }
            )
          }
        ).fail(
          function (failDtoIn) {
            UU5.Common.Tools.error('Cannot send error to server', {failDtoIn: failDtoIn});
          }
        );
      }`, context);
    }
  }
};

Tools.warning = function (msg, context = {}) {
  // if (!Environment.isProduction()) {
  console.warn(msg, context);
  // }
};

Tools.repeat = (value, count) => {
  let rpt = '';
  let str = value + '';

  for (;;) {
    if ((count & 1) == 1) {
      rpt += str;
    }
    count >>>= 1;
    if (count == 0) {
      break;
    }
    str += str;
  }

  return rpt;
};

Tools.rjust = (string, length, padding) => {
  string = '' + string;
  padding = padding || ' ';
  let newString = string;

  if (string.length < length) {
    newString = Tools.repeat(padding, length).substr(0, length - string.length) + newString;
  }

  return newString;
};

Tools.ljust = (string, length, padding) => {
  string = '' + string;
  padding = padding || ' ';
  let newString = string;

  if (string.length < length) {
    newString += Tools.repeat(padding, length).substr(0, length - string.length);
  }
  return newString;
};

// TODO: nezaokrouhluje jen desetinná místa -> není to decimalAdjust, ale numberAdjust
Tools.decimalAdjust = (type, value, exp) => {
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math[type](value);
  }
  value = +value;
  exp = +exp;
  // If the value is not a number or the exp is not an integer...
  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  }
  // Shift
  value = value.toString().split('e');
  value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp)));
  // Shift back
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));
};

// Decimal round
Tools.round10 = function (value, exp) {
  return Tools.decimalAdjust('round', value, exp);
};
// Decimal floor
Tools.floor10 = function (value, exp) {
  return Tools.decimalAdjust('floor', value, exp);
};
// Decimal ceil
Tools.ceil10 = function (value, exp) {
  return Tools.decimalAdjust('ceil', value, exp);
};

Tools.encodeValue = value => {
  let result = value + '';

  if (value && (Array.isArray(value) || typeof value === 'object')) {
    result = JSON.stringify(value);
  }

  return encodeURIComponent(result);
};

Tools.encodeQuery = params => {
  let query = '?';

  for (let name in params) {
    query += name + '=' + Tools.encodeValue(params[name]) + '&';
  }

  return query.substr(0, query.length - 1);
};

Tools.isJson = str => {
  try {
    return JSON.parse(str);
  } catch (e) {
    return false;
  }
};

Tools.decodeValue = value => {
  value = decodeURIComponent(value);
  let result = value;

  if (!isNaN(value)) {
    result = +value;
  } else if (value === 'true') {
    result = true;
  } else if (value === 'false') {
    result = false;
  } else {
    let json = Tools.isJson(value);

    if (json) {
      result = json;
    }
  }

  return result;
};

Tools.decodeQuery = query => {
  let params = {};

  query.substr(1, query.length - 1).split('&').forEach(value => {
    let valueSplitter = value.split('=');
    params[valueSplitter[0]] = Tools.decodeValue(valueSplitter[1]);
  });

  return params;
};

Tools.copyToClipboard = content => {
  let tempElement = document.createElement('textarea');
  tempElement.innerText = content;
  document.body.appendChild(tempElement);
  tempElement.select();
  document.execCommand('copy');
  tempElement.remove();
};

Tools.getWeekNumber = date => {
  let d = new Date(+date);
  d.setHours(0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  return Math.ceil(((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7 + 1) / 7);
};

Tools.formatDate = (date, format, timeZone) => {
  if (timeZone) {
    let utc = new Date(date.getTime() + date.getTimezoneOffset() * 60000);
    date = new Date(utc.getTime() + timeZone * 60 * 60000);
  }

  let config = {
    'd+': date.getDate(), //day
    'm+': date.getMonth() + 1, //month
    'y': (date.getFullYear() + '').substr(2, 2), // year end
    'Y': date.getFullYear(), // year full
    'h+': date.getHours() > 12 ? date.getHours() - 12 : date.getHours() === 0 ? 12 : date.getHours(), //hour 1 - 12
    'H+': date.getHours(), //hour
    'M+': date.getMinutes(), //minute
    'S+': date.getSeconds(), //second
    's+': date.getMilliseconds(), //millisecond
    't': date.getHours() > 12 || date.getHours() < 1 ? 'p.m.' : 'a.m.',
    'T': date.getHours() > 12 || date.getHours() < 1 ? 'PM' : 'AM',
    'w+': Tools.getWeekNumber(date),
    'q': Math.floor((date.getMonth() + 3) / 3), //quarter
    'Z': typeof timeZone === "number" ? timeZone * 60 : -date.getTimezoneOffset()
  };

  for (let k in config) {
    if (new RegExp('(' + k + ')').test(format)) {
      let _formatValue = (chars, value) => {
        let result = value;

        if (chars === 'Z') {
          if (value > 0) {
            result = '+';
          } else {
            result = '-';
            value *= -1;
          }
          result += Tools.rjust(Math.floor(value / 60), 2, '0') + ':' + Tools.rjust(Math.floor(value % 60), 2, '0');
        } else if (chars.length === 2) {
          if (chars === 'ss') {
            result = Tools.rjust(value, 3, '0');
          } else {
            result = Tools.rjust(value, 2, '0');
          }
        }
        return result;
      };

      format = format.replace(RegExp.$1, _formatValue(RegExp.$1, config[k]));
    }
  }
  return format;
};

Tools.extend = function () {
  let src,
      copyIsArray,
      copy,
      name,
      options,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;

    // skip the boolean and the target
    target = arguments[i] || {};
    i++;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== "object" && typeof target !== "function") {
    target = {};
  }

  // extend jQuery itself if only one argument is passed
  if (i === length) {
    target = this;
    i--;
  }

  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    if ((options = arguments[i]) != null) {
      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name];

        // Prevent never-ending loop
        if (target === copy) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if (deep && copy && (Tools.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && Array.isArray(src) ? src : [];
          } else {
            clone = src && Tools.isPlainObject(src) ? src : {};
          }

          // Never move original objects, clone them
          target[name] = Tools.extend(deep, clone, copy);

          // Don't bring in undefined values
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

Tools.isPlainObject = obj => {
  let result = false;
  if (typeof obj == 'object' && obj !== null) {
    if (typeof Object.getPrototypeOf == 'function') {
      let proto = Object.getPrototypeOf(obj);
      result = proto === Object.prototype || proto === null;
    } else {
      result = Object.prototype.toString.call(obj) === '[object Object]';
    }
  }
  return result;
};

Tools.isSame = (x, y) => {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
};

// TODO: deprecated
Tools.shallowEqual = (objA, objB) => {
  Tools.warning("Method UU5.Common.Tools.shallowEqual is deprecated. Use UU5.Common.Tools.deepEqual instead.");
  return Tools.deepEqual(objA, objB);
};

Tools.deepEqual = (objA, objB) => {
  if (Tools.isSame(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  let keysA = Object.keys(objA);
  let keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i])) {
      return false;
    }

    if (objA[keysA[i]] && objB[keysA[i]] && typeof objA[keysA[i]] === 'object' && typeof objB[keysA[i]] === 'object') {
      // must be condition because in React 16 _owner is FiberNode which is recursive
      if ((!objA.$$typeof || keysA[i] !== "_owner") && !Tools.deepEqual(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    } else if (keysA[i] !== 'ref_' && !Tools.isSame(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
};

Tools.prettyJson = (object, space) => JSON.stringify(typeof object === 'string' ? JSON.parse(object) : object, null, space || 2);

Tools.childToBodyItem = child => {
  return { tag: Tools.getChildTagName(child), props: Tools.mergeDeep({}, child.props) };
};

Tools.getElementByComputedStyle = (element, styleProperty, value) => {
  let result;
  let parent = element.parentElement;
  if (parent) {
    let style = window.getComputedStyle(parent);
    if (Array.isArray(value) ? value.indexOf(style.getPropertyValue(styleProperty)) > -1 : style.getPropertyValue(styleProperty) === value) {
      result = parent;
    } else {
      result = Tools.getElementByComputedStyle(parent, styleProperty, value);
    }
  }

  return result;
};

Tools.hasProfile = (sourceProfileList, requestedProfile) => {
  return sourceProfileList ? sourceProfileList.indexOf(requestedProfile) > -1 : false;
};

Tools.hasProfileOnly = (sourceProfileList, requestedProfile) => {
  return sourceProfileList ? sourceProfileList.indexOf(requestedProfile) > -1 && sourceProfileList.length === 1 : false;
};

Tools.hasSomeProfiles = (sourceProfileList, requestedProfileList) => {
  return requestedProfileList ? requestedProfileList.some(v => {
    return Tools.hasProfile(sourceProfileList, v);
  }) : false;
};

Tools.hasEveryProfiles = (sourceProfileList, requestedProfileList) => {
  return requestedProfileList ? requestedProfileList.every(v => {
    return Tools.hasProfile(sourceProfileList, v);
  }) : false;
};

Tools.getScreenSize = () => {
  let result;
  let screenWidth = window.innerWidth;

  if (screenWidth <= Tools.screenSize.xs) {
    result = 'xs';
  } else if (screenWidth <= Tools.screenSize.s) {
    result = 's';
  } else if (screenWidth <= Tools.screenSize.m) {
    result = 'm';
  } else if (screenWidth <= Tools.screenSize.l) {
    result = 'l';
  } else {
    result = 'xl';
  }

  return result;
};

Tools.getLanguages = language => {
  return language ? Tools.sortLanguages(language) : Environment.languages;
};

Tools.getLanguage = () => {
  return Environment.languages[0] ? Environment.languages[0].location || Environment.languages[0].language : navigator.language;
};

Tools.setLanguage = language => {
  Tools.setLanguages(language);
  window.UU5.Environment.EventListener.triggerLsi(language);

  let lang = Environment.languages[0];
  lang && Environment.setDateTimeCountry(lang.language);
  return _this;
};

Tools.setLanguages = languages => {
  if (typeof languages === 'string') {
    Environment.languages = Tools.sortLanguages(languages);
  } else if (typeof languages === 'object') {
    languages.forEach(language => {
      if (!(typeof language.language === 'string') && !(0 < language.q < 1)) {
        Tools.error('The provided language array is not allowed.');
        return _this;
      }
    });
    Environment.languages = languages;
  }
  return _this;
};

Tools.getLsiKey = (lsi, languages, language, defaultLanguage) => {
  let lsiKey = null;
  languages = languages || Tools.getLanguages(language);

  if (lsi) {
    let keys = Object.keys(lsi);
    let resLang = keys[0];

    for (let i = 0; i < languages.length; i++) {
      let lang = languages[i];

      if (lsi[lang.location]) {
        resLang = lang.location;
        break;
      } else if (lsi[lang.language]) {
        resLang = lang.language;
        break;
      } else {
        let lsiKeys = keys.filter(function (key) {
          return key.match("^" + lang.language);
        });

        if (lsiKeys.length) {
          resLang = lsiKeys[0];
          break;
        } else {
          defaultLanguage = defaultLanguage || Environment.defaultLanguage;
          if (defaultLanguage) {
            if (lsi[defaultLanguage]) {
              resLang = defaultLanguage;
              break;
            } else if (lsi[defaultLanguage.split('-')[0]]) {
              resLang = defaultLanguage.split('-')[0];
              break;
            }
          }
        }
      }
    }

    lsiKey = lsi[resLang] ? resLang : lsi[keys[0]] ? keys[0] : null;
  }

  return lsiKey;
};

Tools.getLsiItemByLanguage = (lsi, params, languages) => {
  let lsiKey = Tools.getLsiKey(lsi, languages);
  let result = lsiKey ? lsi[lsiKey] : null;

  if (result && params) {
    result = Tools.formatString(result, params);
  }

  return result;
};

Tools.toLocaleDateString = (date, country, opt) => {
  // because of IE
  return date.toLocaleDateString(country, opt).replace(/\u200E/g, '');
};

Tools.toLocaleTimeString = (date, country, opt) => {
  // because of IE
  return date.toLocaleTimeString(country, opt).replace(/\u200E/g, '');
};

Tools.toLocaleString = (date, country, opt) => {
  // because of IE
  return date.toLocaleString(country, opt).replace(/\u200E/g, '');
};

// TODO: deprecated
Tools.getLSIItemByLanguage = (lsi, params, languages) => {
  Tools.warning("Method UU5.Common.Tools.getLSIItemByLanguage is deprecated. Use UU5.Common.Tools.getLsiItemByLanguage instead.");
  return Tools.getLsiItemByLanguage(lsi, params, languages);
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
Tools.debounce = (func, wait = 0, options = {}) => {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func !== 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  //wait = toNumber(wait) || 0;
  //if (isObject(options)) {
  if (typeof options === "object") {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    //maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    maxWait = options.maxWait ? Math.max(options.maxWait, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = Date.now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now());
  }

  function debounced() {
    var time = Date.now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
};

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
Tools.throttle = (func, wait, options = {}) => {
  var leading = true,
      trailing = true;

  //if (typeof func !== 'function') {
  //  throw new TypeError(FUNC_ERROR_TEXT);
  //}
  //if (isObject(options)) {
  if (typeof options === "object") {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return Tools.debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
};

Tools.buildColWidthClassName = colWidth => {
  var newBsColWidth = colWidth;

  if (typeof newBsColWidth === 'string') {
    var colWidthArray = newBsColWidth.split(' ');
    newBsColWidth = {};
    colWidthArray.forEach(colWidth => {
      var match = colWidth.match(REGEXP.columnRegexp);
      newBsColWidth[match[1]] = parseInt(match[2]);
    });
  }

  var sizeClassNames = [];
  var lowerWidth = 12;

  ["xs", "s", "m", "l", "xl"].forEach(size => {
    typeof newBsColWidth[size] !== "number" && typeof lowerWidth === "number" && (newBsColWidth[size] = lowerWidth);
    (lowerWidth = newBsColWidth[size]) && typeof lowerWidth === "number" && sizeClassNames.push(`uu5-col-${size}` + newBsColWidth[size]);

    typeof newBsColWidth[`offset-${size}`] === "number" && sizeClassNames.push(`uu5-col-offset-${size}` + newBsColWidth[`offset-${size}`]);
  });

  return sizeClassNames.join(' ');
};

// userLanguage for IE
const lang = window.navigator.userLanguage || window.navigator.language;
lang && Tools.setLanguages(lang);

export default Tools;