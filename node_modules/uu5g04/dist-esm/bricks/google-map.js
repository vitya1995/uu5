import React from 'react';
import createReactClass from 'create-react-class';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import * as UU5 from "uu5g04";
import ns from "./bricks-ns.js";

import Link from './link.js';
import Modal from './modal.js';

import './google-map.less';

export const GoogleMap = createReactClass({

  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.NestingLevelMixin, UU5.Common.PureRenderMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("GoogleMap"),
    nestingLevelList: UU5.Environment.getNestingLevelList('bigBoxCollection', 'inline'),
    classNames: {
      main: ns.css("google-map")
    },
    defaults: {
      loadLibsEvent: ns.css("google-map-load-libs"),
      apiKeyUrl: 'https://maps.googleapis.com/maps/api/js'
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    mapType: PropTypes.oneOf(['satellite', 'roadmap']),
    latitude: PropTypes.number,
    longitude: PropTypes.number,
    markers: PropTypes.arrayOf(PropTypes.shape({
      latitude: PropTypes.number,
      longitude: PropTypes.number,
      title: PropTypes.string,
      label: PropTypes.string
    })),
    zoom: PropTypes.number,
    disableZoom: PropTypes.bool,
    draggable: PropTypes.bool,
    disableDefaultUI: PropTypes.bool,
    googleApiKey: PropTypes.string,
    height: PropTypes.string,
    width: PropTypes.string,

    // https://developers.google.com/maps/documentation/javascript/styling
    mapStyle: PropTypes.arrayOf(PropTypes.object)
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      mapType: 'roadmap',
      latitude: 50.107799,
      longitude: 14.453689,
      markers: [],
      zoom: 14,
      disableZoom: false,
      draggable: true,
      disableDefaultUI: false,
      googleApiKey: null,
      height: '400px',
      width: '100%',
      mapStyle: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  componentDidMount() {
    this._initialize();
  },

  // setting map options through props
  // for additions see https://developers.google.com/maps/documentation/javascript/reference#MapOptions
  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      let newMapOptions = {};
      nextProps.draggable !== undefined && (newMapOptions.draggable = nextProps.draggable);
      nextProps.disableZoom !== undefined && (newMapOptions.scrollwheel = !nextProps.disableZoom);
      nextProps.disableDefaultUI !== undefined && (newMapOptions.disableDefaultUI = nextProps.disableDefaultUI);
      Object.keys(newMapOptions).length && this.setMapOptions(newMapOptions);
      if (this.props.markers !== nextProps.markers) {
        this._initialize(nextProps.markers);
      }
    }
  },

  componentWillUnmount: function () {
    UU5.Environment.EventListener.unregisterLoadLibs(this.getId(), this._initMap);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  getMap() {
    return this._googleMap;
  },

  setMapOptions(options) {
    if (typeof options === 'object' && options !== null) {
      this._googleMap.setOptions(options);
    }
    return this;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _initialize(markers) {
    markers = markers || this.props.markers;
    if (typeof google === 'undefined' && !window.googleMapApiLoading) {
      this._loadLibraries(markers, this._initMap);
    } else if (googleMapApiLoading) {
      if (window.googleMapApiLoaded) {
        this._initMap(markers);
      } else {
        UU5.Environment.EventListener.registerLoadLibs(this.getId(), this._initMap);
      }
    } else {
      this._loadLibraries(markers).this._initMap(markers);
    }
  },

  _loadLibraries(markers, callback) {
    let googleMap = this;

    window.google = false;
    window.googleMapApiLoading = true;
    let script = document.createElement('script');
    document.head.appendChild(script);

    script.onload = function () {
      window.googleMapApiLoaded = true;
      UU5.Environment.EventListener.triggerLoadLibs(markers);
      typeof callback === 'function' && callback();
    };

    script.src = this.getDefault().apiKeyUrl + (this.props.googleApiKey ? '?key=' + this.props.googleApiKey : '');
  },

  _initMap(markers) {
    markers = markers || this.props.markers;
    let myCenter = new google.maps.LatLng(this.props.latitude, this.props.longitude);

    let mapProps = {
      center: myCenter,
      zoom: this.props.zoom,
      zoomControl: !this.props.disableZoom,
      scrollwheel: !this.props.disableZoom,
      disableDoubleClickZoom: this.props.disableZoom,
      draggable: this.props.draggable,
      disableDefaultUI: this.props.disableDefaultUI,
      mapTypeId: google.maps.MapTypeId[this.props.mapType.toUpperCase()]
    };

    this._googleMap = this._googleMap || new google.maps.Map(ReactDOM.findDOMNode(this._map), mapProps);
    if (this._markers && this._markers.length > 0) {
      this._markers.forEach(marker => {
        marker.setMap(null); //clear old markers
      });
    }

    if (this.props.mapStyle) {
      let styledMap = new google.maps.StyledMapType(this.props.mapStyle);
      this._googleMap.mapTypes.set('map_style', styledMap);
      this._googleMap.setMapTypeId('map_style');
    }

    if (markers !== null) {
      this._markers = [];
      if (!markers.length) {
        let marker = new google.maps.Marker({
          position: myCenter
        });

        this._markers.push(marker);
        marker.setMap(this._googleMap);
      } else {
        markers.forEach(markerProps => {
          let position = new google.maps.LatLng(markerProps.latitude, markerProps.longitude);
          let animation = markerProps.animation ? google.maps.Animation[markerProps.animation.toUpperCase()] : null;
          let newMarker = new google.maps.Marker({
            position: position,
            center: position,
            title: markerProps.title,
            label: markerProps.label,
            icon: markerProps.icon,
            animation: animation
          });
          if (typeof markerProps.onClick === 'function') {
            newMarker.addListener('click', e => markerProps.onClick(this, newMarker, e));
          }

          this._markers.push(newMarker);
          newMarker.setMap(this._googleMap);
        });
      }
    }
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    let mainAttrs = this.getMainAttrs();

    let mapAttrs = {
      ref: ref => this._map = ref,
      style: { height: this.props.height, width: this.props.width }
    };

    let component;
    switch (this.getNestingLevel()) {
      case 'bigBoxCollection':
      case 'bigBox':
      case 'boxCollection':
      case 'box':
        component = <div {...mainAttrs}>
            <div {...mapAttrs} />
            {this.getDisabledCover()}
          </div>;
        break;
      case 'inline':
        component = <span>
            <Modal ref_={modal => this._modal = modal}>
              <div {...mainAttrs}>
                <div {...mapAttrs} />
                {this.getDisabledCover()}
              </div>
            </Modal>
            <Link onClick={() => this._modal.open()} content={this.props.src} />
          </span>;
        break;
      default:
        component = null;
    }

    return component;
  }
  //@@viewOff:render
});

export default GoogleMap;