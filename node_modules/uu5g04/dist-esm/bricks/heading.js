import React from 'react';
import createReactClass from 'create-react-class';
import PropTypes from 'prop-types';
import * as UU5 from "uu5g04";
import ns from "./bricks-ns.js";

import './heading.less';

export const Heading = createReactClass({

  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.PureRenderMixin, UU5.Common.ElementaryMixin, UU5.Common.ContentMixin, UU5.Common.NestingLevelMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("Heading"),
    nestingLevelList: UU5.Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: ns.css("heading"),
      fixed: ns.css("heading-fixed")
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    fixed: PropTypes.bool,
    fixedOnScroll: PropTypes.bool,
    onScrollToFixed: PropTypes.func, // not called in interface, just on scroll
    onScrollToBlocked: PropTypes.func // not called in interface, just on scroll
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function () {
    return {
      fixed: false,
      fixedOnScroll: false,
      onScrollToFixed: null,
      onScrollToBlocked: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState: function () {
    return {
      fixed: this.props.fixed
    };
  },

  componentWillMount: function () {
    this.scrollPosition = 0;
    this.scrollStart = 0;
    return this;
  },

  componentDidMount: function () {
    if (this.props.fixedOnScroll || this.props.onScrollToFixed || this.props.onScrollToBlocked) {
      UU5.Environment.EventListener.addWindowEvent('scroll', this.getId(), this._scroll);
      UU5.Environment.EventListener.addWindowEvent('wheel', this.getId(), this._scroll);
      UU5.Environment.EventListener.addWindowEvent('DOMMouseScroll', this.getId(), this._scroll);
      UU5.Environment.EventListener.addWindowEvent('mousewheel', this.getId(), this._scroll);
    }
    return this;
  },

  componentWillReceiveProps: function (nextProps) {
    this.scrollPosition = 0;
    if (nextProps.controlled) {
      this.setState({ fixed: nextProps.fixed });
      this._scroll(nextProps);
    }
    return this;
  },

  componentWillUnmount: function () {
    if (this.props.fixedOnScroll || this.props.onScrollToFixed || this.props.onScrollToBlocked) {
      UU5.Environment.EventListener.removeWindowEvent('scroll', this.getId());
      UU5.Environment.EventListener.removeWindowEvent('wheel', this.getId());
      UU5.Environment.EventListener.removeWindowEvent('DOMMouseScroll', this.getId());
      UU5.Environment.EventListener.removeWindowEvent('mousewheel', this.getId());
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  getOffsetTop: function () {
    let component = document.getElementById(this.getId());
    return component ? component.offsetTop : null;

    // var componentJQuery = $("#" + this.getId());
    // return componentJQuery ? componentJQuery.offset().top : null;
  },

  setFixedValue: function (fixed, setStateCallback) {
    this.setState({ fixed: fixed }, setStateCallback);
    return this;
  },

  isFixed: function () {
    return this.state.fixed;
  },

  setFixed: function (setStateCallback) {
    this.setFixedValue(true, setStateCallback);
    return this;
  },

  setBlocked: function (setStateCallback) {
    this.setFixedValue(false, setStateCallback);
    return this;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _scroll: function (props) {
    let prop = {
      onScrollToFixed: props.onScrollToFixed || this.props.onScrollToFixed,
      onScrollToBlocked: props.onScrollToBlocked || this.props.onScrollToBlocked,
      fixedOnScroll: props.fixedOnScroll || this.props.fixedOnScroll
    };

    let scrollPosition = window.scrollY;
    let scrollStart = this.getOffsetTop();

    if (scrollPosition > scrollStart && this.scrollPosition <= scrollStart) {
      //console.log(true, {oldScrollPosition: this.scrollPosition, newScrollPosition: scrollPosition, oldScrollStart: this.scrollOffsetStart, newScrollStart: scrollOffsetStart});
      this.scrollPosition = scrollPosition;
      this.scrollStart = scrollStart;

      if (typeof prop.onScrollToFixed === 'function') {
        prop.onScrollToFixed(this, scrollPosition, scrollStart);
      } else if (prop.fixedOnScroll) {
        this.setFixed();
      }
    } else if (scrollPosition <= this.scrollStart && this.scrollPosition > scrollStart) {
      //console.log(false, {oldScrollPosition: this.scrollPosition, newScrollPosition: 0, oldScrollStart: this.scrollOffsetStart, newScrollStart: 0});

      this.scrollPosition = 0;
      this.scrollStart = 0;

      if (typeof prop.onScrollToBlocked === 'function') {
        prop.onScrollToBlocked(this, scrollPosition, scrollStart);
      } else if (prop.fixedOnScroll) {
        this.setBlocked();
      }
    }
    return this;
  },

  _getMainAttrs: function () {
    var mainAttrs = this.getMainAttrs();

    mainAttrs.id = this.getId();
    this.state.fixed && (mainAttrs.className += " " + this.getClassName().fixed);

    return mainAttrs;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render: function () {
    return this.getNestingLevel() ? <div {...this._getMainAttrs()}>
            {this.getChildren()}
            {this.getDisabledCover()}
          </div> : null;
  }
  //@@viewOff:render
});

export default Heading;