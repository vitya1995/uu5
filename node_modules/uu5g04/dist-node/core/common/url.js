'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var regexp = {
  url: /^((http[s]?|ftp):\/)?\/?([^:\/\s]+):?(\d+)?([^?#]+)?\??([^#]+)?#?(.*)$/,
  colon: /:$/,
  slash: /^[/]/,
  hash: /^#/
};

var Url = exports.Url = function () {
  _createClass(Url, null, [{
    key: 'parse',
    value: function parse(url) {
      url = url || window.location.href;
      var result = new Url();

      if (typeof url === 'string') {
        var parser = void 0;
        try {
          parser = new URL(url);
        } catch (e) {
          // HF for ie, Safari
          var matcher = url.match(regexp.url);

          parser = {
            protocol: matcher[2],
            hostname: matcher[3],
            port: matcher[4],
            pathname: matcher[5],
            search: matcher[6],
            hash: matcher[7]
          };
        }
        parser.protocol && (result.protocol = parser.protocol.replace(regexp.colon, ''));
        parser.hostname && (result.hostName = parser.hostname);
        parser.port && (result.port = parser.port);
        parser.pathname && (result.pathName = parser.pathname.replace(regexp.slash, ''));
        parser.search && (result.parameters = parser.search);
        parser.hash && (result.hash = parser.hash);
      } else if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object') {
        url.protocol && (result.protocol = url.protocol);
        url.hostName && (result.hostName = url.hostName);
        url.port && (result.port = url.port);
        url.pathName && (result.pathName = url.pathName.replace(regexp.slash, ''));
        url.parameters && (result.parameters = url.parameters);
        url.hash && (result.hash = url.hash);
      }

      return result;
    }
  }, {
    key: 'encodeValue',
    value: function encodeValue(value) {
      var result = value + '';

      if (value && (Array.isArray(value) || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object')) {
        result = JSON.stringify(value);
      }

      return encodeURIComponent(result);
    }
  }, {
    key: 'encodeQuery',
    value: function encodeQuery(params) {
      var query = '?';

      for (var name in params) {
        query += name + '=' + Url.encodeValue(params[name]) + '&';
      }

      return query.substr(0, query.length - 1);
    }
  }, {
    key: 'decodeValue',
    value: function decodeValue(value) {
      value = decodeURIComponent(value);
      var result = value;

      if (!isNaN(value)) {
        result = value;
      } else if (value === 'true') {
        result = true;
      } else if (value === 'false') {
        result = false;
      } else {
        var json = Url._checkJson(value);

        if (json) {
          result = json;
        }
      }

      return result;
    }
  }, {
    key: 'decodeQuery',
    value: function decodeQuery(query) {
      var params = {};

      query.substr(1, query.length - 1).split('&').forEach(function (value) {
        var valueSplitter = value.split('=');
        params[valueSplitter[0]] = Url.decodeValue(valueSplitter[1]);
      });

      return params;
    }
  }, {
    key: '_checkJson',
    value: function _checkJson(str) {
      try {
        return JSON.parse(str);
      } catch (e) {
        return false;
      }
    }
  }]);

  function Url() {
    _classCallCheck(this, Url);

    this.protocol = null;
    this.hostName = null;
    this.port = null;
    this._pathName = null;
    this._parameters = null;
    this._hash = null;
  }

  _createClass(Url, [{
    key: 'set',
    value: function set(params) {
      params.protocol !== undefined && (this.protocol = params.protocol);
      params.hostName !== undefined && (this.hostName = params.hostName);
      params.port !== undefined && (this.port = params.port);
      params.pathName !== undefined && (this.pathName = params.pathName);
      params.parameters !== undefined && (this.parameters = params.parameters);
      params.hash !== undefined && (this.hash = params.hash);
      return this;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var url = this.origin;
      this.pathName && (url += '/' + this.pathName);
      this.parameters && (url += Url.encodeQuery(this.parameters));
      this.hash && (url += '#' + this.hash);
      return url;
    }
  }, {
    key: 'pathName',
    get: function get() {
      return this._pathName;
    },
    set: function set(pathName) {
      this._pathName = pathName.replace(regexp.slash, '');
      return this;
    }
  }, {
    key: 'parameters',
    get: function get() {
      return this._parameters;
    },
    set: function set(parameters) {
      if (typeof parameters === 'string') {
        this._parameters = Url.decodeQuery(parameters);
      } else {
        this._parameters = parameters || null;
      }
      return this;
    }
  }, {
    key: 'hash',
    get: function get() {
      return this._hash;
    },
    set: function set(hash) {
      this._hash = hash.replace(regexp.hash, '');
      return this;
    }
  }, {
    key: 'host',
    get: function get() {
      var host = '';
      this.hostName && (host += this.hostName);
      this.port && (host += ':' + this.port);
      return host;
    }
  }, {
    key: 'origin',
    get: function get() {
      var origin = '';

      this.protocol && (origin += this.protocol + '://');

      var host = this.host;
      host && (origin += host);

      return origin;
    }
  }]);

  return Url;
}();

exports.default = Url;