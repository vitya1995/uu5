"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TimeManager = exports.TimeManager = function () {
  function TimeManager() {
    _classCallCheck(this, TimeManager);

    this._intervals = {};
  }

  _createClass(TimeManager, [{
    key: "setInterval",
    value: function (_setInterval) {
      function setInterval(_x, _x2) {
        return _setInterval.apply(this, arguments);
      }

      setInterval.toString = function () {
        return _setInterval.toString();
      };

      return setInterval;
    }(function (fce, ms) {
      var _this = this;

      fce.interval = ms;

      var interval = this._intervals[ms] = this._intervals[ms] || { fces: [] };
      interval.fces.push(fce);

      if (interval.fces.length === 1) {
        interval.setIntervalFce = setInterval(function () {
          return _this._eachInterval(ms);
        }, ms);
      }

      return fce;
    })
  }, {
    key: "clearInterval",
    value: function (_clearInterval) {
      function clearInterval(_x3) {
        return _clearInterval.apply(this, arguments);
      }

      clearInterval.toString = function () {
        return _clearInterval.toString();
      };

      return clearInterval;
    }(function (fce) {
      var ms = fce.interval;
      var interval = this._intervals[ms];

      if (interval && interval.fces) {
        var index = interval.fces.indexOf(fce);
        if (index > -1) {
          interval.fces.splice(index, 1);
          if (interval.fces.length === 0 && interval.setIntervalFce) {
            delete this._intervals[ms];
            clearInterval(interval.setIntervalFce);
          }
        }
      }

      return this;
    })
  }, {
    key: "_eachInterval",
    value: function _eachInterval(ms) {
      this._intervals[ms].fces.forEach(function (fce) {
        return fce();
      });
    }
  }]);

  return TimeManager;
}();

exports.default = TimeManager;