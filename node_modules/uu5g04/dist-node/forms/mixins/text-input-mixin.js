'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextInputMixin = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uu5g = require('uu5g04');

var UU5 = _interopRequireWildcard(_uu5g);

var _formsNs = require('../forms-ns.js');

var _formsNs2 = _interopRequireDefault(_formsNs);

var _inputMixin = require('./input-mixin.js');

var _inputMixin2 = _interopRequireDefault(_inputMixin);

var _selectOption = require('./../select-option.js');

var _selectOption2 = _interopRequireDefault(_selectOption);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TextInputMixin = exports.TextInputMixin = {

  //@@viewOn:mixins
  mixins: [UU5.Common.ColorSchemaMixin, _inputMixin2.default],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    "UU5.Forms.TextInputMixin": {
      classNames: {
        main: _formsNs2.default.css("text-input"),
        item: _formsNs2.default.css("auto-complete-item", "group-item")
      }
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    placeholder: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),
    required: _propTypes2.default.bool,
    requiredMessage: _propTypes2.default.any,
    focusMessage: _propTypes2.default.any,
    patternMessage: _propTypes2.default.any,
    autocompleteItems: _propTypes2.default.arrayOf(_propTypes2.default.shape({
      value: _propTypes2.default.string,
      params: _propTypes2.default.object,
      content: _propTypes2.default.any
    })),
    onFocus: _propTypes2.default.func,
    onBlur: _propTypes2.default.func,
    onEnter: _propTypes2.default.func,
    validateOnChange: _propTypes2.default.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      placeholder: null,
      required: false,
      requiredMessage: null,
      focusMessage: null,
      patternMessage: null,
      autocompleteItems: null,
      onFocus: null,
      onBlur: null,
      onEnter: null,
      validateOnChange: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState: function getInitialState() {
    return {
      autocompleteItems: this.props.autocompleteItems,
      foundAutocompleteItems: null,
      selectedIndex: null
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this.setState({ autocompleteItems: nextProps.autocompleteItems });
    }
  },

  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  isTextInput: function isTextInput() {
    return true;
  },
  getInput: function getInput() {
    return this._textInput;
  },
  focus: function focus() {
    this._textInput && this._textInput.focus();
  },


  isValid: function isValid() {
    var feedback = this.getFeedback();
    var value = this.getValue();
    var result = true;

    if (this.props.required && (value === '' || value === null)) {
      this.setError(this.props.requiredMessage || this.getLsiValue('requiredMessage'));
      result = false;
    } else if (feedback === 'error') {
      result = false;
    } else if (typeof this.isValid_ === 'function') {
      result = this.isValid_();
    }

    if (result && this.props.onValidate) {
      var validation = this.props.onValidate({ value: value, component: this });
      if (validation && (typeof validation === 'undefined' ? 'undefined' : _typeof(validation)) === 'object') {
        if (validation.feedback === 'error') {
          result = false;
        }
      }
    }

    return result;
  },

  open: function open(setStateCallback) {
    this._stopPropagation = true;
    this._addEvent();
    this.setState({ open: true }, setStateCallback);
    return this;
  },
  isOpen: function isOpen() {
    return typeof this.isOpen_ === "function" ? this.isOpen_() : this.state.open;
  },
  getFocusFeedback: function getFocusFeedback() {
    var value = void 0;
    if (this.isInitial() && this.props.focusMessage) {
      value = {
        message: this.props.focusMessage,
        value: this.state.value,
        feedback: 'initial'
      };
    }
    return value;
  },
  getBlurFeedback: function getBlurFeedback(opt) {
    var result = void 0;
    var validateFeedback = this.onValidate(opt);
    if (validateFeedback) {
      result = validateFeedback;
    } else {
      result = {
        feedback: this.state.feedback,
        message: this.state.message,
        value: opt.value
      };
    }
    return result;
  },
  onValidate: function onValidate(opt) {
    var result = void 0;
    if (this.props.pattern) {
      var r = new RegExp(this.props.pattern);
      if (!r.test(opt.value)) {
        result = {
          feedback: 'error',
          message: this.props.patternMessage || this.getLsiComponent('patternMessage'),
          value: opt.value
        };
      }
    } else if (typeof this.props.onValidate === 'function') {
      result = this.props.onValidate(opt);
    }

    return result;
  },
  setAutoCompleteItems: function setAutoCompleteItems(items, opt, setStateCallback) {
    opt = opt || {};

    opt.autocompleteItems = items;
    opt.value = opt.value || this.state.value;
    var result = this.getChangeFeedback(opt);

    this.setState({
      autocompleteItems: items,
      feedback: result.feedback,
      message: result.message,
      value: result.value,
      foundAutocompleteItems: result.foundAutocompleteItems,
      selectedIndex: result.selectedIndex
    }, setStateCallback);

    return this;
  },
  onFocus: function onFocus(e) {
    var opt = { value: e.target.value, event: e, component: this };
    if (typeof this.props.onFocus === 'function') {
      this.props.onFocus(opt);
    } else {
      var result = this.getFocusFeedback(opt);
      result && this.setFeedback(result.feedback, result.message, result.value);
    }

    return this;
  },
  onChange: function onChange(e) {
    var opt = { value: e.target.value, event: e, component: this };

    if (!this.isDisabled() && !this.isReadOnly()) {
      if (typeof this.props.onChange === 'function') {
        this.props.onChange(opt);
      } else if (this.props.validateOnChange) {
        this._validateOnChange(opt);
      } else {
        var result = this.getChangeFeedback(opt);
        this.setState({
          feedback: result.feedback,
          message: result.message,
          value: result.value,
          foundAutocompleteItems: result.foundAutocompleteItems,
          selectedIndex: result.selectedIndex
        });
      }
    }

    return this;
  },
  onBlur: function onBlur(e) {
    var opt = { value: e.target.value, event: e, component: this };

    if (typeof this.props.onBlur === 'function') {
      this.props.onBlur(opt);
    } else {
      if (this._checkRequired({ value: opt.value }) && !this.props.validateOnChange) {
        opt.required = this.props.required;
        var blurResult = this.getBlurFeedback(opt);
        this._setFeedback(blurResult.feedback, blurResult.message, blurResult.value);
      }
    }

    return this;
  },
  onKeyDown: function onKeyDown(e, param) {
    var opt = { value: e.target.value, event: e, component: this };

    // param is user function passed to inputAttrs.onKeyDown
    if (typeof param === 'function') {
      param(e, opt);
    }

    if (typeof this.props.onEnter === 'function' && (e.keyCode || e.which) === 13 && !e.shiftKey && !e.ctrlKey) {
      this.props.onEnter(opt);
    }

    return this;
  },


  // find: function (foundValue, setStateCallback) {
  //   var values = {first: [], last: []};
  //   this.props.items.forEach(function (item) {
  //     if (foundValue !== '') {
  //       if (new RegExp('^' + foundValue, 'i').exec(item.value)) {
  //         values.first.push(item);
  //       } else if (new RegExp(foundValue, 'gi').exec(item.value)) {
  //         values.last.push(item);
  //       }
  //     }
  //   });
  //   var allValues = values.first.concat(values.last);
  //   this.setState({items: allValues.length ? allValues : null, selectedIndex: null}, setStateCallback);
  //   return this;
  // },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  getChangeFeedback_: function getChangeFeedback_(opt) {
    var foundedItems = null;
    var selectedIndex = this.state.selectedIndex;

    if (opt.autocompleteItems || this.state.autocompleteItems) {
      foundedItems = this._find(opt.autocompleteItems || this.state.autocompleteItems, opt.value);
      selectedIndex = null;
    }

    return {
      feedback: opt.feedback || _inputMixin2.default.INITIAL_FEEDBACK,
      message: opt.message || null,
      value: opt.value === undefined ? this.state.value : opt.value,
      foundAutocompleteItems: foundedItems,
      selectedIndex: selectedIndex
    };
  },
  setChangeFeedback_: function setChangeFeedback_(opt, setStateCallback) {
    var result = this.getChangeFeedback(opt);

    this.setState({
      feedback: result.feedback,
      message: result.message,
      value: result.value,
      foundAutocompleteItems: result.foundAutocompleteItems,
      selectedIndex: result.selectedIndex
    }, setStateCallback);

    return this;
  },

  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _checkRequired: function _checkRequired(opt) {
    var result = true;
    if (this.props.required && !opt.value) {
      result = false;
      this.setError(this.props.requiredMessage || this.getLsiComponent('requiredMessage'), opt.value);
    }

    return result;
  },
  _find: function _find(items, foundValue) {
    var values = { first: [], last: [] };
    var foundValueLower = foundValue.toLowerCase();
    items.forEach(function (item) {
      var itemValueLower = item.value.toLowerCase();
      if (foundValue !== '') {
        if (itemValueLower.substring(0, foundValueLower.length) === foundValueLower) {
          values.first.push(item);
        } else if (itemValueLower.indexOf(foundValueLower) > -1) {
          values.last.push(item);
        }
      }
    });
    var allValues = values.first.concat(values.last);

    return allValues.length ? allValues : null;
  },
  _getBackdropProps: function _getBackdropProps() {
    var _this = this;

    var backdropId = this.getId() + "-backdrop";

    return {
      hidden: !this.state.foundAutocompleteItems,
      id: backdropId,
      onClick: function onClick() {
        return _this.setState({ foundAutocompleteItems: null, selectedIndex: null });
      }
    };
  },
  _getItemListProps: function _getItemListProps() {
    var _this2 = this;

    var props = {
      parent: this
    };

    props.hidden = !this.state.foundAutocompleteItems;
    props.ref = function (itemList) {
      return _this2._itemList = itemList;
    };
    props.onChange = function (opt) {
      var value = '';
      if (opt.value !== null) {
        value = _this2.state.foundAutocompleteItems[opt.value].value;
      }

      // TODO: how to do custom onChange, but items should be hidden because of this path is after choosing some item
      // if (typeof this.props.onChange === 'function') {
      //   opt.component = this;
      //   opt.value = value;
      //   this.setState({ foundAutocompleteItems: null, selectedIndex: null }, () => this.props.onChange(opt));
      // } else {
      _this2.setState({ value: value, foundAutocompleteItems: null, selectedIndex: null }, function () {
        if (typeof _this2.props.onBlur === 'function') {
          _this2.props.onBlur({ value: value, component: _this2 });
        }
      });
      // this.close(() => this.setValue(result));
      // }
    };

    props.value = this.state.value;

    return props;
  },
  _getChildren: function _getChildren() {
    var _this3 = this;

    return this.state.foundAutocompleteItems && this.state.foundAutocompleteItems.map(function (item, i) {
      var className = _this3.getClassName().item;
      _this3.state.selectedIndex === i && (className += ' ' + _this3.getClassName().selected);
      return _react2.default.createElement(_selectOption2.default, { className: className, key: i, value: item.content || item.value, content: item.content || item.value, mainAttrs: { id: _this3.getId() + '-item-' + i } });
    });
  }
};

exports.default = TextInputMixin;